<!DOCTYPE html>
<html lang="de" data-theme="dark">
<head>
<meta charset="UTF-8">
<meta property="og:title" content="VoxelShaper – Create in 3D, Effortlessly" />
<meta property="og:description" content="A powerful, intuitive voxel-based 3D editor – made for makers, artists, and coders." />
<meta property="og:image" content="https://voxelshaper.com/preview.png" />
<meta property="og:url" content="https://voxelshaper.com/" />
<meta property="og:type" content="website" />
<meta name="viewport"
      content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover">
<link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAAANl..."/>

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="VoxelShaper – Create in 3D, Effortlessly">
<meta name="twitter:description" content="A powerful, intuitive voxel-based 3D editor – made for makers, artists, and coders.">
<meta name="twitter:image" content="https://voxelshaper.com/preview.png">
<title>VoxelShaper – Voxel Editor & 3D Print Exporter</title>

<link href="https://cdn.jsdelivr.net/npm/daisyui@4.7.2/dist/full.min.css" rel="stylesheet" type="text/css" />
<script src="https://cdn.tailwindcss.com"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

<style>
body {
    padding-top: env(safe-area-inset-top);
    padding-bottom: env(safe-area-inset-bottom);
    padding-left: env(safe-area-inset-left);
    padding-right: env(safe-area-inset-right);
    box-sizing: border-box;
    touch-action: auto;
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
}
#container, #voxelCanvas {
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
    -webkit-touch-callout: none;
    touch-action: none;
}
.touch-indicator { animation: pulse 0.5s; }
@keyframes pulse {
    0% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
    50% { transform: translate(-50%, -50%) scale(1.5); opacity: 0.2; }
    100% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
}
input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
input[type="color"]::-webkit-color-swatch { border: none; border-radius: 50%; }
input[type="color"]::-moz-color-swatch-wrapper { padding: 0; }
input[type="color"]::-moz-color-swatch { border: none; border-radius: 50%; }
.color-preset-box::-webkit-color-swatch-wrapper { padding: 0; }
.color-preset-box::-webkit-color-swatch { border: none; border-radius: 0.375rem; }
.color-preset-box::-moz-color-swatch-wrapper { padding: 0; }
.color-preset-box::-moz-color-swatch { border: none; border-radius: 0.375rem; }

#toast-container {
    position: fixed;
    z-index: 50;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    padding: 1rem;
    pointer-events: none;
}

#toast-container.toast-end {
    bottom: 1rem;
    right: 1rem;
    align-items: flex-end;
}

@media (max-width: 768px) {
    #toast-container {
        top: 1rem;
        left: 50%;
        transform: translateX(-50%);
        width: calc(100% - 2rem);
        max-width: 300px;
        align-items: center;
    }
    #toast-container.toast-end {
        bottom: auto;
        right: auto;
    }
}

.toast .alert {
    pointer-events: auto;
    opacity: 0;
    transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
    transform: translateY(20px);
}

.toast .alert.show {
    opacity: 1;
    transform: translateY(0);
}

@media (max-width: 768px) {
    .toast .alert {
        padding: 0.5rem 0.75rem;
        font-size: 0.875rem;
    }
    .toast .alert svg {
        width: 1.25rem;
        height: 1.25rem;
    }
    .toast .alert strong {
        font-size: 0.9rem;
    }
    .toast .alert span {
        font-size: 0.8rem;
    }
    .toast .alert .close-btn {
        font-size: 1rem;
        padding: 0.25rem;
    }
}
.mobile-btn {
    width: 64px;
    height: 64px;
    font-size: 2rem;
    border-radius: 50%;
    background-color: var(--fallback-b3, oklch(var(--b3)/1));
    color: var(--fallback-bc, oklch(var(--bc)/1));
    border: 2px solid var(--fallback-bc, oklch(var(--bc)/1));
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
    transition: background-color 0.2s, transform 0.2s;
}

.mobile-btn:hover {
    background-color: oklch(var(--bc)/0.2);
}

.mobile-btn:active {
    transform: scale(0.95);
}

#mobile-controls {
    gap: 1rem;
}
</style>
</head>
<body class="bg-base-100 min-h-screen text-base-content flex flex-col">
<button id="menuToggle" aria-label="Menü umschalten" class="fixed top-4 right-4 z-[1500] w-10 h-10 text-xl leading-10 text-center bg-base-300 text-base-content border-none rounded-lg cursor-pointer shadow-md hover:bg-base-content/20 lg:hidden">☰</button>

<div id="controls" class="flex flex-wrap items-center justify-center gap-3 p-4 bg-base-200 border-b border-base-content/20 hidden md:flex">
    <label for="grid-size-slider" class="text-base-content">Gittergröße:</label>
    <input type="range" id="grid-size-slider" min="5" max="180" value="10" aria-label="Gittergröße anpassen" class="range range-xs w-36">
    <span id="grid-size-display" class="font-bold text-primary">10×10×10</span>
    
    <label for="color-picker" class="text-base-content">Farbe:</label>
    <input type="color" id="color-picker" value="#ffffff" aria-label="Aktuelle Farbe wählen" class="input input-bordered w-10 h-10 p-0 rounded-full cursor-pointer border-base-content/20">
    <input type="color" id="color-preset-1" class="color-preset-box w-10 h-10 rounded-md border-2 border-base-content/20 cursor-pointer transition-all duration-200 hover:scale-110" value="#E4002B" aria-label="Voreingestellte Farbe 1">
    <input type="color" id="color-preset-2" class="color-preset-box w-10 h-10 rounded-md border-2 border-base-content/20 cursor-pointer transition-all duration-200 hover:scale-110" value="#00A040" aria-label="Voreingestellte Farbe 2">
    <input type="color" id="color-preset-3" class="color-preset-box w-10 h-10 rounded-md border-2 border-base-content/20 cursor-pointer flex items-center justify-center shadow-lg hover:bg-base-content/20" value="#0057B8" aria-label="Voreingestellte Farbe 3">

    <button id="modeToggle" aria-label="Modus wechseln" class="btn btn-sm btn-neutral">Modus wechseln</button><span id="current-mode" class="font-bold text-success min-w-40 text-center">Modus: Hinzufügen</span>
    <button id="clearBtn" aria-label="Alles löschen" class="btn btn-sm btn-neutral">Alles löschen</button>
    <button id="fillLevelBtn" aria-label="Ebene füllen" class="btn btn-sm btn-neutral">Ebene füllen</button>
    <button id="saveBtn" aria-label="Projekt speichern" aria-describedby="save-description" class="btn btn-sm btn-neutral">Projekt speichern</button>
    <div id="save-description" class="sr-only">Speichert das aktuelle Projekt als JSON-Datei</div>
    <button id="loadBtn" aria-label="Projekt laden" class="btn btn-sm btn-neutral">Projekt laden</button>
    <button id="exportStlBtn" aria-label="STL Export" class="btn btn-sm btn-neutral">STL Export</button>
    <button id="exportObjBtn" aria-label="OBJ Export" class="btn btn-sm btn-neutral">OBJ Export</button>
    <button id="exportGlbBtn" aria-label="GLB Export" class="btn btn-sm btn-neutral">GLB Export</button>

    <label for="fly-speed-slider" class="text-base-content">Fluggeschwindigkeit:</label>
    <input type="range" id="fly-speed-slider" min="0.01" max="1.0" step="0.01" value="0.1" aria-label="Fluggeschwindigkeit anpassen" class="range range-xs w-36">
    <span id="fly-speed-display" class="font-bold text-primary">0.10</span>

    <button id="resetCameraBtn" aria-label="Kamera zurücksetzen" class="btn btn-sm btn-neutral">Zur Szene zurückkehen</button>
    <button id="generateVoxelIdeaBtn" aria-label="Voxel-Idee generieren" class="btn btn-sm btn-primary">✨ Voxel-Idee generieren ✨</button>

    <button id="loadImageTemplateBtn" aria-label="Bild als Vorlage laden" class="btn btn-sm btn-neutral">Bild als Vorlage laden</button>
    <button id="removeImageTemplateBtn" class="btn btn-sm btn-neutral hidden" aria-label="Bildvorlage entfernen">Bildvorlage entfernen</button>
    <input type="file" id="imageFileInput" accept="image/*" class="hidden">

    <button id="loginLogoutBtn" aria-label="Anmelden oder Abmelden" class="btn btn-sm btn-info">Anmelden</button>
    <span id="userIdDisplay" class="font-bold text-info ml-2 mr-2 whitespace-nowrap overflow-hidden text-ellipsis max-w-xs flex items-center gap-1"></span>
    <button id="uploadToHubBtn" aria-label="Auf Hub hochladen" class="btn btn-sm btn-warning hidden">Auf Hub hochladen</button>
    <button id="goToHubBtn" aria-label="Zum VoxelShaper Hub wechseln" class="btn btn-sm btn-secondary">Zum Hub</button>
</div>

<div id="container" class="flex-1 relative border-2 border-transparent box-border overflow-hidden touch-none">
    <canvas id="voxelCanvas" class="w-full h-full block box-border"></canvas>
    <div id="touch-indicator" class="touch-indicator absolute w-10 h-10 rounded-full bg-blue-500/30 transform -translate-x-1/2 -translate-y-1/2 pointer-events-none hidden z-[2000]"></div>
    <input type="file" id="fileInput" accept=".json" class="hidden">
</div>

<dialog id="clearConfirmationModal" class="modal">
    <div class="modal-box bg-base-200 text-base-content p-8 text-center shadow-xl max-w-md">
        <h3 class="font-bold text-lg text-primary mb-4">Projekt löschen</h3>
        <p class="py-4">Möchten Sie das aktuelle Projekt speichern, bevor Sie alle Voxel löschen?</p>
        <div class="modal-buttons flex justify-around gap-4 mt-6">
            <button id="saveAndClearBtn" class="confirm-save btn btn-success flex-1">Speichern & Löschen</button>
            <button id="clearWithoutSaveBtn" class="confirm-no-save btn btn-error flex-1">Ohne Speichern löschen</button>
            <button id="cancelClearBtn" class="cancel btn btn-ghost flex-1">Abbrechen</button>
        </div>
    </div>
</dialog>

<dialog id="uploadProjectModal" class="modal">
    <div class="upload-modal-content modal-box bg-base-200 text-base-content p-8 shadow-xl max-w-xl w-11/12 text-left">
        <h3 class="font-bold text-lg text-primary text-center mb-6">Projekt auf Hub hochladen</h3>
        <label for="uploadTitle" class="label block mb-2 font-bold">Titel:</label>
        <input type="text" id="uploadTitle" placeholder="Ein aussagekräftiger Titel für Ihr Projekt" maxlength="100" class="input input-bordered w-full bg-base-300 border-base-content/20 mb-4">

        <label for="uploadDescription" class="label block mb-2 font-bold">Beschreibung:</label>
        <textarea id="uploadDescription" placeholder="Beschreiben Sie Ihr Projekt kurz" maxlength="500" class="textarea textarea-bordered w-full bg-base-300 border-base-content/20 h-24 mb-4 resize-y"></textarea>

        <label for="uploadCategory" class="label block mb-2 font-bold">Kategorie:</label>
        <select id="uploadCategory" class="select select-bordered w-full bg-base-300 border-base-content/20 mb-4" required>
            <option value="" disabled selected>Kategorie auswählen</option>
        </select>

        <label for="uploadTags" class="label block mb-2 font-bold">Tags (Komma-getrennt):</label>
        <input type="text" id="uploadTags" placeholder="z.B. Haus, Baum, Auto, Gebäude" maxlength="100" class="input input-bordered w-full bg-base-300 border-base-content/20 mb-4">

        <label class="label block mb-2 font-bold">Sichtbarkeit:</label>
        <div class="radio-group flex gap-4 mb-4">
            <label class="flex items-center font-normal">
                <input type="radio" name="uploadVisibility" value="public" checked class="radio radio-primary mr-2"> Öffentlich
            </label>
            <label class="flex items-center font-normal">
                <input type="radio" name="uploadVisibility" value="private" class="radio radio-primary mr-2"> Privat
            </label>
        </div>

        <div class="upload-modal-buttons flex justify-around gap-4 mt-6">
            <button id="uploadConfirmBtn" class="upload-confirm btn btn-success flex-1">Hochladen</button>
            <button id="uploadCancelBtn" class="upload-cancel btn btn-ghost flex-1">Abbrechen</button>
        </div>
    </div>
</dialog>

<dialog id="authModal" class="modal">
    <div class="auth-modal-content modal-box bg-base-200 text-base-content p-8 shadow-xl max-w-lg w-11/12 text-center">
        <h3 class="font-bold text-lg text-primary mb-6">Anmelden bei VoxelShaper Hub</h3>
        <div class="provider-buttons flex flex-col gap-3">
            <button id="signInGoogleBtn" class="google btn btn-error text-white">
                <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" alt="Google Icon" class="w-5 h-5">
                Mit Google anmelden
            </button>
            <button id="signInGithubBtn" class="github btn bg-neutral text-neutral-content hover:bg-neutral-focus">
                <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/github.svg" alt="GitHub Icon" class="w-5 h-5">
                Mit GitHub anmelden
            </button>
            <button id="showEmailLoginFormBtn" class="email btn btn-info">
                Mit E-Mail anmelden
            </button>
        </div>

        <div id="emailLoginForm" class="email-login-form mt-6 pt-6 border-t border-base-content/20 hidden">
            <form id="emailAuthForm">
                <input type="email" id="emailInput" placeholder="E-Mail" autocomplete="email" class="input input-bordered w-full bg-base-300 border-base-content/20 mb-3">
                <input type="password" id="passwordInput" placeholder="Passwort" autocomplete="current-password" class="input input-bordered w-full bg-base-300 border-base-content/20 mb-3">
                <button type="submit" id="emailSignInBtn" class="btn btn-primary w-full">Anmelden</button>
                <button type="button" id="emailSignUpBtn" class="btn btn-secondary w-full mt-2">Registrieren</button>
            </form>
        </div>

        <div class="close-button-container mt-6">
            <button id="authModalCloseBtn" class="btn btn-ghost">Schließen</button>
        </div>
    </div>
</dialog>

<dialog id="ideaGeneratorModal" class="modal">
    <div class="modal-box bg-base-200 text-base-content p-8 shadow-xl max-w-md">
        <h3 class="font-bold text-lg text-primary mb-4">✨ Voxel-Idee generieren ✨</h3>
        <p class="py-2">Geben Sie ein Thema oder Konzept ein, um eine Voxel-Modell-Idee zu generieren:</p>
        <textarea id="ideaPromptInput" placeholder="Z.B. 'Ein gemütliches Baumhaus', 'Ein futuristisches Raumschiff'" class="textarea textarea-bordered w-full bg-base-300 border-base-content/20 h-24 mb-4 resize-y"></textarea>
        <div id="ideaResultDisplay" class="bg-base-300 p-4 rounded-md mb-4 hidden overflow-auto max-h-40"></div>
        <div id="ideaLoadingIndicator" class="text-center py-4 hidden">
            <span class="loading loading-spinner loading-lg text-primary"></span>
            <p>Generiere Idee...</p>
        </div>
        <div class="modal-buttons flex justify-around gap-4 mt-6">
            <button id="generateIdeaConfirmBtn" class="btn btn-primary flex-1">Generieren</button>
            <button id="ideaGeneratorCloseBtn" class="btn btn-ghost flex-1">Schließen</button>
        </div>
    </div>
</dialog>

<div id="toast-container" class="toast toast-end z-50"></div>

<div id="mobile-controls" class="hidden md:hidden flex-col gap-3 fixed bottom-4 right-4 z-[1000]">
    <button class="mobile-btn" id="mobile-undo" aria-label="Rückgängig machen">↺</button>
    <button class="mobile-btn" id="mobile-redo" aria-label="Wiederholen">↻</button>
    <button class="mobile-btn" id="mobile-save" aria-label="Speichern">💾</button>
    <button class="mobile-btn" id="mobile-camera" aria-label="Kamera zurücksetzen">📷</button>

    <button class="mobile-btn" id="mobile-mode-toggle" aria-label="Modus wechseln">
        <span id="mobile-mode-icon" class="fas fa-plus"></span>
    </button>

    <button class="mobile-btn" id="mobile-color-picker-btn" aria-label="Farbe auswählen">🎨</button>
    <input type="color" id="mobile-color-input" value="#ffffff" class="hidden w-0 h-0 opacity-0 absolute pointer-events-none">

    <button class="mobile-btn" id="mobile-axis-toggle" aria-label="Zeichenachse wechseln">
        <span id="mobile-axis-icon" class="fas fa-arrows-alt-v"></span>
    </button>
    <button class="mobile-btn" id="mobile-level-up" aria-label="Ebene erhöhen">⬆️</button>
    <button class="mobile-btn" id="mobile-level-down" aria-label="Ebene verringern">⬇️</button>

    <button class="mobile-btn" id="mobile-generate-idea" aria-label="Voxel-Idee generieren">✨</button>
    <button class="mobile-btn" id="mobile-login-logout" aria-label="Anmelden oder Abmelden">🔑</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/GLTFExporter.js"></script>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import {
        getAuth,
        setPersistence,
        browserLocalPersistence,
        signInWithCustomToken,
        onAuthStateChanged,
        signOut,
        GoogleAuthProvider,
        GithubAuthProvider,
        signInWithPopup,
        createUserWithEmailAndPassword,
        signInWithEmailAndPassword
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import {
        getFirestore,
        doc,
        getDoc,
        collection,
        addDoc,
        serverTimestamp
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    window.firebase = {
        initializeApp,
        getAuth,
        signInWithCustomToken,
        onAuthStateChanged,
        setPersistence,
        browserLocalPersistence,
        signOut,
        GoogleAuthProvider,
        GithubAuthProvider,
        signInWithPopup,
        createUserWithEmailAndPassword,
        signInWithEmailAndPassword,
        getFirestore,
        doc,
        getDoc,
        collection,
        addDoc,
        serverTimestamp
    };

    const FIREBASE_API_KEY = "AIzaSyB9-mpyAu9W6oiVtB0fYG8E6YFvTAsjtAA"; 

    const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {
        apiKey: FIREBASE_API_KEY,
        authDomain: "voxelshaper.firebaseapp.com",
        projectId: "voxelshaper",
        storageBucket: "voxelshaper.firebasestorage.app", 
        messagingSenderId: "1053689247573",
        appId: "1:1053689247573:web:f7960c7f8c2e8849e8e1dc",
        measurementId: "G-QJCNKZ5DR"
    };
    window.firebaseConfig = firebaseConfig;
</script>

<script>
const VS = 1, HALF = VS * 0.5;
const CHUNK_SIZE = 16;
const VOX_BITS = 10;
const VOX_MASK = (1 << VOX_BITS) - 1;
const SHIFT_X  = VOX_BITS * 2;
const SHIFT_Y  = VOX_BITS;

const AI_API_KEY = "AIzaSyD3uQ6BnGsliYAtR9r0jdBUq03KEfFO0"; 

function key(x, y, z) { return ((x << SHIFT_X) | (y << SHIFT_Y) | z) >>> 0; }
function parseKey(k) { return [(k >>> SHIFT_X) & VOX_MASK, (k >>> SHIFT_Y) & VOX_MASK, k & VOX_MASK]; }

const VOXEL_DRAG_THRESHOLD = 1;
const PINCH_ZOOM_MULT = 40;
const TAP_DIST_TH = 10;
const MOVE_PX = 10;
const DT_MS = 250;

const ROTATE_SPEED_TOUCH_MOBILE = 0.008;
const PAN_SPEED_TOUCH_MOBILE = 0.2;
const PINCH_ZOOM_MULT_MOBILE = 80;

const ROTATE_SPEED_TOUCH_DESKTOP = 0.004;
const PAN_SPEED_TOUCH_DESKTOP = 0.1;
const PINCH_ZOOM_MULT_DESKTOP = 40;


let activePointers = new Map();
let gestureState = { type: 'none', startDist: 0, startMid: { x: 0, y: 0 }, lastMid: { x: 0, y: 0 }, lastDist: 0, startTime: 0, initialPointerCount: 0 };
let tapCandidate = null;
let doubleTapDragActive = false;
let touchIndicator;

let scene, cam, ren, gridHelper, boxHelper;
let rotSpeed = 0.004;
let euler;
const voxels = new Map(); // Stores the current state of all voxels
const chunks = new Map();

let cvs, containerDiv;
let activeDrawingLevel = { x: 0, y: 0, z: 0 };
let currentDrawingAxis = 'y';

let currentColor = localStorage.getItem('voxelEditorColor') || '#ffffff';
let moveSpeed = parseFloat(localStorage.getItem('voxelEditorFlySpeed') || '0.1');
let GRID = parseInt(localStorage.getItem('voxelEditorGridSize') || '10');

activeDrawingLevel.x = Number(localStorage.getItem('voxelEditorActiveDrawingLevelX') || '0');
if (!Number.isFinite(activeDrawingLevel.x)) activeDrawingLevel.x = 0;
activeDrawingLevel.x = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.x)));

activeDrawingLevel.y = Number(localStorage.getItem('voxelEditorActiveDrawingLevelY') || '0');
if (!Number.isFinite(activeDrawingLevel.y)) activeDrawingLevel.y = 0;
activeDrawingLevel.y = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.y)));

activeDrawingLevel.z = Number(localStorage.getItem('voxelEditorActiveDrawingLevelZ') || '0');
if (!Number.isFinite(activeDrawingLevel.z)) activeDrawingLevel.z = 0;
activeDrawingLevel.z = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.z)));

currentDrawingAxis = localStorage.getItem('voxelEditorCurrentDrawingAxis') || 'y';

const presetColors = [
    localStorage.getItem('voxelPresetColor1') || '#E4002B',
    localStorage.getItem('voxelPresetColor2') || '#00A040',
    localStorage.getItem('voxelPresetColor3') || '#0057B8'
];
let activePresetIndex = -1;
let presetBoxes = [];

let mainDirectionalLight, fillDirectionalLight, hemisphereLight;
let isShiftDragging = false;
let isControlDragging = false;
let isPointerLocked = false;
let lastActionVoxelCoords = null;
let initialClickPos = null;
let initialTargetVoxelCoords = null;
let isDragging = false;
let firstMoveAfterLock = true;
let mouseMovementX = 0;
let mouseMovementY = 0;

const dummy = new THREE.Object3D();
const previewVoxelGeometry = new THREE.BoxGeometry(VS, VS, VS);
const previewVoxelMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5, depthTest: false });
previewVoxelMaterial.polygonOffset = true;
previewVoxelMaterial.polygonOffsetFactor = -1;
let previewVoxelMesh = new THREE.Mesh(previewVoxelGeometry, previewVoxelMaterial);

const Modes = {
    ADD: 'Hinzufügen',
    DELETE: 'Löschen',
    DRAW: 'Zeichnen',
};

const ModeIcons = {
    ADD: 'fas fa-plus',
    DELETE: 'fas fa-eraser',
    DRAW: 'fas fa-paint-brush'
};

const AxisIcons = {
    x: 'fas fa-arrows-alt-h',
    y: 'fas fa-arrows-alt-v',
    z: 'fas fa-arrows-alt'
};

let currentMode = Modes.ADD;

let history = [];
let historyPointer = -1;
const MAX_HISTORY_SIZE = 5000; // Increased history size for effectively "unlimited" undo/redo

// Variables for new undo/redo logic
let voxelsAtDragStart = null; // Snapshot of voxels before a drag/click started
let currentStrokeChanges = new Map(); // Stores {gx, gy, gz, oldColor, newColor} for the current stroke/click

let previewLineInstancedMesh;
const maxPreviewInstances = 180 * 3;
let previewLineVoxels = [];

let templateImageMesh = null;
let templateImageData = null;

let isMobile = window.matchMedia('(max-width: 768px)').matches;

let initialDragVoxelWorldPos = null;
let dragAxisLock = null;
// let initialDragVoxelCoords = null; // Replaced by initialTargetVoxelCoords in this context

let projectTitle = '';
let projectDescription = '';
let projectCategory = 'Allgemein';
let projectTags = [];
let projectRemixOf = '';
let projectSourceJsonUrl = '';
let projectVisibility = 'public';

const predefinedCategories = ["Spielzeug", "Dekoration", "Funktional", "Kunst", "Allgemein", "Charaktere", "Fahrzeuge", "Natur", "Architektur", "Abstrakt"];

const VoxelShaperIO = {
    voxToOBJ: function(voxModel, voxelSize) {
        let obj = '# VoxelShaper OBJ Export\n';
        let mtls = '# VoxelShaper MTL Export\n';
        let vertexCount = 0;
        const materials = new Map();

        voxModel.voxels.forEach(v => {
            if (!materials.has(v.color)) {
                const matName = `material_${materials.size + 1}`;
                materials.set(v.color, matName);
                const c = new THREE.Color(v.color);
                mtls += `newmtl ${matName}\n`;
                mtls += `Kd ${c.r.toFixed(4)} ${c.g.toFixed(4)} ${c.b.toFixed(4)}\n`;
                mtls += `Ka ${c.r.toFixed(4)} ${c.g.toFixed(4)} ${c.b.toFixed(4)}\n`;
                mtls += `Ks 0.0 0.0 0.0\n`;
                mtls += `Ns 0.0\n`;
                mtls += `d 1.0\n`;
                mtls += `illum 1\n\n`;
            }
        });

        obj += `mtllib voxel_model.mtl\n`;

        obj += '# Vertex Normals\n';
        const normals = [
            new THREE.Vector3(0, 0, 1),
            new THREE.Vector3(0, 0, -1),
            new THREE.Vector3(1, 0, 0),
            new THREE.Vector3(-1, 0, 0),
            new THREE.Vector3(0, 1, 0),
            new THREE.Vector3(0, -1, 0)
        ];
        normals.forEach(n => {
            obj += `vn ${n.x.toFixed(4)} ${n.y.toFixed(4)} ${n.z.toFixed(4)}\n`;
        });
        obj += '\n';


        voxModel.voxels.forEach(v => {
            const x = v.x * voxelSize;
            const y = v.y * voxelSize;
            const z = v.z * voxelSize;

            const verts = [
                [x, y, z],
                [x + voxelSize, y, z],
                [x, y + voxelSize, z],
                [x + voxelSize, y + voxelSize, z],
                [x, y, z + voxelSize],
                [x + voxelSize, y, z + voxelSize],
                [x, y + voxelSize, z + voxelSize],
                [x + voxelSize, y + voxelSize, z + voxelSize]
            ];

            verts.forEach(vert => {
                obj += `v ${vert[0].toFixed(4)} ${vert[1].toFixed(4)} ${vert[2].toFixed(4)}\n`;
            });

            const matName = materials.get(v.color);
            obj += `usemtl ${matName}\n`;

            const baseIdx = vertexCount;

            obj += `f ${baseIdx + 5}//1 ${baseIdx + 6}//1 ${baseIdx + 8}//1 ${baseIdx + 7}//1\n`;
            obj += `f ${baseIdx + 1}//2 ${baseIdx + 3}//2 ${baseIdx + 4}//2 ${baseIdx + 2}//2\n`;
            obj += `f ${baseIdx + 2}//3 ${baseIdx + 6}//3 ${baseIdx + 8}//3 ${baseIdx + 4}//3\n`;
            obj += `f ${baseIdx + 1}//4 ${baseIdx + 3}//4 ${baseIdx + 7}//4 ${baseIdx + 5}//4\n`;
            obj += `f ${baseIdx + 3}//5 ${baseIdx + 4}//5 ${baseIdx + 8}//5 ${baseIdx + 7}//5\n`;
            obj += `f ${baseIdx + 1}//6 ${baseIdx + 5}//6 ${baseIdx + 6}//6 ${baseIdx + 2}//6\n`;

            vertexCount += 8;
        });

        return { obj: obj, mtl: mtls };
    },
    saveBlob: function(data, filename) {
        const objBlob = new Blob([data.obj], { type: 'text/plain' });
        const mtlBlob = new Blob([data.mtl], { type: 'text/plain' });

        const objUrl = URL.createObjectURL(objBlob);
        const mtlUrl = URL.createObjectURL(mtlBlob);

        const aObj = document.createElement('a');
        aObj.href = objUrl;
        aObj.download = filename;
        document.body.appendChild(aObj);
        aObj.click();
        document.body.removeChild(aObj);
        URL.revokeObjectURL(objUrl);

        const aMtl = document.createElement('a');
        aMtl.href = mtlUrl;
        aMtl.download = filename.replace('.obj', '.mtl');
        document.body.appendChild(aMtl);
        aMtl.click();
        document.body.removeChild(aMtl);
        URL.revokeObjectURL(mtlUrl);
    },
    VoxModel: function(width, height, depth, voxels) {
        this.width = width;
        this.height = height;
        this.depth = depth;
        this.voxels = voxels;
    }
};


function getChunkCoords(gx, gy, gz) { return { cx: Math.floor(gx / CHUNK_SIZE), cy: Math.floor(gy / CHUNK_SIZE), cz: Math.floor(gz / CHUNK_SIZE) }; }
function getChunkKey(cx, cy, cz) { return `${cx},${cy},${cz}`; }

class VoxelChunk {
    constructor(chunkX, chunkY, chunkZ, chunkSize, scene) {
        this.chunkX = chunkX; this.chunkY = chunkY; this.chunkZ = chunkZ; this.scene = scene; this.chunkSize = chunkSize;
        this.offsetX = chunkX * chunkSize * VS; this.offsetY = chunkY * chunkSize * VS; this.offsetZ = chunkZ * chunkSize * VS;
        this.voxels = new Map(); // Local voxel data for this chunk
        this.globalToLocalInstanceIdMap = new Map(); // Maps global voxel key to instanceId
        const maxInstancesInChunk = chunkSize * chunkSize * chunkSize;
        const voxelBaseGeometry = new THREE.BoxGeometry(VS, VS, VS);
        const meshMaterial = new THREE.MeshLambertMaterial();
        this.instancedMesh = new THREE.InstancedMesh(voxelBaseGeometry, meshMaterial, maxInstancesInChunk);
        this.instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(maxInstancesInChunk * 3), 3);
        this.instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        this.instancedMesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
        this.instancedMesh.castShadow = true; this.instancedMesh.receiveShadow = true; this.instancedMesh.count = 0;
        this.instancedMesh.position.set(this.offsetX, this.offsetY, this.offsetZ);
        this.scene.add(this.instancedMesh);
        this.boundingBox = new THREE.Box3(
            new THREE.Vector3(this.offsetX, this.offsetY, this.offsetZ),
            new THREE.Vector3(this.offsetX + chunkSize * VS, this.offsetY + chunkSize * VS, this.offsetZ + chunkSize * VS)
        );
    }
    getLocalKey(gx, gy, gz) { return key(gx % this.chunkSize, gy % this.chunkSize, gz % this.chunkSize); }
    addVoxel(gx, gy, gz, colorHex) {
        const lKey = this.getLocalKey(gx, gy, gz);
        const gKey = key(gx, gy, gz); // Global key for mapping

        // If voxel already exists, update its color and instance ID
        if (this.voxels.has(lKey)) {
            const instanceId = this.voxels.get(lKey).instanceId;
            this.voxels.set(lKey, { color: colorHex, instanceId });
            this.updateInstanceColor(instanceId, colorHex);
        } else {
            const instanceId = this.instancedMesh.count++;
            this.voxels.set(lKey, { color: colorHex, instanceId });
            this.globalToLocalInstanceIdMap.set(gKey, instanceId); // Map global to local instance ID
            dummy.position.set((gx % this.chunkSize) * VS + HALF, (gy % this.chunkSize) * VS + HALF, (gz % this.chunkSize) * VS + HALF);
            dummy.updateMatrix();
            this.instancedMesh.setMatrixAt(instanceId, dummy.matrix);
            this.updateInstanceColor(instanceId, colorHex);
            this.instancedMesh.instanceMatrix.needsUpdate = true;
            this.instancedMesh.instanceColor.needsUpdate = true;
        }
    }
    removeVoxel(gx, gy, gz) {
        const lKey = this.getLocalKey(gx, gy, gz);
        const gKey = key(gx, gy, gz);
        if (!this.voxels.has(lKey)) return;

        const { instanceId: removedId } = this.voxels.get(lKey);
        this.voxels.delete(lKey);
        this.globalToLocalInstanceIdMap.delete(gKey); // Remove global to local mapping

        const lastId = this.instancedMesh.count - 1;
        if (removedId !== lastId) {
            // Find the global key of the voxel that was at the lastId position
            let lastVoxelGKey = null;
            for (const [gk, id] of this.globalToLocalInstanceIdMap.entries()) {
                if (id === lastId) {
                    lastVoxelGKey = gk;
                    break;
                }
            }
            
            if (lastVoxelGKey !== null) {
                // Get the coordinates of the last voxel
                const [lx, ly, lz] = parseKey(this.getLocalKey(...parseKey(lastVoxelGKey))); // Need local coords for the map lookup
                
                // Get the matrix and color of the last instance
                const tempMatrix = new THREE.Matrix4();
                this.instancedMesh.getMatrixAt(lastId, tempMatrix);
                
                // Set the removed instance's matrix and color to that of the last instance
                this.instancedMesh.setMatrixAt(removedId, tempMatrix);
                this.updateInstanceColor(removedId, this.voxels.get(key(lx, ly, lz)).color);
                
                // Update the last voxel's instanceId to the removedId
                this.voxels.get(key(lx, ly, lz)).instanceId = removedId;
                this.globalToLocalInstanceIdMap.set(lastVoxelGKey, removedId); // Update global map
            }
        }
        this.instancedMesh.count--;
        this.instancedMesh.instanceMatrix.needsUpdate = true;
        this.instancedMesh.instanceColor.needsUpdate = true;
    }
    recolorVoxel(gx, gy, gz, newColorHex) {
        const lKey = this.getLocalKey(gx, gy, gz);
        if (!this.voxels.has(lKey)) return;
        const { instanceId } = this.voxels.get(lKey);
        this.voxels.set(lKey, { color: newColorHex, instanceId: instanceId });
        this.updateInstanceColor(instanceId, newColorHex);
    }
    updateInstanceColor(instanceId, hex) {
        const c = new THREE.Color(hex); this.instancedMesh.instanceColor.setXYZ(instanceId, c.r, c.g, c.b);
        this.instancedMesh.instanceColor.needsUpdate = true;
    }
    dispose() {
        this.scene.remove(this.instancedMesh);
        this.instancedMesh.geometry.dispose(); this.instancedMesh.material.dispose();
        // Clear maps to release references
        this.instancedMesh = null; this.voxels.clear(); this.globalToLocalInstanceIdMap.clear();
    }
}

function onResize() {
    cam.aspect = containerDiv.clientWidth / containerDiv.clientHeight; cam.updateProjectionMatrix();
    ren.setSize(containerDiv.clientWidth, containerDiv.clientHeight);
    ren.setPixelRatio(isMobile ? Math.min(1.5, window.devicePixelRatio) : window.devicePixelRatio);
}

function handleGesture() {
    const pointers = [...activePointers.values()];
    if (pointers.length === 0) return;

    if (pointers.length === 1) {
        const p = pointers[0];
        const rotateSpeed = isMobile ? ROTATE_SPEED_TOUCH_MOBILE : ROTATE_SPEED_TOUCH_DESKTOP;
        
        euler.y += (p.x - gestureState.lastMid.x) * rotateSpeed;
        euler.x -= (p.y - gestureState.lastMid.y) * rotateSpeed;
        
        euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
        cam.quaternion.setFromEuler(euler);
        gestureState.lastMid = { x: p.x, y: p.y };
        return;
    }

    if (pointers.length >= 2) {
        const [p0, p1] = pointers;
        const midX = (p0.x + p1.x) * 0.5;
        const midY = (p0.y + p1.y) * 0.5;
        const dist = Math.hypot(p1.x - p0.x, p1.y - p0.y);

        if (gestureState.type === 'none') {
            const dMid = Math.hypot(midX - gestureState.startMid.x, midY - gestureState.startMid.y);
            const PINCH_REL_TH = 0.05;
            const relDelta = Math.abs(dist - gestureState.startDist) / gestureState.startDist;
            if (relDelta > PINCH_REL_TH) {
                gestureState.type = 'pinch';
            } else if (dMid > MOVE_PX) {
                gestureState.type = 'pan';
            }
            return;
        } else if (gestureState.type === 'pinch') {
            const pinchZoomMult = isMobile ? PINCH_ZOOM_MULT_MOBILE : PINCH_ZOOM_MULT_DESKTOP;
            const zoomDelta = (dist / gestureState.lastDist - 1) * pinchZoomMult * moveSpeed;
            cam.position.addScaledVector(cam.getWorldDirection(new THREE.Vector3()), zoomDelta);
            gestureState.lastDist = dist;
        } else if (gestureState.type === 'pan') {
            const panSpeed = isMobile ? PAN_SPEED_TOUCH_MOBILE : PAN_SPEED_TOUCH_DESKTOP;
            const dx = (midX - gestureState.lastMid.x) * panSpeed;
            const dy = (midY - gestureState.lastMid.y) * panSpeed;
            
            const right = new THREE.Vector3().crossVectors(cam.getWorldDirection(new THREE.Vector3()), cam.up).normalize();
            cam.position.addScaledVector(right, dx);
            cam.position.addScaledVector(new THREE.Vector3(0, 1, 0), dy);
            
            gestureState.lastMid = { x: midX, y: midY };
        }
    }
}

function releasePointer(id, eventType) {
    activePointers.delete(id);
    if (activePointers.size < 2) {
        gestureState.type = 'none';
        if (activePointers.size === 1) { const last = [...activePointers.values()][0]; gestureState.lastMid = { x: last.x, y: last.y }; }
    }
    if (activePointers.size === 0) {
        doubleTapDragActive = false; lastActionVoxelCoords = null; touchIndicator.style.display = 'none';
        initialDragVoxelWorldPos = null; dragAxisLock = null; // initialDragVoxelCoords = null; // This variable is now effectively initialTargetVoxelCoords
        previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
    }
}

function rebuildHelpers() {
    if (gridHelper) scene.remove(gridHelper); if (boxHelper) scene.remove(boxHelper);
    const size = GRID * VS;
    if (isMobile) {
        gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444 ); gridHelper.position.set(size / 2, activeDrawingLevel.y * VS, size / 2);
    } else {
        if (currentDrawingAxis === 'y') {
            gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444 ); gridHelper.position.set(size / 2, activeDrawingLevel.y * VS, size / 2);
        } else if (currentDrawingAxis === 'x') {
            gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444); gridHelper.rotation.z = Math.PI / 2; gridHelper.position.set(activeDrawingLevel.x * VS, size / 2, size / 2);
        } else if (currentDrawingAxis === 'z') {
            gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444); gridHelper.rotation.x = Math.PI / 2; gridHelper.position.set(size / 2, size / 2, activeDrawingLevel.z * VS);
        }
    }
    scene.add(gridHelper);
    const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(size, size, size));
    boxHelper = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x00ffff }));
    boxHelper.position.set(size / 2, size / 2, size / 2); scene.add(boxHelper);

    const mobileAxisIcon = document.getElementById('mobile-axis-icon');
    if (mobileAxisIcon) {
        mobileAxisIcon.className = AxisIcons[currentDrawingAxis];
    }
}

function updateGridHelperPosition() {
    rebuildHelpers();
    localStorage.setItem('voxelEditorActiveDrawingLevelX', activeDrawingLevel.x);
    localStorage.setItem('voxelEditorActiveDrawingLevelY', activeDrawingLevel.y);
    localStorage.setItem('voxelEditorActiveDrawingLevelZ', activeDrawingLevel.z);
    localStorage.setItem('voxelEditorCurrentDrawingAxis', currentDrawingAxis);
}

function cycleMode() {
    const activeElement = document.activeElement;
    if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'SELECT' || activeElement.tagName === 'TEXTAREA')) {
        cvs.focus(); return;
    }
    switch (currentMode) {
        case Modes.ADD: currentMode = Modes.DELETE; break;
        case Modes.DELETE: currentMode = Modes.DRAW; break;
        case Modes.DRAW: currentMode = Modes.ADD; break;
    }
    document.getElementById('current-mode').textContent = `Modus: ${currentMode}`;
    const mobileModeIcon = document.getElementById('mobile-mode-icon');
    if (mobileModeIcon) {
        mobileModeIcon.className = ModeIcons[currentMode];
    }
    lastActionVoxelCoords = null; updatePreviewVoxel(0, 0, 0, false);
    previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
}

function setActivePreset(index) {
    if (index >= 0 && index < presetColors.length) {
        currentColor = presetColors[index];
        document.getElementById('color-picker').value = currentColor;
        const mobileColorInput = document.getElementById('mobile-color-input');
        if (mobileColorInput) mobileColorInput.value = currentColor;
        localStorage.setItem('voxelEditorColor', currentColor);
        presetBoxes.forEach((box, i) => {
            if (i === index) { box.classList.add('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'); }
            else { box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'); }
        });
        activePresetIndex = index;
        if (previewVoxelMesh.visible) {
            previewVoxelMaterial.color.set(currentColor);
        }
    }
}

function savePresetColor(index, colorValue) {
    if (index >= 0 && index < presetColors.length) {
        presetColors[index] = colorValue;
        localStorage.setItem(`voxelPresetColor${index + 1}`, colorValue);
        if (activePresetIndex === index) {
            currentColor = colorValue;
            document.getElementById('color-picker').value = currentColor;
            const mobileColorInput = document.getElementById('mobile-color-input');
            if (mobileColorInput) mobileColorInput.value = currentColor;
            localStorage.setItem('voxelEditorColor', currentColor);
        }
    }
}

/**
 * Applies a given voxel state (a Map of global keys to { color: hex } objects)
 * to the scene, clearing existing voxels and adding new ones.
 * This is used for loading, undoing/redoing full snapshots (like resizeGrid).
 */
function applyVoxelState(stateMap) {
    // Dispose all current chunks and clear maps
    for (const chunk of chunks.values()) chunk.dispose();
    chunks.clear();
    voxels.clear();

    // Add voxels from the provided state map
    stateMap.forEach((data, gKey) => {
        const p = parseKey(gKey);
        // _addSingleVoxel is a low-level function that doesn't interact with history
        _addSingleVoxel(p[0], p[1], p[2], data.color);
    });
}

/**
 * Adds a command to the history stack.
 * @param {object} command - The command object.
 * - type: string (e.g., 'batch', 'clearAll', 'fillLevel', 'resizeGrid')
 * - changes: Array of {gx, gy, gz, oldColor, newColor} (for 'batch' type)
 * - oldState: Map (for 'clearAll', 'fillLevel', 'resizeGrid')
 * - newState: Map (for 'clearAll', 'fillLevel', 'resizeGrid')
 * - commandData: object (for 'resizeGrid')
 */
function addCommand(command) {
    // If we've undone actions, any new action should clear the redo history
    if (historyPointer < history.length - 1) {
        history.splice(historyPointer + 1);
    }
    history.push(command);
    historyPointer++;

    // Prune history if it exceeds MAX_HISTORY_SIZE
    while (history.length > MAX_HISTORY_SIZE) {
        history.shift(); // Remove the oldest command
        historyPointer--;
    }
}

/**
 * Executes or reverts a command from history.
 * @param {object} command - The command object to execute.
 * @param {boolean} reverse - If true, reverts the command (undo); otherwise, executes (redo).
 */
function executeCommand(command, reverse = false) {
    const { type, changes, oldState, newState, commandData } = command;

    switch (type) {
        case 'batch':
            // Apply or revert individual voxel changes recorded in the batch
            changes.forEach(change => {
                const targetColor = reverse ? change.oldColor : change.newColor;
                const currentVoxelKey = key(change.gx, change.gy, change.gz);
                const currentVoxelExists = voxels.has(currentVoxelKey);

                if (targetColor === null) { // Voxel should be removed
                    if (currentVoxelExists) {
                        _removeSingleVoxel(change.gx, change.gy, change.gz);
                    }
                } else { // Voxel should exist with a specific color
                    if (currentVoxelExists) {
                        // Only recolor if different, for efficiency
                        if (voxels.get(currentVoxelKey).color !== targetColor) {
                            _recolorSingleVoxel(change.gx, change.gy, change.gz, targetColor);
                        }
                    } else {
                        _addSingleVoxel(change.gx, change.gy, change.gz, targetColor);
                    }
                }
            });
            break;
        case 'clearAll':
        case 'fillLevel':
            // For these, we store and apply full snapshots as they are large-scale operations
            applyVoxelState(reverse ? oldState : newState);
            break;
        case 'resizeGrid':
            // Adjust grid size and then apply the filtered voxel state
            GRID = reverse ? commandData.oldGrid : commandData.newGrid;
            document.getElementById('grid-size-slider').value = GRID;
            document.getElementById('grid-size-display').textContent = `${GRID}×${GRID}×${GRID}`;
            localStorage.setItem('voxelEditorGridSize', GRID);
            applyVoxelState(reverse ? oldState : newState);
            break;
    }
    rebuildHelpers(); // Update grid and box helpers after state change
}

function undo() {
    if (historyPointer >= 0) {
        executeCommand(history[historyPointer], true); // true for reverse (undo)
        historyPointer--;
    } else {
        showToast('Info', 'Nichts zum Rückgängigmachen.', 'info', 2000);
    }
}

function redo() {
    if (historyPointer < history.length - 1) {
        historyPointer++;
        executeCommand(history[historyPointer], false); // false for forward (redo)
    } else {
        showToast('Info', 'Nichts zum Wiederholen.', 'info', 2000);
    }
}

/**
 * Low-level function to add a single voxel. Does not interact with history.
 */
function _addSingleVoxel(gx, gy, gz, colorHex) {
    const gKey = key(gx, gy, gz);
    voxels.set(gKey, { color: colorHex }); // Update the main voxel map

    const { cx, cy, cz } = getChunkCoords(gx, gy, gz);
    const cKey = getChunkKey(cx, cy, cz);
    let chunk = chunks.get(cKey);
    if (!chunk) {
        chunk = new VoxelChunk(cx, cy, cz, CHUNK_SIZE, scene);
        chunks.set(cKey, chunk);
    }
    chunk.addVoxel(gx, gy, gz, colorHex); // Add to the chunk's instanced mesh
}

/**
 * Low-level function to remove a single voxel. Does not interact with history.
 */
function _removeSingleVoxel(gx, gy, gz) {
    const gKey = key(gx, gy, gz);
    if (!voxels.has(gKey)) return;

    voxels.delete(gKey); // Remove from the main voxel map

    const { cx, cy, cz } = getChunkCoords(gx, gy, gz);
    const cKey = getChunkKey(cx, cy, cz);
    if (chunks.has(cKey)) {
        const chunk = chunks.get(cKey);
        chunk.removeVoxel(gx, gy, gz); // Remove from the chunk's instanced mesh
        if (chunk.instancedMesh.count === 0) {
            chunk.dispose();
            chunks.delete(cKey); // Dispose chunk if empty
        }
    }
}

/**
 * Low-level function to recolor a single voxel. Does not interact with history.
 */
function _recolorSingleVoxel(gx, gy, gz, newColorHex) {
    const gKey = key(gx, gy, gz);
    if (!voxels.has(gKey)) return;

    // Only recolor if the color is actually different
    if (voxels.get(gKey).color !== newColorHex) {
        voxels.set(gKey, { color: newColorHex }); // Update the main voxel map
        const { cx, cy, cz } = getChunkCoords(gx, gy, gz);
        const cKey = getChunkKey(cx, cy, cz);
        if (chunks.has(cKey)) {
            chunks.get(cKey).recolorVoxel(gx, gy, gz, newColorHex); // Recolor in the chunk's instanced mesh
        }
    }
}

/**
 * Calculates ray intersection with existing voxels or the drawing plane.
 * Returns the integer coordinates of the hit point (voxel or plane) and the face normal if a voxel was hit.
 * IMPORTANT: This function does NOT apply any normal-based adjustments for placement.
 * That logic is handled in the pointer event handlers based on mode.
 */
function calculateRayTargetVoxelCoords(clientX, clientY) {
    if (isPointerLocked) return null;

    const rect = cvs.getBoundingClientRect();
    const mouse = new THREE.Vector2(
        ((clientX - rect.left) / rect.width) * 2 - 1,
        -((clientY - rect.top) / rect.height) * 2 + 1
    );

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, cam);

    const objectsToIntersect = Array.from(chunks.values()).map(chunk => chunk.instancedMesh);
    if (templateImageMesh) {
        templateImageMesh.raycast = function() {}; // Prevent raycasting template image
    }

    const intersects = raycaster.intersectObjects(objectsToIntersect);

    if (intersects.length > 0) {
        const hit = intersects[0];
        // Get the integer coordinates of the hit voxel.
        // We use Math.floor on the point. This gives us the voxel that the ray entered.
        const hitVoxelX = Math.floor(hit.point.x / VS);
        const hitVoxelY = Math.floor(hit.point.y / VS);
        const hitVoxelZ = Math.floor(hit.point.z / VS);

        // Return the hit voxel's coordinates and the face normal.
        return { gx: Number(hitVoxelX), gy: Number(hitVoxelY), gz: Number(hitVoxelZ), faceNormal: hit.face.normal.clone(), hitExistingVoxel: true };
    } else {
        // If no voxel is hit, intersect with the current drawing plane.
        let planeNormal = new THREE.Vector3();
        let planeConstant = 0;

        if (currentDrawingAxis === 'y') {
            planeNormal.set(0, 1, 0);
            planeConstant = -(activeDrawingLevel.y * VS);
        } else if (currentDrawingAxis === 'x') {
            planeNormal.set(1, 0, 0);
            planeConstant = -(activeDrawingLevel.x * VS);
        } else if (currentDrawingAxis === 'z') {
            planeNormal.set(0, 0, 1);
            planeConstant = -(activeDrawingLevel.z * VS);
        }

        const drawingPlane = new THREE.Plane(planeNormal, planeConstant);
        const intersectionPoint = new THREE.Vector3();

        if (raycaster.ray.intersectPlane(drawingPlane, intersectionPoint)) {
            if (!Number.isFinite(intersectionPoint.x) || !Number.isFinite(intersectionPoint.y) || !Number.isFinite(intersectionPoint.z)) {
                return null;
            }

            let gx = Math.floor(intersectionPoint.x / VS);
            let gy = Math.floor(intersectionPoint.y / VS);
            let gz = Math.floor(intersectionPoint.z / VS);

            // Ensure the intersection is on the specific active drawing plane level.
            if (currentDrawingAxis === 'y') gy = activeDrawingLevel.y;
            else if (currentDrawingAxis === 'x') gx = activeDrawingLevel.x;
            else if (currentDrawingAxis === 'z') gz = activeDrawingLevel.z;

            gx = Number(gx);
            gy = Number(gy);
            gz = Number(gz);

            if (!Number.isFinite(gx) || !Number.isFinite(gy) || !Number.isFinite(gz)) {
                return null;
            }

            return { gx, gy, gz, faceNormal: planeNormal.clone(), hitExistingVoxel: false };
        }
    }
    return null;
}

/**
 * Updates the preview voxel mesh's position, visibility, and color based on interaction.
 * This function is now defined globally and explicitly to avoid "not defined" errors.
 * @param {number} x - X coordinate of the preview voxel.
 * @param {number} y - Y coordinate of the preview voxel.
 * @param {number} z - Z coordinate of the preview voxel.
 * @param {boolean} visible - Whether the preview voxel should be visible.
 */
function updatePreviewVoxel(x, y, z, visible) {
    if (previewVoxelMesh) {
        if (visible) {
            if (previewVoxelMesh.geometry.parameters.width !== VS ||
                previewVoxelMesh.geometry.parameters.height !== VS ||
                previewVoxelMesh.geometry.parameters.depth !== VS) {
                previewVoxelMesh.geometry.dispose();
                previewVoxelMesh.geometry = new THREE.BoxGeometry(VS, VS, VS);
            }
            previewVoxelMesh.position.set(x * VS + HALF, y * VS + HALF, z * VS + HALF);
            previewVoxelMesh.visible = true;
            previewVoxelMaterial.color.set(currentColor);
            previewVoxelMaterial.opacity = (currentMode === Modes.DELETE) ? 0.2 : 0.5;
        } else {
            previewVoxelMesh.visible = false;
        }
    }
}


/**
 * Clears all voxels from the scene and adds a corresponding command to history.
 * @param {boolean} fromHistory - True if called by undo/redo, false otherwise.
 */
function clearAllInternal(fromHistory = false) {
    if (!fromHistory) {
        const changes = [];
        // Capture all existing voxels as changes (old color -> null) for history
        voxels.forEach((data, gKey) => {
            const p = parseKey(gKey);
            changes.push({ gx: p[0], gy: p[1], gz: p[2], oldColor: data.color, newColor: null });
        });
        // Add a batch command representing the mass removal
        addCommand({ type: 'batch', changes: changes });
    }
    // Perform the actual clear operation
    for (const chunk of chunks.values()) chunk.dispose();
    chunks.clear();
    voxels.clear();
    rebuildHelpers();
}

function clearAll() { clearAllInternal(false); }

/**
 * Fills the active drawing level with the current color.
 * Adds a corresponding batch command to history.
 */
function fillActiveLevel() {
    const changes = [];
    const voxelsToProcess = new Map(); // Use a map to handle unique coordinates

    // Identify all voxels that would be on the active drawing plane
    for (let x = 0; x < GRID; x++) {
        for (let z = 0; z < GRID; z++) {
            let gx, gy, gz;
            if (currentDrawingAxis === 'y') { gx = x; gy = activeDrawingLevel.y; gz = z; }
            else if (currentDrawingAxis === 'x') { gx = activeDrawingLevel.x; gy = x; gz = z; }
            else if (currentDrawingAxis === 'z') { gx = x; gy = z; gz = activeDrawingLevel.z; }
            
            const gKey = key(gx, gy, gz);
            const oldColor = voxels.has(gKey) ? voxels.get(gKey).color : null;
            const newColor = currentColor;

            // Only add a change if the color is actually changing or a new voxel is being added
            if (oldColor !== newColor) {
                voxelsToProcess.set(gKey, { gx, gy, gz, oldColor, newColor });
            }
        }
    }

    // Apply the changes to the scene and collect them for the history command
    voxelsToProcess.forEach(change => {
        const { gx, gy, gz, oldColor, newColor } = change;
        if (newColor === null) { // Should not happen for fill, but for consistency
            _removeSingleVoxel(gx, gy, gz);
        } else {
            if (oldColor === null) { // Adding a new voxel
                _addSingleVoxel(gx, gy, gz, newColor);
            } else { // Recolor an existing voxel
                _recolorSingleVoxel(gx, gy, gz, newColor);
            }
        }
        changes.push(change); // Add to the list of actual changes for the command
    });
    
    // Add the batch command to history only if there were actual changes
    if (changes.length > 0) {
        addCommand({ type: 'batch', changes: changes });
    }
}

function saveJSON() {
    const data = {};
    voxels.forEach((value, k) => {
        const [gx, gy, gz] = parseKey(k);
        data[`${gx},${gy},${gz}`] = value.color;
    });

    const settings = {
        gridSize: GRID,
        cameraPosition: cam.position.toArray(),
        cameraQuaternion: cam.quaternion.toArray(),
        activeDrawingLevel: activeDrawingLevel,
        currentDrawingAxis: currentDrawingAxis,
        currentColor: currentColor,
        presetColors: presetColors,
        activePresetIndex: activePresetIndex,
        moveSpeed: moveSpeed,
        templateImageData: templateImageData
    };

    const fileContent = {
        title: projectTitle,
        description: projectDescription,
        category: projectCategory,
        tags: projectTags,
        remixOf: projectRemixOf,
        sourceJsonUrl: projectSourceJsonUrl,
        visibility: projectVisibility,
        fileName: `${projectTitle.replace(/\s+/g, "_") || "voxel_project"}.json`,
        timestamp: new Date().toISOString(),

        projectData: {
            settings: settings,
            voxels: data
        }
    };

    const blob = new Blob([JSON.stringify(fileContent, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = fileContent.fileName;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    showToast('Speichern erfolgreich', 'Projekt als JSON-Datei gespeichert.', 'success', 5000);
}

function resetToDefaultProject() {
    clearAllInternal(true); // Clear without adding to history (since we're resetting)
    GRID = 10;
    document.getElementById('grid-size-slider').value = GRID; document.getElementById('grid-size-display').textContent = `${GRID}×${GRID}×${GRID}`; localStorage.setItem('voxelEditorGridSize', GRID);
    currentColor = '#ffffff'; document.getElementById('color-picker').value = currentColor; localStorage.setItem('voxelEditorColor', currentColor);
    const mobileColorInput = document.getElementById('mobile-color-input');
    if (mobileColorInput) mobileColorInput.value = currentColor;

    activeDrawingLevel = { x: 0, y: 0, z: 0 }; currentDrawingAxis = 'y';
    localStorage.setItem('voxelEditorActiveDrawingLevelX', activeDrawingLevel.x);
    localStorage.setItem('voxelEditorActiveDrawingLevelY', activeDrawingLevel.y);
    localStorage.setItem('voxelEditorActiveDrawingLevelZ', activeDrawingLevel.z);
    localStorage.setItem('voxelEditorCurrentDrawingAxis', currentDrawingAxis);
    moveSpeed = 0.1; document.getElementById('fly-speed-slider').value = moveSpeed; document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2); localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
    presetColors[0] = '#E4002B'; presetColors[1] = '#00A040'; presetColors[2] = '#0057B8';
    localStorage.setItem('voxelPresetColor1', presetColors[0]); localStorage.setItem('voxelPresetColor2', presetColors[1]); localStorage.setItem('voxelPresetColor3', presetColors[2]);
    presetBoxes.forEach((box, i) => { box.value = presetColors[i]; box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'); });
    activePresetIndex = -1; removeImageTemplate(true);
    history.length = 0; historyPointer = -1; // Reset history
    previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
    projectTitle = ''; projectDescription = ''; projectCategory = 'Allgemein'; projectTags = []; projectRemixOf = ''; projectSourceJsonUrl = ''; projectVisibility = 'public';
    rebuildHelpers(); resetCameraPosition(); showToast('Projekt zurückgesetzt', 'Das Projekt wurde auf den Standardzustand zurückgesetzt.', 'info', 5000);
}

function loadProjectData(projectData) {
    try {
        const loadedVoxelsMap = new Map();
        const rawVoxels = projectData.projectData ? projectData.projectData.voxels : projectData.voxels;

        // Convert raw object to Map for consistent use with applyVoxelState
        for (const k in rawVoxels) {
            const colorValue = rawVoxels[k];
            const parts = k.split(',').map(Number);
            if (parts.length === 3 && !isNaN(parts[0]) && !isNaN(parts[1]) && !isNaN(parts[2])) {
                loadedVoxelsMap.set(key(parts[0], parts[1], parts[2]), { color: colorValue });
            }
        }

        clearAllInternal(true); // Clear current state without adding to history
        removeImageTemplate(true);

        projectTitle = projectData.title || ''; projectDescription = projectData.description || '';
        projectCategory = projectData.category || 'Allgemein';
        projectTags = Array.isArray(projectData.tags) ? projectData.tags : (typeof projectData.tags === 'string' ? projectData.tags.split(',').map(tag => tag.trim()).filter(tag => tag !== '') : []);
        projectRemixOf = projectData.remixOf || ''; projectSourceJsonUrl = projectData.sourceJsonUrl || ''; projectVisibility = projectData.visibility || 'public';

        const loadedSettings = projectData.projectData ? projectData.projectData.settings : projectData.settings;

        if (loadedSettings) {
            GRID = loadedSettings.gridSize !== undefined ? loadedSettings.gridSize : 10;
            document.getElementById('grid-size-slider').value = GRID; document.getElementById('grid-size-display').textContent = `${GRID}×${GRID}×${GRID}`; localStorage.setItem('voxelEditorGridSize', GRID);
        }

        // Apply loaded voxels
        applyVoxelState(loadedVoxelsMap);

        if (loadedSettings) {
            if (loadedSettings.cameraPosition) cam.position.fromArray(loadedSettings.cameraPosition);
            if (loadedSettings.cameraQuaternion) { cam.quaternion.fromArray(loadedSettings.cameraQuaternion); euler.setFromQuaternion(cam.quaternion, 'YXZ'); }
            if (loadedSettings.activeDrawingLevel) {
                activeDrawingLevel = {
                    x: Number(loadedSettings.activeDrawingLevel.x || 0),
                    y: Number(loadedSettings.activeDrawingLevel.y || 0),
                    z: Number(loadedSettings.activeDrawingLevel.z || 0)
                };
                if (!Number.isFinite(activeDrawingLevel.x)) activeDrawingLevel.x = 0;
                if (!Number.isFinite(activeDrawingLevel.y)) activeDrawingLevel.y = 0;
                if (!Number.isFinite(activeDrawingLevel.z)) activeDrawingLevel.z = 0;

                activeDrawingLevel.x = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.x)));
                activeDrawingLevel.y = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.y)));
                activeDrawingLevel.z = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.z)));

                localStorage.setItem('voxelEditorActiveDrawingLevelX', activeDrawingLevel.x);
                localStorage.setItem('voxelEditorActiveDrawingLevelY', activeDrawingLevel.y);
                localStorage.setItem('voxelEditorActiveDrawingLevelZ', activeDrawingLevel.z);
            }
            if (loadedSettings.currentDrawingAxis) { currentDrawingAxis = loadedSettings.currentDrawingAxis; localStorage.setItem('voxelEditorCurrentDrawingAxis', currentDrawingAxis); }
            updateGridHelperPosition();
            currentColor = loadedSettings.currentColor || '#ffffff'; document.getElementById('color-picker').value = currentColor;
            const mobileColorInput = document.getElementById('mobile-color-input');
            if (mobileColorInput) mobileColorInput.value = currentColor;

            if (loadedSettings.presetColors) {
                for(let i = 0; i < loadedSettings.presetColors.length && i < presetColors.length; i++) {
                    presetColors[i] = loadedSettings.presetColors[i]; document.getElementById(`color-preset-${i + 1}`).value = presetColors[i]; localStorage.setItem(`voxelPresetColor${i + 1}`, presetColors[i]);
                }
            }
            setActivePreset(loadedSettings.activePresetIndex !== undefined ? loadedSettings.activePresetIndex : -1);
            if (loadedSettings.moveSpeed !== undefined) {
                moveSpeed = loadedSettings.moveSpeed; document.getElementById('fly-speed-slider').value = moveSpeed; document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2); localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
            }
            if (loadedSettings.templateImageData) {
                templateImageData = loadedSettings.templateImageData;
                new THREE.TextureLoader().load(templateImageData.src, (texture) => {
                    const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true, depthWrite: false });
                    const geometry = new THREE.PlaneGeometry(templateImageData.scaledWidth, templateImageData.scaledHeight);
                    if (templateImageMesh) { scene.remove(templateImageMesh); templateImageMesh.geometry.dispose(); templateImageMesh.material.dispose(); }
                    templateImageMesh = new THREE.Mesh(geometry, material);
                    templateImageMesh.position.fromArray(templateImageData.position); templateImageMesh.rotation.fromArray(templateImageData.rotation); templateImageMesh.scale.fromArray(templateImageData.scale);
                    templateImageMesh.renderOrder = -1; scene.add(templateImageMesh);
                    document.getElementById('removeImageTemplateBtn').classList.remove('hidden');
                }, undefined, (err) => { templateImageMesh = null; templateImageData = null; document.getElementById('removeImageTemplateBtn').classList.add('hidden'); });
            }
        }
        history.length = 0; historyPointer = -1; // Reset history on project load
        previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
        resetCameraPosition();
    } catch (error) {
        showToast('Fehler', 'Fehler beim Laden der Datei. Stellen Sie sicher, dass es sich um eine gültige JSON-Datei handelt. Fehler: ' + error.message, 'error', 5000);
        resetToDefaultProject();
    }
}

async function loadProjectFromModelId(modelId) {
    showToast('Lade Projekt', `Lade Projekt mit ID: ${modelId}...`, 'info', 5000);
    try {
        const docSnap = await window.firebase.getDoc(window.firebase.doc(db, "models", modelId));
        if (docSnap.exists()) {
            const pData = docSnap.data();
            const isPublic = pData.visibility === 'public';
            const isOwner = auth.currentUser && auth.currentUser.uid === pData.uploaderUid;
            if (isPublic || isOwner) {
                if (pData && pData.projectData) {
                    projectRemixOf = modelId; projectSourceJsonUrl = window.location.href;
                    loadProjectData(pData);
                    showToast('Projekt geladen', `Projekt "${docSnap.data().title}" erfolgreich geladen.`, 'success', 5000);
                } else { showToast('Fehler', 'Projektdaten im Dokument nicht gefunden.', 'error', 5000); resetToDefaultProject(); }
            } else { showToast('Zugriff verweigert', 'Sie haben keine Berechtigung, dieses private Projekt zu laden.', 'error', 5000); resetToDefaultProject(); }
        } else { showToast('Projekt nicht gefunden', `Kein Projekt mit ID "${modelId}" gefunden.`, 'warning', 5000); resetToDefaultProject(); }
    } catch (error) {
        if (error.code === 'permission-denied') showToast('Zugriff verweigert', `Berechtigungsfehler beim Laden des Projekts. Stellen Sie sicher, dass das Modell öffentlich ist oder Sie der Eigentümer sind.`, 'error', 5000);
        else showToast('Fehler', `Fehler beim Laden des Projekts: ${error.message}`, 'error', 5000);
        resetToDefaultProject();
    }
}

function loadJSON(event) {
    const file = event.target.files[0]; if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const projectData = JSON.parse(e.target.result);
            projectRemixOf = ''; projectSourceJsonUrl = ''; loadProjectData(projectData);
        } catch (error) {
            showToast('Fehler', 'Fehler beim Parsen der Datei. Stellen Sie sicher, dass es sich um eine gültige JSON-Datei handelt. Fehler: ' + error.message, 'error', 5000);
            resetToDefaultProject();
        }
    };
    reader.readAsText(file);
}

async function exportSTL() {
    if (voxels.size === 0) { showToast('Export fehlgeschlagen', 'Keine Voxel zum Exportieren vorhanden!', 'warning', 5000); return; }
    showToast('Exportiere STL', 'Erzeuge STL-Modell...', 'info', 5000);
    const geometriesToMerge = []; const tempBoxGeometry = new THREE.BoxGeometry(VS, VS, VS);
    voxels.forEach((data, k) => {
        const [x, y, z] = parseKey(k);
        dummy.position.set(x * VS + HALF, y * VS + HALF, z * VS + HALF); dummy.updateMatrix();
        const instanceGeometry = tempBoxGeometry.clone(); instanceGeometry.applyMatrix4(dummy.matrix);
        const c = new THREE.Color(data.color);
        const vtxColorArr = []; for (let j = 0; j < instanceGeometry.attributes.position.count; j++) vtxColorArr.push(c.r, c.g, c.b);
        instanceGeometry.setAttribute('color', new THREE.Float32BufferAttribute(vtxColorArr, 3));
        geometriesToMerge.push(instanceGeometry);
    });
    const mergedGeometry = geometriesToMerge.length > 0 ? THREE.BufferGeometryUtils.mergeBufferGeometries(geometriesToMerge, true) : new THREE.BufferGeometry();
    const tempMesh = new THREE.Mesh(mergedGeometry);
    if (typeof THREE.STLExporter === 'undefined') { showToast('Export fehlgeschlagen', 'STLExporter-Bibliothek nicht geladen.', 'error', 5000); return; }
    const exporter = new THREE.STLExporter(); const result = exporter.parse(tempMesh);
    const blob = new Blob([result], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'voxel_model.stl';
    document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
    tempBoxGeometry.dispose(); if (mergedGeometry) mergedGeometry.dispose();
    showToast('Export erfolgreich', 'STL-Modell erfolgreich exportiert!', 'success', 5000);
}

async function exportOBJ() {
    if (voxels.size === 0) { showToast('Export fehlgeschlagen', 'Keine Voxel zum Exportieren vorhanden!', 'warning', 5000); return; }
    showToast('Exportiere OBJ', 'Erzeuge OBJ-Modell...', 'info', 5000);
    const voxelsToExport = []; let maxX = 0, maxY = 0, maxZ = 0;
    voxels.forEach((data, k) => {
        const [x, y, z] = parseKey(k); voxelsToExport.push({ x, y, z, color: data.color });
        maxX = Math.max(maxX, x); maxY = Math.max(maxY, y); maxZ = Math.max(maxZ, z);
    });
    const voxModel = new VoxelShaperIO.VoxModel(maxX + 1, maxY + 1, maxZ + 1, voxelsToExport);
    VoxelShaperIO.saveBlob(VoxelShaperIO.voxToOBJ(voxModel, VS), 'voxel_model.obj');
    showToast('Export erfolgreich', 'OBJ-Modell erfolgreich mit Farben exportiert!', 'success', 5000);
}

async function exportGLB() {
    if (voxels.size === 0) {
        showToast('Export fehlgeschlagen', 'Keine Voxel zum Exportieren vorhanden!', 'warning', 5000);
        return;
    }
    showToast('Exportiere GLB', 'Erzeuge GLB-Modell...', 'info', 5000);

    if (typeof THREE.GLTFExporter === 'undefined') {
        showToast('Export fehlgeschlagen', 'GLTFExporter-Bibliothek nicht geladen. Bitte versuchen Sie es erneut.', 'error', 5000);
        return;
    }

    const exporter = new THREE.GLTFExporter();
    const tempGroup = new THREE.Group();
    const tempGeometry = new THREE.BoxGeometry(VS, VS, VS);

    const materialCache = new Map();

    voxels.forEach((data, k) => {
        const [x, y, z] = parseKey(k);
        const colorHex = data.color;

        let material = materialCache.get(colorHex);
        if (!material) {
            material = new THREE.MeshStandardMaterial({ color: new THREE.Color(colorHex) });
            materialCache.set(colorHex, material);
        }

        const mesh = new THREE.Mesh(tempGeometry, material);
        mesh.position.set(x * VS + HALF, y * VS + HALF, z * VS + HALF);
        tempGroup.add(mesh);
    });

    exporter.parse(
        tempGroup,
        function (result) {
            const blob = new Blob([result], { type: 'model/gltf-binary' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'voxel_model.glb';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showToast('Export erfolgreich', 'GLB-Modell erfolgreich exportiert!', 'success', 5000);
        },
        function (error) {
            showToast('Export fehlgeschlagen', `Fehler beim Exportieren des GLB-Modells: ${error.message}`, 'error', 5000);
        },
        { binary: true }
    );

    tempGeometry.dispose();
    materialCache.forEach(mat => mat.dispose());
    while(tempGroup.children.length > 0){
        const object = tempGroup.children[0];
        tempGroup.remove(object);
    }
}


function showToast(title, message, type = 'info', duration = 5000) {
    const toast = document.createElement('div');
    toast.className = `alert shadow-lg ${type === 'info' ? 'alert-info' : type === 'success' ? 'alert-success' : type === 'error' ? 'alert-error' : type === 'warning' ? 'alert-warning' : ''}`;
    toast.innerHTML = `
        ${type === 'info' ? '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" class="stroke-current shrink-0 h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>' : ''}
        ${type === 'success' ? '<svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>' : ''}
        ${type === 'error' ? '<svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>' : ''}
        ${type === 'warning' ? '<svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>' : ''}
        <div><strong>${title}</strong><br><span>${message}</span></div><button class="close-btn btn btn-ghost btn-sm">&times;</button>`;
    toastContainer.appendChild(toast);
    void toast.offsetWidth; toast.classList.add('show');
    toast.querySelector('.close-btn').addEventListener('click', () => { toast.classList.remove('show'); toast.addEventListener('transitionend', () => toast.remove(), { once: true }); });
    setTimeout(() => { if (toast.parentNode) { toast.classList.remove('show'); toast.addEventListener('transitionend', () => toast.remove(), { once: true }); } }, duration);
}

function resetCameraPosition() {
    cam.position.set(GRID * 1.0, GRID * 1.2, GRID * 1.5); cam.lookAt(GRID / 2, GRID / 2, GRID / 2);
    if (euler) euler.setFromQuaternion(cam.quaternion, 'YXZ');
}

function loadImageTemplate() {
    document.getElementById('imageFileInput').click();
}

function handleImageFileSelect(event) {
    const file = event.target.files[0];
    if (!file) {
        return;
    }
    const reader = new FileReader();
    reader.onload = (e) => {
        const base64Image = e.target.result;
        const img = new Image();
        img.onload = () => {
            const aspectRatio = img.width / img.height;
            const planeWidth = GRID * VS;
            const planeHeight = planeWidth / aspectRatio;

            if (templateImageMesh) {
                scene.remove(templateImageMesh);
                templateImageMesh.geometry.dispose();
                templateImageMesh.material.dispose();
            }

            const texture = new THREE.TextureLoader().load(base64Image);
            const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true, depthWrite: false });
            const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
            templateImageMesh = new THREE.Mesh(geometry, material);

            templateImageMesh.position.set((GRID * VS) / 2, (GRID * VS) / 2, -0.001);
            templateImageMesh.rotation.set(0, 0, 0);

            templateImageMesh.renderOrder = -1; scene.add(templateImageMesh);
            templateImageData = {
                src: base64Image,
                position: templateImageMesh.position.toArray(),
                rotation: templateImageMesh.rotation.toArray(),
                scale: [1, 1, 1],
                scaledWidth: planeWidth,
                scaledHeight: planeHeight
            };
            document.getElementById('removeImageTemplateBtn').classList.remove('hidden');
            showToast('Bildvorlage geladen', 'Bild als Vorlage erfolgreich geladen.', 'success', 5000);
        };
        img.onerror = (err) => {
            showToast('Fehler', 'Bild konnte nicht geladen werden. Ungültiges Bildformat?', 'error', 5000);
            templateImageMesh = null;
            templateImageData = null;
            document.getElementById('removeImageTemplateBtn').classList.add('hidden');
        };
        img.src = base64Image;
    };
    reader.onerror = (err) => {
        showToast('Fehler', 'Fehler beim Lesen der Bilddatei.', 'error', 5000);
    };
    reader.readAsDataURL(file);

    event.target.value = '';
}
function removeImageTemplate(fromLoad = false) {
    if (templateImageMesh) {
        scene.remove(templateImageMesh); templateImageMesh.geometry.dispose(); templateImageMesh.material.dispose();
        templateImageMesh = null; templateImageData = null; document.getElementById('removeImageTemplateBtn').classList.add('hidden');
        if (!fromLoad) showToast('Bildvorlage entfernt', 'Bildvorlage erfolgreich entfernt.', 'info', 5000);
    }
}

function getCurrentBlockDimensions() {
    return { dimX: 1, dimY: 1, dimZ: 1 };
}

async function loginLogout() {
    if (auth.currentUser) { try { await window.firebase.signOut(auth); showToast('Abgemeldet', 'Sie wurden erfolgreich abgemeldet.', 'info', 5000); } catch (e) { showToast('Fehler beim Abmelden', `Fehler: ${e.message}`, 'error', 5000); } }
    else openAuthModal();
}

function openUploadModal() {
    if (!currentUserId) { openAuthModal(); return; }
    if (voxels.size === 0) { showToast('Upload fehlgeschuldert', 'Die Szene ist leer. Bitte erstellen Sie zuerst ein Modell.', 'warning', 5000); return; }
    document.getElementById('uploadTitle').value = projectTitle; document.getElementById('uploadDescription').value = projectDescription;
    document.getElementById('uploadCategory').value = projectCategory; document.getElementById('uploadTags').value = projectTags.join(', ');
    document.querySelector(`input[name="uploadVisibility"][value="${projectVisibility}"]`).checked = true;
    const uploadCategorySelect = document.getElementById('uploadCategory');
    uploadCategorySelect.innerHTML = '<option value="" disabled selected>Kategorie auswählen</option>';
    predefinedCategories.forEach(cat => { const opt = document.createElement('option'); opt.value = cat; opt.textContent = cat; uploadCategorySelect.appendChild(opt); });
    uploadCategorySelect.value = projectCategory;
    document.getElementById('uploadProjectModal').showModal();
}

async function uploadProjectToHub() {
    if (!currentUserId) { showToast('Fehler', 'Nicht angemeldet. Bitte melden Sie sich an, um hochzuladen.', 'error', 5000); return; }
    if (voxels.size === 0) { showToast('Upload fehlgeschuldert', 'Die Szene ist leer. Bitte erstellen Sie zuerst ein Modell.', 'warning', 5000); return; }
    const title = document.getElementById('uploadTitle').value.trim();
    const description = document.getElementById('uploadDescription').value.trim();
    const category = document.getElementById('uploadCategory').value;
    const tags = document.getElementById('uploadTags').value.split(',').map(tag => tag.trim()).filter(tag => tag !== '');
    const visibility = document.querySelector('input[name="uploadVisibility"]:checked').value;
    if (!title) { showToast('Fehler', 'Bitte geben Sie einen Titel für Ihr Projekt ein.', 'warning', 5000); return; }
    if (!category) { showToast('Fehler', 'Bitte wählen Sie eine Kategorie für Ihr Projekt aus.', 'warning', 5000); 'warning'; return; }
    showToast('Lade hoch...', 'Ihr Projekt wird hochgeladen. Bitte warten Sie...', 'info', 5000);
    try {
        const voxelMap = {}; voxels.forEach((v, k) => { const [gx, gy, gz] = parseKey(k); voxelMap[`${gx},${gy},${gz}`] = v.color; });
        const firestoreSafeSettings = {
            gridSize: GRID, cameraPosition: cam.position.toArray(), cameraQuaternion: cam.quaternion.toArray(),
            activeDrawingLevel: activeDrawingLevel, currentDrawingAxis: currentDrawingAxis, currentColor: currentColor,
            presetColors: presetColors, activePresetIndex: activePresetIndex, moveSpeed: moveSpeed,
            templateImageData: null
        };
        const firestoreDocument = {
            title: title, description: description, category: category, tags: tags, visibility: visibility,
            remixOf: projectRemixOf || "", sourceJsonUrl: projectSourceJsonUrl || "",
            fileName: `${title.replace(/\s+/g, "_")}.json`, downloads: 0, rating: 0, ratingCount: 0, verified: false,
            userId: currentUserId, uploaderEmail: currentUser?.email || "", uploaderUid: currentUser?.uid || "",
            uploaderPhotoURL: currentUser?.photoURL || "", timestamp: window.firebase.serverTimestamp(),
            projectData: {
                description: description, remixOf: projectRemixOf || "", sourceJsonUrl: projectSourceJsonUrl || "",
                settings: firestoreSafeSettings, activeDrawingLevel: firestoreSafeSettings.activeDrawingLevel, activePresetIndex: firestoreSafeSettings.activePresetIndex,
                cameraPosition: firestoreSafeSettings.cameraPosition, cameraQuaternion: firestoreSafeSettings.cameraQuaternion,
                currentColor: firestoreSafeSettings.currentColor, currentDrawingAxis: firestoreSafeSettings.currentDrawingAxis,
                gridSize: firestoreSafeSettings.gridSize, moveSpeed: firestoreSafeSettings.moveSpeed, presetColors: firestoreSafeSettings.presetColors, templateImageData: null, voxels: voxelMap
            }
        };
        const docRef = await window.firebase.addDoc(window.firebase.collection(db, "models"), firestoreDocument);
        projectTitle = title; projectDescription = description; projectCategory = category; projectTags = tags; projectVisibility = visibility;
        if (!projectSourceJsonUrl) projectSourceJsonUrl = `https://hub.voxelshaper.com?modelId=${docRef.id}`;
        showToast('Erfolgreich hochgeladen', `Ihr Projekt wurde erfolgreich hochgeladen! ID: ${docRef.id}`, 'success', 5000);
    } catch (e) { showToast('Fehler beim Hochladen', `Fehler: ${e.message}`, 'error', 5000); }
    finally { document.getElementById('uploadProjectModal').close(); }
}

function openAuthModal() { document.getElementById('authModal').showModal(); document.getElementById('emailLoginForm').classList.add('hidden'); }
function closeAuthModal() { document.getElementById('authModal').close(); cvs.focus(); }

window.signInWithGoogle = async function() { try { await window.firebase.signInWithPopup(auth, new window.firebase.GoogleAuthProvider()); showToast('Anmeldung erfolgreich', 'Mit Google angemeldet.', 'success', 5000); closeAuthModal(); } catch (e) { showToast('Anmeldefehler', `Google: ${e.message}`, 'error', 5000); } }
window.signInWithGithub = async function() { try { await window.firebase.signInWithPopup(auth, new window.firebase.GithubAuthProvider()); showToast('Anmeldung erfolgreich', 'Mit GitHub angemeldet.', 'success', 5000); closeAuthModal(); } catch (e) { showToast('Anmelmelfehler', `GitHub: ${e.message}`, 'error', 5000); } }
window.signInEmailPassword = async function() { const email = document.getElementById('emailInput').value; const password = document.getElementById('passwordInput').value; try { await window.firebase.signInWithEmailAndPassword(auth, email, password); showToast('Anmeldung erfolgreich', 'Mit E-Mail angemeldet.', 'success', 5000); closeAuthModal(); } catch (e) { showToast('Anmeldefehler', `E-Mail: ${e.message}`, 'error', 5000); } }
window.signUpEmailPassword = async function() { const email = document.getElementById('emailInput').value; const password = document.getElementById('passwordInput').value; try { await window.firebase.createUserWithEmailAndPassword(auth, email, password); showToast('Registrierung erfolgreich', 'Konto erstellt und angemeldet.', 'success', 5000); closeAuthModal(); } catch (e) { showToast('Registrierungsfehler', `E-Mail: ${e.message}`, 'error', 5000); } }

function closeAllModals() {
    const modals = ['clearConfirmationModal', 'uploadProjectModal', 'authModal', 'ideaGeneratorModal'];
    modals.forEach(id => { const modal = document.getElementById(id); if (modal && modal.open) modal.close(); });
}
window.closeAllModals = closeAllModals;

function onPointerLockChange() {
    if (document.pointerLockElement === cvs) {
        isPointerLocked = true;
        firstMoveAfterLock = true;
        mouseMovementX = mouseMovementY = 0;
        updatePreviewVoxel(0,0,0,false);
        euler.setFromQuaternion(cam.quaternion, 'YXZ');
        cvs.focus(); // Explicitly focus the canvas when pointer lock is acquired
    }
    else {
        isPointerLocked = false;
    }
}

function onMouseWheel(e) {
    e.preventDefault();
    if (e.altKey) {
        if (!isMobile && (currentMode === Modes.ADD || currentMode === Modes.DRAW)) {
            if (e.shiftKey) { activeDrawingLevel.z = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.z - Math.sign(e.deltaY))); currentDrawingAxis = 'z'; }
            else if (e.ctrlKey) { activeDrawingLevel.x = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.x - Math.sign(e.deltaY))); currentDrawingAxis = 'x'; }
            else { activeDrawingLevel.y = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.y - Math.sign(e.deltaY))); currentDrawingAxis = 'y'; }
            updateGridHelperPosition();
        } else {
            cam.position.addScaledVector(cam.getWorldDirection(new THREE.Vector3()), e.deltaY * 0.005 * moveSpeed * 5);
        }
    } else {
        moveSpeed = Math.max(0.01, Math.min(1.0, moveSpeed - Math.sign(e.deltaY) * 0.01));
        document.getElementById('fly-speed-slider').value = moveSpeed; document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2); localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
    }
}

const keyboard = {};
function onKeyDown(e) {
    const activeModals = ['authModal', 'uploadProjectModal', 'clearConfirmationModal', 'ideaGeneratorModal'].some(id => document.getElementById(id).open);
    if (activeModals) { if (e.key === 'Escape') { closeAllModals(); e.preventDefault(); } return; }
    keyboard[e.key.toLowerCase()] = true;
    if (e.key === 'Shift') isShiftDragging = true;
    if (e.key === 'Control' || e.metaKey) isControlDragging = true;
    if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); }
    if (((e.ctrlKey || e.metaKey) && e.key === 'y') || ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'Z')) { e.preventDefault(); redo(); }
    if ((e.ctrlKey || e.metaKey) && e.key === 'd') e.preventDefault();
    if (e.key === 'Tab') { e.preventDefault(); cycleMode(); }
    switch (e.key) { case '1': setActivePreset(0); break; case '2': setActivePreset(1); break; case '3': setActivePreset(2); break; }
}

function onKeyUp(e) {
    keyboard[e.key.toLowerCase()] = false;
    if (e.key === 'Shift') isShiftDragging = false;
    if (e.key === 'Control' || e.metaKey) isControlDragging = false;
}

function onPointerLeave(e) {
    // If a stroke was in progress and the pointer leaves, finalize it as a batch command
    if (pointerIsDown && (isDragging || currentStrokeChanges.size > 0)) { // Check for either dragging flag or existing changes
        if (currentStrokeChanges.size > 0) {
            addCommand({ type: 'batch', changes: Array.from(currentStrokeChanges.values()) });
        }
    }
    pointerIsDown = false;
    isDragging = false;
    doubleTapDragActive = false;
    lastActionVoxelCoords = null;
    initialClickPos = null;
    initialTargetVoxelCoords = null;
    voxelsAtDragStart = null;
    currentStrokeChanges.clear(); // Clear for next operation
    updatePreviewVoxel(0, 0, 0, false);
    previewLineInstancedMesh.count = 0;
    previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
    previewLineVoxels = [];
    dragAxisLock = null;
    // initialDragVoxelCoords = null; // This variable is now effectively initialTargetVoxelCoords
}

let pointerIsDown = false;
let rightMouseButtonDown = false;
let lastX, lastY;
let suppressNextTap = false;

function getVoxelsOnLine(start, end) {
    if (!start || !Number.isFinite(start.gx) || !Number.isFinite(start.gy) || !Number.isFinite(start.gz) ||
        !end || !Number.isFinite(end.gx) || !Number.isFinite(end.gy) || !Number.isFinite(end.gz)) {
        return [];
    }
    const voxelsOnLine = [];
    let x1 = start.gx, y1 = start.gy, z1 = start.gz;
    let x2 = end.gx, y2 = end.gy, z2 = end.gz;
    let dx = Math.abs(x2 - x1), dy = Math.abs(y2 - y1), dz = Math.abs(z2 - z1);
    let sx = (x1 < x2) ? 1 : -1, sy = (y1 < y2) ? 1 : -1, sz = (z1 < z2) ? 1 : -1;
    let dm = Math.max(dx, dy, dz); // Dominant axis length
    let x = x1, y = y1, z = z1;
    
    // Bresenham-like algorithm for 3D
    let error1 = dx - dm / 2;
    let error2 = dy - dm / 2;
    let error3 = dz - dm / 2;

    for (let i = 0; i <= dm; i++) {
        // Clamp coordinates to ensure they are within the grid, even if the line goes slightly out
        const clampedX = Math.max(0, Math.min(GRID - 1, x));
        const clampedY = Math.max(0, Math.min(GRID - 1, y));
        const clampedZ = Math.max(0, Math.min(GRID - 1, z));
        voxelsOnLine.push({ gx: clampedX, gy: clampedY, gz: clampedZ });
        
        if (x === x2 && y === y2 && z === z2) break; // Optimization: stop if target reached
        
        const eX = error1;
        const eY = error2;
        const eZ = error3;

        // Move along the dominant axis
        if (eX > dm / 2) { // x is most behind
            error1 -= dm;
            x += sx;
        }
        if (eY > dm / 2) { // y is most behind
            error2 -= dm;
            y += sy;
        }
        if (eZ > dm / 2) { // z is most behind
            error3 -= dm;
            z += sz;
        }

        error1 += dx;
        error2 += dy;
        error3 += dz;
    }
    return voxelsOnLine;
}


function onPointerUp(e) {
    if (e.button === 2) { // Right mouse button
        rightMouseButtonDown = false;
        document.exitPointerLock();
        return;
    }
    
    // Calculate total distance moved to determine if it was a drag or a click
    const totalMovedDist = initialClickPos ? Math.hypot(e.clientX - initialClickPos.x, e.clientY - initialClickPos.y) : 0;
    const wasDrag = isDragging || (totalMovedDist > MOVE_PX); // Check both internal flag and distance

    if (wasDrag) {
        // If it was a drag, a batch command should already be accumulated in currentStrokeChanges
        if (currentStrokeChanges.size > 0) {
            addCommand({ type: 'batch', changes: Array.from(currentStrokeChanges.values()) });
        }
    } else { // It was a single click (no significant drag)
        // For single click, use the initial ray hit to determine the placement
        let rawRayHitAtUp = calculateRayTargetVoxelCoords(e.clientX, e.clientY);
        let finalVoxelCoords = null;

        if (rawRayHitAtUp) {
            if (currentMode === Modes.ADD) {
                // For ADD mode on a single click, step out from the hit face
                if (rawRayHitAtUp.hitExistingVoxel && rawRayHitAtUp.faceNormal) {
                    finalVoxelCoords = {
                        gx: rawRayHitAtUp.gx + rawRayHitAtUp.faceNormal.x,
                        gy: rawRayHitAtUp.gy + rawRayHitAtUp.faceNormal.y,
                        gz: rawRayHitAtUp.gz + rawRayHitAtUp.faceNormal.z
                    };
                } else {
                    // If hitting empty space/plane, place directly at the hit coordinates
                    finalVoxelCoords = { ...rawRayHitAtUp };
                }
            } else { // DELETE or DRAW mode
                // For DELETE/DRAW, act on the voxel directly hit
                finalVoxelCoords = { ...rawRayHitAtUp };
            }

            // Clamp finalVoxelCoords to grid boundaries
            if (finalVoxelCoords) {
                finalVoxelCoords.gx = Math.max(0, Math.min(GRID - 1, finalVoxelCoords.gx));
                finalVoxelCoords.gy = Math.max(0, Math.min(GRID - 1, finalVoxelCoords.gy));
                finalVoxelCoords.gz = Math.max(0, Math.min(GRID - 1, finalVoxelCoords.gz));
            }
        }
        
        if (finalVoxelCoords) {
            const gKey = key(finalVoxelCoords.gx, finalVoxelCoords.gy, finalVoxelCoords.gz);
            const initialColor = voxelsAtDragStart.has(gKey) ? voxelsAtDragStart.get(gKey).color : null;
            
            performVoxelModification(finalVoxelCoords.gx, finalVoxelCoords.gy, finalVoxelCoords.gz, currentMode, currentColor);
            
            const newColor = voxels.has(gKey) ? voxels.get(gKey).color : null;
            
            if (initialColor !== newColor) {
                addCommand({ type: 'batch', changes: [{ gx: finalVoxelCoords.gx, gy: finalVoxelCoords.gy, gz: finalVoxelCoords.gz, oldColor: initialColor, newColor: newColor }] });
            }
        }
    }

    // Reset all temporary state variables after a pointer up event
    pointerIsDown = false;
    isDragging = false;
    doubleTapDragActive = false; 
    lastActionVoxelCoords = null;
    initialClickPos = null;
    initialTargetVoxelCoords = null;
    voxelsAtDragStart = null;
    currentStrokeChanges.clear(); 
    updatePreviewVoxel(0, 0, 0, false);
    previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
    dragAxisLock = null;
    
    if (e.pointerType === 'touch') {
        releasePointer(e.pointerId, e);
    }
}

function onPointerDown(e) {
    if (e.button === 2) { // Right mouse button
        e.preventDefault();
        rightMouseButtonDown = true;
        // Blur any currently active element to ensure canvas gets focus cleanly
        if (document.activeElement && document.activeElement !== document.body) {
            document.activeElement.blur();
        }
        cvs.focus();
        cvs.requestPointerLock();
        return;
    }
    if (isPointerLocked) return;

    if (e.button === 0 && e.altKey) { // Alt + Left Click for color picking
        const hitResult = calculateRayTargetVoxelCoords(e.clientX, e.clientY);
        if (hitResult && hitResult.hitExistingVoxel) {
            const gKey = key(hitResult.gx, hitResult.gy, hitResult.gz);
            if (voxels.has(gKey)) {
                const pickedColor = voxels.get(gKey).color;
                currentColor = pickedColor;
                document.getElementById('color-picker').value = pickedColor;
                const mobileColorInput = document.getElementById('mobile-color-input');
                if (mobileColorInput) mobileColorInput.value = pickedColor;
                localStorage.setItem('voxelEditorColor', pickedColor);
                presetBoxes.forEach(box => box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50')); activePresetIndex = -1;
                showToast('Farbe aufgenommen', `Farbe: ${pickedColor}`, 'info', 2000);
            }
        }
        return; // Consume event if alt+click for color pick
    }

    // --- History & Dragging Setup ---
    voxelsAtDragStart = new Map(voxels); // Capture the scene state BEFORE any modifications begin
    currentStrokeChanges.clear(); // Clear any previous stroke's accumulated changes
    dragAxisLock = null;
    isDragging = false;
    // --- End History & Dragging Setup ---

    initialClickPos = { x: e.clientX, y: e.clientY }; // Record initial click position for drag detection
    pointerIsDown = true;

    // Get raw hit from raycaster (voxel hit OR plane hit, NO normal adjustment yet)
    let rawRayHit = calculateRayTargetVoxelCoords(e.clientX, e.clientY);

    let actualPlacementCoords = null;

    if (rawRayHit) {
        if (currentMode === Modes.ADD) {
            // For ADD mode, on initial click, step out from the hit face
            if (rawRayHit.hitExistingVoxel && rawRayHit.faceNormal) {
                actualPlacementCoords = {
                    gx: rawRayHit.gx + rawRayHit.faceNormal.x,
                    gy: rawRayHit.gy + rawRayHit.faceNormal.y,
                    gz: rawRayHit.gz + rawRayHit.faceNormal.z
                };
            } else {
                // If hitting empty space/plane, place directly at the hit coordinates
                actualPlacementCoords = { ...rawRayHit };
            }
        } else { // DELETE or DRAW mode
            // For DELETE/DRAW, act on the voxel directly hit
            actualPlacementCoords = { ...rawRayHit };
        }
    }

    // Clamp actualPlacementCoords to grid boundaries
    if (actualPlacementCoords) {
        actualPlacementCoords.gx = Math.max(0, Math.min(GRID - 1, actualPlacementCoords.gx));
        actualPlacementCoords.gy = Math.max(0, Math.min(GRID - 1, actualPlacementCoords.gy));
        actualPlacementCoords.gz = Math.max(0, Math.min(GRID - 1, actualPlacementCoords.gz));

        // Perform the first voxel modification of the stroke
        performVoxelModification(actualPlacementCoords.gx, actualPlacementCoords.gy, actualPlacementCoords.gz, currentMode, currentColor);
        lastActionVoxelCoords = { ...actualPlacementCoords }; // Set last action for line drawing
        initialTargetVoxelCoords = { ...actualPlacementCoords }; // For single clicks on pointerUp
    } else {
        pointerIsDown = false; // No valid target
        initialClickPos = null;
        initialTargetVoxelCoords = null;
        return;
    }

    if (e.pointerType === 'touch') {
        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY, pointerType: e.pointerType });
        touchIndicator.style.display = 'block'; touchIndicator.style.left = `${e.clientX}px`; touchIndicator.style.top = `${e.clientY}px`;
        
        if (activePointers.size > 1) { // Multi-touch gesture detected
            initialTargetVoxelCoords = null; // Disable voxel drawing for camera gestures
            previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
            updatePreviewVoxel(0, 0, 0, false);
            doubleTapDragActive = false;
            isDragging = false;
            
            const pointersArr = [...activePointers.values()];
            const [p0, p1] = pointersArr;
            const midX = (p0.x + p1.x) * 0.5; const midY = (p0.y + p1.y) * 0.5; const dist = Math.hypot(p1.x - p0.x, p1.y - p0.y);
            gestureState.type = 'none'; gestureState.startMid = gestureState.lastMid = { x: midX, y: midY };
            gestureState.startDist = gestureState.lastDist = dist;
            gestureState.initialPointerCount = activePointers.size;
            return; // Exit, as it's a camera gesture
        }

        // Single touch for potential drawing/camera rotation
        lastActionVoxelCoords = null;
        previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
        updatePreviewVoxel(0, 0, 0, false);
        gestureState.initialPointerCount = activePointers.size;
        if (activePointers.size === 1) { gestureState.type = 'rotate'; gestureState.lastMid = { x: e.clientX, y: e.clientY }; }
        
        // For single touch, immediately consider it a potential drag for drawing
        if (actualPlacementCoords) { // Use actualPlacementCoords determined above
            isDragging = true; 
            lastActionVoxelCoords = { ...actualPlacementCoords };
            // The initial performVoxelModification already happened above.
        }
        return; 
    }

    // Mouse or Pen pointer down (non-alt-click)
    if (e.pointerType === 'mouse' && e.button === 0) {
        lastX = e.clientX; lastY = e.clientY;
        updatePreviewVoxel(0, 0, 0, false); 
        previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
    }
}

function onPointerMove(e) {
    e.preventDefault();
    if (isPointerLocked) return;

    if (e.pointerType === 'touch' && activePointers.has(e.pointerId)) {
        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY, pointerType: e.pointerType });
        if (activePointers.size > 1) { // Multi-touch gesture for camera movement
            handleGesture();
            updatePreviewVoxel(0, 0, 0, false); 
            previewLineInstancedMesh.count = 0;
            previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
            previewLineVoxels = [];
            return; 
        }
    }

    lastX = e.clientX;
    lastY = e.clientY;

    const currentMovedDist = initialClickPos ? Math.hypot(e.clientX - initialClickPos.x, e.clientY - initialClickPos.y) : 0;
    const shouldStartDrag = pointerIsDown && (currentMovedDist > MOVE_PX);

    // Get raw hit from raycaster (voxel hit OR plane hit, NO normal adjustment yet)
    let rawRayHit = calculateRayTargetVoxelCoords(e.clientX, e.clientY);

    let currentTargetVoxelCoords = null; // This will be the end point for getVoxelsOnLine

    if (rawRayHit) {
        if (currentMode === Modes.ADD) {
            // For ADD mode during a drag, the "target" for the line drawing should be the point
            // from which we would add a new voxel *if this were a single click*.
            if (rawRayHit.hitExistingVoxel && rawRayHit.faceNormal) {
                // Step out from the hit voxel's face. This is critical for continuous adding along the surface.
                currentTargetVoxelCoords = {
                    gx: rawRayHit.gx + rawRayHit.faceNormal.x,
                    gy: rawRayHit.gy + rawRayHit.faceNormal.y,
                    gz: rawRayHit.gz + rawRayHit.faceNormal.z
                };
            } else {
                // If hitting empty space/plane, place directly at the hit coordinates
                currentTargetVoxelCoords = { ...rawRayHit };
            }
        } else { // DELETE or DRAW mode
            // For DELETE/DRAW mode, the target is always the voxel directly hit.
            currentTargetVoxelCoords = { ...rawRayHit };
        }

        // Clamp final currentTargetVoxelCoords to grid bounds
        if (currentTargetVoxelCoords) {
            currentTargetVoxelCoords.gx = Math.max(0, Math.min(GRID - 1, currentTargetVoxelCoords.gx));
            currentTargetVoxelCoords.gy = Math.max(0, Math.min(GRID - 1, currentTargetVoxelCoords.gy));
            currentTargetVoxelCoords.gz = Math.max(0, Math.min(GRID - 1, currentTargetVoxelCoords.gz));
        }
    }

    if (pointerIsDown && currentTargetVoxelCoords) {
        // If dragging hasn't started yet, and the threshold is met, activate dragging.
        if (!isDragging && shouldStartDrag) {
            isDragging = true;
            // Ensure lastActionVoxelCoords is correctly set from the initial click's actual placement.
            if (!lastActionVoxelCoords && initialTargetVoxelCoords) {
                lastActionVoxelCoords = { ...initialTargetVoxelCoords };
            }
        }

        if (isDragging) {
            // If lastActionVoxelCoords is not set (e.g., if drag started without a valid initial target, though it should be handled),
            // initialize it with the current target.
            if (!lastActionVoxelCoords) {
                 lastActionVoxelCoords = { ...currentTargetVoxelCoords };
            }
            
            const startPointForLine = lastActionVoxelCoords;
            const endPointForLine = { ...currentTargetVoxelCoords }; // This is now the 'intended next' voxel, adjusted for ADD mode

            let pathVoxels = getVoxelsOnLine(startPointForLine, endPointForLine);

            // For DELETE and DRAW modes, only process voxels that existed at drag start
            if (currentMode === Modes.DELETE || currentMode === Modes.DRAW) {
                pathVoxels = pathVoxels.filter(voxel => voxelsAtDragStart.has(key(voxel.gx, voxel.gy, voxel.gz)));
            }
            // For ADD mode, all pathVoxels are potential additions.

            // Process voxels along the line
            for (let i = 0; i < pathVoxels.length; i++) {
                const voxel = pathVoxels[i];
                // performVoxelModification now handles recording changes to currentStrokeChanges
                performVoxelModification(voxel.gx, voxel.gy, voxel.gz, currentMode, currentColor);
            }
            lastActionVoxelCoords = { ...endPointForLine }; // Update last action point for next segment of line

            // Update preview voxel to show where the pointer is currently hitting/intending to place
            updatePreviewVoxel(endPointForLine.gx, endPointForLine.gy, endPointForLine.gz, true);
            previewLineInstancedMesh.count = 0; // Clear line preview as drawing is happening

        } else {
            // Pointer is down, but not dragging yet (e.g., waiting for drag threshold)
            // Show preview voxel at current target
            if (currentTargetVoxelCoords) {
                let showPreview = false;
                const gKeyAtPreview = key(currentTargetVoxelCoords.gx, currentTargetVoxelCoords.gy, currentTargetVoxelCoords.gz);
                const hasVoxelAtPreview = voxels.has(gKeyAtPreview);

                if (currentMode === Modes.ADD) {
                    if (!hasVoxelAtPreview) { showPreview = true; } // Preview where it would be added
                } else if (currentMode === Modes.DELETE || currentMode === Modes.DRAW) {
                    if (hasVoxelAtPreview) { showPreview = true; } // Preview existing voxel for deletion/drawing
                }
                updatePreviewVoxel(currentTargetVoxelCoords.gx, currentTargetVoxelCoords.gy, currentTargetVoxelCoords.gz, showPreview);
            } else {
                updatePreviewVoxel(0, 0, 0, false);
            }
            previewLineInstancedMesh.count = 0; // Ensure line preview is off
        }
    } else {
        // Pointer is NOT down (hovering)
        // Ensure drawing-related previews are off
        previewLineInstancedMesh.count = 0;
        previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
        previewLineVoxels = [];

        // Update hover preview voxel based on the raw ray hit
        if (rawRayHit) {
            let hoverPreviewCoords = { gx: rawRayHit.gx, gy: rawRayHit.gy, gz: rawRayHit.gz };
            // For ADD mode, hover preview should also show where it would be placed if clicked
            if (currentMode === Modes.ADD && rawRayHit.faceNormal) {
                hoverPreviewCoords.gx += rawRayHit.faceNormal.x;
                hoverPreviewCoords.gy += rawRayHit.faceNormal.y;
                hoverPreviewCoords.gz += rawRayHit.faceNormal.z;
            }
            // Clamp hover preview coords
            hoverPreviewCoords.gx = Math.max(0, Math.min(GRID - 1, hoverPreviewCoords.gx));
            hoverPreviewCoords.gy = Math.max(0, Math.min(GRID - 1, hoverPreviewCoords.gy));
            hoverPreviewCoords.gz = Math.max(0, Math.min(GRID - 1, hoverPreviewCoords.gz));

            let showPreview = false;
            const gKeyAtPreview = key(hoverPreviewCoords.gx, hoverPreviewCoords.gy, hoverPreviewCoords.gz);
            const hasVoxelAtPreview = voxels.has(gKeyAtPreview);

            if (currentMode === Modes.ADD) {
                if (!hasVoxelAtPreview) { showPreview = true; }
            } else if (currentMode === Modes.DELETE || currentMode === Modes.DRAW) {
                if (hasVoxelAtPreview) { showPreview = true; }
            }
            updatePreviewVoxel(hoverPreviewCoords.gx, hoverPreviewCoords.gy, hoverPreviewCoords.gz, showPreview);
        } else {
            updatePreviewVoxel(0, 0, 0, false);
        }
    }
    
    // Handle single-touch camera rotation when not dragging for voxel modification
    if (e.pointerType === 'touch' && activePointers.size === 1 && !isDragging) {
        handleGesture();
    }
}

function openIdeaGeneratorModal() {
    document.getElementById('ideaPromptInput').value = '';
    document.getElementById('ideaResultDisplay').innerHTML = '';
    document.getElementById('ideaResultDisplay').classList.add('hidden');
    document.getElementById('ideaLoadingIndicator').classList.add('hidden');
    document.getElementById('ideaGeneratorModal').showModal();
}

async function generateVoxelIdea() {
    const promptText = document.getElementById('ideaPromptInput').value.trim();
    const ideaResultDisplay = document.getElementById('ideaResultDisplay');
    const ideaLoadingIndicator = document.getElementById('ideaLoadingIndicator');

    if (!promptText) {
        showToast('Eingabe erforderlich', 'Bitte geben Sie ein Thema oder Konzept ein.', 'warning', 5000);
        return;
    }

    ideaResultDisplay.classList.add('hidden');
    ideaLoadingIndicator.classList.remove('hidden');
    ideaResultDisplay.innerHTML = '';

    try {
        const prompt = `Generate a detailed and recognizable voxel model as a JSON object based on the following theme.
        The model should effectively utilize the available 3D grid space, which ranges from (0,0,0) to (${GRID-1},${GRID-1},${GRID-1}).
        The model *must* form a **single, unified, and fully connected object**. It should be **solid, contiguous, and watertight**, without any internal gaps, disconnected parts, or floating voxels. Every voxel should be directly adjacent (face-to-face) to at least one other voxel within the generated set, forming a continuous, cohesive mass. No individual voxels or groups of voxels should be isolated or floating in space. Prioritize filling internal spaces to ensure no gaps within the overall form. When forming lines, surfaces, or volumes, ensure all intermediate voxels are included to prevent holes. Avoid generating sparse or hollow structures unless explicitly requested by the theme.
        Aim for a reasonable number of voxels, typically between 50 and 700, to create a well-defined, robust structure.
        All x, y, z coordinates must be integers within the grid boundaries (0 to ${GRID-1}).
        Colors should be valid hex color codes (e.g., "#FF0000").
        
        Theme: "${promptText}"
        
        The JSON should have the following structure:
        {
          "model_name": "A concise name for the model",
          "description": "A brief description of the model.",
          "voxels": [
            { "x": integer, "y": integer, "z": integer, "color": "hex_color_string" },
          ]
        }
        `;

        let chatHistory = [];
        chatHistory.push({ role: "user", parts: [{ text: prompt }] });

        const payload = {
            contents: chatHistory,
            generationConfig: {
                responseMimeType: "application/json",
                responseSchema: {
                    type: "OBJECT",
                    properties: {
                        "model_name": { "type": "STRING" },
                        "description": { "type": "STRING" },
                        "voxels": {
                            "type": "ARRAY",
                            "items": {
                                type: "OBJECT",
                                properties: {
                                    "x": { "type": "INTEGER" },
                                    "y": { "type": "INTEGER" },
                                    "z": { "type": "INTEGER" },
                                    "color": { "type": "STRING" }
                                },
                                required: ["x", "y", "z", "color"]
                            }
                        }
                    },
                    required: ["model_name", "description", "voxels"]
                }
            }
        };

        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${AI_API_KEY}`;

        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        const result = await response.json();

        if (result.candidates && result.candidates.length > 0 &&
            result.candidates[0].content && result.candidates[0].content.parts &&
            result.candidates[0].content.parts.length > 0) {
            const jsonResponseText = result.candidates[0].content.parts[0].text;
            try {
                const parsedJson = JSON.parse(jsonResponseText);
                applyAIGeneratedVoxels(parsedJson);
            } catch (parseError) {
                ideaResultDisplay.innerHTML = '<p class="text-error">Fehler: KI-Antwort konnte nicht als Voxel-Modell interpretiert werden. (Ungültiges JSON)</p>';
                ideaResultDisplay.classList.remove('hidden');
            }
        } else {
            ideaResultDisplay.innerHTML = '<p class="text-error">Konnte keine Idee generieren. Bitte versuchen Sie es erneut.</p>';
            ideaResultDisplay.classList.remove('hidden');
        }
    } catch (error) {
        ideaResultDisplay.innerHTML = `<p class="text-error">Fehler beim Generieren der Idee: ${error.message}</p>`;
        ideaResultDisplay.classList.remove('hidden');
    } finally {
        ideaLoadingIndicator.classList.add('hidden');
    }
}

function applyAIGeneratedVoxels(aiData) {
    if (!aiData || !Array.isArray(aiData.voxels)) {
        showToast('Fehler', 'Ungültige AI-Voxeldaten erhalten.', 'error', 5000);
        return;
    }

    const changes = [];
    const oldVoxelStateSnapshot = new Map(voxels); // Capture current state for undo

    // First, remove existing voxels that are NOT in the new AI data, or will be changed.
    // Create a set of new voxel keys for quick lookup.
    const newVoxelKeys = new Set(aiData.voxels.map(v => key(Math.round(v.x), Math.round(v.y), Math.round(v.z))));

    // Identify voxels to be removed or recolored
    oldVoxelStateSnapshot.forEach((data, gKey) => {
        const p = parseKey(gKey);
        const newVoxel = aiData.voxels.find(v => Math.round(v.x) === p[0] && Math.round(v.y) === p[1] && Math.round(v.z) === p[2]);
        if (!newVoxel) {
            // Voxel exists in old state but not in new AI data, so it will be removed.
            _removeSingleVoxel(p[0], p[1], p[2]);
            changes.push({ gx: p[0], gy: p[1], gz: p[2], oldColor: data.color, newColor: null });
        }
    });

    // Then, add or recolor voxels based on AI data
    aiData.voxels.forEach(v => {
        const gx = Math.max(0, Math.min(GRID - 1, Math.round(v.x)));
        const gy = Math.max(0, Math.min(GRID - 1, Math.round(v.y)));
        const gz = Math.max(0, Math.min(GRID - 1, Math.round(v.z)));
        const color = v.color || currentColor;
        const gKey = key(gx, gy, gz);

        const oldColor = oldVoxelStateSnapshot.has(gKey) ? oldVoxelStateSnapshot.get(gKey).color : null;
        
        // Only perform action and record change if there is an actual change
        if (oldColor !== color) {
            if (oldColor === null) { // Voxel being added
                _addSingleVoxel(gx, gy, gz, color);
            } else { // Voxel being recolored
                _recolorSingleVoxel(gx, gy, gz, color);
            }
            changes.push({ gx, gy, gz, oldColor, newColor: color });
        }
    });

    // Add the comprehensive batch command to history
    if (changes.length > 0) {
        addCommand({ type: 'batch', changes: changes });
    }

    projectTitle = aiData.model_name || 'KI Generiertes Modell';
    projectDescription = aiData.description || 'Ein von der KI generiertes Modell.';

    showToast('AI-Modell erstellt', `"${aiData.model_name || 'Unbenannt'}" wurde generiert.`, 'success', 5000);
    document.getElementById('ideaGeneratorModal').close();
}


function cycleDrawingAxis() {
    const axes = ['x', 'y', 'z'];
    const currentIndex = axes.indexOf(currentDrawingAxis);
    currentDrawingAxis = axes[(currentIndex + 1) % axes.length];
    updateGridHelperPosition();
    showToast('Zeichenachse', `Achse: ${currentDrawingAxis.toUpperCase()}`, 'info', 1500);
}

function moveDrawingLevel(direction) {
    if (currentMode !== Modes.ADD && currentMode !== Modes.DRAW) {
        showToast('Hinweis', 'Ebenensteuerung nur im Hinzufügen- oder Zeichenmodus verfügbar.', 'warning', 2000);
        return;
    }
    let level = activeDrawingLevel[currentDrawingAxis];

    if (!Number.isFinite(level)) {
        level = 0;
        activeDrawingLevel[currentDrawingAxis] = level;
    }

    level += direction;
    level = Math.max(0, Math.min(GRID - 1, level));
    activeDrawingLevel[currentDrawingAxis] = level;
    updateGridHelperPosition();
    showToast('Zeichenebene', `Ebene ${currentDrawingAxis.toUpperCase()}: ${level}`, 'info', 1500);
}


window.onload = async function() {
    closeAllModals();
    try {
        cvs = document.getElementById('voxelCanvas'); containerDiv = document.getElementById('container');
        touchIndicator = document.getElementById('touch-indicator');
        toastContainer = document.getElementById('toast-container');
        scene = new THREE.Scene(); scene.background = new THREE.Color(0x282c34);
        cam = new THREE.PerspectiveCamera(75, containerDiv.clientWidth / containerDiv.clientHeight, 0.1, 1000);
        resetCameraPosition(); euler = new THREE.Euler(0, 0, 0, 'YXZ');
        ren = new THREE.WebGLRenderer({ canvas: cvs, antialias: true });
        ren.setSize(containerDiv.clientWidth, containerDiv.clientHeight);
        isMobile = window.matchMedia('(max-width: 768px)').matches;
        ren.setPixelRatio(isMobile ? Math.min(1.5, window.devicePixelRatio) : window.devicePixelRatio);
        ren.shadowMap.enabled = true; ren.shadowMap.type = THREE.PCFSoftShadowMap;
      
        scene.add(new THREE.AmbientLight(0x606060));
        mainDirectionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        mainDirectionalLight.position.set(10, 20, 15); mainDirectionalLight.castShadow = true;
        mainDirectionalLight.shadow.mapSize.width = mainDirectionalLight.shadow.mapSize.height = 2048;
        mainDirectionalLight.shadow.camera.near = 0.5; mainDirectionalLight.shadow.camera.far = 50;
        mainDirectionalLight.shadow.camera.left = -30; mainDirectionalLight.shadow.camera.right = 30;
        mainDirectionalLight.shadow.camera.top = 30; mainDirectionalLight.shadow.camera.bottom = -30;
        mainDirectionalLight.shadow.bias = -0.0005; mainDirectionalLight.shadow.normalBias = 0.02;
        scene.add(mainDirectionalLight);
        const secondDirectionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
        secondDirectionalLight.position.set(-10, 10, -15);
        scene.add(secondDirectionalLight);
        scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.6));
        
        scene.add(previewVoxelMesh); updatePreviewVoxel(0,0,0,false);
        previewLineInstancedMesh = new THREE.InstancedMesh(new THREE.BoxGeometry(VS, VS, VS), new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.3, depthTest: false }));
        previewLineInstancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        previewLineInstancedMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(maxPreviewInstances * 3), 3);
        previewLineInstancedMesh.instanceColor.setUsage(THREE.DynamicDrawUsage); scene.add(previewLineInstancedMesh);
        rebuildHelpers();

        window.addEventListener('resize', onResize);
        containerDiv.addEventListener('pointerdown', onPointerDown);
        containerDiv.addEventListener('pointermove', onPointerMove);
        containerDiv.addEventListener('pointerup', onPointerUp);
        containerDiv.addEventListener('pointercancel', onPointerUp);
        containerDiv.addEventListener('pointerleave', onPointerLeave);
        containerDiv.addEventListener('wheel', onMouseWheel, { passive: false });
        document.addEventListener('keydown', onKeyDown); document.addEventListener('keyup', onKeyUp);
        document.addEventListener('pointerlockchange', onPointerLockChange, false);
        containerDiv.addEventListener('mousemove', (e) => {
            if (isPointerLocked) {
                mouseMovementX = e.movementX;
                mouseMovementY = e.movementY;
                e.preventDefault();
            }
        });
        containerDiv.addEventListener('contextmenu', (e) => e.preventDefault());

        document.getElementById('grid-size-slider').addEventListener('input', (e) => {
            const oldGrid = GRID;
            const newGrid = parseInt(e.target.value);

            if (newGrid < oldGrid) {
                let voxelsWouldBeLost = false;
                for (const [id, data] of voxels.entries()) {
                    const p = parseKey(id);
                    if (p[0] >= newGrid || p[1] >= newGrid || p[2] >= newGrid) {
                        voxelsWouldBeLost = true;
                        break;
                    }
                }

                if (voxelsWouldBeLost) {
                    showToast('Warnung', 'Gittergröße kann nicht reduziert werden, da sonst vorhandene Voxel außerhalb des Rasters verloren gehen würden.', 'warning', 5000);
                    e.target.value = oldGrid;
                    document.getElementById('grid-size-display').textContent = `${oldGrid}×${oldGrid}×${oldGrid}`;
                    return;
                }
            }
            
            // Capture old state before applying new grid and filtering voxels
            const oldVoxelState = new Map(voxels); 
            
            // Clear all voxels and re-add only those within the new grid bounds
            for (const chunk of chunks.values()) chunk.dispose(); chunks.clear(); voxels.clear();
            oldVoxelState.forEach((data, gKey) => {
                const p = parseKey(gKey);
                if (p[0] < newGrid && p[1] < newGrid && p[2] < newGrid) {
                    _addSingleVoxel(p[0], p[1], p[2], data.color);
                }
            });
            GRID = newGrid;
            document.getElementById('grid-size-display').textContent = `${GRID}×${GRID}×${GRID}`; localStorage.setItem('voxelEditorGridSize', GRID);
            
            // Capture new state (after filtering)
            const newVoxelState = new Map(voxels);

            // Add command to history (old and new state as full snapshots for resize)
            addCommand({ 
                type: 'resizeGrid', 
                oldState: oldVoxelState, 
                newState: newVoxelState, 
                commandData: { oldGrid: oldGrid, newGrid: GRID } 
            });
            rebuildHelpers(); resetCameraPosition();
        });

        document.getElementById('color-picker').addEventListener('input', (e) => {
            currentColor = e.target.value; localStorage.setItem('voxelEditorColor', currentColor);
            const mobileColorInput = document.getElementById('mobile-color-input');
            if (mobileColorInput) mobileColorInput.value = currentColor;
            presetBoxes.forEach(box => box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50')); activePresetIndex = -1;
            if (previewVoxelMesh.visible) {
                previewVoxelMaterial.color.set(currentColor);
            }
        });

        presetBoxes = [document.getElementById('color-preset-1'), document.getElementById('color-preset-2'), document.getElementById('color-preset-3')];
        presetColors.forEach((color, i) => {
            const box = presetBoxes[i]; box.value = color;
            box.addEventListener('click', (e) => setActivePreset(i));
            box.addEventListener('input', (e) => savePresetColor(i, e.target.value));
        });
        if (activePresetIndex !== -1) setActivePreset(activePresetIndex); else document.getElementById('color-picker').value = currentColor;

        document.getElementById('modeToggle').addEventListener('click', cycleMode);
        document.getElementById('current-mode').textContent = `Modus: ${currentMode}`;

        document.getElementById('clearBtn').addEventListener('click', () => document.getElementById('clearConfirmationModal').showModal());
        document.getElementById('saveAndClearBtn').addEventListener('click', () => { saveJSON(); clearAll(); document.getElementById('clearConfirmationModal').close(); });
        document.getElementById('clearWithoutSaveBtn').addEventListener('click', () => { clearAll(); document.getElementById('clearConfirmationModal').close(); });
        document.getElementById('cancelClearBtn').addEventListener('click', () => document.getElementById('clearConfirmationModal').close());
        document.getElementById('clearConfirmationModal').addEventListener('cancel', () => document.getElementById('clearConfirmationModal').close());

        document.getElementById('fillLevelBtn').addEventListener('click', fillActiveLevel);
        document.getElementById('saveBtn').addEventListener('click', saveJSON);
        document.getElementById('loadBtn').addEventListener('click', () => document.getElementById('fileInput').click());
        document.getElementById('fileInput').addEventListener('change', loadJSON);
        document.getElementById('exportStlBtn').addEventListener('click', exportSTL);
        document.getElementById('exportObjBtn').addEventListener('click', exportOBJ);
        document.getElementById('exportGlbBtn').addEventListener('click', exportGLB);

        document.getElementById('fly-speed-slider').addEventListener('input', (e) => {
            moveSpeed = parseFloat(e.target.value); document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2); localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
        });

        document.getElementById('resetCameraBtn').addEventListener('click', resetCameraPosition);
        document.getElementById('generateVoxelIdeaBtn').addEventListener('click', openIdeaGeneratorModal);
        document.getElementById('loadImageTemplateBtn').addEventListener('click', loadImageTemplate);
        document.getElementById('imageFileInput').addEventListener('change', handleImageFileSelect);
        document.getElementById('removeImageTemplateBtn').addEventListener('click', removeImageTemplate);

        document.getElementById('menuToggle').addEventListener('click', () => {
            const controlsPanel = document.getElementById('controls');
            controlsPanel.classList.toggle('hidden');
            if (!controlsPanel.classList.contains('hidden')) controlsPanel.classList.add('flex');
            else controlsPanel.classList.remove('flex');
        });

        const mediaQuery = window.matchMedia('(max-width: 768px)');
        function handleMediaQueryChange(e) {
            isMobile = e.matches;
            const controlsPanel = document.getElementById('controls');
            const mobileControls = document.getElementById('mobile-controls');
            const mobileAxisToggle = document.getElementById('mobile-axis-toggle');
            const mobileLevelUp = document.getElementById('mobile-level-up');
            const mobileLevelDown = document.getElementById('mobile-level-down');

            if (e.matches) {
                controlsPanel.classList.add('hidden');
                mobileControls.classList.remove('hidden');
                mobileControls.classList.add('flex');
                toastContainer.classList.remove('toast-end');
                toastContainer.classList.add('toast-top-center');
                
                mobileAxisToggle.classList.remove('hidden');
                mobileLevelUp.classList.remove('hidden');
                mobileLevelDown.classList.remove('hidden');
            }
            else {
                controlsPanel.classList.remove('hidden');
                controlsPanel.classList.add('flex');
                mobileControls.classList.add('hidden');
                mobileControls.classList.remove('flex');
                toastContainer.classList.remove('toast-top-center');
                toastContainer.classList.add('toast-end');

                mobileAxisToggle.classList.add('hidden');
                mobileLevelUp.classList.add('hidden');
                mobileLevelDown.classList.add('hidden');
            }
            onResize();
            rebuildHelpers();
            const mobileModeIcon = document.getElementById('mobile-mode-icon');
            if (mobileModeIcon) {
                mobileModeIcon.className = ModeIcons[currentMode];
            }
        }
        mediaQuery.addListener(handleMediaQueryChange); handleMediaQueryChange(mediaQuery);

        document.getElementById('mobile-undo').addEventListener('click', (e) => { e.stopPropagation(); undo(); });
        document.getElementById('mobile-redo').addEventListener('click', (e) => { e.stopPropagation(); redo(); });
        document.getElementById('mobile-save').addEventListener('click', (e) => { e.stopPropagation(); saveJSON(); });
        document.getElementById('mobile-camera').addEventListener('click', (e) => { e.stopPropagation(); resetCameraPosition(); });
        document.getElementById('mobile-mode-toggle').addEventListener('click', (e) => { e.stopPropagation(); cycleMode(); });
        
        const mobileColorPickerBtn = document.getElementById('mobile-color-picker-btn');
        const mobileColorInput = document.getElementById('mobile-color-input');
        
        mobileColorPickerBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            mobileColorInput.click();
        });

        mobileColorInput.addEventListener('input', (e) => {
            currentColor = e.target.value;
            localStorage.setItem('voxelEditorColor', currentColor);
            document.getElementById('color-picker').value = currentColor;
            presetBoxes.forEach(box => box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'));
            activePresetIndex = -1;
            if (previewVoxelMesh.visible) {
                previewVoxelMaterial.color.set(currentColor);
            }
        });
        mobileColorInput.addEventListener('change', (e) => { // Added change listener for mobile color picker
            currentColor = e.target.value;
            localStorage.setItem('voxelEditorColor', currentColor);
            document.getElementById('color-picker').value = currentColor;
            presetBoxes.forEach(box => box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'));
            activePresetIndex = -1;
            if (previewVoxelMesh.visible) {
                previewVoxelMaterial.color.set(currentColor);
            }
        });

        mobileColorInput.value = currentColor;

        document.getElementById('mobile-axis-toggle').addEventListener('click', (e) => { e.stopPropagation(); cycleDrawingAxis(); });
        document.getElementById('mobile-level-up').addEventListener('click', (e) => { e.stopPropagation(); moveDrawingLevel(1); });
        document.getElementById('mobile-level-down').addEventListener('click', (e) => { e.stopPropagation(); moveDrawingLevel(-1); });

        document.getElementById('mobile-generate-idea').addEventListener('click', (e) => { e.stopPropagation(); openIdeaGeneratorModal(); });
        document.getElementById('mobile-login-logout').addEventListener('click', (e) => { e.stopPropagation(); loginLogout(); });

        document.getElementById('grid-size-slider').value = GRID; document.getElementById('grid-size-display').textContent = `${GRID}×${GRID}×${GRID}`;
        document.getElementById('color-picker').value = currentColor;
        document.getElementById('fly-speed-slider').value = moveSpeed; document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
        
        document.getElementById('mobile-mode-icon').className = ModeIcons[currentMode];
        document.getElementById('mobile-axis-icon').className = AxisIcons[currentDrawingAxis];

        const app = window.firebase.initializeApp(window.firebaseConfig);
        auth = window.firebase.getAuth(app); db = window.firebase.getFirestore(app);
        const loginLogoutBtn = document.getElementById('loginLogoutBtn');
        const uploadToHubBtn = document.getElementById('uploadToHubBtn');
        const userIdDisplay = document.getElementById('userIdDisplay');
        const goToHubBtn = document.getElementById('goToHubBtn');
        let projectLoadedFromUrl = false;

        predefinedCategories.forEach(cat => { const opt = document.createElement('option'); opt.value = cat; opt.textContent = cat; document.getElementById('uploadCategory').appendChild(opt); });

        window.firebase.setPersistence(auth, window.firebase.browserLocalPersistence)
            .then(async () => {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    try { await window.firebase.signInWithCustomToken(auth, __initial_auth_token); }
                    catch (e) { showToast('Anmeldefehler', `Fehler beim Anmelden mit Token: ${e.message}. Bitte versuchen Sie es erneut.`, 'error', 5000); }
                } else {
                    // No custom token provided, user might be anonymous or logging in traditionally
                }

                window.firebase.onAuthStateChanged(auth, async (user) => {
                    currentUserId = user ? user.uid : null; currentUser = user;
                    loginLogoutBtn.textContent = user ? 'Abmelden' : 'Anmelden';
                    userIdDisplay.innerHTML = user ? `<img src="${user.photoURL || 'https://placehold.co/24x24/cccccc/000000?text=U'}" alt="User Avatar" class="w-6 h-6 rounded-full align-middle">` : '';
                    uploadToHubBtn.classList.toggle('hidden', !user);
                    document.getElementById('mobile-login-logout').textContent = user ? '🚪' : '🔑';
                    if (user) document.getElementById('authModal').close();

                    if (!projectLoadedFromUrl) {
                        const urlParams = new URLSearchParams(window.location.search);
                        const modelId = urlParams.get('modelId'); const encodedJson = urlParams.get('projectJson');
                        if (modelId) { await loadProjectFromModelId(modelId); projectLoadedFromUrl = true; }
                        else if (encodedJson) {
                            try {
                                const decodedJson = decodeURIComponent(encodedJson);
                                loadProjectData(JSON.parse(decodedJson));
                                showToast('Projekt geladen', 'Projekt erfolgreich aus URL-Parameter geladen.', 'success', 5000);
                                projectLoadedFromUrl = true;
                            } catch (e) { showToast('Fehler', 'Fehler beim Laden des Projekts aus der URL. Ungültige oder beschädigte Projektdaten. Fehler: ' + e.message, 'error', 5000); resetToDefaultProject(); }
                        } else { projectRemixOf = ''; projectSourceJsonUrl = ''; }
                    }
                });
                animate();
            })
            .catch((e) => { showToast('Anmeldefehler', `Fehler bei der Anmeldungspersistenz: ${e.message}.`, 'error', 10000); animate(); });

        document.getElementById('goToHubBtn').addEventListener('click', () => window.open('https://hub.voxelshaper.com', '_blank'));
        loginLogoutBtn.addEventListener('click', loginLogout);
        document.getElementById('authModal').addEventListener('click', (e) => { if (e.target === document.getElementById('authModal')) closeAuthModal(); });
        document.getElementById('authModalCloseBtn').addEventListener('click', closeAuthModal);
        document.getElementById('signInGoogleBtn').addEventListener('click', window.signInWithGoogle);
        document.getElementById('signInGithubBtn').addEventListener('click', window.signInGithub);
        document.getElementById('emailSignInBtn').addEventListener('click', window.signInEmailPassword);
        document.getElementById('emailSignUpBtn').addEventListener('click', window.signUpEmailPassword);
        document.getElementById('showEmailLoginFormBtn').addEventListener('click', () => document.getElementById('emailLoginForm').classList.remove('hidden'));
        document.getElementById('uploadToHubBtn').addEventListener('click', openUploadModal);
        document.getElementById('uploadProjectModal').addEventListener('click', (e) => { if (e.target === document.getElementById('uploadProjectModal')) { document.getElementById('uploadProjectModal').close(); cvs.focus(); } });
        document.getElementById('uploadConfirmBtn').addEventListener('click', uploadProjectToHub);
        document.getElementById('uploadCancelBtn').addEventListener('click', () => { document.getElementById('uploadProjectModal').close(); cvs.focus(); });

        document.getElementById('generateIdeaConfirmBtn').addEventListener('click', generateVoxelIdea);
        document.getElementById('ideaGeneratorCloseBtn').addEventListener('click', () => { document.getElementById('ideaGeneratorModal').close(); cvs.focus(); });
        document.getElementById('ideaGeneratorModal').addEventListener('click', (e) => { if (e.target === document.getElementById('ideaGeneratorModal')) { document.getElementById('ideaGeneratorModal').close(); cvs.focus(); } });

    } catch (e) { showToast('Schwerer Fehler', `Ein unerwarteter Fehler ist aufgetreten: ${e.message}.`, 'error', 10000); }
};

const frustum = new THREE.Frustum(); const tempCameraMatrix = new THREE.Matrix4();
function animate() {
    requestAnimationFrame(animate);
    if (isPointerLocked) {
        if (firstMoveAfterLock) {
            firstMoveAfterLock = false;
            mouseMovementX = mouseMovementY = 0;
            return;
        }
        euler.y -= (mouseMovementX || 0) * rotSpeed;
        euler.x -= (mouseMovementY || 0) * rotSpeed;
        euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
        cam.quaternion.setFromEuler(euler);
        mouseMovementX = mouseMovementY = 0;
        const camDir = new THREE.Vector3(); cam.getWorldDirection(camDir);
        const rightDir = new THREE.Vector3().crossVectors(camDir, cam.up).normalize();
        const upVec = new THREE.Vector3(0, 1, 0); const currMoveSpeed = moveSpeed * 0.5;
        if (keyboard['w']) cam.position.addScaledVector(camDir, currMoveSpeed);
        if (keyboard['s']) cam.position.addScaledVector(camDir, -currMoveSpeed);
        if (keyboard['a']) cam.position.addScaledVector(rightDir, -currMoveSpeed);
        if (keyboard['d']) cam.position.addScaledVector(rightDir, currMoveSpeed);
        if (keyboard['e']) cam.position.addScaledVector(upVec, currMoveSpeed);
        if (keyboard['q']) cam.position.addScaledVector(upVec, -currMoveSpeed);
    }
    cam.updateMatrixWorld(); tempCameraMatrix.multiplyMatrices(cam.projectionMatrix, cam.matrixWorldInverse);
    frustum.setFromProjectionMatrix(tempCameraMatrix);
    for (const chunk of chunks.values()) chunk.instancedMesh.visible = frustum.intersectsBox(chunk.boundingBox);
    ren.render(scene, cam);
}
</script>
</body>
</html>
