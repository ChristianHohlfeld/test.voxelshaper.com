<!DOCTYPE html>
<html lang="de" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VoxelShaper - Community 3D Modelle</title>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.7.2/dist/full.min.css" rel="stylesheet" type="text/css" />
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* Custom styles for the detail page and cards */
        .voxel-detail-canvas, .voxel-preview-canvas {
            width: 100%;
            height: 600px; /* Adjust height as needed */
            display: block;
            background-color: var(--fallback-b2, oklch(var(--b2))); /* Use DaisyUI background color */
            border-radius: var(--rounded-box, 1rem); /* Use DaisyUI border-radius */
            touch-action: none; /* Prevent browser default touch actions on canvas */
        }
        .voxel-preview-canvas {
            height: 208px; /* Fixed height for cards, roughly h-52 in Tailwind */
        }

        @media (max-width: 768px) {
            .voxel-detail-canvas {
                height: 400px;
            }
        }
        .comment-card {
            border-bottom: 1px solid oklch(var(--bc) / 0.1);
            padding-bottom: 1rem;
            margin-bottom: 1rem;
        }
        .comment-card:last-child {
            border-bottom: none;
            padding-bottom: 0;
            margin-bottom: 0;
        }
        /* Ensure stat-value text wraps if needed, and has enough space */
        .stat .stat-value {
            white-space: normal; /* Allow text to wrap */
            word-break: break-word; /* Break long words */
            min-width: 0; /* Allow shrinking */
        }
        /* Custom styles to make stats smaller and better organized */
        .stat {
            flex-grow: 1; /* Allow stats to grow */
            flex-basis: 0; /* Allow them to shrink */
            min-width: 120px; /* Minimum width before wrapping */
            padding: 1rem; /* Adjust padding for better spacing */
        }
        .stat .stat-title {
            font-size: 0.875rem; /* text-sm */
            line-height: 1.25rem; /* leading-tight */
            white-space: nowrap; /* Prevent title from wrapping */
        }
        .stat .stat-value {
            font-size: 1.875rem; /* text-3xl, smaller than default DaisyUI stat-value */
            line-height: 2.25rem; /* leading-9 */
        }
        .stat .stat-figure i {
            font-size: 1.5rem; /* text-2xl, smaller than default if it was larger */
        }
        /* Adjust stats container for better wrapping on small screens */
        .stats-container {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem; /* Gap between stat items */
            justify-content: space-around; /* Distribute items evenly */
        }
        @media (min-width: 768px) { /* md breakpoint */
            .stats-container {
                flex-wrap: nowrap; /* Prevent wrapping on larger screens */
                justify-content: space-between; /* Space out evenly */
            }
            .stat {
                min-width: unset; /* Remove min-width on larger screens */
            }
        }

        /* Styles for inline editing elements */
        [contenteditable]:hover:not(:focus) {
            background-color: oklch(var(--b3) / 0.5); /* Slight highlight on hover */
            border-radius: 0.25rem;
        }
        [contenteditable]:focus {
            outline: 2px solid oklch(var(--p)); /* Primary color outline on focus */
            outline-offset: 2px;
            background-color: oklch(var(--b3));
        }
        .edit-icon, .edit-icon-desc {
            display: none; /* Hidden by default, shown by JS on hover/focus */
        }
        [contenteditable]:hover + .edit-icon, [contenteditable]:focus + .edit-icon,
        [contenteditable]:hover + .edit-icon-desc, [contenteditable]:focus + .edit-icon-desc {
            display: inline-block !important; /* Force display for icons when editable is hovered/focused */
        }

        /* Profile page styles */
        .profile-section {
            background-color: var(--fallback-b2, oklch(var(--b2)));
            padding: 2rem;
            border-radius: var(--rounded-box, 1rem);
            box-shadow: var(--shadow-2);
        }
        .profile-avatar {
            width: 120px;
            height: 120px;
            font-size: 3rem;
        }

        /* NEW: Responsive styles for action buttons on detail page */
        @media (max-width: 640px) { /* Tailwind's sm breakpoint */
            .action-button-detail {
                padding: 0.75rem 1rem; /* Smaller padding */
                font-size: 1rem; /* Smaller font size */
            }
            .action-button-detail .fas { /* Target icons within these buttons */
                font-size: 1rem; /* Smaller icon size */
            }
        }
    </style>
</head>
<body class="bg-base-100 min-h-screen text-base-content">
    <!-- Navbar -->
    <div class="navbar bg-base-200 border-b border-base-content/20 px-4 py-3 flex-wrap">
        <div class="flex-1">
            <a href="#" class="2xl font-black text-blue-400 tracking-tight" id="nav-home">
                <i class="fas fa-cube mr-2"></i>VoxelShaper
            </a>
            <div class="hidden md:flex ml-10">
                <a href="#" id="nav-discover" class="btn btn-ghost btn-sm">Entdecken</a>
                <a href="#" id="nav-popular" class="btn btn-ghost btn-sm">Beliebt</a>
                <a href="#" id="nav-new" class="btn btn-ghost btn-sm">Neu</a>
                <a href="#" id="nav-categories" class="btn btn-ghost btn-sm">Kategorien</a>
                <!-- New: My Models link -->
                <a href="#" id="nav-my-models" class="btn btn-ghost btn-sm hidden">Meine Modelle</a>
            </div>
        </div>
        <div class="flex-none gap-4 mt-2 md:mt-0 w-full md:w-auto justify-end">
            <!-- Search Input in Navbar -->
            <div class="form-control flex-grow md:flex-grow-0 max-w-xs">
                <input type="text" id="search-input" placeholder="Modelle suchen..." class="input input-bordered w-full bg-base-300 border-base-content/20" aria-label="Modelle suchen" />
            </div>

            <label class="swap swap-rotate btn btn-ghost btn-circle" aria-label="Theme wechseln">
                <input type="checkbox" id="theme-toggle" />

                <svg
                    class="swap-on h-6 w-6 fill-current"
                    xmlns="http://www.w3.org/2000/svg"
                    viewBox="0 0 24 24">
                    <path
                        d="M5.64,17l-.71.71a1,1,0,0,0,0,1.41,1,1,0,0,0,1.41,0l.71-.71A1,1,0,0,0,5.64,17ZM5,12a1,1,0,0,0-1-1H3a1,1,0,0,0,0,2H4A1,1,0,0,0,5,12Zm7-7a1,1,0,0,0,1-1V3a1,1,0,0,0-2,0V4A1,1,0,0,0,12,5ZM5.64,7.05a1,1,0,0,0,.7.29,1,1,0,0,0,.71-.29,1,1,0,0,0,0-1.41l-.71-.71A1,1,0,0,0,4.93,6.34Zm12,.29a1,1,0,0,0,.7-.29l.71-.71a1,1,0,1,0-1.41-1.41L17,5.64a1,1,0,0,0,0,1.41A1,1,0,0,0,17.66,7.34ZM21,11H20a1,1,0,0,0,0,2h1a1,1,0,0,0,0-2Zm-9,8a1,1,0,0,0-1,1v1a1,1,0,0,0,2,0V20A1,1,0,0,0,12,19ZM18.36,17A1,1,0,0,0,17,18.36l.71.71a1,1,0,0,0,1.41,0,1,1,0,0,0,0-1.41ZM12,6.5A5.5,5.5,0,1,0,17.5,12,5.51,5.51,0,0,0,12,6.5Zm0,9A3.5,3.5,0,1,1,15.5,12,3.5,3.5,0,0,1,12,15.5Z" />
                </svg>

                <svg
                    class="swap-off h-6 w-6 fill-current"
                    xmlns="http://www.w3.org/2000/svg"
                    viewBox="0 0 24 24">
                    <path
                        d="M21.64,13a1,1,0,0,0-1.05-.14,8.05,8.05,0,0,1-3.37.73A8.15,8.15,0,0,1,9.08,5.49a8.59,8.59,0,0,1,.25-2A1,1,0,0,0,8,2.36,10.14,10.14,0,1,0,22,14.05,1,1,0,0,0,21.64,13Zm-9.5,6.69A8.14,8.14,0,0,1,7.08,5.22v.27A10.15,10.15,0,0,0,17.22,15.63a9.79,9.79,0,0,0,2.1-.22A8.11,8.11,0,0,1,12.14,19.73Z" />
                </svg>
            </label>
            
            <div class="dropdown dropdown-end">
                <div tabindex="0" role="button" class="btn btn-ghost btn-circle" aria-label="Benachrichtigungen">
                    <i class="fas fa-bell text-xl"></i>
                </div>
                <ul tabindex="0" class="dropdown-content z-[1] menu p-2 shadow bg-base-200 rounded-box w-64 mt-4">
                    <li class="text-center py-4 text-base-content/60">Keine Benachrichtigungen</li>
                </ul>
            </div>
            <div class="dropdown dropdown-end">
                <div tabindex="0" role="button" id="user-menu-button" class="btn btn-ghost btn-circle avatar placeholder" aria-label="Benutzermenü">
                    <div class="bg-neutral text-neutral-content rounded-full w-10 flex items-center justify-center">
                        <span><i class="fas fa-user text-lg"></i></span>
                    </div>
                </div>
                <ul tabindex="0" class="dropdown-content z-[1] menu p-2 shadow bg-base-200 rounded-box w-52 mt-4">
                    <li id="login-button"><a><i class="fas fa-sign-in-alt mr-2"></i>Anmelden</a></li>
                    <li id="profile-button" class="hidden"><a><i class="fas fa-user mr-2"></i>Profil</a></li>
                    <li id="logout-button" class="hidden"><a><i class="fas fa-sign-out-alt mr-2"></i>Abmelden</a></li>
                </ul>
            </div>
        </div>
    </div>

    <!-- Main Content View -->
    <div id="main-content-view" class="container mx-auto px-4 py-8">
        <div class="flex justify-between items-center mb-8">
            <h1 class="text-3xl font-bold" id="main-content-title">Community-Modelle</h1>
            <!-- Changed "Modell hochladen" to "In VoxelShaper öffnen" -->
            <button id="open-voxelshaper-new-button" class="btn btn-primary">
                <i class="fas fa-external-link-alt mr-2"></i>In VoxelShaper öffnen
            </button>
        </div>

        <div class="bg-base-200 rounded-lg p-4 mb-6">
            <div class="flex flex-col md:flex-row md:flex-wrap items-start md:items-center gap-4">
                <!-- Category Filter Buttons -->
                <div class="form-control w-full md:w-auto">
                    <label class="label">
                        <span class="label-text text-base-content/60">Kategorie</span>
                    </label>
                    <div id="category-filter-buttons" class="flex flex-wrap gap-2">
                        <!-- Category buttons dynamically loaded via JS -->
                    </div>
                </div>

                <!-- Sort By -->
                <div class="form-control w-full max-w-xs">
                    <label class="label">
                        <span class="label-text text-base-content/60">Sortieren nach</span>
                    </label>
                    <select id="sort-by" class="select select-bordered w-full bg-base-300 border-base-content/20">
                        <option value="newest-desc">Neueste (absteigend)</option>
                        <option value="newest-asc">Neueste (aufsteigend)</option>
                        <option value="popular-desc">Beliebteste (absteigend)</option>
                        <option value="popular-asc">Beliebteste (aufsteigend)</option>
                        <option value="top-rated-desc">Am besten bewertet (absteigend)</option>
                        <option value="top-rated-asc">Am besten bewertet (aufsteigend)</option>
                    </select>
                </div>

                <!-- Status Filter (Always shown, options vary) -->
                <div class="form-control w-full max-w-xs" id="status-filter-container">
                    <label class="label">
                        <span class="label-text text-base-content/60">Status</span>
                    </label>
                    <select id="status-filter-select" class="select select-bordered w-full bg-base-300 border-base-content/20">
                        <option value="verified">Verifiziert</option>
                        <option value="all">Alle</option>
                        <!-- Unverified option added via JS for admins -->
                    </select>
                </div>

                <!-- Filter Reset Button -->
                <div class="form-control w-full max-w-xs mt-auto">
                    <button id="reset-filters-button" class="btn btn-outline">
                        <i class="fas fa-undo mr-2"></i>Filter zurücksetzen
                    </button>
                </div>

                <!-- License Filter - Keep as is for now -->
                <div class="flex items-center">
                    <span class="text-base-content/60 mr-2">Lizenz:</span>
                    <div class="flex flex-wrap gap-2">
                        <button class="btn btn-xs">Alle</button>
                        <button class="btn btn-xs">CC BY</button>
                        <button class="btn btn-xs">CC BY-SA</button>
                        <button class="btn btn-xs">CC0</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="models-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
            </div>

        <div id="loading-sentinel" class="flex flex-col items-center justify-center mt-10">
            <span id="loading-spinner" class="loading loading-spinner loading-lg text-primary hidden"></span>
            <p id="no-more-models" class="text-base-content/60 mt-4 hidden">Keine weiteren Modelle verfügbar.</p>
        </div>
    </div>

    <!-- Model Detail View (Initially hidden) -->
    <div id="detail-content-view" class="container mx-auto px-4 py-8 hidden">
        <button id="back-to-overview-button" class="btn btn-ghost mb-6">
            <i class="fas fa-arrow-left mr-2"></i>Zurück zur Übersicht
        </button>

        <div id="model-detail-container" class="bg-base-200 rounded-xl p-6 shadow-xl">
            <!-- Loading Spinner -->
            <div id="detail-loading-spinner" class="flex justify-center items-center h-64">
                <span class="loading loading-spinner loading-lg text-primary"></span>
            </div>

            <!-- Model Not Found Message -->
            <div id="model-not-found" class="text-center text-error text-xl p-8 hidden">
                Modell nicht gefunden. Die angeforderte Seite konnte nicht geladen werden.
            </div>

            <!-- Model Details Content (initially hidden) -->
            <div id="model-content" class="hidden">
                <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
                    <!-- Left Column: Model Viewer & Stats -->
                    <div class="lg:col-span-2 flex flex-col gap-6">
                        <div class="rounded-xl overflow-hidden shadow-lg relative bg-base-300 flex items-center justify-center">
                            <canvas id="voxel-detail-canvas" class="voxel-detail-canvas"></canvas>
                            <div id="detail-preview-message" class="absolute inset-0 flex items-center justify-center text-base-content/60 text-sm hidden"></div>
                        </div>
                        <!-- Stats moved here, below the canvas -->
                        <div class="stats stats-vertical lg:stats-horizontal shadow w-full bg-base-300 rounded-box stats-container">
                            <div class="stat">
                                <div class="stat-figure text-primary">
                                    <i class="fas fa-download text-2xl"></i>
                                </div>
                                <div class="stat-title">Downloads</div>
                                <div id="download-count" class="stat-value text-primary">0</div>
                            </div>
                            <div class="stat">
                                <div class="stat-figure text-secondary">
                                    <i class="fas fa-star text-2xl"></i>
                                </div>
                                <div class="stat-title">Bewertungen</div>
                                <div id="rating-count" class="stat-value text-secondary">0</div>
                            </div>
                            <div class="stat">
                                <div class="stat-figure text-info">
                                    <i class="fas fa-cube text-2xl"></i>
                                </div>
                                <div class="stat-title">Kategorie</div>
                                <div id="model-category" class="stat-value text-info"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Right Column: Details, Actions -->
                    <div class="lg:col-span-1 flex flex-col gap-6">
                        <div>
                            <h1 id="model-title" class="text-4xl font-bold mb-2"></h1>
                            <div class="flex items-center text-base-content/60 text-sm mb-4 gap-x-4">
                                <div class="flex items-center">
                                    <div class="avatar mr-2">
                                        <div class="w-8 h-8 rounded-full bg-neutral text-neutral-content flex items-center justify-center text-lg" id="uploader-avatar">
                                            <i class="fas fa-user"></i>
                                        </div>
                                    </div>
                                    <span id="uploader-info"></span>
                                </div>
                                <span id="upload-date" class="ml-auto"></span>
                            </div>

                            <div class="flex items-center mb-4">
                                <!-- Rating stars will be populated dynamically by JS using Font Awesome -->
                                <div class="flex items-center" id="detail-rating-stars"></div>
                                <span id="detail-rating-text" class="text-base-content/60 ml-2"></span>
                            </div>

                            <!-- Action Buttons moved here, to the right column -->
                            <div class="flex flex-col md:flex-row lg:flex-col gap-2 justify-start mb-4">
                                <button id="download-stl-button" class="btn btn-primary btn-lg w-full action-button-detail">
                                    <i class="fas fa-download mr-2"></i>STL Herunterladen
                                </button>
                                <button id="open-voxelshaper-button" class="btn btn-secondary btn-lg w-full action-button-detail">
                                    <i class="fas fa-external-link-alt mr-2"></i>In VoxelShaper öffnen
                                </button>
                                <button id="share-button" class="btn btn-info btn-lg w-full action-button-detail">
                                    <i class="fas fa-share-alt mr-2"></i>Teilen
                                </button>
                            </div>
                        </div>

                        <div>
                            <h2 class="text-2xl font-semibold mb-2">Beschreibung</h2>
                            <p id="model-description" class="text-base-content/80 leading-relaxed"></p>
                        </div>

                        <!-- Admin Actions (only visible to admins) -->
                        <div id="admin-actions" class="flex flex-wrap gap-2 mt-4 hidden">
                            <h2 class="text-xl font-semibold w-full mb-2">Admin-Aktionen</h2>
                            <button id="verify-button" class="btn btn-success">
                                <i class="fas fa-check mr-2"></i>Verifizieren
                            </button>
                            <button id="revert-verify-button" class="btn btn-warning hidden">
                                <i class="fas fa-undo mr-2"></i>Verifizierung rückgängig
                            </button>
                            <button id="delete-button" class="btn btn-error">
                                <i class="fas fa-trash mr-2"></i>Löschen
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Comments Section -->
                <div class="mt-12">
                    <h2 class="text-3xl font-bold mb-6">Kommentare & Bewertungen</h2>
                    <div id="comments-list" class="bg-base-300 p-6 rounded-lg shadow-inner">
                        <!-- Comments will be loaded here -->
                        <p id="no-comments-message" class="text-base-content/60 text-center py-4 hidden">Noch keine Kommentare. Sei der Erste!</p>
                    </div>

                    <!-- Add Comment Button -->
                    <div class="mt-8 text-center">
                        <button id="add-comment-button" class="btn btn-primary btn-lg">
                            <i class="fas fa-comment-alt mr-2"></i>Kommentar hinzufügen
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Profile Page View (Initially hidden) -->
    <div id="profile-content-view" class="container mx-auto px-4 py-8 hidden">
        <button id="back-to-main-from-profile-button" class="btn btn-ghost mb-6">
            <i class="fas fa-arrow-left mr-2"></i>Zurück zur Hauptseite
        </button>

        <div class="profile-section flex flex-col items-center p-8 gap-6">
            <h1 class="text-4xl font-bold mb-4">Mein Profil</h1>
            <div class="avatar placeholder mb-4">
                <div class="profile-avatar rounded-full bg-neutral text-neutral-content flex items-center justify-center">
                    <span id="profile-avatar-initial" class="text-white"></span>
                    <img id="profile-avatar-img" src="" alt="Profilbild" class="w-full h-full object-cover rounded-full hidden">
                </div>
            </div>
            <div class="text-center">
                <p class="text-xl font-semibold mb-2" id="profile-email"></p>
                <p class="text-base-content/60 text-sm" id="profile-creation-date"></p>
            </div>
            <button id="delete-account-button" class="btn btn-error mt-8">
                <i class="fas fa-user-times mr-2"></i>Konto löschen
            </button>
        </div>
    </div>


    <!-- Modals -->
    <dialog id="auth-modal" class="modal">
        <div class="modal-box bg-base-200">
            <h3 class="font-bold text-lg text-center">Anmeldung bei VoxelShaper</h3>
            <p class="py-4 text-center">Melde dich an, um Modelle zu bewerten, herunterzuladen und eigene Kreationen zu teilen.</p>
            <div class="modal-action flex flex-col items-center w-full">
                <form method="dialog" class="w-full">
                    <div class="flex flex-col gap-3 w-full">
                        <input id="email-input" type="email" placeholder="E-Mail" class="input input-bordered w-full bg-base-300 border-base-content/20" autocomplete="email" />
                        <input id="password-input" type="password" placeholder="Passwort" class="input input-bordered w-full bg-base-300 border-base-content/20" autocomplete="current-password" />
                        <button id="firebase-login" class="btn btn-primary w-full">
                            <i class="fas fa-sign-in-alt mr-2"></i> Anmelden
                        </button>
                        <button id="firebase-signup" class="btn btn-secondary w-full">
                            <i class="fas fa-user-plus mr-2"></i> Registrieren
                        </button>
                        <div class="divider text-base-content/60">ODER</div>
                        <button id="google-login" class="btn btn-info w-full">
                            <i class="fab fa-google mr-2"></i> Mit Google anmelden
                        </button>
                        <button id="github-login" class="btn w-full bg-neutral hover:bg-neutral-focus text-neutral-content border-none">
                            <i class="fab fa-github mr-2"></i> Mit GitHub anmelden
                        </button>
                        <button class="btn btn-outline w-full" onclick="document.getElementById('auth-modal').close()">Abbrechen</button>
                    </div>
                    <p id="auth-error-message" class="text-error text-sm mt-4 text-center hidden"></p>
                </form>
            </div>
        </div>
    </dialog>

    <!-- New: Add/Edit Comment Modal -->
    <dialog id="add-comment-modal" class="modal">
        <div class="modal-box bg-base-200">
            <h3 class="font-bold text-lg" id="add-comment-modal-title">Kommentar hinzufügen</h3>
            <div class="flex items-center mb-4 mt-4">
                <span class="mr-4 text-base-content/80">Ihre Bewertung:</span>
                <div class="rating rating-md" id="add-comment-rating-input">
                    <input type="radio" name="add-comment-rating" class="mask mask-star-2" value="1" aria-label="1 Stern">
                    <input type="radio" name="add-comment-rating" class="mask mask-star-2" value="2" aria-label="2 Sterne">
                    <input type="radio" name="add-comment-rating" class="mask mask-star-2" value="3" aria-label="3 Sterne">
                    <input type="radio" name="add-comment-rating" class="mask mask-star-2" value="4" aria-label="4 Sterne">
                    <input type="radio" name="add-comment-rating" class="mask mask-star-2" value="5" aria-label="5 Sterne">
                </div>
            </div>
            <textarea id="add-comment-input" class="textarea textarea-bordered w-full bg-base-300 border-base-content/20 h-32 mb-4" placeholder="Schreiben Sie hier Ihren Kommentar..."></textarea>
            <div class="modal-action">
                <button id="submit-add-comment-button" class="btn btn-primary">Senden</button>
                <button class="btn btn-outline" onclick="document.getElementById('add-comment-modal').close()">Abbrechen</button>
            </div>
            <p id="add-comment-error-message" class="text-error text-sm mt-2 hidden"></p>
        </div>
    </dialog>

    <dialog id="delete-confirm-modal" class="modal">
        <div class="modal-box bg-base-200">
            <h3 class="font-bold text-lg">Modell löschen bestätigen</h3>
            <p class="py-4">Möchten Sie das Modell "<span id="model-to-delete-title" class="font-semibold"></span>" wirklich löschen? Diese Aktion kann nicht rückgängig gemacht werden.</p>
            <div class="modal-action">
                <button id="confirm-delete-button" class="btn btn-error">Löschen</button>
                <button class="btn btn-outline" onclick="document.getElementById('delete-confirm-modal').close()">Abbrechen</button>
            </div>
        </div>
    </dialog>

    <!-- New: Comment Edit Modal (renamed from edit-comment-modal to be consistent with add-comment-modal) -->
    <dialog id="edit-comment-modal" class="modal">
        <div class="modal-box bg-base-200">
            <h3 class="font-bold text-lg">Kommentar bearbeiten</h3>
            <textarea id="edit-comment-input" class="textarea textarea-bordered w-full bg-base-300 border-base-content/20 h-32 my-4"></textarea>
            <div class="modal-action">
                <button id="save-comment-edit-button" class="btn btn-primary">Speichern</button>
                <button class="btn btn-outline" onclick="document.getElementById('edit-comment-modal').close()">Abbrechen</button>
            </div>
            <p id="edit-comment-error-message" class="text-error text-sm mt-2 hidden"></p>
        </div>
    </dialog>

    <!-- New: Delete Comment Confirmation Modal -->
    <dialog id="delete-comment-confirm-modal" class="modal">
        <div class="modal-box bg-base-200">
            <h3 class="font-bold text-lg">Kommentar löschen bestätigen</h3>
            <p class="py-4">Möchten Sie diesen Kommentar wirklich löschen? Diese Aktion kann nicht rückgängig gemacht werden.</p>
            <div class="modal-action">
                <button id="confirm-delete-comment-button" class="btn btn-error">Löschen</button>
                <button class="btn btn-outline" onclick="document.getElementById('delete-comment-confirm-modal').close()">Abbrechen</button>
            </div>
        </div>
    </dialog>

    <!-- New: Delete Account Confirmation Modal -->
    <dialog id="delete-account-confirm-modal" class="modal">
        <div class="modal-box bg-base-200">
            <h3 class="font-bold text-lg text-error">Konto löschen bestätigen</h3>
            <p class="py-4 text-warning">
                Sind Sie sicher, dass Sie Ihr Konto löschen möchten?
                <br><br>
                Diese Aktion ist **ENDGÜLTIG** und kann nicht rückgängig gemacht werden.
                Ihre hochgeladenen Modelle bleiben weiterhin sichtbar, werden aber von Ihrem Konto getrennt. Sie können diese Modelle danach nicht mehr bearbeiten oder löschen.
            </p>
            <div class="modal-action flex flex-col sm:flex-row gap-2">
                <button id="confirm-delete-account-button" class="btn btn-error w-full sm:w-auto">Ja, Konto löschen</button>
                <button class="btn btn-outline w-full sm:w-auto" onclick="document.getElementById('delete-account-confirm-modal').close()">Abbrechen</button>
            </div>
        </div>
    </dialog>

    <!-- Footer -->
    <footer class="footer p-10 bg-base-300 text-base-content mt-16">
        <div class="container mx-auto">
            <div class="grid grid-cols-1 md:grid-cols-4 gap-8">
                <div>
                    <h3 class="footer-title text-base-content">VoxelShaper</h3>
                    <p class="mt-4">Die Community für 3D-Voxelmodelle. Teile, entdecke und drucke einzigartige Kreationen.</p>
                    <div class="flex gap-4 mt-4">
                        <a href="#"><i class="fab fa-discord text-xl"></i></a>
                        <a href="#"><i class="fab fa-twitter text-xl"></i></a>
                        <a href="#"><i class="fab fa-instagram text-xl"></i></a>
                        <a href="#"><i class="fab fa-github text-xl"></i></a>
                    </div>
                </div>
                <div>
                    <h3 class="footer-title">Ressourcen</h3>
                    <a class="link link-hover mt-4">Blog</a>
                    <a class="link link-hover">Tutorials</a>
                    <a class="link link-hover">Dokumentation</a>
                    <a class="link link-hover">API</a>
                </div>
                <div>
                    <h3 class="footer-title">Community</h3>
                    <a class="link link-hover mt-4">Forum</a>
                    <a class="link link-hover">Events</a>
                    <a class="link link-hover">Mitwirkende</a>
                    <a class="link link-hover">Partner</a>
                </div>
                <div>
                    <h3 class="footer-title">Rechtliches</h3>
                    <a class="link link-hover mt-4">AGB</a>
                    <a class="link link-hover">Datenschutz</a>
                    <a class="link link-hover">Lizenzierung</a>
                    <a class="link link-hover">Cookie-Richtlinie</a>
                </div>
            </div>
            <div class="border-t border-base-content/20 mt-12 pt-6 text-center">
                <p>© 2023 VoxelShaper. Alle Rechte vorbehalten.</p>
            </div>
        </div>
    </footer>

    <div id="toast-container" class="toast toast-end z-50"></div>

    <!-- Three.js Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script type="module">
        // Import the functions you need from the SDKs you need
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-app.js";
        import { 
            getAuth, 
            setPersistence,
            browserLocalPersistence, 
            signInWithEmailAndPassword, 
            createUserWithEmailAndPassword, 
            onAuthStateChanged,
            signOut,
            GoogleAuthProvider, 
            GithubAuthProvider,
            signInWithPopup,
            deleteUser // Import deleteUser
        } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-auth.js";
        import { 
            getFirestore, 
            collection, 
            addDoc, 
            serverTimestamp,
            query, 
            limit, 
            getDocs, 
            startAfter,
            where,
            doc, 
            getDoc,
            updateDoc,
            deleteDoc, 
            orderBy, 
            runTransaction, 
            or, 
            onSnapshot, 
        } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-firestore.js";

        // Your web app's Firebase configuration
        // The API key here is for Firebase services (Auth, Firestore).
        // The Gemini API key for generateContent calls will be provided by the Canvas environment.
        const firebaseConfig = {
            apiKey: "AIzaSyB9-mpyAu9W6oiVtB0fYG8E6YFvTAsjtAA", 
            authDomain: "voxelshaper.firebaseapp.com", 
            projectId: "voxelshaper",
            storageBucket: "voxelshaper.appspot.com", 
            messagingSenderId: "1053689247573",
            appId: "1:1053689247573:web:f7960c7f8c2e8849e8e1dc",
            measurementId: "G-QJ5CNKZ5DR"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        console.log("[Firebase] Firebase initialisiert.");

        let currentUser = null;
        let currentUserId = null;
        let _isAdmin = false; // Globale Variable, um den Admin-Status zu speichern
        let initialAuthCheckCompleted = false; // Neues Flag, um die anfängliche Authentifizierungsstatusauflösung zu verfolgen
        let manualFilterResetActive = false; // NEU: Flag, um einen manuellen Filter-Reset anzuzeigen

        // Variablen für unendliches Scrollen
        const MODELS_PER_LOAD = 8;
        let lastVisible = null;
        let isLoadingModels = false; 
        let allModelsData = []; // Speichert alle abgerufenen Modelldaten für clientseitiges Filtern

        // UI Elemente (Hauptansicht)
        const loginButton = document.getElementById('login-button');
        const logoutButton = document.getElementById('logout-button');
        const profileButton = document.getElementById('profile-button');
        const userMenuButton = document.getElementById('user-menu-button');
        const authModal = document.getElementById('auth-modal');
        const firebaseLoginButton = document.getElementById('firebase-login');
        const firebaseSignupButton = document.getElementById('firebase-signup');
        const googleLoginButton = document.getElementById('google-login'); 
        const githubLoginButton = document.getElementById('github-login'); 
        const emailInput = document.getElementById('email-input');
        const passwordInput = document.getElementById('password-input');
        const authErrorMessage = document.getElementById('auth-error-message');
        const htmlElement = document.documentElement; // Das HTML-Element abrufen
        const themeToggle = document.getElementById('theme-toggle'); // Theme-Umschalt-Element

        // Replaced uploadModelButton with openVoxelshaperNewButton
        const openVoxelshaperNewButton = document.getElementById('open-voxelshaper-new-button');

        // Removed upload modal elements as they are no longer needed
        // const uploadModal = document.getElementById('upload-modal');
        // const jsonErrorMessage = document.getElementById('json-error-message');
        // const modelTitleInput = document.getElementById('model-title-input');
        // const modelDescriptionInput = document.getElementById('model-description-input');
        // const modelCategoryInput = document.getElementById('model-category-input');
        // const projectJsonInput = document.getElementById('project-json-input');
        // const visibilitySelect = document.getElementById('visibility-select');
        // const uploadSubmitButton = document.getElementById('upload-submit-button');
        // const uploadErrorMessage = document.getElementById('upload-error-message');
        // const uploadSuccessMessage = document.getElementById('upload-success-message');
        // const aiSuggestionStatusDiv = document.getElementById('ai-suggestion-status');
        // const aiSuggestionSpinner = document.getElementById('ai-suggestion-spinner');
        // const aiSuggestionMessage = document.getElementById('ai-suggestion-message');


        // Modellelemente für die endlose Liste
        const modelsGrid = document.getElementById('models-grid');
        const loadingSpinner = document.getElementById('loading-spinner');
        const noMoreModelsMessage = document.getElementById('no-more-models');
        const loadingSentinel = document.getElementById('loading-sentinel'); 

        // Filter- und Sortier-Elemente
        const sortBy = document.getElementById('sort-by');
        const categoryFilterButtonsContainer = document.getElementById('category-filter-buttons'); // Neu: Container für Kategorie-Buttons
        let activeCategory = 'all'; // Neu: Um den aktiven Kategorie-Button zu verfolgen
        const statusFilterSelect = document.getElementById('status-filter-select');
        const statusFilterContainer = document.getElementById('status-filter-container');
        const searchInput = document.getElementById('search-input'); // In die Navigationsleiste verschoben
        const resetFiltersButton = document.getElementById('reset-filters-button');
        const mainContentTitle = document.getElementById('main-content-title'); // Titel der Hauptansicht

        // UI Elemente für Navigationsleisten-Links
        const navDiscoverButton = document.getElementById('nav-discover');
        const navPopularButton = document.getElementById('nav-popular');
        const navNewButton = document.getElementById('nav-new');
        const navCategoriesButton = document.getElementById('nav-categories');
        const navHomeButton = document.getElementById('nav-home'); // Neu: Home-Button in der Navigationsleiste
        const navMyModelsButton = document.getElementById('nav-my-models'); // Neu: Meine Modelle-Link
        let currentFilterView = 'community'; // 'community', 'my-models'

        // UI Elemente (Detailansicht)
        const mainContentView = document.getElementById('main-content-view');
        const detailContentView = document.getElementById('detail-content-view');
        const backToOverviewButton = document.getElementById('back-to-overview-button');

        const detailLoadingSpinner = document.getElementById('detail-loading-spinner');
        const modelNotFoundMessage = document.getElementById('model-not-found');
        const modelContent = document.getElementById('model-content');

        const modelTitleElement = document.getElementById('model-title');
        const uploaderAvatarElement = document.getElementById('uploader-avatar');
        const uploaderInfoElement = document.getElementById('uploader-info');
        const uploadDateElement = document.getElementById('upload-date');
        // Changed from DaisyUI rating to a div for Font Awesome stars
        const detailRatingStars = document.getElementById('detail-rating-stars');
        const detailRatingText = document.getElementById('detail-rating-text');
        // In die linke Spalte unter dem Canvas verschoben:
        const downloadCountElement = document.getElementById('download-count'); 
        const ratingCountElement = document.getElementById('rating-count'); 
        const modelCategoryElement = document.getElementById('model-category'); 

        const modelDescriptionElement = document.getElementById('model-description');

        // In die rechte Spalte verschoben:
        const downloadStlButton = document.getElementById('download-stl-button'); 
        const openVoxelshaperButton = document.getElementById('open-voxelshaper-button'); 
        const shareButton = document.getElementById('share-button'); 

        const adminActionsDiv = document.getElementById('admin-actions');
        const verifyButton = document.getElementById('verify-button');
        const revertVerifyButton = document.getElementById('revert-verify-button');
        const deleteButton = document.getElementById('delete-button');

        // Kommentarbereich Elemente
        const commentsList = document.getElementById('comments-list');
        const noCommentsMessage = document.getElementById('no-comments-message');
        // Removed direct comment input elements
        // const commentInput = document.getElementById('comment-input');
        // const postCommentButton = document.getElementById('post-comment-button');
        // const commentAuthMessage = document.getElementById('comment-auth-message');
        // const userRatingInput = document.getElementById('user-rating-input'); 

        // NEU: Add Comment Button
        const addCommentButton = document.getElementById('add-comment-button');

        // NEU: Add/Edit Comment Modal Elements
        const addCommentModal = document.getElementById('add-comment-modal');
        const addCommentModalTitle = document.getElementById('add-comment-modal-title');
        const addCommentRatingInput = document.getElementById('add-comment-rating-input');
        const addCommentInput = document.getElementById('add-comment-input');
        const submitAddCommentButton = document.getElementById('submit-add-comment-button');
        const addCommentErrorMessage = document.getElementById('add-comment-error-message');


        // NEU: Kommentar Bearbeiten/Löschen Modals
        const editCommentModal = document.getElementById('edit-comment-modal');
        const editCommentInput = document.getElementById('edit-comment-input');
        const saveCommentEditButton = document.getElementById('save-comment-edit-button');
        const editCommentErrorMessage = document.getElementById('edit-comment-error-message');

        const deleteCommentConfirmModal = document.getElementById('delete-comment-confirm-modal');
        const confirmDeleteCommentButton = document.getElementById('confirm-delete-comment-button');
        let currentCommentToEdit = null; // Speichert { modelId, commentId, commentText }
        let currentCommentToDelete = null; // Speichert { modelId, commentId }

        // NEU: Profilseite Elemente
        const profileContentView = document.getElementById('profile-content-view');
        const backToMainFromProfileButton = document.getElementById('back-to-main-from-profile-button');
        const profileEmail = document.getElementById('profile-email');
        const profileCreationDate = document.getElementById('profile-creation-date');
        const profileAvatarInitial = document.getElementById('profile-avatar-initial');
        const profileAvatarImg = document.getElementById('profile-avatar-img');
        const deleteAccountButton = document.getElementById('delete-account-button');
        const deleteAccountConfirmModal = document.getElementById('delete-account-confirm-modal');
        const confirmDeleteAccountButton = document.getElementById('confirm-delete-account-button');

        // Three.js Canvas Elemente
        const voxelDetailCanvas = document.getElementById('voxel-detail-canvas');
        const detailPreviewMessage = document.getElementById('detail-preview-message'); // Neu: Für Detailansicht leere Daten-Nachricht
        let detailRenderer = null; // Globale Instanz für den Detailseiten-Renderer

        // Auth-Anbieter
        const googleProvider = new GoogleAuthProvider();
        const githubProvider = new GithubAuthProvider(); 

        // Removed variables related to project JSON data as upload modal is removed
        // let currentProjectJsonData = null;
        // let currentProjectJsonFile = null; 

        // Definierte Kategorien für den Upload (still used for filtering)
        const predefinedCategories = ["Alle", "Spielzeug", "Dekoration", "Funktional", "Kunst", "Allgemein"]; // "Alle" für Filter-Buttons hinzugefügt

        // Variable zum Speichern des Elements, das ein Modal ausgelöst hat, für die Fokus-Rückgabe
        let lastFocusedElement = null;

        // Funktion, um zu prüfen, ob der aktuelle Benutzer ein Admin ist
        function isAdmin() {
            return _isAdmin;
        }

        // Variable zum Speichern der ID des zu löschenden Modells
        let modelIdToDelete = null; 

        // Globale Variable zum Speichern der aktuellen Modelldaten für die Detailansicht
        let currentDetailModelData = null;

        // Globale Variablen für das Toast-Management
        let lastToastTime = 0;
        const MIN_TOAST_INTERVAL = 1500; // Mindestens 1,5 Sekunden zwischen Toasts

        // Funktion zum Anzeigen von Toast-Benachrichtigungen
        function showToast(message, type = 'info', duration = 3000) {
            const now = Date.now();
            if (now - lastToastTime < MIN_TOAST_INTERVAL) {
                console.log("Toast unterdrückt aufgrund des Intervalls:", message);
                return; // Toast unterdrücken, wenn zu früh
            }
            lastToastTime = now; // Letzte Toast-Zeit aktualisieren

            const toastContainer = document.getElementById('toast-container');
            if (!toastContainer) {
                console.error("Toast-Container nicht gefunden!");
                return;
            }

            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type} shadow-lg`;
            alertDiv.setAttribute('role', 'alert'); // ARIA-Rolle
            alertDiv.innerHTML = `
                ${type === 'info' ? '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" class="stroke-current shrink-0 h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>' : ''}
                ${type === 'success' ? '<svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>' : ''}
                ${type === 'error' || type === 'warning' ? '<svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>' : ''}
                <span>${message}</span>
            `;
            toastContainer.appendChild(alertDiv);

            setTimeout(() => {
                alertDiv.remove();
            }, duration);
        }

        // Funktion zum Ausblenden von Nachrichten (für Kompatibilität beibehalten)
        function hideMessage(element) {
            element.classList.add('hidden');
            element.textContent = '';
        }

        // Hilfsfunktion zum Abrufen der berechneten Farbe von DaisyUI CSS-Variablen für Three.js-Hintergrund
        function getDaisyUICSSColorForThreeJS(selectedTheme) {
            const originalTheme = htmlElement.getAttribute('data-theme');
            htmlElement.setAttribute('data-theme', selectedTheme); // Neues Theme anwenden

            // Ein Reflow/Neuberechnung erzwingen, um sicherzustellen, dass Stile angewendet werden
            void document.body.offsetHeight; 

            // Jetzt die berechnete Hintergrundfarbe des Bodys abrufen, die das neue Theme widerspiegeln sollte
            const computedColor = getComputedStyle(document.body).backgroundColor;
            
            // Ursprüngliches Theme wiederherstellen
            htmlElement.setAttribute('data-theme', originalTheme); 

            let hexColor = '#000000'; // Standard-Fallback

            // Einen temporären Canvas verwenden, um zuverlässige RGB-Werte aus beliebigen CSS-Farbstrings zu erhalten
            const canvas = document.createElement('canvas');
            canvas.width = 1;
            canvas.height = 1;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = computedColor;
            ctx.fillRect(0, 0, 1, 1);
            const pixelData = ctx.getImageData(0, 0, 1, 1).data;
            
            // RGBA in Hex konvertieren
            const toHex = (c) => c.toString(16).padStart(2, '0');
            hexColor = `#${toHex(pixelData[0])}${toHex(pixelData[1])}${toHex(pixelData[2])}`;

            // Farbe basierend auf dem Theme für besseren Kontrast anpassen
            let r = pixelData[0];
            let g = pixelData[1];
            let b = pixelData[2];

            const adjustmentFactor = 0.1; // Um 10 % anpassen

            if (selectedTheme === 'dark') {
                // Farbe im Dunkelmodus leicht aufhellen
                r = Math.min(255, r + Math.round(r * adjustmentFactor));
                g = Math.min(255, g + Math.round(g * adjustmentFactor));
                b = Math.min(255, b + Math.round(b * adjustmentFactor));
            } else { // Hellmodus
                // Farbe im Hellmodus leicht abdunkeln
                r = Math.max(0, r - Math.round(r * adjustmentFactor));
                g = Math.max(0, g - Math.round(g * adjustmentFactor));
                b = Math.max(0, b - Math.round(b * adjustmentFactor));
            }

            hexColor = `#${toHex(r)}${toHex(g)}${toHex(b)}`;

            return hexColor;
        }

        // Vereinheitlichter Voxel-Renderer für Vorschau-Karten und Detailseite
        class VoxelRenderer { 
            constructor(canvasElement, voxelsData, gridSize = 10, backgroundColor, messageElement = null, enableControls = false, enableAutoRotate = false) {
                this.canvas = canvasElement;
                this.voxelsData = voxelsData; 
                this.gridSize = gridSize;
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null; 
                this.animationFrameId = null;
                this.pivotGroup = null; 
                this.instancedMesh = null; 
                this.isAnimating = false; 
                this.autoRotateEnabled = enableAutoRotate; 
                this.backgroundColor = backgroundColor; 
                this.messageElement = messageElement; 
                this.enableControls = enableControls; 
                
                // Properties only for custom drag logic (when enableControls is false)
                if (!this.enableControls) {
                    this.isDragging = false; 
                    this.hasMoved = false; 
                    this.dragThreshold = 5; 
                    this.startX = 0;
                    this.startY = 0;
                    this.lastX = undefined; 
                    this.lastY = undefined; 
                }

                this.init();
                this.bindEventListeners();
            }

            init() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(this.backgroundColor); 

                this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true }); 
                this.renderer.setSize(this.canvas.clientWidth, this.canvas.clientHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);

                // Schatten aktivieren
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Für weichere Schatten

                const aspect = this.canvas.clientWidth / this.canvas.clientHeight;
                this.camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000); 

                const ambientLight = new THREE.AmbientLight(0x606060); 
                this.scene.add(ambientLight);
                
                // Direktionales Licht für Schatten
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); /* FIX: Corrected typo from DirectionionalLight to DirectionalLight */
                // Position für einen schönen Winkel, normalisiert
                directionalLight.position.set(2, 3, 1).normalize(); // Licht von vorne-oben-rechts
                directionalLight.castShadow = true; // Schattenwurf aktivieren

                // Schatteneigenschaften für das direktionale Licht konfigurieren
                directionalLight.shadow.mapSize.width = 1024; // Auflösung der Schattenkarte
                directionalLight.shadow.mapSize.height = 1024; // Auflösung der Schattenkarte
                directionalLight.shadow.camera.near = 0.1;
                directionalLight.shadow.camera.far = 50; // Weit-Ebene basierend auf der erwarteten Modellgröße anpassen
                // Frustum-Größe basierend auf gridSize für bessere Schattenqualität anpassen
                const shadowCameraSize = this.gridSize * 2; 
                directionalLight.shadow.camera.left = -shadowCameraSize;
                directionalLight.shadow.camera.right = shadowCameraSize;
                directionalLight.shadow.camera.top = shadowCameraSize;
                directionalLight.shadow.camera.bottom = -shadowCameraSize;
                
                this.scene.add(directionalLight);

                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true; 
                this.controls.dampingFactor = 0.05;
                this.controls.screenSpacePanning = false;
                this.controls.minDistance = 1;
                this.controls.maxDistance = 500;
                this.controls.enabled = this.enableControls; 
                this.controls.enableZoom = this.enableControls; // Enable/disable zoom based on enableControls
                this.controls.update(); 
                this.loadVoxels(); 
            }

            loadVoxels() {
                console.log("[VoxelRenderer] loadVoxels - tatsächliche VoxelsData:", this.voxelsData);
                const voxelKeys = Object.keys(this.voxelsData || {}); 
                
                if (this.pivotGroup) {
                    this.scene.remove(this.pivotGroup);
                    this.pivotGroup.traverse((object) => {
                        if (object.isMesh) {
                            object.geometry.dispose();
                            object.material.dispose();
                        }
                    });
                    this.pivotGroup.clear();
                    this.pivotGroup = null;
                }
                this.instancedMesh = null; 

                if (!this.voxelsData || voxelKeys.length === 0) {
                    console.warn("Keine Voxeldaten zum Laden für die Vorschau. Szene wird geleert.");
                    this.canvas.classList.add('hidden'); // Canvas ausblenden
                    if (this.messageElement) {
                        this.messageElement.textContent = 'Keine 3D-Vorschau verfügbar (keine Voxeldaten)';
                        this.messageElement.classList.remove('hidden');
                    }
                    return; 
                } else {
                    this.canvas.classList.remove('hidden'); // Canvas anzeigen
                    if (this.messageElement) {
                        this.messageElement.classList.add('hidden'); // Nachricht ausblenden
                    }
                }

                const voxelGeometry = new THREE.BoxGeometry(1, 1, 1);
                const dummy = new THREE.Object3D();
                const meshMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.7, metalness: 0.1 });

                const maxInstances = voxelKeys.length;
                const instancedMesh = new THREE.InstancedMesh(voxelGeometry, meshMaterial, maxInstances);
                instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(maxInstances * 3), 3);
                instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
                instancedMesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
                
                // Schatten auf dem Instanced Mesh aktivieren
                instancedMesh.castShadow = true;
                instancedMesh.receiveShadow = true;

                let minX = Infinity, minY = Infinity, minZ = Infinity;
                let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

                let instanceId = 0; // Initialize instanceId here

                for (const key of voxelKeys) { 
                    const parts = key.split(',').map(Number);
                    if (parts.length === 3) {
                        const [x, y, z] = parts;
                        const colorHex = this.voxelsData[key];
                        const color = new THREE.Color(colorHex);

                        dummy.position.set(x + 0.5, y + 0.5, z + 0.5); 
                        dummy.updateMatrix();
                        instancedMesh.setMatrixAt(instanceId, dummy.matrix);
                        instancedMesh.instanceColor.setXYZ(instanceId, color.r, color.g, color.b);
                        instanceId++;

                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        minZ = Math.min(minZ, z);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                        maxZ = Math.max(maxZ, z);
                    }
                }
                instancedMesh.count = instanceId;
                instancedMesh.instanceMatrix.needsUpdate = true;
                instancedMesh.instanceColor.needsUpdate = true;
                
                this.pivotGroup = new THREE.Group();
                this.scene.add(this.pivotGroup); 

                const modelBoundingBox = new THREE.Box3(
                    new THREE.Vector3(minX, minY, minZ),
                    new THREE.Vector3(maxX + 1, maxY + 1, maxZ + 1) 
                );
                const modelCenter = new THREE.Vector3();
                modelBoundingBox.getCenter(modelCenter);

                instancedMesh.position.sub(modelCenter);
                this.pivotGroup.add(instancedMesh); 
                this.instancedMesh = instancedMesh; 

                const centeredModelTarget = new THREE.Vector3(0, 0, 0);

                const boundingSphere = new THREE.Sphere();
                modelBoundingBox.getBoundingSphere(boundingSphere);
                const radius = boundingSphere.radius;

                const fov = this.camera.fov * (Math.PI / 180); 
                let distance = radius / Math.tan(fov / 2);

                distance *= 1.2; 

                const cameraOffset = new THREE.Vector3(1, 1, 1).normalize().multiplyScalar(distance);
                this.camera.position.copy(centeredModelTarget).add(cameraOffset); 
                this.camera.lookAt(centeredModelTarget); 
                this.camera.updateProjectionMatrix();

                this.controls.target.copy(centeredModelTarget);
                this.controls.update();
                this.renderer.render(this.scene, this.camera); 
            }

            startAnimation() {
                if (!this.isAnimating) {
                    this.isAnimating = true;
                    this.animationFrameId = requestAnimationFrame(this.animate.bind(this)); 
                }
            }

            stopAnimation() {
                if (this.isAnimating) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.isAnimating = false;
                }
            }

            startAutoRotation() {
                this.autoRotateEnabled = true;
            }

            stopAutoRotation() {
                this.autoRotateEnabled = false;
            }

            animate() {
                this.animationFrameId = requestAnimationFrame(this.animate.bind(this));
                
                if (this.controls) {
                    this.controls.update();
                }

                this.renderer.render(this.scene, this.camera);

                if (this.autoRotateEnabled && this.pivotGroup && !this.isDragging) { 
                    this.pivotGroup.rotation.y += 0.005; 
                }
            }

            bindEventListeners() {
                // Only add custom pointer event listeners if OrbitControls are NOT enabled
                if (!this.enableControls) { 
                    this.canvas.addEventListener('pointerdown', this.onPointerDown.bind(this));
                    this.canvas.addEventListener('pointermove', this.onPointerMove.bind(this));
                    this.canvas.addEventListener('pointerup', this.onPointerUp.bind(this));
                    this.canvas.addEventListener('pointerleave', this.onPointerLeave.bind(this));
                }

                this.onWindowResize = this.onWindowResize.bind(this);
                window.addEventListener('resize', this.onWindowResize);
            }

            onPointerDown(event) {
                // Only handle primary button (left click) or single touch
                if (event.button === 0 || event.pointerType === 'touch') {
                    this.startX = event.clientX;
                    this.startY = event.clientY;
                    this.hasMoved = false; // Reset on every new press
                    this.isDragging = false; // Reset on every new press
                    this.lastX = undefined; // Initialize lastX/Y for smooth delta calculation
                    this.lastY = undefined;
                    this.stopAutoRotation();
                    this.canvas.setPointerCapture(event.pointerId); // Capture pointer for consistent tracking
                    event.preventDefault(); // **CRUCIAL**: Prevent default browser drag behavior from the start
                }
            }

            onPointerMove(event) {
                // Only proceed if a pointer is down and captured and pivotGroup exists
                if (this.canvas.hasPointerCapture(event.pointerId) && this.pivotGroup) {
                    const currentX = event.clientX;
                    const currentY = event.clientY;
                    const deltaXFromStart = currentX - this.startX; 
                    const deltaYFromStart = currentY - this.startY; 

                    // If total movement exceeds threshold, it's a drag
                    if (!this.hasMoved && Math.sqrt(deltaXFromStart * deltaXFromStart + deltaYFromStart * deltaYFromStart) > this.dragThreshold) {
                        this.hasMoved = true;
                    }

                    if (this.hasMoved) {
                        this.isDragging = true; // We are now actively dragging
                        event.preventDefault(); // Continue to prevent default during drag
                    }

                    // Perform rotation based on the difference from the last position
                    // Only rotate if lastX and lastY are defined (i.e., not the very first move)
                    if (this.lastX !== undefined && this.lastY !== undefined) {
                        const rotationDeltaX = currentX - this.lastX;
                        const rotationDeltaY = currentY - this.lastY;

                        if (event.pointerType === 'touch') {
                            // For touch, only rotate if horizontal movement is dominant
                            if (Math.abs(rotationDeltaX) > Math.abs(rotationDeltaY)) {
                                this.pivotGroup.rotation.y += rotationDeltaX * 0.01; 
                            }
                        } else if (event.pointerType === 'mouse') {
                            // For mouse (on card previews), always rotate horizontally if dragging
                            if (this.isDragging) { 
                                this.pivotGroup.rotation.y += rotationDeltaX * 0.01; 
                            }
                        }
                    }
                    
                    this.lastX = currentX; // Update for next move
                    this.lastY = currentY; // Update for next move
                }
            }

            onPointerUp(event) {
                if (this.canvas.hasPointerCapture(event.pointerId)) {
                    this.canvas.releasePointerCapture(event.pointerId); // Release pointer capture
                }
                this.lastX = undefined; // Reset to undefined
                this.lastY = undefined; // Reset to undefined
                this.isDragging = false; // Reset dragging state on pointer up

                // Auto-rotation logic
                const modelCard = this.canvas.closest('.model-card');
                if (modelCard) {
                    if (!isMobileDevice) {
                        // Desktop: Start auto-rotation if pointer is still over the card and no movement occurred
                        const rect = modelCard.getBoundingClientRect();
                        if (event.clientX >= rect.left && event.clientX <= rect.right &&
                            event.clientY >= rect.top && event.clientY <= rect.bottom) {
                            if (!this.hasMoved) { // Only start auto-rotation if it was a "click" (no significant movement)
                                this.startAutoRotation();
                            }
                        } else {
                            this.stopAutoRotation();
                        }
                    } else {
                        // Mobile: Use IntersectionObserver to decide auto-rotation
                        if (intersectionObserver) {
                            const entry = intersectionObserver.takeRecords().find(e => e.target === modelCard);
                            if (entry && entry.isIntersecting && entry.intersectionRatio > 0.75) {
                                if (!this.hasMoved) { // Only start auto-rotation if it was a "tap" (no significant movement)
                                    this.startAutoRotation();
                                }
                            } else {
                                this.stopAutoRotation();
                            }
                        }
                    }
                }
            }

            onPointerLeave(event) {
                if (this.canvas.hasPointerCapture(event.pointerId)) {
                    this.canvas.releasePointerCapture(event.pointerId);
                }
                this.isDragging = false;
                this.hasMoved = false; // Reset hasMoved when pointer leaves
                this.lastX = undefined; // Reset to undefined
                this.lastY = undefined; // Reset to undefined
                this.stopAutoRotation();
            }

            onWindowResize() {
                const width = this.canvas.clientWidth;
                const height = this.canvas.clientHeight;
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(width, height);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.render(this.scene, this.camera);
            }

            dispose() {
                this.stopAnimation(); 
                window.removeEventListener('resize', this.onWindowResize); 

                // Only remove custom pointer event listeners if they were added
                if (!this.enableControls) { 
                    this.canvas.removeEventListener('pointerdown', this.onPointerDown.bind(this));
                    this.canvas.removeEventListener('pointermove', this.onPointerMove.bind(this));
                    this.canvas.removeEventListener('pointerup', this.onPointerUp.bind(this));
                    this.canvas.removeEventListener('pointerleave', this.onPointerLeave.bind(this));
                }

                this.scene.traverse((object) => {
                    if (object.isMesh) {
                        object.geometry.dispose();
                        object.material.dispose();
                        if (this.instancedMesh) {
                            this.instancedMesh.geometry.dispose();
                            this.instancedMesh.material.dispose();
                        }
                    } 
                });
                if (this.pivotGroup) {
                    this.scene.remove(this.pivotGroup);
                    this.pivotGroup.clear(); 
                }
                this.renderer.dispose();
                if (this.controls) {
                    this.controls.dispose();
                }
            }
        }

        // Globale Karte zum Speichern der Renderer-Instanzen
        const rendererInstances = new Map();
        // Ermitteln, ob es sich um ein mobiles Gerät (oder einen kleinen Bildschirm) handelt
        const isMobileDevice = window.innerWidth <= 768; 

        // Intersection Observer für mobile Auto-Rotation
        let intersectionObserver;
        if (isMobileDevice) {
            intersectionObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    const modelId = entry.target.dataset.modelId;
                    const renderer = rendererInstances.get(modelId);

                    if (renderer) {
                        if (entry.isIntersecting && entry.intersectionRatio > 0.75) { 
                            if (!renderer.hasMoved) { // Check hasMoved instead of isDragging/isTouching
                                renderer.startAutoRotation();
                                console.log(`Mobil: Modell ${modelId} ist >75% sichtbar. Starte automatische Rotation (wenn nicht gezogen wird).`);
                            }
                        } else {
                            renderer.stopAutoRotation();
                            console.log(`Mobil: Modell ${modelId} ist nicht >75% sichtbar. Stoppe automatische Rotation.`);
                        }
                    }
                });
            }, { threshold: [0, 0.25, 0.5, 0.75, 1.0] }); 
        }

        // Funktion zum Erstellen einer Model-Card
        function createModelCard(model) {
            // The entire card becomes a link to the detail page
            const cardLink = document.createElement('a');
            // Use onclick to handle navigation internally
            cardLink.onclick = (event) => {
                // Prevent navigation if any movement (drag) was detected since pointerdown
                const renderer = rendererInstances.get(model.id);
                if (renderer && renderer.hasMoved) { // Check hasMoved instead of isDragging
                    console.log(`[Card Click] Drag detected for model ${model.id}. Preventing navigation.`);
                    event.preventDefault();
                    // hasMoved is reset on the next pointerdown, so no need to reset here.
                    return;
                }
                event.preventDefault(); // Prevent default link behavior
                showModelDetail(model.id);
            };
            cardLink.className = 'card bg-base-200 rounded-xl overflow-hidden border border-base-content/10 transition-transform duration-300 hover:translate-y-[-5px] hover:shadow-xl model-card block cursor-pointer'; // Added 'block' for full link area and cursor-pointer
            
            const averageRating = model.ratingCount > 0 ? (model.rating / model.ratingCount) : 0;
            const ratingText = averageRating.toFixed(1);
            // Determine if the current user can rate this model
            const canRate = currentUser && currentUser.uid !== model.uploaderUid;

            const uploadDate = model.timestamp ? new Date(model.timestamp.toDate()).toLocaleDateString('de-DE') : 'Unbekannt';

            let uploaderAvatarHtml;
            if (model.uploaderPhotoURL) {
                uploaderAvatarHtml = `<img src="${model.uploaderPhotoURL}" alt="Profilbild" class="w-full h-full object-cover rounded-full">`;
            } else if (model.email) { 
                uploaderAvatarHtml = `<span class="text-white">${model.uploaderEmail.charAt(0).toUpperCase()}</span>`; 
            } else {
                uploaderAvatarHtml = `<i class="fas fa-user"></i>`; 
            }

            const isUploaderOrAdmin = currentUser && (currentUser.uid === model.uploaderUid || isAdmin());

            cardLink.innerHTML = `
                <div class="h-52 flex items-center justify-center overflow-hidden relative text-base-content/60 text-sm text-center">
                    <!-- Skeleton Loader -->
                    <div class="skeleton h-full w-full absolute inset-0 flex flex-col gap-2 p-4 justify-center items-center z-10" id="skeleton-${model.id}">
                        <div class="skeleton h-32 w-full"></div>
                        <div class="skeleton h-4 w-28"></div>
                        <div class="skeleton h-4 w-full"></div>
                    </div>
                    <canvas class="voxel-preview-canvas w-full h-full block opacity-0 absolute inset-0 z-0 transition-opacity duration-500"></canvas>
                    <div class="preview-message absolute inset-0 flex items-center justify-center text-error text-sm hidden"></div>
                </div>
                <div class="card-body p-4">
                    <div class="flex justify-between items-start">
                        <div class="flex flex-col flex-grow">
                            <div class="flex items-center gap-2">
                                <h2 class="card-title text-lg" contenteditable="${isUploaderOrAdmin}" data-model-id="${model.id}" data-field="title">${model.title}</h2>
                                ${isUploaderOrAdmin ? `<span class="edit-icon text-base-content/50 cursor-pointer hidden"><i class="fas fa-pencil-alt"></i></span>` : ''}
                                <span class="save-status text-xs text-base-content/40 ml-2 hidden"></span>
                            </div>
                            <p class="text-base-content/60 text-sm mt-2" contenteditable="${isUploaderOrAdmin}" data-model-id="${model.id}" data-field="description">${model.description}</p>
                            ${isUploaderOrAdmin ? `<span class="edit-icon-desc text-base-content/50 cursor-pointer hidden"><i class="fas fa-pencil-alt"></i></span>` : ''}
                                <span class="save-status-desc text-xs text-base-content/40 ml-2 hidden"></span>
                        </div>
                        <div class="flex flex-col items-end gap-2 ml-4">
                            <div class="badge badge-outline badge-primary">${model.category || 'Allgemein'}</div>
                            ${model.verified ? `<div class="badge badge-success">Verifiziert</div>` : `<div class="badge badge-info">Unverifiziert</div>`}
                        </div>
                    </div>
                    <div class="mt-4 flex flex-col sm:flex-row sm:justify-between items-start sm:items-center gap-4">
                        <div>
                            <div class="flex items-center whitespace-nowrap">
                                <!-- Overall Average Rating Display (Font Awesome stars) -->
                                <div class="flex items-center" id="card-average-rating-display-${model.id}">
                                    <!-- Stars will be dynamically added here by JS -->
                                </div>
                                <span class="text-base-content/60 ml-2">${ratingText} (${model.ratingCount || 0})</span>
                            </div>
                            <div class="text-base-content/60 text-sm mt-1">${model.downloads || 0} Downloads</div>
                        </div>
                    </div>
                    <div class="mt-4 flex items-center text-sm text-base-content/60">
                        <div class="avatar">
                            <div class="w-8 h-8 rounded-full bg-neutral text-neutral-content flex items-center justify-center text-lg">
                                ${uploaderAvatarHtml}
                            </div>
                        </div>
                        <span class="ml-2">${model.uploaderEmail ? model.uploaderEmail.split('@')[0] : 'Unbekannt'}</span>
                        <span class="ml-auto">${uploadDate}</span>
                    </div>
                </div>
            `;
            
            // Populate the overall average rating display with Font Awesome stars
            const averageRatingDisplay = cardLink.querySelector(`#card-average-rating-display-${model.id}`);
            const roundedAverage = Math.round(averageRating);
            for (let i = 1; i <= 5; i++) {
                const starIcon = document.createElement('i');
                starIcon.className = `fas fa-star text-lg ${i <= roundedAverage ? 'text-amber-500' : 'text-gray-300'}`;
                averageRatingDisplay.appendChild(starIcon);
            }

            // In-place editing logic
            if (isUploaderOrAdmin) {
                const titleElement = cardLink.querySelector('h2[data-field="title"]');
                const descriptionElement = cardLink.querySelector('p[data-field="description"]');
                const titleEditIcon = cardLink.querySelector('.edit-icon');
                const descEditIcon = cardLink.querySelector('.edit-icon-desc');
                const titleSaveStatus = cardLink.querySelector('.save-status');
                const descSaveStatus = cardLink.querySelector('.save-status-desc');

                // Show/hide edit icons on hover/focus
                titleElement.addEventListener('mouseenter', () => titleEditIcon.classList.remove('hidden'));
                titleElement.addEventListener('mouseleave', () => { if (document.activeElement !== titleElement) titleEditIcon.classList.add('hidden'); });
                titleElement.addEventListener('focus', () => titleEditIcon.classList.remove('hidden'));
                titleElement.addEventListener('blur', () => titleEditIcon.classList.add('hidden'));

                descriptionElement.addEventListener('mouseenter', () => descEditIcon.classList.remove('hidden'));
                descriptionElement.addEventListener('mouseleave', () => { if (document.activeElement !== descriptionElement) descEditIcon.classList.add('hidden'); });
                descriptionElement.addEventListener('focus', () => descEditIcon.classList.remove('hidden'));
                descriptionElement.addEventListener('blur', () => descEditIcon.classList.add('hidden'));


                // Handle saving on blur
                titleElement.addEventListener('blur', async (event) => {
                    const newTitle = event.target.textContent.trim();
                    if (newTitle !== model.title) {
                        await handleInPlaceEdit(model.id, 'title', newTitle, titleSaveStatus);
                    }
                });

                descriptionElement.addEventListener('blur', async (event) => {
                    const newDescription = event.target.textContent.trim();
                    if (newDescription !== model.description) {
                        await handleInPlaceEdit(model.id, 'description', newDescription, descSaveStatus);
                    }
                });

                // Handle saving on Enter keydown
                titleElement.addEventListener('keydown', async (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault(); // Prevent new line
                        titleElement.blur(); // Trigger blur to save
                    }
                });

                descriptionElement.addEventListener('keydown', async (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault(); // Prevent new line
                        descriptionElement.blur(); // Trigger blur to save
                    }
                });

                // Prevent navigation when editing
                titleElement.addEventListener('click', (event) => event.preventDefault());
                descriptionElement.addEventListener('click', (event) => event.preventDefault());
            }

            // Assign model ID to the card element for easy lookup in Intersection Observer
            cardLink.dataset.modelId = model.id; 

            return cardLink; // Return the <a> element
        }

        // Funktion zum Initialisieren des Vorschau-Renderers für eine gegebene Karte
        function initPreviewRendererForCard(card, model) {
            const previewCanvas = card.querySelector('.voxel-preview-canvas');
            const skeletonElement = card.querySelector(`#skeleton-${model.id}`); 
            const previewMessageDiv = card.querySelector('.preview-message'); 
            const modelId = card.dataset.modelId;
            const voxelsData = model.projectData ? model.projectData.voxels : {};
            const gridSize = (model.projectData && model.projectData.settings && model.projectData.settings.gridSize) ? model.projectData.settings.gridSize : 10;
            
            let previewRendererInstance = null; 

            // Skeleton zunächst anzeigen, Canvas und Nachricht ausblenden
            if (skeletonElement) skeletonElement.classList.remove('hidden');
            previewCanvas.classList.add('opacity-0'); 
            previewCanvas.classList.remove('opacity-100');
            if (previewMessageDiv) previewMessageDiv.classList.add('hidden'); // FIX: Corrected typo here

            // Dynamische Three.js-Hintergrundfarbe basierend auf dem aktuellen Theme
            const currentTheme = htmlElement.getAttribute('data-theme');
            const threeJsBgColor = getDaisyUICSSColorForThreeJS(currentTheme);

            // ResizeObserver verwenden, um zu warten, bis der Canvas Dimensionen hat
            const resizeObserver = new ResizeObserver(entries => {
                for (let entry of entries) {
                    if (entry.target === previewCanvas) {
                        const { width, height } = entry.contentRect;
                        if (width > 0 && height > 0) {
                            // Canvas hat Dimensionen, initialisiere den Renderer
                            resizeObserver.disconnect(); // Beobachtung nach Initialisierung stoppen
                            try {
                                console.log(`[VoxelRenderer] Canvas-Dimensionen sind ${width}x${height} für Modell ${modelId}. Renderer wird initialisiert.`);
                                // VoxelRenderer für Karten verwenden, mit deaktivierten Steuerelementen und aktivierter Auto-Rotation
                                previewRendererInstance = new VoxelRenderer(previewCanvas, voxelsData, gridSize, threeJsBgColor, previewMessageDiv, false, true); 
                                previewRendererInstance.renderer.render(previewRendererInstance.scene, previewRendererInstance.camera);

                                if (skeletonElement) skeletonElement.classList.add('hidden');
                                previewCanvas.classList.remove('opacity-0');
                                previewCanvas.classList.add('opacity-100');
                                if (previewMessageDiv) previewMessageDiv.classList.add('hidden');

                                rendererInstances.set(model.id, previewRendererInstance);

                                if (!isMobileDevice) {
                                    card.addEventListener('mouseenter', () => {
                                        console.log(`Desktop: Maus auf Karte für Modell ${modelId} eingetreten. Starte Auto-Rotation.`);
                                        if (previewRendererInstance) {
                                            previewRendererInstance.startAutoRotation();
                                        }
                                    });
                                    card.addEventListener('mouseleave', () => {
                                        console.log(`Desktop: Maus auf Karte für Modell ${modelId} verlassen. Stoppe Auto-Rotation.`);
                                        if (previewRendererInstance) {
                                            previewRendererInstance.stopAutoRotation();
                                        }
                                    });
                                    previewRendererInstance.stopAutoRotation(); // Anfangszustand
                                } else {
                                    if (intersectionObserver) {
                                        console.log(`Mobil: Beobachte Karte für Modell ${modelId} mit IntersectionObserver.`);
                                        intersectionObserver.observe(card); 
                                    }
                                    previewRendererInstance.stopAutoRotation(); // Anfangszustand
                                }

                                previewRendererInstance.startAnimation();

                            } catch (error) {
                                console.error("[VoxelRenderer] Fehler beim Initialisieren des VoxelRenderers für Modell", model.id, ":", error);
                                previewCanvas.classList.add('hidden'); 
                                if (skeletonElement) skeletonElement.classList.remove('hidden'); 
                                if (previewMessageDiv) {
                                    previewMessageDiv.textContent = 'Fehler beim Laden der Vorschau.';
                                    previewMessageDiv.classList.remove('hidden'); 
                                    previewMessageDiv.classList.add('text-error');
                                }
                                previewRendererInstance = null; 
                            }
                        }
                    }
                }
            });

            resizeObserver.observe(previewCanvas); // Beobachtung des Canvas starten
        }

        // Intersection Observer für unendliches Scrollen
        let infiniteScrollObserver;

        function setupInfiniteScrollObserver() {
            if (infiniteScrollObserver) {
                infiniteScrollObserver.disconnect();
            }

            infiniteScrollObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting && !isLoadingModels && lastVisible) {
                        console.log("[InfiniteScroll] Sentinel sichtbar, lade weitere Modelle...");
                        fetchModels();
                    }
                });
            }, {
                root: null, 
                rootMargin: '0px',
                threshold: 0.1 
            });

            infiniteScrollObserver.observe(loadingSentinel);
        }

       // Funktion zum Laden von Modellen aus Firestore
        async function fetchModels() {
            if (isLoadingModels) {
                console.log("[fetchModels] Modelle werden bereits geladen, Abbruch.");
                return;
            }

            isLoadingModels = true;
            loadingSpinner.classList.remove('hidden');
            noMoreModelsMessage.classList.add('hidden'); 

            console.log(`\n--- fetchModels START ---`);
            console.log(`[fetchModels] _isAdmin (global): ${_isAdmin}`);
            console.log(`[fetchModels] statusFilterSelect.value (UI): ${statusFilterSelect.value}`);
            console.log(`[fetchModels] currentUser (global): ${currentUser ? currentUser.email : 'null'}`);
            console.log(`[fetchModels] currentFilterView: ${currentFilterView}`);

            try {
                const modelsCollectionRef = collection(db, "models");
                const selectedCategory = activeCategory; 
                const selectedStatus = statusFilterSelect.value;
                const currentSortBy = sortBy.value; 
                const currentUserIsAdmin = isAdmin(); 
                const searchTerm = searchInput.value.toLowerCase().trim(); 

                // Filterstatus für Nicht-Admins anpassen
                let effectiveStatus = selectedStatus;
                if (!currentUserIsAdmin && effectiveStatus === 'all') {
                    effectiveStatus = 'verified';
                    console.log(`[fetchModels] Nicht-Admin-Benutzer hat 'all' Status ausgewählt. Verwende 'verified' für die Abfrage.`);
                }

                console.log(`\n--- fetchModels Abfragekonstruktion ---`);
                console.log(`[Abfrage] Aktueller Benutzer ist Admin: ${currentUserIsAdmin}`);
                console.log(`[Abfrage] Ausgewählte Kategorie: '${selectedCategory}'`);
                console.log(`[Abfrage] Ausgewählter Status (UI): '${selectedStatus}'`);
                console.log(`[Abfrage] Effektiver Status (Abfrage): '${effectiveStatus}'`);
                console.log(`[Abfrage] Aktuelle Sortierung nach: '${currentSortBy}'`);
                console.log(`[Abfrage] Suchbegriff: '${searchTerm}'`);

                let queriesToExecute = [];
                let baseConstraints = [];

                if (currentFilterView === 'my-models') {
                    if (currentUser) {
                        baseConstraints.push(where("uploaderUid", "==", currentUser.uid));
                        mainContentTitle.textContent = "Meine Modelle";
                        console.log(`[Abfrage] Filter für 'Meine Modelle' hinzugefügt: uploaderUid == ${currentUser.uid}`);
                    } else {
                        // If 'My Models' is selected but no user is logged in, show no models.
                        // This case should ideally be prevented by hiding the 'My Models' link.
                        console.warn("[fetchModels] 'Meine Modelle' ausgewählt, aber kein Benutzer angemeldet. Zeige keine Modelle an.");
                        isLoadingModels = false;
                        loadingSpinner.classList.add('hidden');
                        noMoreModelsMessage.classList.remove('hidden');
                        return;
                    }
                } else {
                    mainContentTitle.textContent = "Community-Modelle";
                    if (!currentUserIsAdmin) {
                        baseConstraints.push(where("visibility", "==", "public"));
                        console.log(`[Abfrage] Hinzugefügt: where("visibility", "==", "public")`);
                    }
                }

                if (currentUserIsAdmin && effectiveStatus === 'all' && currentFilterView !== 'my-models') {
                    // Admin sieht sowohl verifizierte als auch unverifizierte Modelle in der Community-Ansicht
                    console.log("[Abfrage] Admin mit 'all' Status: Führe zwei Abfragen aus (verifiziert + unverifiziert)");

                    for (const verifiedValue of [true, false]) {
                        let constraints = [...baseConstraints]; // Kopie der Basiseinschränkungen

                        if (selectedCategory !== 'all') {
                            constraints.push(where("category", "==", selectedCategory));
                        }

                        constraints.push(where("verified", "==", verifiedValue));

                        if (currentSortBy.startsWith('newest')) {
                            constraints.push(orderBy("timestamp", currentSortBy.endsWith('-asc') ? "asc" : "desc"));
                        }

                        if (lastVisible) {
                            constraints.push(startAfter(lastVisible));
                        }

                        constraints.push(limit(MODELS_PER_LOAD));
                        queriesToExecute.push(query(modelsCollectionRef, ...constraints));
                        console.log(`[Abfrage]   - ${verifiedValue ? 'Verifiziert' : 'Unverifiziert'} Abfrage:`, query(modelsCollectionRef, ...constraints));
                    }
                } else {
                    // Einzelabfrage für Nicht-Admins oder Admins mit gefiltertem Status
                    let queryConstraints = [...baseConstraints]; // Kopie der Basiseinschränkungen

                    if (effectiveStatus === 'verified') {
                        queryConstraints.push(where("verified", "==", true));
                        console.log(`[Abfrage] Hinzugefügt: where("verified", "==", true)`);
                    } else if (effectiveStatus === 'unverified') {
                        queryConstraints.push(where("verified", "==", false));
                        console.log(`[Abfrage] Hinzugefügt: where("verified", "==", false)`);
                    }

                    if (selectedCategory !== 'all') {
                        queryConstraints.push(where("category", "==", selectedCategory));
                        console.log(`[Abfrage] Hinzugefügt: where("category", "==", "${selectedCategory}")`);
                    }

                    if (currentSortBy.startsWith('newest')) {
                        queryConstraints.push(orderBy("timestamp", currentSortBy.endsWith('-asc') ? "asc" : "desc"));
                        console.log(`[Abfrage] Hinzugefügt: orderBy("timestamp", "${currentSortBy.endsWith('-asc') ? 'asc' : 'desc'}")`);
                    }

                    if (lastVisible) {
                        queryConstraints.push(startAfter(lastVisible));
                        console.log(`[Abfrage] Hinzugefügt: startAfter(lastVisible)`);
                    }

                    queryConstraints.push(limit(MODELS_PER_LOAD));
                    console.log(`[Abfrage] Hinzugefügt: limit(${MODELS_PER_LOAD})`);

                    queriesToExecute.push(query(modelsCollectionRef, ...queryConstraints));
                    console.log(`[Abfrage] Endgültiges Firestore-Abfrageobjekt:`, queriesToExecute[0]);
                }

                let allDocumentSnapshots = [];
                for (const q of queriesToExecute) {
                    try {
                        const snapshots = await getDocs(q);
                        allDocumentSnapshots.push(...snapshots.docs);
                    } catch (error) {
                        console.warn("Abfrage fehlgeschlagen, wahrscheinlich aufgrund von Berechtigungen:", q, error);
                    }
                }

                const uniqueModelIds = new Set();
                let fetchedModels = [];

                allDocumentSnapshots.forEach((doc) => {
                    if (!uniqueModelIds.has(doc.id)) {
                        uniqueModelIds.add(doc.id);
                        fetchedModels.push({ id: doc.id, ...doc.data() });
                    }
                });

                console.log(`[fetchModels] Zusammengeführtes Ergebnis: ${fetchedModels.length} eindeutige Modelle.`);

                // Benutzerspezifische Bewertungsabfrage
                if (currentUser) {
                    console.log(`[fetchModels] Rufe Bewertungen für Benutzer ab: ${currentUser.uid}`);
                    for (let i = 0; i < fetchedModels.length; i++) {
                        const model = fetchedModels[i];
                        const ratingDocRef = doc(db, `models/${model.id}/ratings`, currentUser.uid);
                        const ratingDocSnap = await getDoc(ratingDocRef);
                        if (ratingDocSnap.exists()) {
                            fetchedModels[i].userRating = ratingDocSnap.data().rating;
                            console.log(`[Modell ${model.id}] Benutzerbewertung gefunden: ${fetchedModels[i].userRating}`);
                        }
                    }
                }

                // Clientseitiges Suchfiltern
                let filteredModels = fetchedModels;
                if (searchTerm) {
                    filteredModels = fetchedModels.filter(model =>
                        model.title.toLowerCase().includes(searchTerm) ||
                        model.description.toLowerCase().includes(searchTerm)
                    );
                    console.log(`[fetchModels] Nach Suchbegriff '${searchTerm}' gefiltert: ${filteredModels.length} Modelle.`);
                }

                // In-Memory-Sortierung
                if (!currentSortBy.startsWith('newest')) {
                    console.log(`[fetchModels] In-Memory-Sortierung nach: ${currentSortBy}`);
                    filteredModels.sort((a, b) => {
                        let cmp = 0;
                        if (currentSortBy.startsWith('popular')) {
                            cmp = (b.downloads || 0) - (a.downloads || 0);
                        } else if (currentSortBy.startsWith('top-rated')) {
                            const ra = a.ratingCount ? (a.rating / a.ratingCount) : 0;
                            const rb = b.ratingCount ? (b.rating / b.ratingCount) : 0;
                            cmp = rb - ra;
                        }
                        return currentSortBy.endsWith('-asc') ? -cmp : cmp;
                    });
                }

                if (filteredModels.length > 0) {
                    filteredModels.forEach(model => {
                        const newCard = createModelCard(model); 
                        modelsGrid.appendChild(newCard); 
                        initPreviewRendererForCard(newCard, model); 
                    });

                    if (allDocumentSnapshots.length > 0) {
                        lastVisible = allDocumentSnapshots[allDocumentSnapshots.length - 1];
                    } else {
                        lastVisible = null;
                    }

                    console.log(`[fetchModels] ${filteredModels.length} Modelle hinzugefügt. lastVisible aktualisiert.`);
                } else {
                    if (!lastVisible || allDocumentSnapshots.length === 0) {
                        noMoreModelsMessage.classList.remove('hidden'); 
                        console.log("[fetchModels] Keine weiteren Modelle verfügbar.");
                    }
                    if (infiniteScrollObserver) {
                        infiniteScrollObserver.unobserve(loadingSentinel);
                        loadingSentinel.classList.add('hidden'); 
                        console.log("[fetchModels] Infinite Scroll Observer deaktiviert.");
                    }
                }

                if (allDocumentSnapshots.length < MODELS_PER_LOAD) {
                    noMoreModelsMessage.classList.remove('hidden');
                    if (infiniteScrollObserver) {
                        infiniteScrollObserver.unobserve(loadingSentinel); 
                        loadingSentinel.classList.add('hidden');
                    }
                    console.log("[fetchModels] Ende der Liste erreicht.");
                } else {
                    loadingSentinel.classList.remove('hidden'); 
                    if (infiniteScrollObserver) {
                        infiniteScrollObserver.observe(loadingSentinel); 
                    }
                    console.log("[fetchModels] Weitere Modelle könnten verfügbar sein. Observer wieder scharfgeschaltet.");
                }

                allModelsData = allModelsData.concat(filteredModels);

            } catch (error) {
                console.error("[fetchModels] FEHLER:", error);
                showToast(`Fehler beim Laden: ${error.message}`, 'error');
                loadingSentinel.classList.add('hidden'); 
            } finally {
                isLoadingModels = false;
                loadingSpinner.classList.add('hidden');
                console.log("[fetchModels] Laden abgeschlossen.");
            }
        }


        // Hilfsfunktion zum Zurücksetzen des Rasters und Abrufen von Modellen
        function resetAndFetch() {
            console.log(`[resetAndFetch] Start: Raster geleert, Paginierung zurückgesetzt.`);
            modelsGrid.innerHTML = ''; // Raster leeren
            lastVisible = null; // Paginierung zurücksetzen
            allModelsData = []; // Gespeicherte Modelle löschen
            rendererInstances.forEach(renderer => { if (renderer) renderer.dispose(); }); // Three.js-Renderer freigeben
            rendererInstances.clear(); // Renderer-Karte löschen

            setActiveCategory(activeCategory); // Aktives Kategorie-Styling erneut anwenden
            sortBy.value = 'newest-desc';
            // Der Reset von statusFilterSelect hängt vom Admin-Status ab und wird in updateUI behandelt (aber durch resetFiltersButton überschrieben)
            searchInput.value = ''; // Sucheingabe ist jetzt im Header, wird nicht durch allgemeinen Filter-Reset zurückgesetzt

            // IntersectionObserver für Mobilgeräte trennen und neu initialisieren, falls zutreffend
            if (intersectionObserver && isMobileDevice) {
                console.log("[resetAndFetch] Mobile IntersectionObserver wird neu initialisiert.");
                intersectionObserver.disconnect();
                intersectionObserver = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        const modelId = entry.target.dataset.modelId;
                        const renderer = rendererInstances.get(modelId);
                        if (renderer) {
                            if (entry.isIntersecting && entry.intersectionRatio > 0.75) {
                                if (!renderer.hasMoved) { // Check hasMoved instead of isDragging/isTouching
                                    renderer.startAutoRotation();
                                }
                            } else {
                                renderer.stopAutoRotation();
                            }
                        }
                    });
                }, { threshold: [0, 0.25, 0.5, 0.75, 1.0] });
            }
            console.log("[resetAndFetch] fetchModels wird aufgerufen.");
            fetchModels(); // Modelle neu laden
        }


        // UI basierend auf dem Anmeldestatus aktualisieren
        async function updateUI(user) {
            console.log(`[updateUI] Start: user=${user ? user.email : 'null'}, _isAdmin=${_isAdmin}, manualFilterResetActive=${manualFilterResetActive}`);

            if (user) {
                loginButton.classList.add('hidden');
                logoutButton.classList.remove('hidden');
                profileButton.classList.remove('hidden'); // Profil-Button anzeigen
                navMyModelsButton.classList.remove('hidden'); // "Meine Modelle" Link anzeigen
                
                // Benutzerprofilbild oder Initialen anzeigen
                let avatarContent;
                if (user.photoURL) {
                    avatarContent = `<img src="${user.photoURL}" alt="Profilbild" class="w-full h-full object-cover rounded-full">`;
                } else if (user.email) { 
                    avatarContent = `<span class="text-white">${user.email.charAt(0).toUpperCase()}</span>`; 
                } else {
                    avatarContent = `<i class="fas fa-user text-lg"></i>`; 
                }

                userMenuButton.innerHTML = `
                    <div class="avatar">
                        <div class="w-10 rounded-full bg-primary flex items-center justify-center">
                            ${avatarContent}
                        </div>
                    </div>
                `;

                // "Unverifiziert" Option hinzufügen, wenn Admin, entfernen, wenn nicht
                if (_isAdmin) {
                    console.log("[updateUI] Benutzer ist Admin. Prüfe/füge 'Unverifiziert' Option hinzu.");
                    if (!statusFilterSelect.querySelector('option[value="unverified"]')) {
                        const unverifiedOption = document.createElement('option');
                        unverifiedOption.value = 'unverified';
                        unverifiedOption.textContent = 'Unverifiziert';
                        statusFilterSelect.appendChild(unverifiedOption);
                        console.log("[updateUI] 'Unverifiziert' Option hinzugefügt.");
                    }
                    if (!manualFilterResetActive && (statusFilterSelect.value === 'verified' || statusFilterSelect.value === 'all')) {
                        console.log(`[updateUI] Admin: Filter wird nicht automatisch auf 'unverified' gesetzt.`);
                    } else if (manualFilterResetActive) {
                        console.log(`[updateUI] Manueller Filter-Reset aktiv, aktueller statusFilterSelect.value (${statusFilterSelect.value}) wird beibehalten.`);
                    }
                } else {
                    console.log("[updateUI] Benutzer ist KEIN Admin. Prüfe/entferne 'Unverifiziert' Option.");
                    const unverifiedOption = statusFilterSelect.querySelector('option[value="unverified"]'); 
                    if (unverifiedOption) { 
                        unverifiedOption.remove(); 
                        console.log("[updateUI] 'Unverifiziert' Option entfernt.");
                    }
                    if (statusFilterSelect.value === 'unverified') { // Wenn es zuvor unverifiziert war (als Admin), auf verifiziert zurücksetzen
                        statusFilterSelect.value = 'verified'; 
                        console.log(`[updateUI] statusFilterSelect.value auf 'verified' für Nicht-Admin gesetzt.`);
                    }
                }
                
                console.log(`[updateUI] Ende: Rufe resetAndFetch auf. _isAdmin=${_isAdmin}, statusFilterSelect.value=${statusFilterSelect.value}`);
                // Nur resetAndFetch aufrufen, wenn wir uns in der Hauptansicht befinden
                if (!mainContentView.classList.contains('hidden') && initialAuthCheckCompleted) { // Ensure initial auth check is done
                     resetAndFetch(); 
                }

            } else { // Benutzer ist abgemeldet
                console.log("[updateUI] Benutzer ist abgemeldet.");
                loginButton.classList.remove('hidden');
                logoutButton.classList.add('hidden');
                profileButton.classList.add('hidden'); // Profil-Button ausblenden
                navMyModelsButton.classList.add('hidden'); // "Meine Modelle" Link ausblessenden
                
                userMenuButton.innerHTML = `
                    <div class="bg-neutral text-neutral-content rounded-full w-10 flex items-center justify-center">
                        <i class="fas fa-user text-lg"></i> </div>
                `;
                _isAdmin = false; // Admin-Status bei Abmeldung zurücksetzen
                const unverifiedOption = statusFilterSelect.querySelector('option[value="unverified"]');
                if (unverifiedOption) { unverifiedOption.remove(); }
                statusFilterSelect.value = 'verified'; // Standardmäßig auf 'verified' für abgemeldete Benutzer

                console.log(`[updateUI] Ende: Rufe resetAndFetch auf (abgemeldet). _isAdmin=${_isAdmin}, statusFilterSelect.value=${statusFilterSelect.value}`);
                // Nur resetAndFetch aufrufen, wenn wir uns in der Hauptansicht befinden
                if (!mainContentView.classList.contains('hidden') && initialAuthCheckCompleted) { // Ensure initial auth check is done
                    resetAndFetch(); 
                }
            }

            // Sichtbarkeit der Admin-Aktionen auf der Detailseite aktualisieren
            if (currentDetailModelData) {
                if (_isAdmin) {
                    adminActionsDiv.classList.remove('hidden');
                    if (currentDetailModelData.verified) {
                        verifyButton.classList.add('hidden');
                        revertVerifyButton.classList.remove('hidden');
                    } else {
                        verifyButton.classList.remove('hidden');
                        revertVerifyButton.classList.add('hidden');
                    }
                } else {
                    adminActionsDiv.classList.add('hidden');
                }
            } else {
                adminActionsDiv.classList.add('hidden');
            }
        }


        // Funktion zum Initialisieren der Kategorien im Filter- und Upload-Modal
        function initializeCategoryOptions() {
            // Für Kategorie-Filter-Buttons
            categoryFilterButtonsContainer.innerHTML = ''; // Vorherige Buttons löschen
            predefinedCategories.forEach(category => {
                const button = document.createElement('button');
                button.className = `btn btn-sm category-filter-btn ${category === activeCategory ? 'btn-active btn-primary' : 'btn-ghost'}`;
                button.textContent = category;
                button.dataset.category = category === 'Alle' ? 'all' : category; // 'all' für den "Alle"-Button verwenden
                button.setAttribute('aria-pressed', category === activeCategory ? 'true' : 'false'); // ARIA-Attribut
                categoryFilterButtonsContainer.appendChild(button);

                button.addEventListener('click', () => {
                    setActiveCategory(button.dataset.category);
                    resetAndFetch();
                });
            });

            // Removed category input for upload modal as it's no longer needed
            // modelCategoryInput.innerHTML = '<option value="" disabled selected>Kategorie auswählen</option>';
            // predefinedCategories.filter(cat => cat !== "Alle").forEach(category => {
            //     const option = document.createElement('option');
            //     option.value = category;
            //     option.textContent = category;
            //     modelCategoryInput.appendChild(option);
            // });
        }

        // Funktion zum Setzen des aktiven Kategorie-Buttons
        function setActiveCategory(category) {
            activeCategory = category;
            document.querySelectorAll('.category-filter-btn').forEach(btn => {
                if (btn.dataset.category === category) {
                    btn.classList.add('btn-active', 'btn-primary');
                    btn.classList.remove('btn-ghost');
                    btn.setAttribute('aria-pressed', 'true');
                } else {
                    btn.classList.remove('btn-active', 'btn-primary');
                    btn.classList.add('btn-ghost');
                    btn.setAttribute('aria-pressed', 'false');
                }
            });
        }

        setPersistence(auth, browserLocalPersistence)
            .then(() => {
                console.log("[Firebase Auth] Persistenz auf browserLocalPersistence gesetzt.");
                onAuthStateChanged(auth, async (user) => { // Diese Callback-Funktion asynchron machen
                    currentUser = user;
                    currentUserId = user?.uid || null;
                    console.log(`\n[onAuthStateChanged] Auth-Status geändert. Benutzer: ${user ? user.email : 'null'}`);

                    // Admin-Status zuerst asynchron ermitteln
                    if (user) {
                        try {
                            const userDocRef = doc(db, "users", user.uid);
                            console.log(`[onAuthStateChanged] Rufe Benutzerdokument für Admin-Status ab: users/${user.uid}`);
                            const userDocSnap = await getDoc(userDocRef); // Darauf warten
                            _isAdmin = (userDocSnap.exists() && userDocSnap.data().isAdmin === true);
                            console.log(`[onAuthStateChanged] Admin-Status ermittelt: _isAdmin=${_isAdmin} (existiert: ${userDocSnap.exists()}, isAdmin-Feld: ${userDocSnap.exists() ? userDocSnap.data().isAdmin : 'N/A'})`);
                        } catch (error) {
                            console.error("[onAuthStateChanged] Fehler beim Abrufen des Admin-Status:", error);
                            _isAdmin = false;
                        }
                    } else {
                        _isAdmin = false; // Nicht angemeldet, kein Admin
                        console.log("[onAuthStateChanged] Benutzer abgemeldet, _isAdmin auf false gesetzt.");
                    }

                    // Jetzt die UI basierend auf dem ermittelten Status aktualisieren
                    console.log(`[onAuthStateChanged] Rufe updateUI auf mit Benutzer: ${user ? user.email : 'null'} und _isAdmin: ${_isAdmin}`);
                    updateUI(user); // Dies wird nun den bereits ermittelten _isAdmin verwenden

                    // Nur Modelle abrufen, wenn dies die erste vollständige Auth-Statusprüfung ist
                    if (!initialAuthCheckCompleted) {
                        initialAuthCheckCompleted = true;
                        console.log("[onAuthStateChanged] Anfängliche Auth-Prüfung abgeschlossen.");
                    }
                });
            })
            .catch((error) => {
                console.error("[Firebase Auth] Fehler beim Setzen der Persistenz:", error);
                showToast(`Fehler bei der Anmeldebeständigkeit: ${error.message}. Die Funktionalität könnte eingeschränkt sein.`, 'error');
            });


        // Login-Handler
        loginButton.addEventListener('click', (e) => {
            console.log("[UI Event] Login-Button geklickt.");
            lastFocusedElement = e.currentTarget; // Element speichern, das das Modal ausgelöst hat
            hideMessage(authErrorMessage);
            authModal.showModal();
            emailInput.focus(); // Fokus auf das erste Eingabefeld setzen
        });

        // Modal-Schließereignis-Listener zur Fokus-Rückgabe
        authModal.addEventListener('close', () => {
            console.log("[UI Event] Auth-Modal geschlossen.");
            if (lastFocusedElement) {
                lastFocusedElement.focus();
                lastFocusedElement = null;
            }
        });

        // Firebase Login
        firebaseLoginButton.addEventListener('click', async (e) => {
            e.preventDefault();
            console.log("[Auth] Firebase Login-Button geklickt.");
            hideMessage(authErrorMessage);
            const email = emailInput.value;
            const password = passwordInput.value;

            try {
                await signInWithEmailAndPassword(auth, email, password);
                console.log("[Auth] Firebase Login erfolgreich.");
                // Eine kleine Verzögerung vor dem Schließen hinzufügen, um potenzielle COOP-Warnungen zu mildern
                setTimeout(() => {
                    authModal.close(); 
                    showToast('Erfolgreich angemeldet!', 'success');
                }, 100); 
            } catch (error) {
                console.error("[Auth] Firebase Login Fehler:", error.code, error.message);
                let errorMessage = "Anmeldung fehlgeschlagen. Bitte versuchen Sie es erneut.";
                if (error.code === 'auth/user-not-found' || error.code === 'auth/wrong-password' || error.code === 'auth/invalid-credential') {
                    errorMessage = "Ungültige E-Mail oder Passwort.";
                } else if (error.code === 'auth/invalid-email') {
                    errorMessage = "Ungültiges E-Mail-Format.";
                }
                showToast(errorMessage, 'error'); 
            }
        });

        // Firebase Registrierung
        firebaseSignupButton.addEventListener('click', async (e) => {
            e.preventDefault();
            console.log("[Auth] Firebase Registrierungs-Button geklickt.");
            hideMessage(authErrorMessage);
            const email = emailInput.value;
            const password = passwordInput.value; 

            try {
                await createUserWithEmailAndPassword(auth, email, password);
                console.log("[Auth] Firebase Registrierung erfolgreich.");
                // Eine kleine Verzögerung vor dem Schließen hinzufügen, um potenzielle COOP-Warnungen zu mildern
                setTimeout(() => {
                    authModal.close(); 
                    showToast('Registrierung erfolgreich! Sie sind jetzt angemeldet.', 'success');
                }, 100);
            } catch (error) {
                console.error("[Auth] Firebase Registrierungs-Fehler:", error.code, error.message);
                let errorMessage = "Registrierung fehlgeschlagen. Bitte versuchen Sie es erneut.";
                if (error.code === 'auth/email-already-in-use') {
                    errorMessage = "Diese E-Mail-Adresse wird bereits verwendet.";
                } else if (error.code === 'auth/weak-password') {
                    errorMessage = "Das Passwort sollte mindestens 6 Zeichen lang sein.";
                } else if (error.code === 'auth/invalid-email') {
                    errorMessage = "Ungültiges E-Mail-Format.";
                }
                showToast(errorMessage, 'error'); 
            }
        });

        // Firebase Google Login (jetzt über Popup)
        googleLoginButton.addEventListener('click', async (e) => {
            e.preventDefault();
            console.log("[Auth] Google Login-Button geklickt.");
            hideMessage(authErrorMessage);
            try {
                const result = await signInWithPopup(auth, googleProvider);
                console.log("[Auth] Google-Anmeldung erfolgreich:", result.user);
                // Eine kleine Verzögerung vor dem Schließen hinzufügen, um potenzielle COOP-Warnungen zu mildern
                setTimeout(() => {
                    authModal.close(); 
                    showToast('Erfolgreich mit Google angemeldet!', 'success');
                }, 100);
            } catch (error) {
                console.error("[Auth] Firebase Google Login Fehler:", error.code, error.message);
                let errorMessage = "Anmeldung fehlgeschlagen. Bitte versuchen Sie es erneut.";
                if (error.code === 'auth/popup-closed-by-user' || error.code === 'auth/cancelled-popup-request') {
                    errorMessage = "Anmeldung abgebrochen.";
                } else if (error.code === 'auth/operation-not-allowed') {
                    errorMessage = "Diese Anmeldemethode ist in Ihrem Firebase-Projekt nicht aktiviert. Bitte überprüfen Sie die Firebase Console.";
                } else if (error.code === 'auth/network-request-failed') {
                    errorMessage = "Netzwerkfehler. Bitte überprüfen Sie Ihre Internetverbindung.";
                } else if (error.code === 'auth/unauthorized-domain') {
                    errorMessage = `Fehler: Nicht autorisierte Domain. Bitte fügen Sie "${window.location.origin}" zu den autorisierten Domains in Ihrer Firebase Console (Authentifizierung -> Einstellungen) hinzu.`;
                }
                showToast(errorMessage, 'error'); 
            }
        });

        // Firebase GitHub Login (jetzt über Popup)
        githubLoginButton.addEventListener('click', async (e) => {
            e.preventDefault();
            console.log("[Auth] GitHub Login-Button geklickt.");
            hideMessage(authErrorMessage);
            try {
                const result = await signInWithPopup(auth, githubProvider);
                console.log("[Auth] GitHub-Anmeldung erfolgreich:", result.user);
                // Eine kleine Verzögerung vor dem Schließen hinzufügen, um potenzielle COOP-Warnungen zu mildern
                setTimeout(() => {
                    authModal.close(); 
                    showToast('Erfolgreich mit GitHub angemeldet!', 'success');
                }, 100);
            } catch (error) {
                console.error("[Auth] Firebase GitHub Login Fehler:", error.code, error.message);
                let errorMessage = "Anmeldung fehlgeschlagen. Bitte versuchen Sie es erneut.";
                if (error.code === 'auth/popup-closed-by-user' || error.code === 'auth/cancelled-popup-request') {
                    errorMessage = "Anmeldung abgebrochen.";
                } else if (error.code === 'auth/operation-not-allowed') {
                    errorMessage = "Diese Anmeldemethode ist in Ihrem Firebase-Projekt nicht aktiviert. Bitte überprüfen Sie die Firebase Console.";
                } else if (error.code === 'auth/network-request-failed') {
                    errorMessage = "Netzwerkfehler. Bitte überprüfen Sie Ihre Internetverbindung.";
                } else if (error.code === 'auth/unauthorized-domain') {
                    errorMessage = `Fehler: Nicht autorisierte Domain. Bitte fügen Sie "${window.location.origin}" zu den autorisierten Domains in Ihrer Firebase Console (Authentifizierung -> Einstellungen) hinzu.`;
                }
                showToast(errorMessage, 'error'); 
            }
        });


        // Firebase Abmeldung
        logoutButton.addEventListener('click', async (e) => {
            e.preventDefault();
            console.log("[Auth] Abmelde-Button geklickt.");
            try {
                await signOut(auth);
                console.log("[Auth] Benutzer erfolgreich abgemeldet.");
                showToast('Erfolgreich abgemeldet!', 'info');
            } catch (error) {
                console.error("[Auth] Firebase Abmelde-Fehler:", error.message);
                showToast(`Fehler beim Abmelden: ${error.message}`, 'error');
            }
        });

        // Event listener for the new "In VoxelShaper öffnen" button
        openVoxelshaperNewButton.addEventListener('click', () => {
            console.log("[UI Event] 'In VoxelShaper öffnen' button clicked.");
            const editorUrl = `https://voxelshaper.com/`; // URL for creating a new model

            if (isMobileDevice) {
                window.location.href = editorUrl;
                console.log(`[VoxelShaper öffnen] Mobilgerät: Aktuellen Tab mit URL ersetzt: ${editorUrl}`);
            } else {
                const a = document.createElement('a');
                a.href = editorUrl;
                a.target = '_blank';
                a.rel = 'noopener noreferrer';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                console.log(`[VoxelShaper öffnen] Desktop-Gerät: Neuen Tab mit URL ausgelöst: ${editorUrl}`);
            }
            showToast('VoxelShaper wird geöffnet, um ein neues Modell zu erstellen!', 'info');
        });

        // Function to create a Three.js scene from voxel data for STL export
        function createSceneFromVoxels(voxelsData) {
            console.log("[STL Export] Erstelle Three.js-Szene aus Voxeldaten.");
            const scene = new THREE.Scene();
            const scaleFactor = 10; // Skalierungsfaktor für STL-Export (1 Einheit im Editor = 10 Einheiten in STL für cm)
            const material = new THREE.MeshNormalMaterial(); // Einfaches Material für den Export
            
            const geometries = [];

            let minX = Infinity, minY = Infinity, minZ = Infinity;
            let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

            for (const key in voxelsData) {
                const parts = key.split(',').map(Number);
                if (parts.length === 3) {
                    const [x, y, z] = parts;
                    minX = Math.min(minX, x);
                    minY = Math.min(minY, y);
                    minZ = Math.min(minZ, z);
                    maxX = Math.max(maxX, x);
                    maxY = Math.max(maxY, y);
                    maxZ = Math.max(maxZ, z);
                }
            }

            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            const centerZ = (minZ + maxZ) / 2;
            console.log(`[STL Export] Bounding Box: X[${minX},${maxX}], Y[${minY},${maxY}], Z[${minZ},${maxZ}]`);

            for (const key in voxelsData) {
                const parts = key.split(',').map(Number);
                if (parts.length === 3) {
                    const [x, y, z] = parts;
                    
                    const geometry = new THREE.BoxGeometry(scaleFactor, scaleFactor, scaleFactor);
                    
                    const posX = (x - centerX) * scaleFactor;
                    const posY = (y - centerY) * scaleFactor;
                    const posZ = (z - centerZ) * scaleFactor;
                    
                    const matrix = new THREE.Matrix4().makeTranslation(
                        posX + scaleFactor / 2, 
                        posY + scaleFactor / 2, 
                        posZ + scaleFactor / 2
                    );
                    
                    geometry.applyMatrix4(matrix);
                    geometries.push(geometry);
                }
            }

            if (geometries.length === 0) {
                console.error("[STL Export] Keine Voxel zum Exportieren gefunden. Leere Szene wird zurückgegeben.");
                return scene; // Eine leere Szene zurückgeben
            }

            const mergedGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries(geometries);
            const mesh = new THREE.Mesh(mergedGeometry, material);
            scene.add(mesh);
            console.log("[STL Export] Geometrien zusammengeführt und Mesh zur Szene hinzugefügt.");

            return scene;
        }


        // Download-Handler (jetzt für STL)
        async function handleDownload(modelId, modelTitle) {
            console.log(`[Download] Download angefordert für Modell-ID: ${modelId}, Titel: "${modelTitle}"`);
            if (!auth.currentUser) { 
                lastFocusedElement = document.getElementById('download-stl-button'); // Setze den letzten Fokus auf den Detailseiten-Button
                authModal.showModal();
                showToast('Bitte melden Sie sich an, um Modelle herunterzuladen.', 'info');
                console.log("[Download] Benutzer nicht angemeldet, zeige Auth-Modal an.");
                return;
            }

            showToast(`Download von "${modelTitle}" als STL wird vorbereitet...`, 'info');

            try {
                const docRef = doc(db, "models", modelId);
                console.log(`[Download] Rufe Modelldokument von Firestore ab: models/${modelId}`);
                const docSnap = await getDoc(docRef);

                if (docSnap.exists()) {
                    const modelData = docSnap.data();
                    const voxelsData = modelData.projectData ? modelData.projectData.voxels : null;

                    console.log("[Download] Modelldokument gefunden. Voxeldaten vorhanden:", !!voxelsData); 

                    if (voxelsData && Object.keys(voxelsData).length > 0) {
                        console.log("[Download] Voxeldaten verfügbar. Erstelle Three.js-Szene für den STL-Export.");
                        const sceneToExport = createSceneFromVoxels(voxelsData);
                        const exporter = new THREE.STLExporter();
                        console.log("[Download] Exportiere Szene in STL-String.");
                        const stlString = exporter.parse(sceneToExport);

                        const blob = new Blob([stlString], { type: 'text/plain' }); // 'text/plain' für ASCII STL verwenden
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `${modelTitle.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.stl`; 
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        console.log(`[Download] STL-Datei "${a.download}" erstellt und Download ausgelöst.`);

                        try {
                            console.log(`[Download] Aktualisiere Download-Zählung für Modell ${modelId}. Aktuell: ${modelData.downloads || 0}`);
                            await updateDoc(docRef, {
                                downloads: (modelData.downloads || 0) + 1
                            });
                            showToast(`"${modelTitle}.stl" erfolgreich heruntergeladen!`, 'success');
                            console.log("[Download] Download-Zählung erfolgreich aktualisiert.");
                            // UI sofort auf der Detailseite aktualisieren
                            if (currentDetailModelData && currentDetailModelData.id === modelId) {
                                currentDetailModelData.downloads = (currentDetailModelData.downloads || 0) + 1;
                                document.getElementById('download-count').textContent = currentDetailModelData.downloads;
                            }
                        } catch (updateError) {
                            console.error("[Download] Fehler beim Aktualisieren der Download-Zählung:", updateError);
                            showToast(`STL-Download erfolgreich, aber Fehler beim Aktualisieren des Zählers: ${updateError.message}.`, 'warning');
                        }

                    } else {
                         console.error("[Download] Keine Voxeldaten im Dokument für den STL-Export gefunden.");
                         showToast('Fehler beim Download: Keine Voxeldaten für STL-Export gefunden.', 'error');
                    }

                } else {
                    console.error("[Download] Dokument nicht gefunden für Modell-ID:", modelId);
                    showToast('Fehler beim Download: Modell nicht gefunden.', 'error');
                }
            } catch (error) {
                console.error("[Download] Fehler beim Herunterladen des Modell-STL:", error);
                showToast(`Fehler beim Download der STL-Datei: ${error.message}`, 'error');
            }
        }

        // Funktion zum Öffnen in VoxelShaper
        async function handleOpenOnVoxelShaper(modelId) {
            console.log(`[VoxelShaper öffnen] Öffne Modell-ID ${modelId} in VoxelShaper.`);
            showToast(`Modell ${modelId} wird in VoxelShaper geöffnet!`, 'info');

            try {
                const docRef = doc(db, "models", modelId);
                console.log(`[VoxelShaper öffnen] Rufe Modelldokument von Firestore ab: models/${modelId}`);
                const docSnap = await getDoc(docRef);

                if (docSnap.exists()) {
                    const editorUrl = `https://voxelshaper.com/?modelId=${modelId}`;
                    
                    if (isMobileDevice) {
                        window.location.href = editorUrl;
                        console.log(`[VoxelShaper öffnen] Mobilgerät: Aktuellen Tab mit URL ersetzt: ${editorUrl}`);
                    } else {
                        const a = document.createElement('a');
                        a.href = editorUrl;
                        a.target = '_blank'; 
                        a.rel = 'noopener noreferrer';
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        console.log(`[VoxelShaper öffnen] Desktop-Gerät: Neuen Tab mit URL ausgelöst: ${editorUrl}`);
                    }

                } else {
                    console.error("[VoxelShaper öffnen] Dokument nicht gefunden für Modell-ID:", modelId);
                    showToast('Fehler beim Öffnen: Modell nicht gefunden. Es wurde möglicherweise gelöscht oder die ID ist falsch.', 'error');
                }
            } catch (error) {
                console.error("[VoxelShaper öffnen] Fehler beim Öffnen des Modells in VoxelShaper:", error);
                showToast(`Fehler beim Öffnen des Modells: ${error.message}`, 'error');
            }
        }

        // Admin-Funktion: Modell verifizieren
        async function verifyModel(modelId) {
            console.log(`[Admin-Aktion] Verifiziere Modell-ID: ${modelId}. Aktueller _isAdmin-Status: ${_isAdmin}`);
            if (!isAdmin()) {
                showToast('Keine Berechtigung zum Verifizieren von Modellen.', 'error');
                console.warn("[Admin-Aktion] Unbefugter Versuch, Modell zu verifizieren.");
                return;
            }
            try {
                const modelRef = doc(db, "models", modelId);
                console.log(`[Admin-Aktion] Aktualisiere Modell ${modelId} auf verifiziert: true.`);
                await updateDoc(modelRef, { verified: true });
                showToast('Modell erfolgreich verifiziert!', 'success');
                console.log("[Admin-Aktion] Modell erfolgreich verifiziert. Rufe Modelldetails erneut ab.");
                // UI sofort aktualisieren
                if (currentDetailModelData && currentDetailModelData.id === modelId) {
                    currentDetailModelData.verified = true;
                    updateUI(currentUser); // Admin-Buttons aktualisieren
                }
                getModelDetails(modelId);
            } catch (error) {
                console.error("[Admin-Aktion] Fehler beim Verifizieren des Modells:", error);
                showToast(`Fehler beim Verifizieren des Modells: ${error.message}`, 'error');
            }
        }

        // Admin-Funktion: Verifizierung rückgängig machen
        async function revertVerification(modelId) {
            console.log(`[Admin-Aktion] Verifizierung rückgängig machen für Modell-ID: ${modelId}. Aktueller _isAdmin-Status: ${_isAdmin}`);
            if (!isAdmin()) {
                showToast('Keine Berechtigung zum Rückgängigmachen der Verifizierung.', 'error');
                console.warn("[Admin-Aktion] Unbefugter Versuch, Verifizierung rückgängig zu machen.");
                return;
            }
            try {
                const modelRef = doc(db, "models", modelId);
                console.log(`[Admin-Aktion] Aktualisiere Modell ${modelId} auf verifiziert: false.`);
                await updateDoc(modelRef, { verified: false });
                showToast('Verifizierung erfolgreich rückgängig gemacht!', 'success');
                console.log("[Admin-Aktion] Verifizierung erfolgreich rückgängig gemacht. Rufe Modelldetails erneut ab.");
                if (currentDetailModelData && currentDetailModelData.id === modelId) {
                    currentDetailModelData.verified = false;
                    updateUI(currentUser);
                }
                getModelDetails(modelId);
            } catch (error) {
                console.error("[Admin-Aktion] Fehler beim Rückgängigmachen der Verifizierung:", error);
                showToast(`Fehler beim Rückgängigmachen der Verifizierung: ${error.message}`, 'error');
            }
        }

        // Admin-Funktion: Modell löschen
        async function deleteModel(modelId) {
            console.log(`[Admin-Aktion] Lösche Modell-ID: ${modelId}. Aktueller _isAdmin-Status: ${_isAdmin}`);
            if (!isAdmin()) {
                showToast('Keine Berechtigung zum Löschen von Modellen.', 'error');
                console.warn("[Admin-Aktion] Unbefugter Versuch, Modell zu löschen.");
                return;
            }
            try {
                console.log(`[Admin-Aktion] Lösche Modelldokument von Firestore: models/${modelId}`);
                await deleteDoc(doc(db, "models", modelId));
                showToast('Modell erfolgreich gelöscht!', 'success');
                console.log("[Admin-Aktion] Modell erfolgreich aus Firestore gelöscht.");
                
                showMainContent();
            }
            catch (error) {
                console.error("[Admin-Aktion] Fehler beim Löschen des Modells:", error);
                showToast(`Fehler beim Löschen des Modells: ${error.message}`, 'error');
            }
        }

        // Funktion zum Posten eines neuen Kommentars und Speichern der Bewertung
        async function submitFeedback() {
            const commentText = addCommentInput.value.trim(); // Changed from commentInput
            const modelId = currentDetailModelData ? currentDetailModelData.id : null;
            const selectedRating = addCommentRatingInput.querySelector('input:checked')?.value; // Changed from userRatingInput

            hideMessage(addCommentErrorMessage); // Hide error message for add comment modal

            // FIX: Improved validation flow
            if (!currentUser) {
                showToast('Sie müssen angemeldet sein, um einen Kommentar zu hinterlassen.', 'error');
                return;
            }
            if (!modelId) {
                showToast('Modell-ID nicht gefunden.', 'error');
                return;
            }
            if (!selectedRating) {
                showToast('Bitte wählen Sie eine Sternebewertung aus.', 'warning');
                return;
            }
            if (!commentText) {
                showToast('Bitte geben Sie einen Kommentartext ein.', 'warning');
                return;
            }

            submitAddCommentButton.disabled = true; // Button deaktivieren, um Doppelsendungen zu verhindern

            const modelRef = doc(db, "models", modelId);
            const ratingRef = doc(db, `models/${modelId}/ratings`, currentUser.uid); 
            const commentsCollectionRef = collection(db, `models/${modelId}/comments`);

            try {
                console.log("[Feedback] Starte Firestore-Transaktion für Kommentar und Bewertung.");
                await runTransaction(db, async (transaction) => {
                    const modelDoc = await transaction.get(modelRef);
                    const ratingDoc = await transaction.get(ratingRef);

                    if (!modelDoc.exists()) {
                        throw new Error("Modell existiert nicht!");
                    }

                    const modelData = modelDoc.data();
                    
                    // FIX: Prevent self-rating with a friendly toast
                    if (currentUser.uid === modelData.uploaderUid) {
                        throw new Error('self-rating'); // Use a specific error type
                    }

                    let currentRatingSum = modelData.rating || 0;
                    let currentRatingCount = modelData.ratingCount || 0;
                    let oldRating = 0;

                    if (ratingDoc.exists()) {
                        oldRating = ratingDoc.data().rating;
                        currentRatingSum = currentRatingSum - oldRating + parseInt(selectedRating);
                        console.log(`[Feedback] Aktualisiere vorhandene Bewertung. Alt: ${oldRating}, Neu: ${selectedRating}. Summe: ${currentRatingSum}`);
                    } else {
                        currentRatingSum = currentRatingSum + parseInt(selectedRating);
                        currentRatingCount = currentRatingCount + 1;
                        console.log(`[Feedback] Füge neue Bewertung hinzu. Neu: ${selectedRating}. Summe: ${currentRatingSum}, Anzahl: ${currentRatingCount}`);
                    }

                    transaction.update(modelRef, {
                        rating: currentRatingSum,
                        ratingCount: currentRatingCount
                    });

                    transaction.set(ratingRef, {
                        rating: parseInt(selectedRating),
                        timestamp: serverTimestamp()
                    });

                    await addDoc(commentsCollectionRef, {
                        userId: currentUser.uid,
                        userName: currentUser.displayName || (currentUser.email ? currentUser.email.split('@')[0] : 'Anonym'),
                        userEmail: currentUser.email || null,
                        userPhotoURL: currentUser.photoURL || null,
                        commentText: commentText,
                        rating: parseInt(selectedRating),
                        timestamp: serverTimestamp()
                    });
                });

                showToast('Bewertung und Kommentar erfolgreich abgegeben!', 'success');
                addCommentInput.value = ''; // Eingabefeld leeren
                addCommentRatingInput.querySelectorAll('input').forEach(radio => radio.checked = false);
                addCommentModal.close(); // Close the modal on success
                console.log("[Feedback] Transaktion erfolgreich. Modelldetails erneut abrufen.");
                getModelDetails(modelId); // Modelldetails erneut abrufen, um UI zu aktualisieren

            } catch (error) {
                console.error("[Feedback] Fehler beim Posten von Bewertung/Kommentar:", error);
                // FIX: Handle the custom self-rating error
                if (error.message === 'self-rating') {
                    showToast('Sie können Ihre eigenen Modelle nicht bewerten.', 'info');
                    addCommentErrorMessage.textContent = 'Sie können Ihre eigenen Modelle nicht bewerten.';
                } else {
                    showToast(`Fehler beim Posten von Bewertung/Kommentar: ${error.message}`, 'error');
                    addCommentErrorMessage.textContent = `Fehler: ${error.message}`;
                }
                addCommentErrorMessage.classList.remove('hidden');
            } finally {
                submitAddCommentButton.disabled = false; // Re-enable button
            }
        }

        // Funktion zum Bearbeiten eines Kommentars
        async function editComment(modelId, commentId, newText) {
            hideMessage(editCommentErrorMessage);
            if (!currentUser) {
                showToast('Sie müssen angemeldet sein, um Kommentare zu bearbeiten.', 'error');
                return;
            }
            if (!newText.trim()) {
                showToast('Kommentar darf nicht leer sein.', 'error');
                return;
            }

            const commentRef = doc(db, `models/${modelId}/comments`, commentId);
            try {
                const commentSnap = await getDoc(commentRef);
                if (!commentSnap.exists()) {
                    showToast('Kommentar nicht gefunden.', 'error');
                    return;
                }
                const commentData = commentSnap.data();

                if (commentData.userId !== currentUser.uid && !isAdmin()) {
                    showToast('Sie sind nicht berechtigt, diesen Kommentar zu bearbeiten.', 'error');
                    return;
                }

                await updateDoc(commentRef, {
                    commentText: newText.trim(),
                    timestamp: serverTimestamp()
                });
                showToast('Kommentar erfolgreich aktualisiert!', 'success');
                editCommentModal.close();
            } catch (error) {
                console.error("[Comments] Fehler beim Bearbeiten des Kommentars:", error);
                showToast(`Fehler beim Bearbeiten des Kommentars: ${error.message}`, 'error');
                editCommentErrorMessage.textContent = `Fehler: ${error.message}`;
                editCommentErrorMessage.classList.remove('hidden');
            }
        }

        // Funktion zum Löschen eines Kommentars
        async function deleteComment(modelId, commentId) {
            if (!currentUser) {
                showToast('Sie müssen angemeldet sein, um Kommentare zu löschen.', 'error');
                return;
            }

            const commentRef = doc(db, `models/${modelId}/comments`, commentId);
            try {
                const commentSnap = await getDoc(commentRef);
                if (!commentSnap.exists()) {
                    showToast('Kommentar nicht gefunden.', 'error');
                    return;
                }
                const commentData = commentSnap.data();

                if (commentData.userId !== currentUser.uid && !isAdmin()) {
                    showToast('Sie sind nicht berechtigt, diesen Kommentar zu löschen.', 'error');
                    return;
                }

                await deleteDoc(commentRef);
                showToast('Kommentar erfolgreich gelöscht!', 'success');
                deleteCommentConfirmModal.close();

                if (commentData.rating) {
                    const modelRef = doc(db, "models", modelId);
                    const ratingRef = doc(db, `models/${modelId}/ratings`, commentData.userId);

                    await runTransaction(db, async (transaction) => {
                        const modelDoc = await transaction.get(modelRef);
                        const userRatingDoc = await transaction.get(ratingRef);

                        if (modelDoc.exists()) {
                            const modelData = modelDoc.data();
                            let currentRatingSum = modelData.rating || 0;
                            let currentRatingCount = modelData.ratingCount || 0;
                            const deletedCommentRating = commentData.rating;

                            if (userRatingDoc.exists() && userRatingDoc.data().rating === deletedCommentRating) {
                                transaction.delete(ratingRef);
                                
                                currentRatingSum -= deletedCommentRating;
                                currentRatingCount -= 1;
                                
                                if (currentRatingSum < 0) currentRatingSum = 0;
                                if (currentRatingCount < 0) currentRatingCount = 0;

                                transaction.update(modelRef, {
                                    rating: currentRatingSum,
                                    ratingCount: currentRatingCount
                                });
                            }
                        }
                    });
                }

                if (!detailContentView.classList.contains('hidden') && currentDetailModelData.id === modelId) {
                    getModelDetails(modelId);
                } else if (!mainContentView.classList.contains('hidden')) {
                    resetAndFetch();
                }

            } catch (error) {
                console.error("[Comments] Fehler beim Löschen des Kommentars:", error);
                showToast(`Fehler beim Löschen des Kommentars: ${error.message}`, 'error');
            }
        }


        // In-Place-Bearbeitung für Titel und Beschreibung handhaben
        async function handleInPlaceEdit(modelId, field, newValue, statusElement) {
            console.log(`[In-Place Edit] Versuch, Modell ${modelId}, Feld '${field}' auf '${newValue}' zu bearbeiten.`);
            if (!currentUser) {
                showToast('Sie müssen angemeldet sein, um Änderungen vorzunehmen.', 'error');
                console.warn("[In-Place Edit] Nicht autorisiert: Nicht angemeldet.");
                return;
            }

            const modelRef = doc(db, "models", modelId);
            console.log(`[In-Place Edit] Rufe Modelldokument für Berechtigungsprüfung ab: models/${modelId}`);
            const modelSnap = await getDoc(modelRef);
            if (!modelSnap.exists()) {
                showToast('Modell nicht gefunden.', 'error');
                console.error("[In-Place Edit] Modell nicht gefunden für In-Place-Bearbeitung.");
                return;
            }
            const modelData = modelSnap.data();

            if (currentUser.uid !== modelData.uploaderUid && !isAdmin()) {
                showToast('Keine Berechtigung zum Bearbeiten dieses Modells.', 'error');
                console.warn(`[In-Place Edit] Nicht autorisiert: Benutzer ${currentUser.uid} ist nicht Uploader (${modelData.uploaderUid}) und kein Admin.`);
                const element = document.querySelector(`[data-model-id="${modelId}"][data-field="${field}"]`);
                if (element) {
                    element.textContent = modelData[field];
                    console.log(`[In-Place Edit] Text auf Original für Feld '${field}' zurückgesetzt.`);
                }
                return;
            }
            console.log(`[In-Place Edit] Benutzer zum Bearbeiten autorisiert. Uploader: ${currentUser.uid === modelData.uploaderUid}, Admin: ${isAdmin()}`);


            if (statusElement) {
                statusElement.textContent = 'Speichern...';
                statusElement.classList.remove('hidden');
                statusElement.classList.remove('text-success', 'text-error');
                statusElement.classList.add('text-base-content/40');
                console.log("[In-Place Edit] Zeige 'Speichern...'-Status an.");
            }

            const updateData = {};
            updateData[field] = newValue;

            try {
                console.log(`[In-Place Edit] Versuch, Firestore-Dokument für Modell ${modelId}, Feld '${field}' zu aktualisieren.`);
                await updateDoc(modelRef, updateData);
                if (statusElement) {
                    statusElement.textContent = 'Gespeichert!';
                    statusElement.classList.remove('text-base-content/40');
                    statusElement.classList.add('text-success');
                }
                showToast(`"${field}" erfolgreich aktualisiert!`, 'success');
                console.log(`[In-Place Edit] Feld '${field}' erfolgreich aktualisiert.`);
            } catch (error) {
                console.error(`[In-Place Edit] Fehler beim Aktualisieren von "${field}":`, error);
                if (statusElement) {
                    statusElement.textContent = 'Fehler!';
                    statusElement.classList.remove('text-base-content/40');
                    statusElement.classList.add('text-error');
                }
                showToast(`Fehler beim Aktualisieren von "${field}": ${error.message}`, 'error');
            } finally {
                if (statusElement) {
                    setTimeout(() => {
                        statusElement.classList.add('hidden');
                        statusElement.textContent = '';
                        console.log("[In-Place Edit] Statusnachricht ausblenden.");
                    }, 2000);
                }
            }
        }


        // Löschbestätigungs-Modal-Logik
        document.getElementById('confirm-delete-button').addEventListener('click', () => {
            console.log("[UI Event] Löschen bestätigen-Button geklickt.");
            if (modelIdToDelete) {
                deleteModel(modelIdToDelete);
                document.getElementById('delete-confirm-modal').close();
                modelIdToDelete = null; 
            }
        });

        function showDeleteConfirmationModal(modelId, modelTitle) {
            console.log(`[UI Event] Zeige Löschbestätigungs-Modal für Modell-ID: ${modelId}, Titel: "${modelTitle}"`);
            modelIdToDelete = modelId;
            document.getElementById('model-to-delete-title').textContent = modelTitle;
            lastFocusedElement = document.getElementById('delete-button');
            document.getElementById('delete-confirm-modal').showModal();
            document.getElementById('confirm-delete-button').focus();
        }

        document.getElementById('delete-confirm-modal').addEventListener('close', () => {
            console.log("[UI Event] Löschbestätigungs-Modal geschlossen.");
            if (lastFocusedElement) {
                lastFocusedElement.focus();
                lastFocusedElement = null;
            }
        });


        // Event-Listener für Filter-Auswahlen
        sortBy.addEventListener('change', () => {
            console.log("[Filter] Sortierung geändert. Setze zurück und rufe Modelle ab.");
            resetAndFetch(); 
        });

        statusFilterSelect.addEventListener('change', () => {
            console.log("[Filter] Statusfilter geändert. Setze zurück und rufe Modelle ab.");
            resetAndFetch();
        });

        // Event-Listener für Sucheingabe
        searchInput.addEventListener('keyup', () => {
            console.log("[Search] Sucheingabe Keyup-Ereignis. Filtere clientseitig.");
            const searchTerm = searchInput.value.toLowerCase().trim();
            const cards = modelsGrid.querySelectorAll('.model-card');
            cards.forEach(card => {
                const title = card.querySelector('.card-title').textContent.toLowerCase();
                const description = card.querySelector('p[data-field="description"]').textContent.toLowerCase();
                if (title.includes(searchTerm) || description.includes(searchTerm)) {
                    card.style.display = '';
                } else {
                    card.style.display = 'none';
                }
            });
            if (searchTerm === '' && modelsGrid.children.length !== allModelsData.length) {
                console.log("[Search] Suchbegriff gelöscht, rufe alle Modelle erneut ab.");
                resetAndFetch();
            }
        });

        // Event-Listener für "Filter zurücksetzen"-Button
        resetFiltersButton.addEventListener('click', () => {
            console.log("[Filter] 'Filter zurücksetzen'-Button geklickt. Setze alle Filter zurück und rufe Modelle ab.");
            manualFilterResetActive = true;
            activeCategory = 'all';
            initializeCategoryOptions();
            sortBy.value = 'newest-desc';
            statusFilterSelect.value = 'verified';
            searchInput.value = '';
            currentFilterView = 'community';
            console.log(`[Filter] Nach Klick auf den Reset-Button: statusFilterSelect.value = ${statusFilterSelect.value}, _isAdmin = ${_isAdmin}, manualFilterResetActive = ${manualFilterResetActive}`);
            resetAndFetch();
            setTimeout(() => {
                manualFilterResetActive = false;
                console.log("[Filter] manualFilterResetActive nach Verzögerung auf false gesetzt.");
            }, 500);
        });


        // Event-Listener für Navigationsleisten-Buttons
        navDiscoverButton.addEventListener('click', (e) => {
            e.preventDefault();
            console.log("[Navbar] 'Entdecken'-Button geklickt.");
            currentFilterView = 'community';
            sortBy.value = 'newest-desc';
            activeCategory = 'all';
            initializeCategoryOptions();
            statusFilterSelect.value = 'verified';
            showMainContent();
            resetAndFetch();
        });

        navPopularButton.addEventListener('click', (e) => {
            e.preventDefault();
            console.log("[Navbar] 'Beliebt'-Button geklickt.");
            currentFilterView = 'community';
            sortBy.value = 'popular-desc';
            activeCategory = 'all';
            initializeCategoryOptions();
            statusFilterSelect.value = 'verified';
            showMainContent();
            resetAndFetch();
        });

        navNewButton.addEventListener('click', (e) => {
            e.preventDefault();
            console.log("[Navbar] 'Neu'-Button geklickt.");
            currentFilterView = 'community';
            sortBy.value = 'newest-desc';
            activeCategory = 'all';
            initializeCategoryOptions();
            statusFilterSelect.value = 'verified';
            showMainContent();
            resetAndFetch();
        });

        navCategoriesButton.addEventListener('click', (e) => {
            e.preventDefault();
            console.log("[Navbar] 'Kategorien'-Button geklickt.");
            currentFilterView = 'community';
            sortBy.value = 'newest-desc';
            activeCategory = 'all';
            initializeCategoryOptions();
            statusFilterSelect.value = 'verified';
            showMainContent();
            resetAndFetch();
        });

        navHomeButton.addEventListener('click', (e) => {
            e.preventDefault();
            console.log("[Navbar] 'Home'-Button geklickt.");
            showMainContent();
        });

        navMyModelsButton.addEventListener('click', (e) => {
            e.preventDefault();
            console.log("[Navbar] 'Meine Modelle'-Button geklickt.");
            if (!currentUser) {
                showToast('Bitte melden Sie sich an, um Ihre Modelle anzuzeigen.', 'info');
                lastFocusedElement = e.currentTarget;
                authModal.showModal();
                return;
            }
            currentFilterView = 'my-models';
            sortBy.value = 'newest-desc';
            activeCategory = 'all';
            initializeCategoryOptions();
            statusFilterSelect.value = 'all';
            showMainContent();
            resetAndFetch();
        });


        // Funktion zum Anzeigen der Modelldetailansicht
        async function showModelDetail(modelId) {
            console.log(`[Ansichtswechsel] Zeige Details für Modell-ID: ${modelId}`);
            mainContentView.classList.add('hidden');
            profileContentView.classList.add('hidden');
            detailContentView.classList.remove('hidden');
            try {
                history.pushState({ view: 'detail', modelId: modelId }, '', `?modelId=${modelId}`);
                console.log(`[Ansichtswechsel] history.pushState erfolgreich für modelId: ${modelId}`);
            } catch (e) {
                console.warn(`[Ansichtswechsel] history.pushState fehlgeschlagen: ${e.message}.`);
                showToast('Hinweis: Deep-Linking über die URL ist in dieser Umgebung möglicherweise eingeschränkt.', 'warning');
            }

            rendererInstances.forEach(renderer => { if (renderer) renderer.dispose(); });
            rendererInstances.clear();
            if (infiniteScrollObserver) {
                infiniteScrollObserver.disconnect();
            }

            await getModelDetails(modelId);
        }

        // Funktion zum Anzeigen der Hauptinhaltsansicht
        function showMainContent() {
            console.log("[Ansichtswechsel] Zeige Hauptinhaltsansicht.");
            detailContentView.classList.add('hidden');
            profileContentView.classList.add('hidden');
            mainContentView.classList.remove('hidden');
            try {
                history.pushState({ view: 'main' }, '', window.location.pathname);
                console.log("[Ansichtswechsel] history.pushState erfolgreich für Hauptansicht.");
            } catch (e) {
                console.warn(`[Ansichtswechsel] history.pushState fehlgeschlagen: ${e.message}.`);
            }

            if (detailRenderer) {
                detailRenderer.dispose();
                detailRenderer = null;
            }
            setupInfiniteScrollObserver();
            resetAndFetch();
        }

        // Funktion zum Anzeigen der Profilseite
        function showProfilePage() {
            console.log("[Ansichtswechsel] Zeige Profilseite.");
            mainContentView.classList.add('hidden');
            detailContentView.classList.add('hidden');
            profileContentView.classList.remove('hidden');

            if (currentUser) {
                profileEmail.textContent = currentUser.email || 'N/A';
                if (currentUser.metadata && currentUser.metadata.creationTime) {
                    const creationDate = new Date(currentUser.metadata.creationTime).toLocaleDateString('de-DE');
                    profileCreationDate.textContent = `Mitglied seit: ${creationDate}`;
                } else {
                    profileCreationDate.textContent = '';
                }

                if (currentUser.photoURL) {
                    profileAvatarImg.src = currentUser.photoURL;
                    profileAvatarImg.classList.remove('hidden');
                    profileAvatarInitial.classList.add('hidden');
                } else if (currentUser.email) {
                    profileAvatarInitial.textContent = currentUser.email.charAt(0).toUpperCase();
                    profileAvatarInitial.classList.remove('hidden');
                    profileAvatarImg.classList.add('hidden');
                } else {
                    profileAvatarInitial.innerHTML = '<i class="fas fa-user text-6xl"></i>';
                    profileAvatarInitial.classList.remove('hidden');
                    profileAvatarImg.classList.add('hidden');
                }
            }
        }

        // Handle Browser-Zurück-/Vorwärts-Buttons
        window.addEventListener('popstate', (event) => {
            console.log("[Popstate-Ereignis] Status geändert:", event.state);
            const urlParams = new URLSearchParams(window.location.search);
            const modelIdFromUrl = urlParams.get('modelId');

            if (modelIdFromUrl) {
                showModelDetail(modelIdFromUrl);
            } else if (event.state && event.state.view === 'profile') {
                showProfilePage();
            } else {
                showMainContent();
            }
        });

        // Funktion zum Abrufen von Modelldetails
        async function getModelDetails(modelId) {
            detailLoadingSpinner.classList.remove('hidden');
            modelContent.classList.add('hidden');
            modelNotFoundMessage.classList.add('hidden');
            detailPreviewMessage.classList.add('hidden');

            try {
                const docRef = doc(db, "models", modelId);
                const docSnap = await getDoc(docRef);

                if (docSnap.exists()) {
                    const modelData = { id: docSnap.id, ...docSnap.data() };
                    console.log("[getModelDetails] Modelldaten abgerufen:", modelData);
                    console.log("[getModelDetails] Modell projectData:", modelData.projectData);

                    if (currentUser) {
                        const ratingDocRef = doc(db, `models/${modelId}/ratings`, currentUser.uid);
                        const ratingDocSnap = await getDoc(ratingDocRef);
                        if (ratingDocSnap.exists()) {
                            modelData.userRating = ratingDocSnap.data().rating;
                            console.log(`[getModelDetails] Benutzerbewertung für Modell ${modelId}: ${modelData.userRating}`);
                        }
                    }
                    currentDetailModelData = modelData;
                    renderModelDetails(modelData);
                    loadComments(modelId);
                } else {
                    console.warn("[getModelDetails] Kein solches Dokument für Modell-ID:", modelId);
                    modelNotFoundMessage.classList.remove('hidden');
                }
            } catch (error) {
                console.error("[getModelDetails] Fehler beim Abrufen der Modelldetails:", error);
                showToast(`Fehler beim Laden der Modelldetails: ${error.message}`, 'error');
                modelNotFoundMessage.classList.remove('hidden');
            } finally {
                detailLoadingSpinner.classList.add('hidden');
            }
        }

        // Funktion zum Rendern von Modelldetails auf der Seite
        function renderModelDetails(model) {
            modelTitleElement.textContent = model.title;
            modelDescriptionElement.textContent = model.description;
            modelCategoryElement.textContent = model.category || 'Allgemein';
            downloadCountElement.textContent = model.downloads || 0;
            ratingCountElement.textContent = model.ratingCount || 0;

            let uploaderAvatarHtml;
            if (model.uploaderPhotoURL) {
                uploaderAvatarHtml = `<img src="${model.uploaderPhotoURL}" alt="Profilbild" class="w-full h-full object-cover rounded-full">`;
            } else if (model.uploaderEmail) { 
                uploaderAvatarHtml = `<span class="text-white">${model.uploaderEmail.charAt(0).toUpperCase()}</span>`; 
            } else {
                uploaderAvatarHtml = `<i class="fas fa-user"></i>`; 
            }
            uploaderAvatarElement.innerHTML = uploaderAvatarHtml;
            uploaderInfoElement.textContent = model.uploaderEmail ? model.uploaderEmail.split('@')[0] : 'Unbekannt';
            uploadDateElement.textContent = model.timestamp ? new Date(model.timestamp.toDate()).toLocaleDateString('de-DE') : 'Unbekannt';

            // Clear previous stars
            detailRatingStars.innerHTML = '';

            const averageRating = model.ratingCount > 0 ? (model.rating / model.ratingCount) : 0;
            console.log(`[renderModelDetails] Model ID: ${model.id}, Raw Rating: ${model.rating}, Rating Count: ${model.ratingCount}, Calculated Average: ${averageRating}, Rounded Average: ${Math.round(averageRating)}`);
            detailRatingText.textContent = `${averageRating.toFixed(1)} (${model.ratingCount || 0} Bewertungen)`;

            // Populate the overall rating display with Font Awesome stars
            const roundedAverage = Math.round(averageRating);
            for (let i = 1; i <= 5; i++) {
                const starIcon = document.createElement('i');
                starIcon.className = `fas fa-star text-xl ${i <= roundedAverage ? 'text-amber-500' : 'text-gray-300'}`; // Tailwind colors
                detailRatingStars.appendChild(starIcon);
            }

            modelContent.classList.remove('hidden'); 

            if (detailRenderer) {
                detailRenderer.dispose();
                detailRenderer = null;
            }

            const voxelsData = model.projectData ? model.projectData.voxels : {};
            const gridSize = (model.projectData && model.projectData.settings && model.projectData.settings.gridSize) ? model.projectData.settings.gridSize : 10;
            const currentTheme = htmlElement.getAttribute('data-theme');
            const threeJsBgColor = getDaisyUICSSColorForThreeJS(currentTheme);

            const detailCanvasResizeObserver = new ResizeObserver(entries => {
                for (let entry of entries) {
                    if (entry.target === voxelDetailCanvas) {
                        const { width, height } = entry.contentRect;
                        if (width > 0 && height > 0) {
                            detailCanvasResizeObserver.disconnect();

                            console.log(`[Detail VoxelRenderer] Canvas-Dimensionen sind ${width}x${height}. Renderer wird initialisiert.`);
                            detailRenderer = new VoxelRenderer(voxelDetailCanvas, voxelsData, gridSize, threeJsBgColor, detailPreviewMessage, true, false);
                            detailRenderer.startAnimation();

                            voxelDetailCanvas.classList.remove('hidden'); 
                            detailPreviewMessage.classList.add('hidden'); 
                        }
                    }
                }
            });

            detailCanvasResizeObserver.observe(voxelDetailCanvas);
        }

        // Funktion zum Laden von Kommentaren für ein Modell
        function loadComments(modelId) {
            console.log(`[Kommentare] Lade Kommentare für Modell-ID: ${modelId}`);
            commentsList.innerHTML = '';
            noCommentsMessage.classList.add('hidden');

            const commentsCollectionRef = collection(db, `models/${modelId}/comments`);
            const q = query(commentsCollectionRef, orderBy('timestamp', 'desc'));

            onSnapshot(q, (snapshot) => {
                const comments = [];
                snapshot.forEach(doc => {
                    comments.push({ id: doc.id, ...doc.data() });
                });
                console.log(`[Kommentare] ${comments.length} Kommentare abgerufen.`);
                renderComments(comments, modelId);
            }, (error) => {
                console.error("[Kommentare] Fehler beim Laden der Kommentare:", error);
                showToast(`Fehler beim Laden der Kommentare: ${error.message}.`, 'error');
                commentsList.innerHTML = `<p class="text-error text-center py-4">Fehler beim Laden der Kommentare.</p>`;
            });
        }

        // Funktion zum Rendern von Kommentaren
        function renderComments(comments, modelId) {
            commentsList.innerHTML = '';
            if (comments.length === 0) {
                noCommentsMessage.classList.remove('hidden');
                return;
            }
            noCommentsMessage.classList.add('hidden');

            comments.forEach(comment => {
                const commentDiv = document.createElement('div');
                commentDiv.className = 'comment-card';

                let userAvatarHtml;
                if (comment.userPhotoURL) {
                    userAvatarHtml = `<img src="${comment.userPhotoURL}" alt="Profilbild" class="w-full h-full object-cover rounded-full">`;
                } else if (comment.userEmail) {
                    userAvatarHtml = `<span class="text-white">${comment.userEmail.charAt(0).toUpperCase()}</span>`;
                } else {
                    userAvatarHtml = `<i class="fas fa-user"></i>`;
                }

                const commentDate = comment.timestamp ? new Date(comment.timestamp.toDate()).toLocaleDateString('de-DE') : 'Unbekannt';
                const commentTime = comment.timestamp ? new Date(comment.timestamp.toDate()).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }) : '';

                const canEditOrDelete = currentUser && (comment.userId === currentUser.uid || isAdmin());

                commentDiv.innerHTML = `
                    <div class="flex items-start mb-2">
                        <div class="avatar mr-3">
                            <div class="w-10 h-10 rounded-full bg-neutral text-neutral-content flex items-center justify-center text-lg">
                                ${userAvatarHtml}
                            </div>
                        </div>
                        <div class="flex-grow">
                            <p class="font-semibold text-lg">${comment.userName || (comment.userEmail ? comment.userEmail.split('@')[0] : 'Anonym')}</p>
                            <div class="text-base-content/60 text-sm flex items-center">
                                <span>${commentDate} ${commentTime}</span>
                                ${comment.rating ? `
                                    <div class="flex items-center ml-2" id="comment-rating-display-${comment.id}">
                                        <!-- Stars will be dynamically added here by JS -->
                                    </div>
                                    <span class="ml-1 text-xs text-base-content/50">(${comment.rating} Sterne)</span>
                                ` : ''}
                            </div>
                        </div>
                        ${canEditOrDelete ? `
                            <div class="flex gap-2 ml-auto">
                                <button class="btn btn-ghost btn-circle btn-sm edit-comment-btn" data-comment-id="${comment.id}" data-model-id="${modelId}" aria-label="Kommentar bearbeiten">
                                    <i class="fas fa-edit"></i>
                                </button>
                                <button class="btn btn-ghost btn-circle btn-sm delete-comment-btn" data-comment-id="${comment.id}" data-model-id="${modelId}" aria-label="Kommentar löschen">
                                    <i class="fas fa-trash-alt"></i>
                                </button>
                            </div>
                        ` : ''}
                    </div>
                    <p class="text-base-content/80 ml-12 comment-text">${comment.commentText}</p> <!-- Added comment-text class -->
                `;
                commentsList.appendChild(commentDiv);

                // Dynamically add stars for comment rating display
                if (comment.rating) {
                    const commentRatingDisplay = commentDiv.querySelector(`#comment-rating-display-${comment.id}`);
                    for (let i = 1; i <= 5; i++) {
                        const starIcon = document.createElement('i');
                        starIcon.className = `fas fa-star text-xs ${i <= comment.rating ? 'text-amber-500' : 'text-gray-300'}`;
                        commentRatingDisplay.appendChild(starIcon);
                    }
                }
            });

            document.querySelectorAll('.edit-comment-btn').forEach(button => {
                button.onclick = (e) => {
                    const commentId = e.currentTarget.dataset.commentId;
                    const modelId = e.currentTarget.dataset.modelId;
                    // Changed selector to use the new class
                    const commentTextElement = e.currentTarget.closest('.comment-card').querySelector('.comment-text'); 
                    if (commentTextElement) { // Added null check
                        currentCommentToEdit = { modelId, commentId, commentText: commentTextElement.textContent };
                        editCommentInput.value = currentCommentToEdit.commentText;
                        editCommentModal.showModal();
                        editCommentInput.focus();
                    } else {
                        console.error("Comment text element not found for editing.");
                        showToast("Fehler: Kommentartext zum Bearbeiten nicht gefunden.", "error");
                    }
                };
            });

            document.querySelectorAll('.delete-comment-btn').forEach(button => {
                button.onclick = (e) => {
                    const commentId = e.currentTarget.dataset.commentId;
                    const modelId = e.currentTarget.dataset.modelId;
                    currentCommentToDelete = { modelId, commentId };
                    deleteCommentConfirmModal.showModal();
                };
            });
        }

        // Event-Listener for "Add Comment" button
        addCommentButton.addEventListener('click', () => {
            if (!currentUser) {
                lastFocusedElement = addCommentButton;
                authModal.showModal();
                showToast('Bitte melden Sie sich an, um einen Kommentar zu hinterlassen.', 'info');
            } else {
                // Reset modal content
                addCommentModalTitle.textContent = 'Kommentar hinzufügen';
                addCommentInput.value = '';
                addCommentRatingInput.querySelectorAll('input').forEach(radio => radio.checked = false);
                hideMessage(addCommentErrorMessage);
                addCommentModal.showModal();
                addCommentInput.focus();
            }
        });

        // Event-Listener for "Submit" button in the Add Comment Modal
        submitAddCommentButton.addEventListener('click', submitFeedback);

        // Event-Listener für den "Speichern"-Button im Kommentar-Bearbeiten-Modal
        saveCommentEditButton.addEventListener('click', () => {
            if (currentCommentToEdit) {
                const newText = editCommentInput.value.trim();
                editComment(currentCommentToEdit.modelId, currentCommentToEdit.commentId, newText);
            }
        });

        // Event-Listener für den "Löschen"-Button im Kommentar-Löschen-Bestätigungs-Modal
        confirmDeleteCommentButton.addEventListener('click', () => {
            if (currentCommentToDelete) {
                deleteComment(currentCommentToDelete.modelId, currentCommentToDelete.commentId);
            }
        });


        // Event-Listener für Teilen-Button
        document.getElementById('share-button').addEventListener('click', async () => {
            const modelId = currentDetailModelData ? currentDetailModelData.id : null;
            if (!modelId) {
                showToast('Modell-ID nicht gefunden zum Teilen.', 'error');
                return;
            }
            const shareUrl = window.location.origin + window.location.pathname + `?modelId=${modelId}`; 

            if (navigator.share) {
                try {
                    await navigator.share({
                        title: currentDetailModelData ? currentDetailModelData.title : 'VoxelShaper Modell',
                        text: currentDetailModelData ? currentDetailModelData.description : 'Schau dir dieses 3D-Voxelmodell auf VoxelShaper an!',
                        url: shareUrl,
                    });
                    showToast('Modell erfolgreich geteilt!', 'success');
                } catch (error) {
                    console.error('Fehler beim Teilen:', error);
                    showToast('Fehler beim Teilen des Modells.', 'error');
                }
            } else {
                try {
                    await navigator.clipboard.writeText(shareUrl);
                    showToast('Link in die Zwischenablage kopiert!', 'success');
                } catch (err) {
                    console.error('Text konnte nicht kopiert werden: ', err);
                    showToast('Fehler beim Kopieren des Links.', 'error');
                }
            }
        });

        // Anfängliches Setup beim Laden der Seite
        document.addEventListener('DOMContentLoaded', () => {
            console.log("[DOMContentLoaded] Seite vollständig geladen.");
            const savedTheme = localStorage.getItem('theme');
            const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

            let initialTheme = 'dark'; 
            if (savedTheme) {
                initialTheme = savedTheme;
            } else if (!systemPrefersDark) { 
                initialTheme = 'light';
            }

            htmlElement.setAttribute('data-theme', initialTheme);
            themeToggle.checked = (initialTheme === 'dark'); 
            console.log(`[DOMContentLoaded] Initiales Theme gesetzt auf: ${initialTheme}`);

            initializeCategoryOptions(); // Now globally accessible
            console.log("[DOMContentLoaded] Kategorie-Optionen initialisiert.");

            const urlParams = new URLSearchParams(window.location.search);
            const modelIdFromUrl = urlParams.get('modelId');

            if (modelIdFromUrl) {
                showModelDetail(modelIdFromUrl);
            } else {
                showMainContent();
            }

            themeToggle.addEventListener('change', () => {
                const isChecked = themeToggle.checked;
                const newTheme = isChecked ? 'dark' : 'light';
                htmlElement.setAttribute('data-theme', newTheme);
                localStorage.setItem('theme', newTheme);
                console.log(`[Theme Toggle] Theme geändert zu: ${newTheme}.`);
                if (detailRenderer) {
                    const threeJsBgColor = getDaisyUICSSColorForThreeJS(newTheme);
                    detailRenderer.scene.background = new THREE.Color(threeJsBgColor);
                    detailRenderer.renderer.render(detailRenderer.scene, detailRenderer.camera);
                }
                rendererInstances.forEach(renderer => {
                    const threeJsBgColor = getDaisyUICSSColorForThreeJS(newTheme);
                    renderer.scene.background = new THREE.Color(threeJsBgColor);
                    renderer.renderer.render(renderer.scene, renderer.camera);
                });
            });

            document.getElementById('download-stl-button').addEventListener('click', () => {
                if (currentDetailModelData) {
                    handleDownload(currentDetailModelData.id, currentDetailModelData.title);
                } else {
                    showToast('Modellinformationen nicht geladen.', 'error');
                }
            });

            document.getElementById('open-voxelshaper-button').addEventListener('click', () => {
                if (currentDetailModelData) {
                    handleOpenOnVoxelShaper(currentDetailModelData.id);
                } else {
                    showToast('Modellinformationen nicht geladen.', 'error');
                }
            });

            // Removed postCommentButton.addEventListener('click', submitFeedback);
            // Replaced with submitAddCommentButton.addEventListener('click', submitFeedback);

            verifyButton.addEventListener('click', () => {
                if (currentDetailModelData) {
                    verifyModel(currentDetailModelData.id);
                }
            });
            revertVerifyButton.addEventListener('click', () => {
                if (currentDetailModelData) {
                    revertVerification(currentDetailModelData.id);
                }
            });
            deleteButton.addEventListener('click', () => {
                if (currentDetailModelData) {
                    showDeleteConfirmationModal(currentDetailModelData.id, currentDetailModelData.title);
                }
            });

            backToOverviewButton.addEventListener('click', () => {
                showMainContent();
            });

            profileButton.addEventListener('click', (e) => {
                e.preventDefault();
                showProfilePage();
            });

            backToMainFromProfileButton.addEventListener('click', () => {
                showMainContent();
            });

            deleteAccountButton.addEventListener('click', () => {
                lastFocusedElement = deleteAccountButton;
                deleteAccountConfirmModal.showModal();
            });

            confirmDeleteAccountButton.addEventListener('click', async () => {
                if (currentUser) {
                    try {
                        await deleteUser(currentUser);
                        showToast('Konto erfolgreich gelöscht! Sie wurden abgemeldet.', 'success');
                        deleteAccountConfirmModal.close();
                        showMainContent();
                        signOut(auth);
                    } catch (error) {
                        console.error("Fehler beim Löschen des Kontos:", error);
                        let errorMessage = "Fehler beim Löschen des Kontos.";
                        if (error.code === 'auth/requires-recent-login') {
                            errorMessage = 'Bitte melden Sie sich erneut an und versuchen Sie es dann erneut. Diese Aktion erfordert eine aktuelle Authentifizierung.';
                        }
                        showToast(errorMessage, 'error');
                        deleteAccountConfirmModal.close();
                    }
                }
            });
        });
    </script>
</body>
</html>
