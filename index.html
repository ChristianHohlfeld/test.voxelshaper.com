<!DOCTYPE html>
<html lang="de" data-theme="dark">
<head>
<meta charset="UTF-8">
<meta property="og:title" content="VoxelBlocks ‚Äì Create in 3D, Effortlessly" />
<meta property="og:description" content="A powerful, intuitive voxel-based 3D editor ‚Äì made for makers, artists, and coders." />
<meta property="og:image" content="https://voxelshaper.com/preview.png" />
<meta property="og:url" content="https://voxelshaper.com/" />
<meta property="og:type" content="website" />
<meta name="viewport"
      content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover">
<link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAAANl..."/>

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="VoxelBlocks ‚Äì Create in 3D, Effortlessly">
<meta name="twitter:description" content="A powerful, intuitive voxel-based 3D editor ‚Äì made for makers, artists, and coders.">
<meta name="twitter:image" content="https://voxelshaper.com/preview.png">
<title>VoxelBlocks ‚Äì Voxel Editor & 3D Print Exporter</title>

<link href="https://cdn.jsdelivr.net/npm/daisyui@4.7.2/dist/full.min.css" rel="stylesheet" type="text/css" />
<script src="https://cdn.tailwindcss.com"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

<style>
body {
    padding-top: env(safe-area-inset-top);
    padding-bottom: env(safe-area-inset-bottom);
    padding-left: env(safe-area-inset-left);
    padding-right: env(safe-area-inset-right);
    box-sizing: border-box;
    touch-action: auto;
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
}
#container, #voxelCanvas {
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
    -webkit-touch-callout: none;
    touch-action: none;
}
.touch-indicator { animation: pulse 0.5s; }
@keyframes pulse {
    0% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
    50% { transform: translate(-50%, -50%) scale(1.5); opacity: 0.2; }
    100% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
}
/* Styles for native color inputs (presets and hidden native picker) */
input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
input[type="color"]::-webkit-color-swatch { border: none; border-radius: 50%; }
input[type="color"]::-moz-color-swatch-wrapper { padding: 0; }
input[type="color"]::-moz-color-swatch { border: none; border-radius: 50%; }

/* Styles for the custom color swatch (the square representing current color) */
.custom-color-swatch {
    width: 40px;
    height: 40px;
    border-radius: 0.375rem; /* Rounded corners for consistency */
    border: 2px solid oklch(var(--bc)/0.2);
    cursor: pointer;
    transition: all 0.2s ease-in-out;
    display: inline-block;
    vertical-align: middle;
    box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
}
.custom-color-swatch:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
}
.custom-color-swatch:active {
    transform: scale(0.95);
}

/* Styles for color preset boxes (used in controls and custom palette) */
.color-preset-box::-webkit-color-swatch-wrapper { padding: 0; }
.color-preset-box::-webkit-color-swatch { border: none; border-radius: 0.375rem; }
.color-preset-box::-moz-color-swatch-wrapper { padding: 0; }
.color-preset-box::-moz-color-swatch { border: none; border-radius: 0.375rem; }

/* Custom Color Palette Modal */
#customColorPaletteModal .modal-box {
    padding: 1.5rem;
    max-width: 320px;
    background-color: var(--fallback-b2, oklch(var(--b2)/1));
}
#customColorPaletteModal .color-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
    gap: 0.5rem;
    margin-bottom: 1.5rem;
}
#customColorPaletteModal .color-grid .color-swatch-item {
    width: 40px;
    height: 40px;
    border-radius: 0.375rem;
    cursor: pointer;
    border: 2px solid transparent;
    transition: all 0.1s ease-in-out;
}
#customColorPaletteModal .color-grid .color-swatch-item:hover {
    transform: scale(1.1);
    border-color: oklch(var(--p)/0.5);
}
#customColorPaletteModal .color-grid .color-swatch-item.active {
    border-color: oklch(var(--p)/1);
    box-shadow: 0 0 0 2px oklch(var(--p)/0.5);
}


#toast-container {
    position: fixed;
    z-index: 50;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    padding: 1rem;
    pointer-events: none;
}

#toast-container.toast-end {
    bottom: 1rem;
    right: 1rem;
    align-items: flex-end;
}

@media (max-width: 768px) {
    #toast-container {
        top: 1rem;
        left: 50%;
        transform: translateX(-50%);
        width: calc(100% - 2rem);
        max-width: 300px;
        align-items: center;
    }
    #toast-container.toast-end {
        bottom: auto;
        right: auto;
    }
}

.toast .alert {
    pointer-events: auto;
    opacity: 0;
    transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
    transform: translateY(20px);
}

.toast .alert.show {
    opacity: 1;
    transform: translateY(0);
}

@media (max-width: 768px) {
    .toast .alert {
        padding: 0.5rem 0.75rem;
        font-size: 0.875rem;
    }
    .toast .alert svg {
        width: 1.25rem;
        height: 1.25rem;
    }
    .toast .alert strong {
        font-size: 0.9rem;
    }
    .toast .alert span {
        font-size: 0.8rem;
    }
    .toast .alert .close-btn {
        font-size: 1rem;
        padding: 0.25rem;
    }
}
.mobile-btn {
    width: 64px;
    height: 64px;
    font-size: 2rem;
    border-radius: 50%;
    background-color: var(--fallback-b3, oklch(var(--b3)/1));
    color: var(--fallback-bc, oklch(var(--bc)/1));
    border: 2px solid var(--fallback-bc, oklch(var(--bc)/1));
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
    transition: background-color 0.2s, transform 0.2s;
}

.mobile-btn:hover {
    background-color: oklch(var(--bc)/0.2);
}

.mobile-btn:active {
    transform: scale(0.95);
}

#mobile-controls {
    gap: 1rem;
}
</style>
</head>
<body class="bg-base-100 min-h-screen text-base-content flex flex-col">
<button id="menuToggle" aria-label="Men√º umschalten" class="fixed top-4 right-4 z-[1500] w-10 h-10 text-xl leading-10 text-center bg-base-300 text-base-content border-none rounded-lg cursor-pointer shadow-md hover:bg-base-content/20 lg:hidden">‚ò∞</button>

<div id="controls" class="flex flex-wrap items-center justify-center gap-3 p-4 bg-base-200 border-b border-base-content/20 hidden md:flex">
    <label for="grid-size-slider" class="text-base-content">Gittergr√∂√üe:</label>
    <input type="range" id="grid-size-slider" min="5" max="180" value="10" aria-label="Gittergr√∂√üe anpassen" class="range range-xs w-36">
    <span id="grid-size-display" class="font-bold text-primary">10√ó10√ó10</span>
    
    <label for="color-picker-label" class="text-base-content">Farbe:</label>
    <!-- Custom Color Swatch / Button to open custom palette -->
    <div id="color-picker-swatch" class="custom-color-swatch" style="background-color: #ffffff;" aria-label="Aktuelle Farbe w√§hlen"></div>
    
    <!-- Original preset color inputs, now potentially part of the custom palette -->
    <input type="color" id="color-preset-1" class="color-preset-box w-10 h-10 rounded-md border-2 border-base-content/20 cursor-pointer transition-all duration-200 hover:scale-110" value="#E4002B" aria-label="Voreingestellte Farbe 1">
    <input type="color" id="color-preset-2" class="color-preset-box w-10 h-10 rounded-md border-2 border-base-content/20 cursor-pointer transition-all duration-200 hover:scale-110" value="#00A040" aria-label="Voreingestellte Farbe 2">
    <input type="color" id="color-preset-3" class="color-preset-box w-10 h-10 rounded-md border-2 border-base-content/20 cursor-pointer flex items-center justify-center shadow-lg hover:bg-base-content/20" value="#0057B8" aria-label="Voreingestellte Farbe 3">

    <button id="modeToggle" aria-label="Modus wechseln" class="btn btn-sm btn-neutral">Modus wechseln</button><span id="current-mode" class="font-bold text-success min-w-40 text-center">Modus: Hinzuf√ºgen</span>
    <button id="blockStyleToggleBtn" aria-label="Block-Stil wechseln" class="btn btn-sm btn-neutral">Block-Stil: Einfach</button>
    <button id="clearBtn" aria-label="Alles l√∂schen" class="btn btn-sm btn-neutral">Alles l√∂schen</button>
    <button id="fillLevelBtn" aria-label="Ebene f√ºllen" class="btn btn-sm btn-neutral">Ebene f√ºllen</button>
    <button id="saveBtn" aria-label="Projekt speichern" aria-describedby="save-description" class="btn btn-sm btn-neutral">Projekt speichern</button>
    <div id="save-description" class="sr-only">Speichert das aktuelle Projekt als JSON-Datei</div>
    <button id="loadBtn" aria-label="Projekt laden" class="btn btn-sm btn-neutral">Projekt laden</button>
    <button id="exportStlBtn" aria-label="STL Export" class="btn btn-sm btn-neutral">STL Export</button>
    <button id="undoBtn" aria-label="R√ºckg√§ngig machen" class="btn btn-sm btn-neutral">R√ºckg√§ngig</button>
    <button id="redoBtn" aria-label="Wiederherstellen" class="btn btn-sm btn-neutral">Wiederherstellen</button>
    <label for="fly-speed-slider" class="text-base-content">Fluggeschwindigkeit:</label>
    <input type="range" id="fly-speed-slider" min="0.01" max="1.0" step="0.01" value="0.1" aria-label="Fluggeschwindigkeit anpassen" class="range range-xs w-36">
    <span id="fly-speed-display" class="font-bold text-primary">0.10</span>

    <button id="resetCameraBtn" aria-label="Kamera zur√ºcksetzen" class="btn btn-sm btn-neutral">Zur Szene zur√ºckkehren</button>
    
    <button id="loadImageTemplateBtn" aria-label="Bild als Vorlage laden" class="btn btn-sm btn-neutral">Bild als Vorlage laden</button>
    <button id="removeImageTemplateBtn" class="btn btn-sm btn-neutral hidden" aria-label="Bildvorlage entfernen">Bildvorlage entfernen</button>
    <input type="file" id="imageFileInput" accept="image/*" class="hidden">

    <button id="toggleMeshViewBtn" aria-label="Mesh-Ansicht umschalten" class="btn btn-sm btn-neutral">Mesh-Ansicht umschalten</button>

    <button id="loginLogoutBtn" aria-label="Anmelden oder Abmelden" class="btn btn-sm btn-info">Anmelden</button>
    <span id="userIdDisplay" class="font-bold text-info ml-2 mr-2 whitespace-nowrap overflow-hidden text-ellipsis max-w-xs flex items-center gap-1"></span>
    <button id="uploadToHubBtn" aria-label="Auf Hub hochladen" class="btn btn-sm btn-warning hidden">Auf Hub hochladen</button>
    <button id="goToHubBtn" aria-label="Zum VoxelBlocks Hub wechseln" class="btn btn-sm btn-secondary">Zum Hub</button>
</div>

<div id="container" class="flex-1 relative border-2 border-transparent box-border overflow-hidden touch-none">
    <canvas id="voxelCanvas" class="w-full h-full block box-border"></canvas>
    <div id="touch-indicator" class="touch-indicator absolute w-10 h-10 rounded-full bg-blue-500/30 transform -translate-x-1/2 -translate-y-1/2 pointer-events-none hidden z-[2000]"></div>
    <input type="file" id="fileInput" accept=".json" class="hidden">
</div>

<dialog id="clearConfirmationModal" class="modal">
    <div class="modal-box bg-base-200 text-base-content p-8 text-center shadow-xl max-w-md">
        <h3 class="font-bold text-lg text-primary mb-4">Projekt l√∂schen</h3>
        <p class="py-4">M√∂chten Sie das aktuelle Projekt speichern, bevor Sie alle Voxel l√∂schen?</p>
        <div class="modal-buttons flex justify-around gap-4 mt-6">
            <button id="saveAndClearBtn" class="confirm-save btn btn-success flex-1">Speichern & L√∂schen</button>
            <button id="clearWithoutSaveBtn" class="confirm-no-save btn btn-error flex-1">Ohne Speichern l√∂schen</button>
            <button id="cancelClearBtn" class="cancel btn btn-ghost flex-1">Abbrechen</button>
        </div>
    </div>
</dialog>

<dialog id="uploadProjectModal" class="modal">
    <div class="upload-modal-content modal-box bg-base-200 text-base-content p-8 shadow-xl max-w-xl w-11/12 text-left">
        <h3 class="font-bold text-lg text-primary text-center mb-6">Projekt auf VoxelBlocks Hub hochladen</h3>
        <label for="uploadTitle" class="label block mb-2 font-bold">Titel:</label>
        <input type="text" id="uploadTitle" placeholder="Ein aussagekr√§ftiger Titel f√ºr Ihr Projekt" maxlength="100" class="input input-bordered w-full bg-base-300 border-base-content/20 mb-4">

        <label for="uploadDescription" class="label block mb-2 font-bold">Beschreibung:</label>
        <textarea id="uploadDescription" placeholder="Beschreiben Sie Ihr Projekt kurz" maxlength="500" class="textarea textarea-bordered w-full bg-base-300 border-base-content/20 h-24 mb-4 resize-y"></textarea>

        <label for="uploadCategory" class="label block mb-2 font-bold">Kategorie:</label>
        <select id="uploadCategory" class="select select-bordered w-full bg-base-300 border-base-content/20 mb-4" required>
            <option value="" disabled selected>Kategorie ausw√§hlen</option>
        </select>

        <label for="uploadTags" class="label block mb-2 font-bold">Tags (Komma-getrennt):</label>
        <input type="text" id="uploadTags" placeholder="z.B. Haus, Baum, Auto, Geb√§ude" maxlength="100" class="input input-bordered w-full bg-base-300 border-base-content/20 mb-4">

        <label class="label block mb-2 font-bold">Sichtbarkeit:</label>
        <div class="radio-group flex gap-4 mb-4">
            <label class="flex items-center font-normal">
                <input type="radio" name="uploadVisibility" value="public" checked class="radio radio-primary mr-2"> √ñffentlich
            </label>
            <label class="flex items-center font-normal">
                <input type="radio" name="uploadVisibility" value="private" class="radio radio-primary mr-2"> Privat
            </label>
        </div>

        <div class="upload-modal-buttons flex justify-around gap-4 mt-6">
            <button id="uploadConfirmBtn" class="upload-confirm btn btn-success flex-1">Hochladen</button>
            <button id="uploadCancelBtn" class="upload-cancel btn btn-ghost flex-1">Abbrechen</button>
        </div>
    </div>
</dialog>

<dialog id="exportStlModal" class="modal">
    <div class="modal-box bg-base-200 text-base-content p-8 text-left shadow-xl max-w-md">
        <h3 class="font-bold text-lg text-primary mb-4">STL Export Optionen</h3>
        <p class="mb-4">Bitte w√§hlen Sie die Einheit f√ºr den Export. Jedes Voxel wird als 1x1x1 Einheit exportiert.</p>
        
        <div class="form-control mb-4">
            <label class="label cursor-pointer">
                <span class="label-text">1 Voxel = 1 mm</span>
                <input type="radio" name="export-unit" class="radio radio-primary" value="mm" checked />
            </label>
        </div>
        <div class="form-control mb-6">
            <label class="label cursor-pointer">
                <span class="label-text">1 Voxel = 1 cm</span>
                <input type="radio" name="export-unit" class="radio radio-primary" value="cm" />
            </label>
        </div>

        <div class="modal-action">
            <button id="confirmStlExportBtn" class="btn btn-success">Exportieren</button>
            <button id="cancelStlExportBtn" class="btn btn-ghost">Abbrechen</button>
        </div>
    </div>
</dialog>

<dialog id="authModal" class="modal">
    <div class="auth-modal-content modal-box bg-base-200 text-base-content p-8 shadow-xl max-w-lg w-11/12 text-center">
        <h3 class="font-bold text-lg text-primary mb-6">Anmelden bei VoxelBlocks Hub</h3>
        <div class="provider-buttons flex flex-col gap-3">
            <button id="signInGoogleBtn" class="google btn btn-error text-white">
                <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" alt="Google Icon" class="w-5 h-5">
                Mit Google anmelden
            </button>
            <button id="signInGithubBtn" class="github btn bg-neutral text-neutral-content hover:bg-neutral-focus">
                <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/github.svg" alt="GitHub Icon" class="w-5 h-5">
                Mit GitHub anmelden
            </button>
            <button id="showEmailLoginFormBtn" class="email btn btn-info">
                Mit E-Mail anmelden
            </button>
        </div>

        <div id="emailLoginForm" class="email-login-form mt-6 pt-6 border-t border-base-content/20 hidden">
            <form id="emailAuthForm">
                <input type="email" id="emailInput" placeholder="E-Mail" autocomplete="email" class="input input-bordered w-full bg-base-300 border-base-content/20 mb-3">
                <input type="password" id="passwordInput" placeholder="Passwort" autocomplete="current-password" class="input input-bordered w-full bg-base-300 border-base-content/20 mb-3">
                <button type="submit" id="emailSignInBtn" class="btn btn-primary w-full">Anmelden</button>
                <button type="button" id="emailSignUpBtn" class="btn btn-secondary w-full mt-2">Registrieren</button>
            </form>
        </div>

        <div class="close-button-container mt-6">
            <button id="authModalCloseBtn" class="btn btn-ghost">Schlie√üen</button>
        </div>
    </div>
</dialog>

<!-- Custom Color Palette Modal -->
<dialog id="customColorPaletteModal" class="modal">
    <div class="modal-box bg-base-200 text-base-content p-6 shadow-xl max-w-xs">
        <h3 class="font-bold text-lg text-primary mb-4 text-center">Farbe w√§hlen</h3>
        <div class="color-grid">
            <!-- Common Colors -->
            <div class="color-swatch-item" style="background-color: #F44336;" data-color="#F44336"></div>
            <div class="color-swatch-item" style="background-color: #E91E63;" data-color="#E91E63"></div>
            <div class="color-swatch-item" style="background-color: #9C27B0;" data-color="#9C27B0"></div>
            <div class="color-swatch-item" style="background-color: #673AB7;" data-color="#673AB7"></div>
            <div class="color-swatch-item" style="background-color: #3F51B5;" data-color="#3F51B5"></div>
            <div class="color-swatch-item" style="background-color: #2196F3;" data-color="#2196F3"></div>
            <div class="color-swatch-item" style="background-color: #03A9F4;" data-color="#03A9F4"></div>
            <div class="color-swatch-item" style="background-color: #00BCD4;" data-color="#00BCD4"></div>
            <div class="color-swatch-item" style="background-color: #009688;" data-color="#009688"></div>
            <div class="color-swatch-item" style="background-color: #4CAF50;" data-color="#4CAF50"></div>
            <div class="color-swatch-item" style="background-color: #8BC34A;" data-color="#8BC34A"></div>
            <div class="color-swatch-item" style="background-color: #CDDC39;" data-color="#CDDC39"></div>
            <div class="color-swatch-item" style="background-color: #FFEB3B;" data-color="#FFEB3B"></div>
            <div class="color-swatch-item" style="background-color: #FFC107;" data-color="#FFC107"></div>
            <div class="color-swatch-item" style="background-color: #FF9800;" data-color="#FF9800"></div>
            <div class="color-swatch-item" style="background-color: #FF5722;" data-color="#FF5722"></div>
            <div class="color-swatch-item" style="background-color: #795548;" data-color="#795548"></div>
            <div class="color-swatch-item" style="background-color: #9E9E9E;" data-color="#9E9E9E"></div>
            <div class="color-swatch-item" style="background-color: #607D8B;" data-color="#607D8B"></div>
            <div class="color-swatch-item" style="background-color: #000000;" data-color="#000000"></div>
            <div class="color-swatch-item" style="background-color: #FFFFFF;" data-color="#FFFFFF"></div>
            
            <!-- Preset Colors - now integrated into the grid -->
            <input type="color" id="palette-color-preset-1" class="color-preset-box color-swatch-item" value="#E4002B" aria-label="Voreingestellte Farbe 1">
            <input type="color" id="palette-color-preset-2" class="color-preset-box color-swatch-item" value="#00A040" aria-label="Voreingestellte Farbe 2">
            <input type="color" id="palette-color-preset-3" class="color-preset-box color-swatch-item" value="#0057B8" aria-label="Voreingestellte Farbe 3">
        </div>
        <input type="color" id="hidden-native-color-picker" class="hidden" value="#ffffff">
        <button id="moreColorsBtn" class="btn btn-neutral w-full mb-4">Weitere Farben...</button>
        <button id="closeColorPaletteModalBtn" class="btn btn-ghost w-full">Schlie√üen</button>
    </div>
</dialog>

<div id="toast-container" class="toast toast-end z-50"></div>

<div id="mobile-controls" class="hidden md:hidden flex-col gap-3 fixed bottom-4 right-4 z-[1000]">
    <button class="mobile-btn" id="mobile-undo" aria-label="R√ºckg√§ngig machen">‚Ü∫</button>
    <button class="mobile-btn" id="mobile-redo" aria-label="Wiederholen">‚Üª</button>
    <button class="mobile-btn" id="mobile-save" aria-label="Speichern">üíæ</button>
    <button class="mobile-btn" id="mobile-camera" aria-label="Kamera zur√ºcksetzen">üì∑</button>

    <button class="mobile-btn" id="mobile-mode-toggle" aria-label="Modus wechseln">
        <span id="mobile-mode-icon">‚ûï</span>
    </button>

    <button class="mobile-btn" id="mobile-color-picker-btn" aria-label="Farbe ausw√§hlen">üé®</button>
    <input type="color" id="mobile-color-input" value="#ffffff" class="hidden w-0 h-0 opacity-0 absolute pointer-events-none">
    
    <button class="mobile-btn" id="mobile-level-up" aria-label="Ebene erh√∂hen">‚¨ÜÔ∏è</button>
    <button class="mobile-btn" id="mobile-level-down" aria-label="Ebene verringern">‚¨áÔ∏è</button>
    
    <button class="mobile-btn" id="mobile-login-logout" aria-label="Anmelden oder Abmelden">üîë</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>


<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import {
        getAuth,
        setPersistence,
        browserLocalPersistence,
        signInWithCustomToken,
        onAuthStateChanged,
        signOut,
        GoogleAuthProvider,
        GithubAuthProvider,
        signInWithPopup,
        createUserWithEmailAndPassword,
        signInWithEmailAndPassword
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import {
        getFirestore,
        doc,
        getDoc,
        collection,
        addDoc,
        serverTimestamp
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    window.firebase = {
        initializeApp,
        getAuth,
        signInWithCustomToken,
        onAuthStateChanged,
        setPersistence,
        browserLocalPersistence,
        signOut,
        GoogleAuthProvider,
        GithubAuthProvider,
        signInWithPopup,
        createUserWithEmailAndPassword,
        signInWithEmailAndPassword,
        getFirestore,
        doc,
        getDoc,
        collection,
        addDoc,
        serverTimestamp
    };

    const FIREBASE_API_KEY = "AIzaSyB9-mpyAu9W6oiVtB0fYG8E6YFvTAsjtAA"; 

    const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {
        apiKey: FIREBASE_API_KEY,
        authDomain: "voxelshaper.firebaseapp.com",
        projectId: "voxelshaper",
        storageBucket: "voxelshaper.firebasestorage.app", 
        messagingSenderId: "1053689247573",
        appId: "1:1053689247573:web:f7960c7f8c2e8849e8e1dc",
        measurementId: "G-QJCNKZ5DR"
    };
    window.firebaseConfig = firebaseConfig;
</script>

<script>
const VS = 1, HALF = VS * 0.5;
const CHUNK_SIZE = 16;
const VOX_BITS = 10;
const VOX_MASK = (1 << VOX_BITS) - 1;
const SHIFT_X  = VOX_BITS * 2;
const SHIFT_Y  = VOX_BITS;

function key(x, y, z) { return ((x << SHIFT_X) | (y << SHIFT_Y) | z) >>> 0; }
function parseKey(k) { return [(k >>> SHIFT_X) & VOX_MASK, (k >>> SHIFT_Y) & VOX_MASK, k & VOX_MASK]; }

const VOXEL_DRAG_THRESHOLD = 1;
const PINCH_ZOOM_MULT = 40;
const TAP_DIST_TH = 10;
const MOVE_PX = 10;
const DT_MS = 250;

const ROTATE_SPEED_TOUCH_MOBILE = 0.008;
const PAN_SPEED_TOUCH_MOBILE = 0.2;
const PINCH_ZOOM_MULT_MOBILE = 80;

const ROTATE_SPEED_TOUCH_DESKTOP = 0.004;
const PAN_SPEED_TOUCH_DESKTOP = 0.1;
const PINCH_ZOOM_MULT_DESKTOP = 40;


let activePointers = new Map();
let gestureState = { type: 'none', startDist: 0, startMid: { x: 0, y: 0 }, lastMid: { x: 0, y: 0 }, lastDist: 0, startTime: 0, initialPointerCount: 0 };
let tapCandidate = null;
let doubleTapDragActive = false;
let touchIndicator;

let scene, cam, ren, gridHelper, boxHelper;
let rotSpeed = 0.004;
let euler;
const voxels = new Map();
const chunks = new Map();

let cvs, containerDiv;
let activeDrawingLevel = { x: 0, y: 0, z: 0 };
let currentDrawingAxis = 'y';

let currentColor = localStorage.getItem('voxelEditorColor') || '#ffffff';
let moveSpeed = parseFloat(localStorage.getItem('voxelEditorFlySpeed') || '0.1');
let GRID = parseInt(localStorage.getItem('voxelEditorGridSize') || '10');

activeDrawingLevel.x = Number(localStorage.getItem('voxelEditorActiveDrawingLevelX') || '0');
if (!Number.isFinite(activeDrawingLevel.x)) activeDrawingLevel.x = 0;
activeDrawingLevel.x = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.x)));

activeDrawingLevel.y = Number(localStorage.getItem('voxelEditorActiveDrawingLevelY') || '0');
if (!Number.isFinite(activeDrawingLevel.y)) activeDrawingLevel.y = 0;
activeDrawingLevel.y = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.y)));

activeDrawingLevel.z = Number(localStorage.getItem('voxelEditorActiveDrawingLevelZ') || '0');
if (!Number.isFinite(activeDrawingLevel.z)) activeDrawingLevel.z = 0;
activeDrawingLevel.z = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.z)));

currentDrawingAxis = localStorage.getItem('voxelEditorCurrentDrawingAxis') || 'y';

const presetColors = [
    localStorage.getItem('voxelPresetColor1') || '#E4002B',
    localStorage.getItem('voxelPresetColor2') || '#00A040',
    localStorage.getItem('voxelPresetColor3') || '#0057B8'
];
let activePresetIndex = -1;
let presetBoxes = []; // These are the original preset input[type="color"] elements
let palettePresetBoxes = []; // These are the the preset input[type="color"] elements inside the custom palette modal

let mainDirectionalLight, fillDirectionalLight, hemisphereLight;
let isShiftDragging = false;
let isControlDragging = false;
let isPointerLocked = false;
let lastActionVoxelCoords = null;
let initialClickPos = null;
let initialTargetVoxelCoords = null;
let isDragging = false;
let firstMoveAfterLock = true;
let mouseMovementX = 0;
let mouseMovementY = 0;

const dummy = new THREE.Object3D();
let previewVoxelMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5, depthTest: false });
previewVoxelMaterial.polygonOffset = true;
previewVoxelMaterial.polygonOffsetFactor = -1;
let previewVoxelMesh;

const Modes = {
    ADD: 'Hinzuf√ºgen',
    DELETE: 'L√∂schen',
    DRAW: 'Zeichnen',
};

const ModeIcons = {
    ADD: '‚ûï',
    DELETE: '‚ûñ',
    DRAW: 'üñåÔ∏è'
};

const AxisIcons = {
    x: 'fas fa-arrows-alt-h',
    y: 'fas fa-arrows-alt-v',
    z: 'fas fa-arrows-alt'
};

let currentMode = Modes.ADD;

let history = [];
let historyPointer = -1;
const MAX_HISTORY_SIZE = 100;

let currentStrokeVoxels = new Map();
let voxelsAtDragStart = null;

let previewLineInstancedMesh;
const maxPreviewInstances = 180 * 3;
let previewLineVoxels = [];

let templateImageMesh = null;
let templateImageData = null;

let isMobile = window.matchMedia('(max-width: 768px)').matches;

let initialDragVoxelWorldPos = null;
let dragAxisLock = null;
let initialDragVoxelCoords = null;
let initialDragYLevel = null;

let projectTitle = '';
let projectDescription = '';
let projectCategory = 'Allgemein';
let projectTags = [];
let projectRemixOf = '';
let projectSourceJsonUrl = '';
let projectVisibility = 'public';

const predefinedCategories = ["Spielzeug", "Dekoration", "Funktional", "Kunst", "Allgemein", "Charaktere", "Fahrzeuge", "Natur", "Architektur", "Abstrakt"];

// NEW: Block style management
let currentBlockStyle = localStorage.getItem('voxelEditorBlockStyle') || 'simple'; // 'simple' or 'detailed'
let defaultVoxelGeometry; // This will be set based on currentBlockStyle
let ACTUAL_BRICK_HEIGHT; // Actual height of the current block style

/**
 * Creates a simple 1x1x1 cube geometry.
 * @param {number} unitSize - The desired side length of the cube.
 * @returns {THREE.BufferGeometry} A BufferGeometry representing a simple cube.
 */
function createSimpleCubeGeometry(unitSize) {
    const geometry = new THREE.BoxGeometry(unitSize, unitSize, unitSize);
    geometry.computeBoundingBox();
    const minY = geometry.boundingBox.min.y;
    geometry.translate(0, -minY, 0); // Ensure base is at Y=0
    return geometry;
}

/**
 * Erstellt eine Geometrie f√ºr einen Baustein mit einem quadratischen Noppen oben
 * und einer passenden quadratischen Aussparung unten.
 * Die Geometrie wird so erstellt, dass ihre K√ñRPERH√ñTE (ohne Noppen) exakt 'unitSize' betr√§gt,
 * und die Breite und Tiefe des K√∂rpers ebenfalls 'unitSize' betragen.
 * Die Noppen ragen √ºber diese H√∂he hinaus.
 *
 * @param {number} unitSize - Die gew√ºnschte Seitenl√§nge des Bausteink√∂rpers (z.B. VS).
 * @returns {THREE.BufferGeometry} Eine zusammengef√ºhrte BufferGeometry, die den Baustein darstellt.
 */
function createBrickGeometry(unitSize) {
    const geometries = [];
    const printTolerance_mm = 0.05;

    // Standard brickdimensions in mm
    const _brick_width_mm = 8.0; // Width and Depth of a 1x1 brick
    const _brick_body_height_mm = 9.6; // Body height (3 plates)
    const _stud_height_mm = 4.0; // MODIFIED: Increased stud height for better stacking
    const _stud_diameter_mm = 4.8;
    const _outer_wall_thickness_mm = 1.6;

    // Calculate scaling factors for each dimension to make the BODY unitSize x unitSize x unitSize
    const scaleX = unitSize / _brick_width_mm;
    const scaleY = unitSize / _brick_body_height_mm;
    const scaleZ = unitSize / _brick_width_mm;

    // Apply scaling factors to nominal dimensions
    const scaled_brick_width = _brick_width_mm * scaleX; // This will now be unitSize
    const scaled_brick_body_height = _brick_body_height_mm * scaleY; // This will now be unitSize
    const scaled_stud_height = _stud_height_mm * scaleY;
    const scaled_stud_diameter = _stud_diameter_mm * scaleX;
    const scaled_outer_wall_thickness = _outer_wall_thickness_mm * scaleX;
    const scaled_print_tolerance = printTolerance_mm * scaleX;

    const halfScaledWidth = scaled_brick_width / 2;
    const innerSpan = scaled_brick_width - 2 * scaled_outer_wall_thickness; // Inner dimension of the hollow brick

    // 1. Outer Walls (main body)
    const outerWallHeight = scaled_brick_body_height;
    const outerWallYPos = outerWallHeight / 2;

    // Front and back walls
    geometries.push(new THREE.BoxGeometry(innerSpan, outerWallHeight, scaled_outer_wall_thickness).translate(0, outerWallYPos, halfScaledWidth - scaled_outer_wall_thickness / 2));
    geometries.push(new THREE.BoxGeometry(innerSpan, outerWallHeight, scaled_outer_wall_thickness).translate(0, outerWallYPos, -halfScaledWidth + scaled_outer_wall_thickness / 2));

    // Left and right walls (cover full width to include corners)
    geometries.push(new THREE.BoxGeometry(scaled_outer_wall_thickness, outerWallHeight, scaled_brick_width).translate(-halfScaledWidth + scaled_outer_wall_thickness / 2, outerWallYPos, 0));
    geometries.push(new THREE.BoxGeometry(scaled_outer_wall_thickness, outerWallHeight, scaled_brick_width).translate(halfScaledWidth - scaled_outer_wall_thickness / 2, outerWallYPos, 0));

    // 3. Square Stud (Top)
    const studYPos = (scaled_brick_body_height + scaled_stud_height / 2) - scaled_stud_height /2;
    const squareStudGeo = new THREE.BoxGeometry(scaled_stud_diameter, scaled_stud_height, scaled_stud_diameter);
    squareStudGeo.translate(0, studYPos, 0);
    geometries.push(squareStudGeo);

    // 4. Anti-Stud Recess (Bottom) and Inner Support
    // The anti-stud is a square hole. We need to define the material *around* this hole.
    // Define the dimensions of the square hole for the stud
    let antiStudHoleSide = scaled_stud_diameter + 2 * scaled_print_tolerance; // Slightly larger than stud for fit

    // Calculate the dimensions of the four "pillars" that define the square anti-stud hole.
    // The total inner width is `innerSpan`.
    // The hole width is `antiStudHoleSide`.
    // The remaining width for the two pillars on one side is `innerSpan - antiStudHoleSide`.
    // So, each pillar's side will be `(innerSpan - antiStudHoleSide) / 2`.
    let pillarSide = (innerSpan - antiStudHoleSide) / 2;

    // Ensure pillarSide is not negative or too small due to floating point inaccuracies or very large tolerances
    const minPillarThickness = 0.05 * scaleX; // Minimum thickness for printability
    if (pillarSide < minPillarThickness) {
        // If calculated pillarSide is too small, we will use minPillarThickness for the pillars.
        // We DO NOT adjust antiStudHoleSide here, as that would make the stud not fit.
        pillarSide = minPillarThickness; // Force pillarSide to minimum thickness
    }

    const halfAntiStudHoleSide = antiStudHoleSide / 2;
    const halfPillarSide = pillarSide / 2;

    const xPosPillar = halfAntiStudHoleSide + halfPillarSide;
    const zPosPillar = halfAntiStudHoleSide + halfPillarSide;

    const internalStructureYPos = scaled_brick_body_height / 2; // Y-position for all internal elements

    // Four corner pillars for the anti-stud recess
    geometries.push(new THREE.BoxGeometry(pillarSide, scaled_brick_body_height, pillarSide).translate(xPosPillar, internalStructureYPos, zPosPillar));
    geometries.push(new THREE.BoxGeometry(pillarSide, scaled_brick_body_height, pillarSide).translate(-xPosPillar, internalStructureYPos, zPosPillar));
    geometries.push(new THREE.BoxGeometry(pillarSide, scaled_brick_body_height, pillarSide).translate(xPosPillar, internalStructureYPos, -zPosPillar));
    geometries.push(new THREE.BoxGeometry(pillarSide, scaled_brick_body_height, pillarSide).translate(-xPosPillar, internalStructureYPos, -zPosPillar));

    // Central cross support - this is the infill inside the anti-stud hole.
    // It should be positioned within the `antiStudHoleSide` square.
    // The arms should extend to almost the edge of the anti-stud hole, leaving a small gap for the stud.
    const crossThickness = scaled_outer_wall_thickness / 2; // Thinner for internal support
    const crossWidth = antiStudHoleSide - 2 * scaled_print_tolerance; // Slightly smaller than the hole for fit
    const crossHeight = scaled_brick_body_height / 2; // Same height as the brick body / 2
    const crossDepth = crossThickness; // Use crossThickness for depth of arms

    // Horizontal part of the inner cross
    geometries.push(new THREE.BoxGeometry(crossWidth, crossHeight, crossDepth).translate(0, internalStructureYPos, 0));
    // Vertical part of the inner cross
    geometries.push(new THREE.BoxGeometry(crossDepth, crossHeight, crossWidth).translate(0, internalStructureYPos, 0));


    const mergedGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries(geometries);
    mergedGeometry.computeVertexNormals();

    // Ensure the very bottom of the brick (minY) is at Y=0
    mergedGeometry.computeBoundingBox();
    const minY = mergedGeometry.boundingBox.min.y;
    mergedGeometry.translate(0, -minY, 0);

    return mergedGeometry;
}


// Erstelle ein einziges, geteiltes Material f√ºr alle Voxel
const standardVoxelMaterial = new THREE.MeshStandardMaterial({
    roughness: 0.7,
    metalness: 0.1
});

const wireframeVoxelMaterial = new THREE.MeshBasicMaterial({
    color: 0xffffff, // Wei√üe Farbe f√ºr das Drahtgitter
    wireframe: true
});

// Neu: Einfache Box-Geometrie f√ºr Raycasting/Kollisionserkennung
// Diese Geometrie wird f√ºr die Kollisionserkennung verwendet und ist immer ein einfacher W√ºrfel
const collisionVoxelGeometry = new THREE.BoxGeometry(VS, VS, VS);
// Neu: Unsichtbares Material f√ºr Kollisions-Meshes
const invisibleMaterial = new THREE.MeshBasicMaterial({ visible: false });

let isMeshViewMode = false; // Neuer Status f√ºr den Mesh-Ansichts-Umschalter

function getChunkCoords(gx, gy, gz) { return { cx: Math.floor(gx / CHUNK_SIZE), cy: Math.floor(gy / CHUNK_SIZE), cz: Math.floor(gz / CHUNK_SIZE) }; }
function getChunkKey(cx, cy, cz) { return `${cx},${cy},${cz}`; }

class VoxelChunk {
    constructor(chunkX, chunkY, chunkZ, chunkSize, scene) {
        this.chunkX = chunkX; this.chunkY = chunkY; this.chunkZ = chunkZ; this.scene = scene; this.chunkSize = chunkSize;
        this.offsetX = chunkX * chunkSize * VS; this.offsetY = chunkY * chunkSize * VS; this.offsetZ = chunkZ * chunkSize * VS;
        this.voxels = new Map(); this.globalToLocalInstanceIdMap = new Map();
        const maxInstancesInChunk = chunkSize * chunkSize * chunkSize;
        
        // Sichtbares Mesh mit detaillierter Geometrie
        this.instancedMesh = new THREE.InstancedMesh(defaultVoxelGeometry, isMeshViewMode ? wireframeVoxelMaterial : standardVoxelMaterial, maxInstancesInChunk);
        this.instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(maxInstancesInChunk * 3), 3);
        this.instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        this.instancedMesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
        this.instancedMesh.castShadow = true; this.instancedMesh.receiveShadow = true; this.instancedMesh.count = 0;
        this.instancedMesh.position.set(this.offsetX, this.offsetY, this.offsetZ);
        this.scene.add(this.instancedMesh);

        // Unsichtbares Mesh f√ºr die Kollisionserkennung (einfacher W√ºrfel)
        this.collisionMesh = new THREE.InstancedMesh(collisionVoxelGeometry, invisibleMaterial, maxInstancesInChunk);
        this.collisionMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        this.collisionMesh.count = 0; // Wird mit instancedMesh.count synchron gehalten
        this.collisionMesh.position.set(this.offsetX, this.offsetY, this.offsetZ);
        this.scene.add(this.collisionMesh);

        this.boundingBox = new THREE.Box3(
            new THREE.Vector3(this.offsetX, this.offsetY, this.offsetZ),
            new THREE.Vector3(this.offsetX + chunkSize * VS, this.offsetY + chunkSize * VS, this.offsetZ + chunkSize * VS)
        );
    }
    getLocalKey(gx, gy, gz) { return key(gx % this.chunkSize, gy % this.chunkSize, gz % this.chunkSize); }
    addVoxel(gx, gy, gz, colorHex) {
        const lKey = this.getLocalKey(gx, gy, gz); const gKey = key(gx, gy, gz);
        if (this.voxels.has(lKey)) {
            const instanceId = this.voxels.get(lKey).instanceId;
            this.voxels.set(lKey, { color: colorHex, instanceId }); this.updateInstanceColor(instanceId, colorHex);
        } else {
            const instanceId = this.instancedMesh.count++;
            this.voxels.set(lKey, { color: colorHex, instanceId }); this.globalToLocalInstanceIdMap.set(gKey, instanceId);
            // The brick geometry has its base (bottom of anti-studs) at Y=0 in its local coordinates.
            // To place its base at the grid's Y-coordinate (gy * VS), its center should be at (gy * VS + ACTUAL_BRICK_HEIGHT / 2).
            // However, setMatrixAt applies the matrix to the local origin (0,0,0) of the geometry.
            // Since the geometry's local Y=0 is its base, we simply need to set the dummy's Y position to gy * VS.
            dummy.position.set((gx % this.chunkSize) * VS + HALF, (gy % this.chunkSize) * VS, (gz % this.chunkSize) * VS + HALF);
            dummy.updateMatrix(); 
            this.instancedMesh.setMatrixAt(instanceId, dummy.matrix);

            // Position for the INVISIBLE collision mesh (simple cube):
            // It must be centered within the grid cell (gx, gy, gz)
            dummy.position.set((gx % this.chunkSize) * VS + HALF, (gy % this.chunkSize) * VS + HALF, (gz % this.chunkSize) * VS + HALF);
            dummy.updateMatrix(); 
            this.collisionMesh.setMatrixAt(instanceId, dummy.matrix); // Aktualisiere Kollisions-Mesh
            this.collisionMesh.count = this.instancedMesh.count; // Halte Z√§hler synchron

            this.updateInstanceColor(instanceId, colorHex);
            this.instancedMesh.instanceMatrix.needsUpdate = true; this.instancedMesh.instanceColor.needsUpdate = true;
            this.collisionMesh.instanceMatrix.needsUpdate = true;
        }
    }
    removeVoxel(gx, gy, gz) {
        const lKey = this.getLocalKey(gx, gy, gz); const gKey = key(gx, gy, gz);
        if (!this.voxels.has(lKey)) return;
        const { instanceId: removedId } = this.voxels.get(lKey);
        this.voxels.delete(lKey); this.globalToLocalInstanceIdMap.delete(gKey);
        const lastId = this.instancedMesh.count - 1;
        if (removedId !== lastId) {
            let lastVoxelLKey = null;
            for (const [lk, data] of this.voxels.entries()) { if (data.instanceId === lastId) { lastVoxelLKey = lk; break; } }
            if (lastVoxelLKey !== null) {
                // Aktualisiere sichtbares Mesh
                const tempMatrix = new THREE.Matrix4(); this.instancedMesh.getMatrixAt(lastId, tempMatrix);
                this.instancedMesh.setMatrixAt(removedId, tempMatrix);
                
                // Aktualisiere Kollisions-Mesh mit seiner korrekten Position
                const [lx, ly, lz] = parseKey(lastVoxelLKey);
                dummy.position.set((lx % this.chunkSize) * VS + HALF, (ly % this.chunkSize) * VS + HALF, (lz % this.chunkSize) * VS + HALF);
                dummy.updateMatrix();
                this.collisionMesh.setMatrixAt(removedId, dummy.matrix); // Aktualisiere Kollisions-Mesh mit korrekter Position f√ºr einfachen W√ºrfel
                
                this.updateInstanceColor(removedId, this.voxels.get(lastVoxelLKey).color);
                this.voxels.get(lastVoxelLKey).instanceId = removedId;
                this.globalToLocalInstanceIdMap.set(key(this.chunkX * this.chunkSize + lx, this.chunkY * this.chunkSize + ly, this.chunkZ * this.chunkSize + lz), removedId);
            }
        }
        this.instancedMesh.count--;
        this.collisionMesh.count--; // Halte Z√§hler synchron
        this.instancedMesh.instanceMatrix.needsUpdate = true; this.instancedMesh.instanceColor.needsUpdate = true;
        this.collisionMesh.instanceMatrix.needsUpdate = true;
    }
    recolorVoxel(gx, gy, gz, newColorHex) {
        const lKey = this.getLocalKey(gx, gy, gz);
        if (!this.voxels.has(lKey)) return;
        const { instanceId } = this.voxels.get(lKey);
        this.voxels.set(lKey, { color: newColorHex, instanceId: instanceId });
        this.updateInstanceColor(instanceId, newColorHex);
        // Keine √Ñnderung f√ºr collisionMesh erforderlich, da es keine Farbe hat
    }
    updateInstanceColor(instanceId, hex) {
        const c = new THREE.Color(hex); this.instancedMesh.instanceColor.setXYZ(instanceId, c.r, c.g, c.b);
        this.instancedMesh.instanceColor.needsUpdate = true;
    }
    dispose() {
        this.scene.remove(this.instancedMesh);
        this.instancedMesh.geometry.dispose(); 
        // Hinweis: Material hier nicht entsorgen, da es global geteilt wird
        this.instancedMesh = null; this.voxels.clear(); this.globalToLocalInstanceIdMap.clear();

        this.scene.remove(this.collisionMesh);
        this.collisionMesh.geometry.dispose();
        this.collisionMesh = null;
    }
}

function onResize() {
    cam.aspect = containerDiv.clientWidth / containerDiv.clientHeight; cam.updateProjectionMatrix();
    ren.setSize(containerDiv.clientWidth, containerDiv.clientHeight);
    ren.setPixelRatio(isMobile ? Math.min(1.5, window.devicePixelRatio) : window.devicePixelRatio);
}

function handleGesture() {
    const pointers = [...activePointers.values()];
    if (pointers.length === 0) return;

    if (pointers.length === 1) {
        const p = pointers[0];
        const rotateSpeed = isMobile ? ROTATE_SPEED_TOUCH_MOBILE : ROTATE_SPEED_TOUCH_DESKTOP;
        
        euler.y += (p.x - gestureState.lastMid.x) * rotateSpeed;
        euler.x -= (p.y - gestureState.lastMid.y) * rotateSpeed;
        
        euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
        cam.quaternion.setFromEuler(euler);
        gestureState.lastMid = { x: p.x, y: p.y };
        return;
    }

    if (pointers.length >= 2) {
        const [p0, p1] = pointers;
        const midX = (p0.x + p1.x) * 0.5;
        const midY = (p0.y + p1.y) * 0.5;
        const dist = Math.hypot(p1.x - p0.x, p1.y - p0.y);

        if (gestureState.type === 'none') {
            const dMid = Math.hypot(midX - gestureState.startMid.x, midY - gestureState.startMid.y);
            const PINCH_REL_TH = 0.05;
            const relDelta = Math.abs(dist - gestureState.startDist) / gestureState.startDist;
            if (relDelta > PINCH_REL_TH) {
                gestureState.type = 'pinch';
            } else if (dMid > MOVE_PX) {
                gestureState.type = 'pan';
            }
            return;
        } else if (gestureState.type === 'pinch') {
            const pinchZoomMult = isMobile ? PINCH_ZOOM_MULT_MOBILE : PINCH_ZOOM_MULT_DESKTOP;
            const zoomDelta = (dist / gestureState.lastDist - 1) * pinchZoomMult * moveSpeed;
            cam.position.addScaledVector(cam.getWorldDirection(new THREE.Vector3()), zoomDelta);
            gestureState.lastDist = dist;
        } else if (gestureState.type === 'pan') {
            const panSpeed = isMobile ? PAN_SPEED_TOUCH_MOBILE : PAN_SPEED_TOUCH_DESKTOP;
            const dx = (midX - gestureState.lastMid.x) * panSpeed;
            const dy = (midY - gestureState.lastMid.y) * panSpeed;
            
            const right = new THREE.Vector3().crossVectors(cam.getWorldDirection(new THREE.Vector3()), cam.up).normalize();
            cam.position.addScaledVector(right, dx);
            cam.position.addScaledVector(new THREE.Vector3(0, 1, 0), dy);
            
            gestureState.lastMid = { x: midX, y: midY };
        }
    }
}

function releasePointer(id, eventType) {
    activePointers.delete(id);
    if (activePointers.size < 2) {
        gestureState.type = 'none';
        if (activePointers.size === 1) { const last = [...activePointers.values()][0]; gestureState.lastMid = { x: last.x, y: last.y }; }
    }
    if (activePointers.size === 0) {
        doubleTapDragActive = false; lastActionVoxelCoords = null; touchIndicator.style.display = 'none';
        initialDragVoxelWorldPos = null; dragAxisLock = null; initialDragVoxelCoords = null;
    }
}

function rebuildHelpers() {
    if (gridHelper) scene.remove(gridHelper); if (boxHelper) scene.remove(boxHelper);
    const size = GRID * VS;
    if (isMobile) {
        gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444 ); gridHelper.position.set(size / 2, activeDrawingLevel.y * VS, size / 2);
    } else {
        if (currentDrawingAxis === 'y') {
            gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444 ); gridHelper.position.set(size / 2, activeDrawingLevel.y * VS, size / 2);
        } else if (currentDrawingAxis === 'x') {
            gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444); gridHelper.rotation.z = Math.PI / 2; gridHelper.position.set(activeDrawingLevel.x * VS, size / 2, size / 2);
        } else if (currentDrawingAxis === 'z') {
            gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444); gridHelper.rotation.x = Math.PI / 2; gridHelper.position.set(size / 2, size / 2, activeDrawingLevel.z * VS);
        }
    }
    scene.add(gridHelper);
    const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(size, size, size));
    boxHelper = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x00ffff }));
    boxHelper.position.set(size / 2, size / 2, size / 2); scene.add(boxHelper);
}

function updateGridHelperPosition() {
    rebuildHelpers();
    localStorage.setItem('voxelEditorActiveDrawingLevelX', activeDrawingLevel.x);
    localStorage.setItem('voxelEditorActiveDrawingLevelY', activeDrawingLevel.y);
    localStorage.setItem('voxelEditorActiveDrawingLevelZ', activeDrawingLevel.z);
    localStorage.setItem('voxelEditorCurrentDrawingAxis', currentDrawingAxis);
}

function cycleMode() {
    const activeElement = document.activeElement;
    if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'SELECT' || activeElement.tagName === 'TEXTAREA')) {
        return;
    }
    switch (currentMode) {
        case Modes.ADD: currentMode = Modes.DELETE; break;
        case Modes.DELETE: currentMode = Modes.DRAW; break;
        case Modes.DRAW: currentMode = Modes.ADD; break;
    }
    document.getElementById('current-mode').textContent = `Modus: ${currentMode}`;
    const mobileModeIcon = document.getElementById('mobile-mode-icon');
    if (mobileModeIcon) {
        mobileModeIcon.textContent = ModeIcons[currentMode];
    }
    lastActionVoxelCoords = null; updatePreviewVoxel(0, 0, 0, false);
}

function setActiveColor(colorValue) {
    currentColor = colorValue;
    document.getElementById('color-picker-swatch').style.backgroundColor = currentColor; // Update the main swatch
    const mobileColorInput = document.getElementById('mobile-color-input');
    if (mobileColorInput) mobileColorInput.value = currentColor;
    localStorage.setItem('voxelEditorColor', currentColor);

    // Remove active state from all preset boxes
    presetBoxes.forEach(box => box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'));
    palettePresetBoxes.forEach(box => box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'));

    // Check if the current color matches any preset and set active state
    const presetIndex = presetColors.indexOf(currentColor);
    if (presetIndex !== -1) {
        activePresetIndex = presetIndex;
        if (presetBoxes[activePresetIndex]) {
            presetBoxes[activePresetIndex].classList.add('active', 'border-primary', 'shadow-lg', 'shadow-primary/50');
        }
        if (palettePresetBoxes[activePresetIndex]) {
            palettePresetBoxes[activePresetIndex].classList.add('active', 'border-primary', 'shadow-lg', 'shadow-primary/50');
        }
    } else {
        activePresetIndex = -1;
    }

    // Update preview voxel color
    if (previewVoxelMesh.visible) {
        previewVoxelMaterial.color.set(currentColor);
    }
}


function setActivePreset(index) {
    if (index >= 0 && index < presetColors.length) {
        setActiveColor(presetColors[index]);
    }
}

function savePresetColor(index, colorValue) {
    if (index >= 0 && index < presetColors.length) {
        presetColors[index] = colorValue;
        localStorage.setItem(`voxelPresetColor${index + 1}`, colorValue);
        // Update both the main controls preset box and the palette preset box
        if (presetBoxes[index]) presetBoxes[index].value = colorValue;
        if (palettePresetBoxes[index]) palettePresetBoxes[index].value = colorValue;
        if (activePresetIndex === index) {
            setActiveColor(colorValue); // Re-apply if it was the active preset
        }
    }
}

// Function to apply a batch of voxel modifications
// This function is for internal use by undo/redo and initial load
function applyVoxelModifications(modifications) {
    modifications.forEach(mod => {
        const gKey = key(mod.gx, mod.gy, mod.gz);
        if (mod.type === 'add') {
            _addSingleVoxel(mod.gx, mod.gy, mod.gz, mod.color);
        } else if (mod.type === 'delete') {
            _removeSingleVoxel(mod.gx, mod.gy, mod.gz);
        } else if (mod.type === 'recolor') {
            _recolorSingleVoxel(mod.gx, mod.gy, mod.gz, mod.color);
        }
    });
}

/**
 * Adds a command to the history stack.
 * A command is an array of granular voxel actions.
 * @param {Array<Object>} actionsArray - An array of action objects, e.g.,
 * `{ type: 'add', gx, gy, gz, color }`,
 * `{ type: 'delete', gx, gy, gz, oldColor }`,
 * `{ type: 'recolor', gx, gy, gz, color, oldColor }`
 */
function addCommand(actionsArray) {
    if (actionsArray.length === 0) return; // Don't add empty commands

    if (historyPointer < history.length - 1) {
        history.splice(historyPointer + 1); // Truncate history if we're not at the end
    }
    history.push(actionsArray);
    historyPointer++;
    if (history.length > MAX_HISTORY_SIZE) {
        history.shift(); // Remove oldest command
        historyPointer--;
    }
}

/**
 * Executes or reverses a command from the history.
 * @param {Array<Object>} commandActions - The array of actions for this command.
 * @param {boolean} reverse - True to undo, false to redo.
 */
function executeCommand(commandActions, reverse = false) {
    commandActions.forEach(action => {
        const { gx, gy, gz, color, oldColor, type, oldGrid, newGrid, oldVoxelState, newVoxelState } = action;
        if (type === 'resizeGrid') {
            const targetGrid = reverse ? oldGrid : newGrid;
            const targetVoxelState = reverse ? oldVoxelState : newVoxelState;

            // Apply grid size change
            GRID = targetGrid;
            document.getElementById('grid-size-slider').value = GRID;
            document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`;
            localStorage.setItem('voxelEditorGridSize', GRID);

            // Clear current scene
            for (const chunk of chunks.values()) chunk.dispose();
            chunks.clear();
            voxels.clear();

            // Re-add voxels for the target state
            targetVoxelState.forEach(v => _addSingleVoxel(v.gx, v.gy, v.gz, v.color));
            
            rebuildHelpers();
            resetCameraPosition();
        } else {
            // Standard voxel modification actions
            if (reverse) {
                // Undo logic
                if (action.type === 'add') {
                    _removeSingleVoxel(gx, gy, gz);
                } else if (action.type === 'delete') {
                    _addSingleVoxel(gx, gy, gz, oldColor);
                } else if (action.type === 'recolor') {
                    _recolorSingleVoxel(gx, gy, gz, oldColor);
                }
            } else {
                // Redo logic (original action)
                if (action.type === 'add') {
                    _addSingleVoxel(gx, gy, gz, color);
                } else if (action.type === 'delete') {
                    _removeSingleVoxel(gx, gy, gz);
                } else if (action.type === 'recolor') {
                    _recolorSingleVoxel(gx, gy, gz, color);
                }
            }
        }
    });
    // Rebuild helpers only if it's not a resizeGrid command, as resizeGrid already does it
    if (commandActions.length > 0 && commandActions[0].type !== 'resizeGrid') {
        rebuildHelpers();
    }
}

function undo() {
    if (historyPointer >= 0) {
        executeCommand(history[historyPointer], true); // Execute in reverse
        historyPointer--;
    }
}

function redo() {
    if (historyPointer < history.length - 1) {
        historyPointer++;
        executeCommand(history[historyPointer], false); // Execute original action
    }
}

function _addSingleVoxel(gx, gy, gz, colorHex) {
    const gKey = key(gx, gy, gz); voxels.set(gKey, { color: colorHex });
    const { cx, cy, cz } = getChunkCoords(gx, gy, gz); const cKey = getChunkKey(cx, cy, cz);
    let chunk = chunks.get(cKey);
    if (!chunk) { chunk = new VoxelChunk(cx, cy, cz, CHUNK_SIZE, scene); chunks.set(cKey, chunk); }
    chunk.addVoxel(gx, gy, gz, colorHex);
}

function _removeSingleVoxel(gx, gy, gz) {
    const gKey = key(gx, gy, gz); if (!voxels.has(gKey)) return;
    voxels.delete(gKey);
    const { cx, cy, cz } = getChunkCoords(gx, gy, gz); const cKey = getChunkKey(cx, cy, cz);
    if (chunks.has(cKey)) {
        const chunk = chunks.get(cKey); chunk.removeVoxel(gx, gy, gz);
        if (chunk.instancedMesh.count === 0) { chunk.dispose(); chunks.delete(cKey); }
    }
}

function _recolorSingleVoxel(gx, gy, gz, newColorHex) {
    const gKey = key(gx, gy, gz); if (!voxels.has(gKey)) return;
    voxels.set(gKey, { color: newColorHex });
    const { cx, cy, cz } = getChunkCoords(gx, gy, gz); const cKey = getChunkKey(cx, cy, cz);
    if (chunks.has(cKey)) chunks.get(cKey).recolorVoxel(gx, gy, gz, newColorHex);
}

/**
 * Performs a single voxel modification and records it to the current stroke/history.
 * @param {number} gx - Grid X coordinate.
 * @param {number} gy - Grid Y coordinate.
 * @param {number} gz - Grid Z coordinate.
 * @param {string} mode - The current mode (ADD, DELETE, DRAW).
 * @param {string} newColor - The color to apply if adding or drawing.
 * @param {boolean} recordHistory - Whether to record this modification to history.
 * @returns {Object|null} The action object if a modification occurred, otherwise null.
 */
function performVoxelModification(gx, gy, gz, mode, newColor, recordHistory = true) {
    const gKey = key(gx, gy, gz);
    const hasVoxel = voxels.has(gKey);
    const originalColor = hasVoxel ? voxels.get(gKey).color : null;
    let action = null;

    gx = Math.max(0, Math.min(GRID - 1, gx));
    gy = Math.max(0, Math.min(GRID - 1, gy));
    gz = Math.max(0, Math.min(GRID - 1, gz));

    switch (mode) {
        case Modes.ADD:
            if (!hasVoxel) {
                _addSingleVoxel(gx, gy, gz, newColor);
                action = { type: 'add', gx, gy, gz, color: newColor };
            }
            break;
        case Modes.DELETE:
            if (hasVoxel) {
                _removeSingleVoxel(gx, gy, gz);
                action = { type: 'delete', gx, gy, gz, oldColor: originalColor };
            }
            break;
        case Modes.DRAW:
            if (hasVoxel && originalColor !== newColor) {
                _recolorSingleVoxel(gx, gy, gz, newColor);
                action = { type: 'recolor', gx, gy, gz, color: newColor, oldColor: originalColor };
            }
            break;
    }

    if (action && recordHistory) {
        // Store the action in currentStrokeVoxels for batching if part of a drag
        currentStrokeVoxels.set(gKey, { originalColor: originalColor, finalColor: voxels.has(gKey) ? voxels.get(gKey).color : null, action: action });
    }
    return action;
}

function updatePreviewVoxel(x, y, z, visible) {
    if (previewVoxelMesh) {
        if (visible) {
            // Y-position for preview brick is now simply y * VS, aligning its base to the grid.
            previewVoxelMesh.position.set(x * VS + HALF, y * VS, z * VS + HALF);
            previewVoxelMesh.visible = true;
            previewVoxelMaterial.color.set(currentColor);
            previewVoxelMaterial.opacity = (currentMode === Modes.DELETE) ? 0.2 : 0.5;
            previewVoxelMaterial.wireframe = isMeshViewMode; // Wende Drahtgitter auch auf die Vorschau an
        } else {
            previewVoxelMesh.visible = false;
        }
    }
}

function calculateRayTargetVoxelCoords(clientX, clientY) {
    if (isPointerLocked) return null;

    const rect = cvs.getBoundingClientRect();
    const mouse = new THREE.Vector2(
        ((clientX - rect.left) / rect.width) * 2 - 1,
        -((clientY - rect.top) / rect.height) * 2 + 1
    );

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, cam);

    // Wichtig: Raycasting sollte immer mit der einfachen Box-Geometrie (collisionVoxelGeometry) erfolgen,
    // um sicherzustellen, dass die Intersektionen immer auf den Gitterzellen basieren und nicht auf
    // der komplexen Geometrie des -Bausteins.
    const objectsToIntersect = Array.from(chunks.values()).map(chunk => chunk.collisionMesh);
    if (templateImageMesh) {
        templateImageMesh.raycast = function() {}; // Bildvorlage vom Raycasting ausschlie√üen
    }

    const intersects = raycaster.intersectObjects(objectsToIntersect);

    if (intersects.length > 0) {
        const hit = intersects[0];
        const hitNormal = hit.face.normal.clone();
        const intersectionPoint = hit.point;

        if (!Number.isFinite(intersectionPoint.x) || !Number.isFinite(intersectionPoint.y) || !Number.isFinite(intersectionPoint.z)) {
            return null;
        }

        const epsilon = 0.001; // Eine kleine Verschiebung, um die korrekte Seite des Voxels zu treffen
        const adjustedPoint = intersectionPoint.clone().addScaledVector(hitNormal, -epsilon);

        const hitVoxelX = Math.floor(adjustedPoint.x / VS);
        const hitVoxelY = Math.floor(adjustedPoint.y / VS);
        const hitVoxelZ = Math.floor(adjustedPoint.z / VS);
        
        const result = { gx: Number(hitVoxelX), gy: Number(hitVoxelY), gz: Number(hitVoxelZ), faceNormal: hitNormal, hitExistingVoxel: true };
        if (!Number.isFinite(result.gx) || !Number.isFinite(result.gy) || !Number.isFinite(result.gz)) {
            return null;
        }
        return result;
    } else {
        // Wenn kein Voxel getroffen wird, projiziere auf die aktive Zeichenebene
        let planeNormal = new THREE.Vector3();
        let planeConstant = 0;

        if (currentDrawingAxis === 'y') {
            planeNormal.set(0, 1, 0);
            planeConstant = -(activeDrawingLevel.y * VS);
        } else if (currentDrawingAxis === 'x') {
            planeNormal.set(1, 0, 0);
            planeConstant = -(activeDrawingLevel.x * VS);
        } else if (currentDrawingAxis === 'z') {
            planeNormal.set(0, 0, 1);
            planeConstant = -(activeDrawingLevel.z * VS);
        }

        const drawingPlane = new THREE.Plane(planeNormal, planeConstant);
        const intersectionPoint = new THREE.Vector3();

        if (raycaster.ray.intersectPlane(drawingPlane, intersectionPoint)) {
            if (!Number.isFinite(intersectionPoint.x) || !Number.isFinite(intersectionPoint.y) || !Number.isFinite(intersectionPoint.z)) {
                return null;
            }

            let gx = Math.floor(intersectionPoint.x / VS);
            let gy = Math.floor(intersectionPoint.y / VS);
            let gz = Math.floor(intersectionPoint.z / VS);

            // Stelle sicher, dass die Koordinaten auf der aktiven Zeichenebene liegen
            if (currentDrawingAxis === 'y') gy = activeDrawingLevel.y;
            else if (currentDrawingAxis === 'x') gx = activeDrawingLevel.x;
            else if (currentDrawingAxis === 'z') gz = activeDrawingLevel.z;

            gx = Number(gx);
            gy = Number(gy);
            gz = Number(gz);

            if (!Number.isFinite(gx) || !Number.isFinite(gy) || !Number.isFinite(gz)) {
                return null;
            }

            const result = { gx: gx, gy: gy, gz: gz, faceNormal: null, hitExistingVoxel: false };
            return result;
        }
    }
    return null;
}

function clearAllInternal(fromHistory = false) {
    const actions = [];
    if (!fromHistory) {
        // Capture current state for undo
        voxels.forEach((data, gKey) => {
            const [gx, gy, gz] = parseKey(gKey);
            actions.push({ type: 'delete', gx, gy, gz, oldColor: data.color });
        });
    }

    for (const chunk of chunks.values()) chunk.dispose();
    chunks.clear(); voxels.clear(); rebuildHelpers();

    if (!fromHistory) {
        addCommand(actions); // Add the batch delete command
    }
}
function clearAll() { clearAllInternal(false); }

function fillActiveLevel() {
    const actions = [];
    const voxelsToProcess = new Map(); // Use a map to track unique voxels and their original state

    // Collect all voxels that would be affected by the fill operation
    for (let x = 0; x < GRID; x++) {
        for (let z = 0; z < GRID; z++) {
            let gx, gy, gz;
            if (currentDrawingAxis === 'y') { gx = x; gy = activeDrawingLevel.y; gz = z; }
            else if (currentDrawingAxis === 'x') { gx = activeDrawingLevel.x; gy = x; gz = z; }
            else if (currentDrawingAxis === 'z') { gx = x; gy = z; gz = activeDrawingLevel.z; }

            const gKey = key(gx, gy, gz);
            const hasVoxel = voxels.has(gKey);
            const originalColor = hasVoxel ? voxels.get(gKey).color : null;
            
            voxelsToProcess.set(gKey, { gx, gy, gz, hasVoxel, originalColor });
        }
    }

    // Perform modifications and record actions
    voxelsToProcess.forEach(voxelData => {
        const { gx, gy, gz, hasVoxel, originalColor } = voxelData;
        if (hasVoxel) {
            if (originalColor !== currentColor) {
                // Recolor existing voxel
                _recolorSingleVoxel(gx, gy, gz, currentColor);
                actions.push({ type: 'recolor', gx, gy, gz, color: currentColor, oldColor: originalColor });
            }
        } else {
            // Add new voxel
            _addSingleVoxel(gx, gy, gz, currentColor);
            actions.push({ type: 'add', gx, gy, gz, color: currentColor });
        }
    });

    addCommand(actions); // Add the batch fill command
    rebuildHelpers(); // Ensure helpers are updated after changes
}

function saveJSON() {
    const data = {};
    voxels.forEach((value, k) => {
        const [gx, gy, gz] = parseKey(k);
        data[`${gx},${gy},${gz}`] = value.color;
    });

    const settings = {
        gridSize: GRID,
        cameraPosition: cam.position.toArray(),
        cameraQuaternion: cam.quaternion.toArray(),
        activeDrawingLevel: activeDrawingLevel,
        currentDrawingAxis: currentDrawingAxis,
        currentColor: currentColor,
        presetColors: presetColors,
        activePresetIndex: activePresetIndex,
        moveSpeed: moveSpeed,
        templateImageData: templateImageData,
        currentBlockStyle: currentBlockStyle // Save block style
    };

    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    const hours = String(now.getHours()).padStart(2, '0');
    const minutes = String(now.getMinutes()).padStart(2, '0');
    const seconds = String(now.getSeconds()).padStart(2, '0');
    const fileName = `voxelblocks_${year}-${month}-${day}_${hours}-${minutes}-${seconds}.json`;


    const fileContent = {
        title: projectTitle,
        description: projectDescription,
        category: projectCategory,
        tags: projectTags,
        remixOf: projectRemixOf,
        sourceJsonUrl: projectSourceJsonUrl,
        visibility: projectVisibility,
        fileName: fileName,
        timestamp: new Date().toISOString(),

        projectData: {
            settings: settings,
            voxels: data
        }
    };

    const blob = new Blob([JSON.stringify(fileContent, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = fileContent.fileName;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    showToast('Speichern erfolgreich', 'Projekt als JSON-Datei gespeichert.', 'success', 5000);
}

function saveAutosave() {
    const data = {};
    voxels.forEach((value, k) => {
        const [gx, gy, gz] = parseKey(k);
        data[`${gx},${gy},${gz}`] = value.color;
    });

    const settings = {
        gridSize: GRID,
        cameraPosition: cam.position.toArray(),
        cameraQuaternion: cam.quaternion.toArray(),
        activeDrawingLevel: activeDrawingLevel,
        currentDrawingAxis: currentDrawingAxis,
        currentColor: currentColor,
        presetColors: presetColors,
        activePresetIndex: activePresetIndex,
        moveSpeed: moveSpeed,
        templateImageData: templateImageData,
        currentBlockStyle: currentBlockStyle // NEW: Save block style
    };

    const autosaveContent = {
        timestamp: new Date().toISOString(),
        projectData: {
            settings: settings,
            voxels: data
        }
    };
    localStorage.setItem('voxelblocks_autosave', JSON.stringify(autosaveContent));
}

function resetToDefaultProject() {
    clearAllInternal(true); GRID = 10;
    document.getElementById('grid-size-slider').value = GRID; document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`; localStorage.setItem('voxelEditorGridSize', GRID);
    setActiveColor('#ffffff'); // Use the new function to set color
    
    activeDrawingLevel = { x: 0, y: 0, z: 0 }; currentDrawingAxis = 'y';
    localStorage.setItem('voxelEditorActiveDrawingLevelX', activeDrawingLevel.x);
    localStorage.setItem('voxelEditorActiveDrawingLevelY', activeDrawingLevel.y);
    localStorage.setItem('voxelEditorActiveDrawingLevelZ', activeDrawingLevel.z);
    localStorage.setItem('voxelEditorCurrentDrawingAxis', currentDrawingAxis);
    moveSpeed = 0.1; document.getElementById('fly-speed-slider').value = moveSpeed; document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2); localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
    presetColors[0] = '#E4002B'; presetColors[1] = '#00A040'; presetColors[2] = '#0057B8';
    localStorage.setItem('voxelPresetColor1', presetColors[0]); localStorage.setItem('voxelPresetColor2', presetColors[1]); localStorage.setItem('voxelPresetColor3', presetColors[2]);
    
    // Update both sets of preset boxes
    presetBoxes.forEach((box, i) => { box.value = presetColors[i]; box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'); });
    palettePresetBoxes.forEach((box, i) => { box.value = presetColors[i]; box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'); });

    activePresetIndex = -1; removeImageTemplate(true); history.length = 0; historyPointer = -1;
    currentBlockStyle = 'simple'; // Reset block style to default
    updateBlockStyle(true); // Update geometry and UI without toast
    resetCameraPosition(); showToast('Projekt zur√ºckgesetzt', 'Das Projekt wurde auf den Standardzustand zur√ºckgesetzt.', 'info', 5000);
}

function loadProjectData(projectData, fromAutosave = false) {
    try {
        const loadedVoxels = projectData.projectData ? projectData.projectData.voxels : projectData.voxels;
        const loadedSettings = projectData.projectData ? projectData.projectData.settings : projectData.settings;
        
        // Clear current scene without adding to history
        for (const chunk of chunks.values()) chunk.dispose();
        chunks.clear(); voxels.clear();

        projectTitle = projectData.title || ''; projectDescription = projectData.description || '';
        projectCategory = projectData.category || 'Allgemein';
        projectTags = Array.isArray(projectData.tags) ? projectData.tags : (typeof projectData.tags === 'string' ? projectData.tags.split(',').map(tag => tag.trim()).filter(tag => tag !== '') : []);
        projectRemixOf = projectData.remixOf || ''; projectSourceJsonUrl = projectData.sourceJsonUrl || ''; projectVisibility = projectData.visibility || 'public';

        if (loadedSettings) {
            GRID = loadedSettings.gridSize !== undefined ? loadedSettings.gridSize : 10;
            document.getElementById('grid-size-slider').value = GRID; document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`; localStorage.setItem('voxelEditorGridSize', GRID);

            currentBlockStyle = loadedSettings.currentBlockStyle || 'simple';
            updateBlockStyle(true); // Update geometry and UI without toast
        }
        for (const k in loadedVoxels) {
            const colorValue = loadedVoxels[k]; const parts = k.split(',').map(Number);
            if (parts.length === 3 && !isNaN(parts[0]) && !isNaN(parts[1]) && !isNaN(parts[2])) {
                const gx = parts[0]; const gy = parts[1]; const gz = parts[2];
                if (gx >= 0 && gx < GRID && gy >= 0 && gy < GRID && gz >= 0 && gz < GRID) _addSingleVoxel(gx, gy, gz, colorValue);
            }
        }
        if (loadedSettings) {
            if (loadedSettings.cameraPosition) cam.position.fromArray(loadedSettings.cameraPosition);
            if (loadedSettings.cameraQuaternion) { cam.quaternion.fromArray(loadedSettings.cameraQuaternion); euler.setFromQuaternion(cam.quaternion, 'YXZ'); }
            if (loadedSettings.activeDrawingLevel) {
                activeDrawingLevel = {
                    x: Number(loadedSettings.activeDrawingLevel.x || 0),
                    y: Number(loadedSettings.activeDrawingLevel.y || 0),
                    z: Number(loadedSettings.activeDrawingLevel.z || 0)
                };
                if (!Number.isFinite(activeDrawingLevel.x)) activeDrawingLevel.x = 0;
                if (!Number.isFinite(activeDrawingLevel.y)) activeDrawingLevel.y = 0;
                if (!Number.isFinite(activeDrawingLevel.z)) activeDrawingLevel.z = 0;

                activeDrawingLevel.x = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.x)));
                activeDrawingLevel.y = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.y)));
                activeDrawingLevel.z = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.z)));

                localStorage.setItem('voxelEditorActiveDrawingLevelX', activeDrawingLevel.x);
                localStorage.setItem('voxelEditorActiveDrawingLevelY', activeDrawingLevel.y);
                localStorage.setItem('voxelEditorActiveDrawingLevelZ', activeDrawingLevel.z);
            }
            if (loadedSettings.currentDrawingAxis) { currentDrawingAxis = loadedSettings.currentDrawingAxis; localStorage.setItem('voxelEditorCurrentDrawingAxis', currentDrawingAxis); }
            updateGridHelperPosition();
            setActiveColor(loadedSettings.currentColor || '#ffffff'); // Use the new function to set color

            if (loadedSettings.presetColors) {
                for(let i = 0; i < loadedSettings.presetColors.length && i < presetColors.length; i++) {
                    presetColors[i] = loadedSettings.presetColors[i]; 
                    if (presetBoxes[i]) presetBoxes[i].value = presetColors[i];
                    if (palettePresetBoxes[i]) palettePresetBoxes[i].value = presetColors[i];
                }
            }
            setActivePreset(loadedSettings.activePresetIndex !== undefined ? loadedSettings.activePresetIndex : -1);
            if (loadedSettings.moveSpeed !== undefined) {
                moveSpeed = loadedSettings.moveSpeed; document.getElementById('fly-speed-slider').value = moveSpeed; document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2); localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
            }
            if (loadedSettings.templateImageData) {
                templateImageData = loadedSettings.templateImageData;
                new THREE.TextureLoader().load(templateImageData.src, (texture) => {
                    const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true, depthWrite: false });
                    const geometry = new THREE.PlaneGeometry(templateImageData.scaledWidth, templateImageData.scaledHeight);
                    if (templateImageMesh) { scene.remove(templateImageMesh); templateImageMesh.geometry.dispose(); templateImageMesh.material.dispose(); }
                    templateImageMesh = new THREE.Mesh(geometry, material);
                    templateImageMesh.position.fromArray(templateImageData.position); templateImageMesh.rotation.fromArray(templateImageData.rotation); templateImageMesh.scale.fromArray(templateImageData.scale);
                    templateImageMesh.renderOrder = -1; scene.add(templateImageMesh);
                    document.getElementById('removeImageTemplateBtn').classList.remove('hidden');
                }, undefined, (err) => { templateImageMesh = null; templateImageData = null; document.getElementById('removeImageTemplateBtn').classList.add('hidden'); });
            }
        }
        history.length = 0; historyPointer = -1;
        resetCameraPosition();
        return true; // Indicate success
    } catch (error) {
        if (!fromAutosave) { // Only show error toast if not from autosave (autosave has its own error handling)
            showToast('Fehler', 'Fehler beim Laden der Datei. Stellen Sie sicher, dass es sich um eine g√ºltige JSON-Datei handelt. Fehler: ' + error.message, 'error', 5000);
        }
        resetToDefaultProject();
        return false; // Indicate failure
    }
}

function loadAutosave() {
    const savedData = localStorage.getItem('voxelblocks_autosave');
    if (savedData) {
        try {
            const projectData = JSON.parse(savedData);
            return loadProjectData(projectData, true); // Pass true for fromAutosave
        } catch (error) {
            showToast('Fehler beim Laden', 'Fehler beim Laden des letzten Projekts aus dem lokalen Speicher. Es wird ein neues Projekt gestartet. Fehler: ' + error.message, 'error', 5000);
            localStorage.removeItem('voxelblocks_autosave'); // Clear corrupted autosave
            return false;
        }
    }
    return false;
}


async function loadProjectFromModelId(modelId) {
    showToast('Lade Projekt', `Lade Projekt mit ID: ${modelId}...`, 'info', 5000);
    try {
        const docSnap = await window.firebase.getDoc(window.firebase.doc(db, "models", modelId));
        if (docSnap.exists()) {
            const pData = docSnap.data();
            const isPublic = pData.visibility === 'public';
            const isOwner = auth.currentUser && auth.currentUser.uid === pData.uploaderUid;
            if (isPublic || isOwner) {
                if (pData && pData.projectData) {
                    projectRemixOf = modelId; projectSourceJsonUrl = window.location.href;
                    loadProjectData(pData);
                    showToast('Projekt geladen', `Projekt "${docSnap.data().title}" erfolgreich geladen.`, 'success', 5000);
                } else { showToast('Fehler', 'Projektdaten im Dokument nicht gefunden.', 'error', 5000); resetToDefaultProject(); }
            } else { showToast('Zugriff verweigert', 'Sie haben keine Berechtigung, dieses private Projekt zu laden.', 'error', 5000); resetToDefaultProject(); }
        } else { showToast('Projekt nicht gefunden', `Kein Projekt mit ID "${modelId}" gefunden.`, 'warning', 5000); resetToDefaultProject(); }
    } catch (error) {
        if (error.code === 'permission-denied') showToast('Zugriff verweigert', `Berechtigungsfehler beim Laden des Projekts. Stellen Sie sicher, dass das Modell √∂ffentlich ist oder Sie der Eigent√ºmer sind.`, 'error', 5000);
        else showToast('Fehler', `Fehler beim Laden des Projekts: ${error.message}`, 'error', 5000);
        resetToDefaultProject();
    }
}

function loadJSON(event) {
    const file = event.target.files[0]; if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const projectData = JSON.parse(e.target.result);
            projectRemixOf = ''; projectSourceJsonUrl = ''; loadProjectData(projectData);
        } catch (error) {
            showToast('Fehler', 'Fehler beim Parsen der Datei. Stellen Sie sicher, dass es sich um eine g√ºltige JSON-Datei handelt. Fehler: ' + error.message, 'error', 5000);
            resetToDefaultProject();
        }
    };
    reader.readAsText(file);
}

function openStlExportModal() {
    if (voxels.size === 0) { showToast('Export fehlgeschlagen', 'Keine Voxel zum Exportieren vorhanden!', 'warning', 5000); return; }
    document.getElementById('exportStlModal').showModal();
}

async function exportSTL(unit) {
    if (voxels.size === 0) { showToast('Export fehlgeschlagen', 'Keine Voxel zum Exportieren vorhanden!', 'warning', 5000); return; }
    showToast('Exportiere STL', 'Erzeuge STL-Modell...', 'info', 5000);
    
    let scaleFactor = 1;
    if (unit === 'cm') {
        scaleFactor = 10; // 1 Voxel = 1cm, so 10mm
    }
    
    const geometriesToMerge = [];
    // Erstelle eine tempor√§re Geometrie mit der korrekten Skalierung f√ºr den Export
    // The createBrickGeometry now ensures the body is 1x1x1 unitSize.
    // So, for STL export, we want the body to be (VS * scaleFactor) in each dimension.
    const tempGeometry = (currentBlockStyle === 'simple' ? createSimpleCubeGeometry(VS * scaleFactor) : createBrickGeometry(VS * scaleFactor));

    voxels.forEach((data, k) => {
        const [x, y, z] = parseKey(k);
        // Positioniere die Instanz korrekt im Verh√§ltnis zur Voxel-Grid-Einheit
        // Der Baustein hat seinen lokalen Y=0 an seiner Basis.
        // Daher muss die Y-Position des Dummy-Objekts einfach y * VS * scaleFactor sein.
        dummy.position.set((x * VS + HALF) * scaleFactor, (y * VS * scaleFactor), (z * VS + HALF) * scaleFactor);
        dummy.updateMatrix();
        const instanceGeometry = tempGeometry.clone();
        instanceGeometry.applyMatrix4(dummy.matrix);
        geometriesToMerge.push(instanceGeometry);
    });

    const mergedGeometry = geometriesToMerge.length > 0 ? THREE.BufferGeometryUtils.mergeBufferGeometries(geometriesToMerge, true) : new THREE.BufferGeometry();
    
    // Wende eine 90-Grad-Rotation um die X-Achse f√ºr Bambu Labs an
    const rotationMatrix = new THREE.Matrix4();
    rotationMatrix.makeRotationX(Math.PI / 2); // 90 Grad im Bogenma√ü

    mergedGeometry.applyMatrix4(rotationMatrix);

    const tempMesh = new THREE.Mesh(mergedGeometry);
    if (typeof THREE.STLExporter === 'undefined') { showToast('Export fehlgeschlagen', 'STLExporter-Bibliothek nicht geladen.', 'error', 5000); return; }
    const exporter = new THREE.STLExporter();
    const result = exporter.parse(tempMesh);
    const blob = new Blob([result], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'voxel_model.stl';
    document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
    tempGeometry.dispose(); if (mergedGeometry) mergedGeometry.dispose();
    showToast('Export erfolgreich', `STL-Modell erfolgreich exportiert! (1 Voxel = 1 ${unit})`, 'success', 5000);
    document.getElementById('exportStlModal').close();
}


function showToast(title, message, type = 'info', duration = 5000) {
    const toast = document.createElement('div');
    toast.className = `alert shadow-lg ${type === 'info' ? 'alert-info' : type === 'success' ? 'alert-success' : type === 'error' ? 'alert-error' : type === 'warning' ? 'alert-warning' : ''}`;
    toast.innerHTML = `
        ${type === 'info' ? '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" class="stroke-current shrink-0 h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>' : ''}
        ${type === 'success' ? '<svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>' : ''}
        ${type === 'error' ? '<svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>' : ''}
        ${type === 'warning' ? '<svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>' : ''}
        <div><strong>${title}</strong><br><span>${message}</span></div><button class="close-btn btn btn-ghost btn-sm">&times;</button>`;
    toastContainer.appendChild(toast);
    void toast.offsetWidth; toast.classList.add('show');
    toast.querySelector('.close-btn').addEventListener('click', () => { toast.classList.remove('show'); toast.addEventListener('transitionend', () => toast.remove(), { once: true }); });
    setTimeout(() => { if (toast.parentNode) { toast.classList.remove('show'); toast.addEventListener('transitionend', () => toast.remove(), { once: true }); } }, duration);
}

function resetCameraPosition() {
    cam.position.set(GRID * 1.0, GRID * 1.2, GRID * 1.5); cam.lookAt(GRID / 2, GRID / 2, GRID / 2);
    if (euler) euler.setFromQuaternion(cam.quaternion, 'YXZ');
}

function loadImageTemplate() {
    document.getElementById('imageFileInput').click();
}

function handleImageFileSelect(event) {
    const file = event.target.files[0];
    if (!file) {
        return;
    }
    const reader = new FileReader();
    reader.onload = (e) => {
        const base64Image = e.target.result;
        const img = new Image();
        img.onload = () => {
            const aspectRatio = img.width / img.height;
            const planeWidth = GRID * VS;
            const planeHeight = planeWidth / aspectRatio;

            if (templateImageMesh) {
                scene.remove(templateImageMesh);
                templateImageMesh.geometry.dispose();
                templateImageMesh.material.dispose();
            }

            const texture = new THREE.TextureLoader().load(base64Image);
            const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true, depthWrite: false });
            const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
            templateImageMesh = new THREE.Mesh(geometry, material);

            templateImageMesh.position.set((GRID * VS) / 2, (GRID * VS) / 2, -0.001);
            templateImageMesh.rotation.set(0, 0, 0);

            templateImageMesh.renderOrder = -1; scene.add(templateImageMesh);
            templateImageData = {
                src: base64Image,
                position: templateImageMesh.position.toArray(),
                rotation: templateImageMesh.rotation.toArray(),
                scale: [1, 1, 1],
                scaledWidth: planeWidth,
                scaledHeight: planeHeight
            };
            document.getElementById('removeImageTemplateBtn').classList.remove('hidden');
            showToast('Bildvorlage geladen', 'Bild als Vorlage erfolgreich geladen.', 'success', 5000);
        };
        img.onerror = (err) => {
            showToast('Fehler', 'Bild konnte nicht geladen werden. Ung√ºltiges Bildformat?', 'error', 5000);
            templateImageMesh = null;
            templateImageData = null;
            document.getElementById('removeImageTemplateBtn').classList.add('hidden');
        };
        img.src = base64Image;
    };
    reader.onerror = (err) => {
        showToast('Fehler', 'Fehler beim Lesen der Bilddatei.', 'error', 5000);
    };
    reader.readAsDataURL(file);

    event.target.value = '';
}
function removeImageTemplate(fromLoad = false) {
    if (templateImageMesh) {
        scene.remove(templateImageMesh); templateImageMesh.geometry.dispose(); templateImageMesh.material.dispose();
        templateImageMesh = null; templateImageData = null; document.getElementById('removeImageTemplateBtn').classList.add('hidden');
        if (!fromLoad) showToast('Bildvorlage entfernt', 'Bildvorlage erfolgreich entfernt.', 'info', 5000);
    }
}

function getCurrentBlockDimensions() {
    return { dimX: 1, dimY: 1, dimZ: 1 };
}

async function loginLogout() {
    if (auth.currentUser) { try { await window.firebase.signOut(auth); showToast('Abgemeldet', 'Sie wurden erfolgreich abgemeldet.', 'info', 5000); } catch (e) { showToast('Fehler beim Abmelden', `Fehler: ${e.message}`, 'error', 5000); } }
    else openAuthModal();
}

function openUploadModal() {
    if (!currentUserId) { openAuthModal(); return; }
    if (voxels.size === 0) { showToast('Upload fehlgeschuldert', 'Die Szene ist leer. Bitte erstellen Sie zuerst ein Modell.', 'warning', 5000); return; }
    document.getElementById('uploadTitle').value = projectTitle; document.getElementById('uploadDescription').value = projectDescription;
    document.getElementById('uploadCategory').value = projectCategory; document.getElementById('uploadTags').value = projectTags.join(', ');
    document.querySelector(`input[name="uploadVisibility"]:checked`).value = projectVisibility;
    const uploadCategorySelect = document.getElementById('uploadCategory');
    uploadCategorySelect.innerHTML = '<option value="" disabled selected>Kategorie ausw√§hlen</option>';
    predefinedCategories.forEach(cat => { const opt = document.createElement('option'); opt.value = cat; opt.textContent = cat; uploadCategorySelect.appendChild(opt); });
    uploadCategorySelect.value = projectCategory;
    document.getElementById('uploadProjectModal').showModal();
}

async function uploadProjectToHub() {
    if (!currentUserId) { showToast('Fehler', 'Nicht angemeldet. Bitte melden Sie sich an, um hochzuladen.', 'error', 5000); return; }
    if (voxels.size === 0) { showToast('Upload fehlgeschuldert', 'Die Szene ist leer. Bitte erstellen Sie zuerst ein Modell.', 'warning', 5000); return; }
    const title = document.getElementById('uploadTitle').value.trim();
    const description = document.getElementById('uploadDescription').value.trim();
    const category = document.getElementById('uploadCategory').value;
    const tags = document.getElementById('uploadTags').value.split(',').map(tag => tag.trim()).filter(tag => tag !== '');
    const visibility = document.querySelector('input[name="uploadVisibility"]:checked').value;
    if (!title) { showToast('Fehler', 'Bitte geben Sie einen Titel f√ºr Ihr Projekt ein.', 'warning', 5000); return; }
    if (!category) { showToast('Fehler', 'Bitte w√§hlen Sie eine Kategorie f√ºr Ihr Projekt aus.', 'warning', 5000); 'warning'; return; }
    showToast('Lade hoch...', 'Ihr Projekt wird hochgeladen. Bitte warten Sie...', 'info', 5000);
    try {
        const voxelMap = {}; voxels.forEach((v, k) => { const [gx, gy, gz] = parseKey(k); voxelMap[`${gx},${gy},${gz}`] = v.color; });
        const firestoreSafeSettings = {
            gridSize: GRID, cameraPosition: cam.position.toArray(), cameraQuaternion: cam.quaternion.toArray(),
            activeDrawingLevel: activeDrawingLevel, currentDrawingAxis: currentDrawingAxis, currentColor: currentColor,
            presetColors: presetColors, activePresetIndex: activePresetIndex, moveSpeed: moveSpeed,
            templateImageData: null, currentBlockStyle: currentBlockStyle
        };
        const firestoreDocument = {
            title: title, description: description, category: category, tags: tags, visibility: visibility,
            remixOf: projectRemixOf || "", sourceJsonUrl: projectSourceJsonUrl || "",
            fileName: `${title.replace(/\s+/g, "_")}.json`, downloads: 0, rating: 0, ratingCount: 0, verified: false,
            userId: currentUserId, uploaderEmail: currentUser?.email || "", uploaderUid: currentUser?.uid || "",
            uploaderPhotoURL: currentUser?.photoURL || "", timestamp: window.firebase.serverTimestamp(),
            projectData: {
                description: description, remixOf: projectRemixOf || "", sourceJsonUrl: projectSourceJsonUrl || "",
                settings: firestoreSafeSettings, activeDrawingLevel: firestoreSafeSettings.activeDrawingLevel, activePresetIndex: firestoreSafeSettings.activePresetIndex,
                cameraPosition: firestoreSafeSettings.cameraPosition, cameraQuaternion: firestoreSafeSettings.cameraQuaternion,
                currentColor: firestoreSafeSettings.currentColor, currentDrawingAxis: firestoreSafeSettings.currentDrawingAxis,
                gridSize: firestoreSafeSettings.gridSize, moveSpeed: firestoreSafeSettings.moveSpeed, presetColors: firestoreSafeSettings.presetColors, templateImageData: null, voxels: voxelMap
            }
        };
        const docRef = await window.firebase.addDoc(window.firebase.collection(db, "models"), firestoreDocument);
        projectTitle = title; projectDescription = description; projectCategory = category; projectTags = tags; projectVisibility = visibility;
        if (!projectSourceJsonUrl) projectSourceJsonUrl = `https://hub.voxelshaper.com?modelId=${docRef.id}`; // Keep old URL for now
        showToast('Erfolgreich hochgeladen', `Ihr Projekt wurde erfolgreich hochgeladen! ID: ${docRef.id}`, 'success', 5000);
    } catch (e) { showToast('Fehler beim Hochladen', `Fehler: ${e.message}`, 'error', 5000); }
    finally { document.getElementById('uploadProjectModal').close(); }
}

function openAuthModal() { document.getElementById('authModal').showModal(); document.getElementById('emailLoginForm').classList.add('hidden'); }
function closeAuthModal() { document.getElementById('authModal').close(); cvs.focus(); }

window.signInWithGoogle = async function() { try { await window.firebase.signInWithPopup(auth, new window.firebase.GoogleAuthProvider()); showToast('Anmeldung erfolgreich', 'Mit Google angemeldet.', 'success', 5000); closeAuthModal(); } catch (e) { showToast('Anmeldefehler', `Google: ${e.message}`, 'error', 5000); } }
window.signInWithGithub = async function() { try { await window.firebase.signInWithPopup(auth, new window.firebase.GithubAuthProvider()); showToast('Anmeldung erfolgreich', 'Mit GitHub angemeldet.', 'success', 5000); closeAuthModal(); } catch (e) { showToast('Anmelmelfehler', `GitHub: ${e.message}`, 'error', 5000); } }
window.signInEmailPassword = async function() { const email = document.getElementById('emailInput').value; const password = document.getElementById('passwordInput').value; try { await window.firebase.signInWithEmailAndPassword(auth, email, password); showToast('Anmeldung erfolgreich', 'Mit E-Mail angemeldet.', 'success', 5000); closeAuthModal(); } catch (e) { showToast('Anmeldefehler', `E-Mail: ${e.message}`, 'error', 5000); } }
window.signUpEmailPassword = async function() { const email = document.getElementById('emailInput').value; const password = document.getElementById('passwordInput').value; try { await window.firebase.createUserWithEmailAndPassword(auth, email, password); showToast('Registrierung erfolgreich', 'Konto erstellt und angemeldet.', 'success', 5000); closeAuthModal(); } catch (e) { showToast('Registrierungsfehler', `E-Mail: ${e.message}`, 'error', 5000); } }

function closeAllModals() {
    const modals = ['clearConfirmationModal', 'uploadProjectModal', 'authModal', 'exportStlModal', 'customColorPaletteModal'];
    modals.forEach(id => { const modal = document.getElementById(id); if (modal && modal.open) modal.close(); });
    // Stelle sicher, dass cvs definiert ist, bevor focus aufgerufen wird
    if (cvs) {
        cvs.focus(); // Stelle sicher, dass das Canvas nach dem Schlie√üen eines Modals den Fokus wiedererlangt
    }
}
window.closeAllModals = closeAllModals;

function onPointerLockChange() {
    if (document.pointerLockElement === cvs) { isPointerLocked = true; firstMoveAfterLock = true; updatePreviewVoxel(0,0,0,false); euler.setFromQuaternion(cam.quaternion, 'YXZ'); }
    else { isPointerLocked = false; }
}

function onMouseWheel(e) {
    e.preventDefault();
    if (e.altKey) {
        if (!isMobile && (currentMode === Modes.ADD || currentMode === Modes.DRAW)) {
            if (e.shiftKey) { activeDrawingLevel.z = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.z - Math.sign(e.deltaY))); currentDrawingAxis = 'z'; }
            else if (e.ctrlKey) { activeDrawingLevel.x = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.x - Math.sign(e.deltaY))); currentDrawingAxis = 'x'; }
            else { activeDrawingLevel.y = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.y - Math.sign(e.deltaY))); currentDrawingAxis = 'y'; }
            updateGridHelperPosition();
        } else {
            cam.position.addScaledVector(cam.getWorldDirection(new THREE.Vector3()), e.deltaY * 0.005 * moveSpeed * 5);
        }
    } else {
        moveSpeed = Math.max(0.01, Math.min(1.0, moveSpeed - Math.sign(e.deltaY) * 0.01));
        document.getElementById('fly-speed-slider').value = moveSpeed; document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2); localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
    }
}

const keyboard = {};
function onKeyDown(e) {
    const activeModals = ['authModal', 'uploadProjectModal', 'clearConfirmationModal', 'exportStlModal', 'customColorPaletteModal'].some(id => document.getElementById(id).open);
    if (activeModals) { if (e.key === 'Escape') { closeAllModals(); e.preventDefault(); } return; }
    keyboard[e.key.toLowerCase()] = true;
    if (e.key === 'Shift') isShiftDragging = true;
    if (e.key === 'Control' || e.metaKey) isControlDragging = true;
    if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); }
    if (((e.ctrlKey || e.metaKey) && e.key === 'y') || ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'Z')) { e.preventDefault(); redo(); }
    if ((e.ctrlKey || e.metaKey) && e.key === 'd') e.preventDefault();
    if (e.key === ' ') { e.preventDefault(); cycleMode(); } // Leertaste zum Umschalten des Modus
    switch (e.key) { case '1': setActivePreset(0); break; case '2': setActivePreset(1); break; case '3': setActivePreset(2); break; }
}

function onKeyUp(e) {
    keyboard[e.key.toLowerCase()] = false;
    if (e.key === 'Shift') isShiftDragging = false;
    if (e.key === 'Control' || e.metaKey) isControlDragging = false;
}

function onPointerLeave(e) {
    if (pointerIsDown && isDragging) {
        // When dragging ends due to pointer leaving, commit the stroke
        const actionsToCommit = [];
        currentStrokeVoxels.forEach(change => {
            // Only add actions that actually resulted in a change
            const currentVoxelState = voxels.has(key(change.action.gx, change.action.gy, change.action.gz)) ? voxels.get(key(change.action.gx, change.action.gy, change.action.gz)).color : null;
            if (change.originalColor !== currentVoxelState) { // Check if the voxel's state actually changed from its original state at stroke start
                actionsToCommit.push(change.action);
            }
        });
        addCommand(actionsToCommit);
    }
    pointerIsDown = false;
    isDragging = false;
    doubleTapDragActive = false;
    lastActionVoxelCoords = null;
    initialClickPos = null;
    initialTargetVoxelCoords = null;
    voxelsAtDragStart = null;
    currentStrokeVoxels.clear();
    updatePreviewVoxel(0, 0, 0, false);
    dragAxisLock = null;
    initialDragVoxelCoords = null;
    initialDragYLevel = null;
    
    if (e.pointerType === 'touch') {
        releasePointer(e.pointerId, e);
    }
}

let pointerIsDown = false;
let rightMouseButtonDown = false;
let lastX, lastY;
let suppressNextTap = false;

function getVoxelsOnLine(start, end) {
    if (!start || !Number.isFinite(start.gx) || !Number.isFinite(start.gy) || !Number.isFinite(start.gz) ||
        !end || !Number.isFinite(end.gx) || !Number.isFinite(end.gy) || !Number.isFinite(end.gz)) {
        return [];
    }
    const voxelsOnLine = [];
    let x1 = start.gx, y1 = start.gy, z1 = start.gz;
    let x2 = end.gx, y2 = end.gy, z2 = end.gz;
    let dx = Math.abs(x2 - x1), dy = Math.abs(y2 - y1), dz = Math.abs(z2 - z1);
    let sx = (x1 < x2) ? 1 : -1, sy = (y1 < y2) ? 1 : -1, sz = (z1 < z2) ? 1 : -1;
    let dm = Math.max(dx, dy, dz);
    let x = x1, y = y1, z = z1;
    let p1 = 2 * dy - dm, p2 = 2 * dz - dm;

    for (let i = 0; i <= dm; i++) {
        const clampedX = Math.max(0, Math.min(GRID - 1, x));
        const clampedY = Math.max(0, Math.min(GRID - 1, y));
        const clampedZ = Math.max(0, Math.min(GRID - 1, z));
        voxelsOnLine.push({ gx: clampedX, gy: clampedY, gz: clampedZ });
        
        if (dm === dx) { y += sy * (p1 > 0); p1 += 2 * dy; z += sz * (p2 > 0); p2 += 2 * dz; }
        else if (dm === dy) { x += sx * (p1 > 0); p1 += 2 * dx; z += sz * (p2 > 0); p2 += 2 * dz; }
        else { x += sx * (p1 > 0); p1 += 2 * dy; y += sy * (p2 > 0); p2 += 2 * dx; }
        if (dm === dx) x += sx; else if (dm === dy) y += sy; else z += sz;
    }
    return voxelsOnLine;
}

function onPointerUp(e) {
    if (e.button === 2) {
        rightMouseButtonDown = false;
        document.exitPointerLock();
        return;
    }
    
    const totalMovedDist = initialClickPos ? Math.hypot(e.clientX - initialClickPos.x, e.clientY - initialClickPos.y) : 0;

    const wasDrag = (totalMovedDist > MOVE_PX) || isDragging;

    if (wasDrag) {
        // Commit the stroke as a single command
        const actionsToCommit = [];
        currentStrokeVoxels.forEach(change => {
            // Only add actions that actually resulted in a change
            const currentVoxelState = voxels.has(key(change.action.gx, change.action.gy, change.action.gz)) ? voxels.get(key(change.action.gx, change.action.gy, change.action.gz)).color : null;
            if (change.originalColor !== currentVoxelState) { // Check if the voxel's state actually changed from its original state at stroke start
                actionsToCommit.push(change.action);
            }
        });
        addCommand(actionsToCommit);
    } else {
        // Single click action
        if (initialTargetVoxelCoords) {
            const finalVoxelCoords = { ...initialTargetVoxelCoords };

            const rawTargetAtDown = calculateRayTargetVoxelCoords(initialClickPos.x, initialClickPos.y);
            if (currentMode === Modes.ADD && rawTargetAtDown && rawTargetAtDown.faceNormal) {
                finalVoxelCoords.gx = rawTargetAtDown.gx + Math.round(rawTargetAtDown.faceNormal.x);
                finalVoxelCoords.gy = rawTargetAtDown.gy + Math.round(rawTargetAtDown.faceNormal.y);
                finalVoxelCoords.gz = rawTargetAtDown.gz + Math.round(rawTargetAtDown.faceNormal.z);
                
                finalVoxelCoords.gx = Math.max(0, Math.min(GRID - 1, finalVoxelCoords.gx));
                finalVoxelCoords.gy = Math.max(0, Math.min(GRID - 1, finalVoxelCoords.gy));
                finalVoxelCoords.gz = Math.max(0, Math.min(GRID - 1, finalVoxelCoords.gz));
            }

            const action = performVoxelModification(finalVoxelCoords.gx, finalVoxelCoords.gy, finalVoxelCoords.gz, currentMode, currentColor, false); // Do not record history here yet
            if (action) {
                addCommand([action]); // Add as a single-action command
            }
        }
    }

    pointerIsDown = false;
    isDragging = false;
    doubleTapDragActive = false;
    lastActionVoxelCoords = null;
    initialClickPos = null;
    initialTargetVoxelCoords = null;
    voxelsAtDragStart = null;
    currentStrokeVoxels.clear();
    updatePreviewVoxel(0, 0, 0, false);
    dragAxisLock = null;
    initialDragVoxelCoords = null;
    initialDragYLevel = null;
    
    if (e.pointerType === 'touch') {
        releasePointer(e.pointerId, e);
    }
}

function onPointerDown(e) {
    if (e.button === 2) {
        e.preventDefault();
        rightMouseButtonDown = true;
        cvs.focus();
        cvs.requestPointerLock();
        return;
    }
    if (isPointerLocked) return; // Wenn der Zeiger f√ºr die freie Bewegung gesperrt ist, andere Interaktionen verhindern

    if (e.button === 0 && e.altKey) { 
        const hitResult = calculateRayTargetVoxelCoords(e.clientX, e.clientY);
        if (hitResult && hitResult.hitExistingVoxel) {
            const gKey = key(hitResult.gx, hitResult.gy, hitResult.gz);
            if (voxels.has(gKey)) {
                const pickedColor = voxels.get(gKey).color;
                setActiveColor(pickedColor); // Use the new function to set color
            }
        }
        return; 
    }

    voxelsAtDragStart = new Map(voxels); // Capture state at drag start for undo/redo
    currentStrokeVoxels.clear(); // Clear for new stroke
    dragAxisLock = null;
    isDragging = false;
    initialDragVoxelCoords = null;
    initialDragYLevel = null;

    initialClickPos = { x: e.clientX, y: e.clientY };
    pointerIsDown = true;

    initialTargetVoxelCoords = calculateRayTargetVoxelCoords(e.clientX, e.clientY);
    if (initialTargetVoxelCoords && (!Number.isFinite(initialTargetVoxelCoords.gx) || !Number.isFinite(initialTargetVoxelCoords.gy) || !Number.isFinite(initialTargetVoxelCoords.gz))) {
        pointerIsDown = false; initialClickPos = null; initialTargetVoxelCoords = null;
        return;
    }
    
    if (initialTargetVoxelCoords && currentMode === Modes.ADD) {
        if (initialTargetVoxelCoords.hitExistingVoxel) {
            initialDragYLevel = initialTargetVoxelCoords.gy + Math.round(initialTargetVoxelCoords.faceNormal.y);
        } else {
            initialDragYLevel = initialTargetVoxelCoords.gy;
        }
    }


    if (e.pointerType === 'touch') {
        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY, pointerType: e.pointerType });
        touchIndicator.style.display = 'block'; touchIndicator.style.left = `${e.clientX}px`; touchIndicator.style.top = `${e.clientY}px`;
        const now = performance.now();

        if (activePointers.size > 1) {
            initialTargetVoxelCoords = null;
            currentStrokeVoxels.clear();
            updatePreviewVoxel(0, 0, 0, false);
            doubleTapDragActive = false;
            isDragging = false;
            initialDragVoxelCoords = null;
            initialDragYLevel = null;
            
            const pointersArr = [...activePointers.values()];
            const [p0, p1] = pointersArr;
            const midX = (p0.x + p1.x) * 0.5; const midY = (p0.y + p1.y) * 0.5; const dist = Math.hypot(p1.x - p0.x, p1.y - p0.y);
            gestureState.type = 'none'; gestureState.startMid = gestureState.lastMid = { x: midX, y: midY };
            gestureState.startDist = gestureState.lastDist = dist;
            gestureState.initialPointerCount = activePointers.size;
            return;
        }

        lastActionVoxelCoords = null; currentStrokeVoxels.clear();
        updatePreviewVoxel(0, 0, 0, false);
        gestureState.initialPointerCount = activePointers.size;
        if (activePointers.size === 1) { gestureState.type = 'rotate'; gestureState.lastMid = { x: e.clientX, y: e.clientY }; }
        
        if (initialTargetVoxelCoords) {
            isDragging = true; // Start dragging immediately for touch
            initialDragVoxelCoords = { ...initialTargetVoxelCoords };
            lastActionVoxelCoords = { ...initialTargetVoxelCoords };
            
            // Perform the initial modification and record it for the stroke
            performVoxelModification(initialTargetVoxelCoords.gx, initialTargetVoxelCoords.gy, initialTargetVoxelCoords.gz, currentMode, currentColor, true);
        }
        return;
    }

    if (e.pointerType === 'mouse' && e.button === 0) {
        lastX = e.clientX; lastY = e.clientY;
        updatePreviewVoxel(0, 0, 0, false);
    }
}

function onPointerMove(e) {
    e.preventDefault();
    if (isPointerLocked) { // Wenn der Zeiger f√ºr die freie Bewegung gesperrt ist, nur die Mausbewegung f√ºr die Kamera verarbeiten
        mouseMovementX += e.movementX; // Bewegung akkumulieren
        mouseMovementY += e.movementY; // Bewegung akkumulieren
        return; // Wichtig: fr√ºhzeitig zur√ºckkehren, um Voxel-Interaktion beim freien Bewegen zu verhindern
    }

    if (e.pointerType === 'touch' && activePointers.has(e.pointerId)) {
        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY, pointerType: e.pointerType });
        if (activePointers.size > 1) {
            handleGesture();
            updatePreviewVoxel(0, 0, 0, false);
            return;
        }
    }

    lastX = e.clientX;
    lastY = e.clientY;

    const currentMovedDist = initialClickPos ? Math.hypot(e.clientX - initialClickPos.x, e.clientY - initialClickPos.y) : 0;
    
    const shouldStartDrag = pointerIsDown && (currentMovedDist > MOVE_PX);

    let currentRayHit = calculateRayTargetVoxelCoords(e.clientX, e.clientY);
    let currentTargetVoxelCoords = null;

    if (currentRayHit) {
        let gx = currentRayHit.gx;
        let gy = currentRayHit.gy;
        let gz = currentRayHit.gz;

        // Korrigierte Logik f√ºr die Vorschau und Platzierung im Hinzuf√ºgen-Modus
        if (currentMode === Modes.ADD) {
            if (currentRayHit.hitExistingVoxel) {
                gx = currentRayHit.gx + Math.round(currentRayHit.faceNormal.x);
                gy = currentRayHit.gy + Math.round(currentRayHit.faceNormal.y);
                gz = currentRayHit.gz + Math.round(currentRayHit.faceNormal.z);
            } else {
                 if (currentDrawingAxis === 'y') {
                    gy = activeDrawingLevel.y;
                } else if (currentDrawingAxis === 'x') {
                    gx = activeDrawingLevel.x;
                } else if (currentDrawingAxis === 'z') {
                        gz = activeDrawingLevel.z;
                }
            }
        }
        
        gx = Math.floor(gx);
        gy = Math.floor(gy);
        gz = Math.floor(gz);

        gx = Math.max(0, Math.min(GRID - 1, gx));
        gy = Math.max(0, Math.min(GRID - 1, gy));
        gz = Math.max(0, Math.min(GRID - 1, gz));

        if (Number.isFinite(gx) && Number.isFinite(gy) && Number.isFinite(gz)) {
            currentTargetVoxelCoords = { gx: gx, gy: gy, gz: gz };
        } else {
            currentTargetVoxelCoords = null;
        }
    }
    
    if (pointerIsDown && currentTargetVoxelCoords) {
        if (!isDragging && shouldStartDrag) {
            isDragging = true;
            if (initialTargetVoxelCoords) {
                lastActionVoxelCoords = { ...initialTargetVoxelCoords };
            }
        }
        
        if (isDragging) {
            const startPointForLine = lastActionVoxelCoords;
            const endPointForLine = { ...currentTargetVoxelCoords };
            
            // Wende die Ebenensperre f√ºr den Hinzuf√ºgen-Modus an
            if (currentMode === Modes.ADD && initialDragYLevel !== null) {
                endPointForLine.gy = initialDragYLevel;
            }

            let pathVoxels = getVoxelsOnLine(startPointForLine, endPointForLine);

            // Filter voxels for delete/draw modes based on initial state at drag start
            if (currentMode === Modes.DELETE || currentMode === Modes.DRAW) {
                pathVoxels = pathVoxels.filter(voxel => voxelsAtDragStart.has(key(voxel.gx, voxel.gy, voxel.gz)));
            }

            for (let i = 0; i < pathVoxels.length; i++) {
                const voxel = pathVoxels[i];
                const gKey = key(voxel.gx, voxel.gy, voxel.gz);
                
                // Perform the modification and record it for the current stroke
                performVoxelModification(voxel.gx, voxel.gy, voxel.gz, currentMode, currentColor, true);
            }
            lastActionVoxelCoords = { ...endPointForLine };
            updatePreviewVoxel(currentTargetVoxelCoords.gx, currentTargetVoxelCoords.gy, currentTargetVoxelCoords.gz, true);

        } else {
            // Not dragging, just hovering or initial click not yet a drag
            if (currentTargetVoxelCoords) {
                let showPreview = false;
                const gKeyAtPreview = key(currentTargetVoxelCoords.gx, currentTargetVoxelCoords.gy, currentTargetVoxelCoords.gz);
                const hasVoxelAtPreview = voxels.has(gKeyAtPreview);

                if (currentMode === Modes.ADD) {
                    if (!hasVoxelAtPreview) { showPreview = true; }
                } else if (currentMode === Modes.DELETE || currentMode === Modes.DRAW) {
                    if (hasVoxelAtPreview) { showPreview = true; }
                }
                updatePreviewVoxel(currentTargetVoxelCoords.gx, currentTargetVoxelCoords.gy, currentTargetVoxelCoords.gz, showPreview);
            } else {
                updatePreviewVoxel(0, 0, 0, false);
            }
        }
    } else {
        // Pointer is not down, just hovering
        if (currentRayHit) {
            let hoverPreviewCoords = { gx: currentRayHit.gx, gy: currentRayHit.gy, gz: currentRayHit.gz };
            if (currentMode === Modes.ADD) {
                if (currentRayHit.hitExistingVoxel) {
                    hoverPreviewCoords.gx += Math.round(currentRayHit.faceNormal.x);
                    hoverPreviewCoords.gy += Math.round(currentRayHit.faceNormal.y);
                    hoverPreviewCoords.gz += Math.round(currentRayHit.faceNormal.z);
                } else {
                    if (currentDrawingAxis === 'y') {
                        hoverPreviewCoords.gy = activeDrawingLevel.y;
                    } else if (currentDrawingAxis === 'x') {
                        hoverPreviewCoords.gx = activeDrawingLevel.x;
                    } else if (currentDrawingAxis === 'z') {
                        hoverPreviewCoords.gz = activeDrawingLevel.z;
                    }
                }
            }
            
            hoverPreviewCoords.gx = Math.floor(hoverPreviewCoords.gx);
            hoverPreviewCoords.gy = Math.floor(hoverPreviewCoords.gy);
            hoverPreviewCoords.gz = Math.floor(hoverPreviewCoords.gz);

            hoverPreviewCoords.gx = Math.max(0, Math.min(GRID - 1, hoverPreviewCoords.gx));
            hoverPreviewCoords.gy = Math.max(0, Math.min(GRID - 1, hoverPreviewCoords.gy));
            hoverPreviewCoords.gz = Math.max(0, Math.min(GRID - 1, hoverPreviewCoords.gz));
            
            let showPreview = false;
            const gKeyAtPreview = key(hoverPreviewCoords.gx, hoverPreviewCoords.gy, hoverPreviewCoords.gz);
            const hasVoxelAtPreview = voxels.has(gKeyAtPreview);

            if (currentMode === Modes.ADD) {
                if (!hasVoxelAtPreview) { showPreview = true; }
            } else if (currentMode === Modes.DELETE || currentMode === Modes.DRAW) {
                if (hasVoxelAtPreview) { showPreview = true; }
            }
            updatePreviewVoxel(hoverPreviewCoords.gx, hoverPreviewCoords.gy, hoverPreviewCoords.gz, showPreview);
        } else {
            updatePreviewVoxel(0, 0, 0, false);
        }
    }
    
    if (e.pointerType === 'touch' && activePointers.size === 1 && !isDragging) {
        handleGesture();
    }
}


function cycleDrawingAxis() {
    const axes = ['x', 'y', 'z'];
    const currentIndex = axes.indexOf(currentDrawingAxis);
    currentDrawingAxis = axes[(currentIndex + 1) % axes.length];
    updateGridHelperPosition();
    showToast('Zeichenachse', `Achse: ${currentDrawingAxis.toUpperCase()}`, 'info', 1500);
}

function moveDrawingLevel(direction) {
    if (currentMode !== Modes.ADD && currentMode !== Modes.DRAW) {
        showToast('Hinweis', 'Ebenensteuerung nur im Hinzuf√ºgen- oder Zeichenmodus verf√ºgbar.', 'warning', 2000);
        return;
    }
    let level = activeDrawingLevel[currentDrawingAxis];

    if (!Number.isFinite(level)) {
        level = 0;
        activeDrawingLevel[currentDrawingAxis] = level;
    }

    level += direction;
    level = Math.max(0, Math.min(GRID - 1, level));
    activeDrawingLevel[currentDrawingAxis] = level;
    updateGridHelperPosition();
    showToast('Zeichenebene', `Achse: ${currentDrawingAxis.toUpperCase()}, Ebene: ${level}`, 'info', 1500);
}

function toggleMeshView() {
    isMeshViewMode = !isMeshViewMode;
    // Aktualisiere das Material f√ºr alle vorhandenen Chunks
    chunks.forEach(chunk => {
        chunk.instancedMesh.material = isMeshViewMode ? wireframeVoxelMaterial : standardVoxelMaterial;
    });
    // Aktualisiere das Vorschau-Voxel-Material
    previewVoxelMaterial.wireframe = isMeshViewMode;
    showToast('Mesh-Ansicht', isMeshViewMode ? 'Drahtgitter-Ansicht aktiviert.' : 'Standard-Ansicht aktiviert.', 'info', 2000);
}

/**
 * Toggles the block style between 'simple' (cube) and 'detailed' (brick).
 * Rebuilds all existing voxels with the new geometry.
 * @param {boolean} isInitialLoad - True if called during initial app load, prevents toast.
 */
function updateBlockStyle(isInitialLoad = false) {
    // Dispose old geometry if it exists
    if (defaultVoxelGeometry) {
        defaultVoxelGeometry.dispose();
    }

    if (currentBlockStyle === 'simple') {
        defaultVoxelGeometry = createSimpleCubeGeometry(VS);
        document.getElementById('blockStyleToggleBtn').textContent = 'Block-Stil: Einfach';
    } else { // 'detailed'
        defaultVoxelGeometry = createBrickGeometry(VS);
        document.getElementById('blockStyleToggleBtn').textContent = 'Block-Stil: Detailliert';
    }

    // Update ACTUAL_BRICK_HEIGHT based on the new geometry
    defaultVoxelGeometry.computeBoundingBox();
    ACTUAL_BRICK_HEIGHT = defaultVoxelGeometry.boundingBox.max.y;

    // Re-initialize all chunks with the new geometry
    const currentVoxelsData = [];
    voxels.forEach((data, gKey) => {
        const [gx, gy, gz] = parseKey(gKey);
        currentVoxelsData.push({ gx, gy, gz, color: data.color });
    });

    // Dispose existing chunks
    for (const chunk of chunks.values()) {
        chunk.dispose();
    }
    chunks.clear();
    voxels.clear(); // Clear the global voxels map as well to rebuild it

    // Re-add all voxels with the new geometry
    currentVoxelsData.forEach(v => {
        _addSingleVoxel(v.gx, v.gy, v.gz, v.color);
    });

    // Update preview voxel mesh
    if (previewVoxelMesh) {
        scene.remove(previewVoxelMesh);
        previewVoxelMesh.geometry.dispose();
    }
    previewVoxelMesh = new THREE.Mesh(defaultVoxelGeometry, previewVoxelMaterial);
    scene.add(previewVoxelMesh);
    updatePreviewVoxel(0, 0, 0, false); // Hide initially

    rebuildHelpers(); // Rebuild grid and box helpers

    if (!isInitialLoad) {
        localStorage.setItem('voxelEditorBlockStyle', currentBlockStyle);
        showToast('Block-Stil ge√§ndert', `Block-Stil auf "${currentBlockStyle === 'simple' ? 'Einfach' : 'Detailliert'}" ge√§ndert.`, 'info', 2000);
    }
}


window.onload = async function() {
    closeAllModals();
    try {
        cvs = document.getElementById('voxelCanvas'); containerDiv = document.getElementById('container');
        touchIndicator = document.getElementById('touch-indicator');
        toastContainer = document.getElementById('toast-container');
        scene = new THREE.Scene(); scene.background = new THREE.Color(0x282c34);
        cam = new THREE.PerspectiveCamera(75, containerDiv.clientWidth / containerDiv.clientHeight, 0.1, 1000);
        resetCameraPosition(); euler = new THREE.Euler(0, 0, 0, 'YXZ');
        ren = new THREE.WebGLRenderer({ canvas: cvs, antialias: true });
        ren.setSize(containerDiv.clientWidth, containerDiv.clientHeight);
        isMobile = window.matchMedia('(max-width: 768px)').matches;
        ren.setPixelRatio(isMobile ? Math.min(1.5, window.devicePixelRatio) : window.devicePixelRatio);
        ren.shadowMap.enabled = true; ren.shadowMap.type = THREE.PCFSoftShadowMap;
      
        scene.add(new THREE.AmbientLight(0x606060));
        mainDirectionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        mainDirectionalLight.position.set(10, 20, 15); mainDirectionalLight.castShadow = true;
        mainDirectionalLight.shadow.mapSize.width = mainDirectionalLight.shadow.mapSize.height = 2048;
        mainDirectionalLight.shadow.camera.near = 0.5; mainDirectionalLight.shadow.camera.far = 50;
        mainDirectionalLight.shadow.camera.left = -30; mainDirectionalLight.shadow.camera.right = 30;
        mainDirectionalLight.shadow.camera.top = 30; mainDirectionalLight.shadow.camera.bottom = -30;
        mainDirectionalLight.shadow.bias = -0.0005; mainDirectionalLight.shadow.normalBias = 0.02;
        scene.add(mainDirectionalLight);
        const secondDirectionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
        secondDirectionalLight.position.set(-10, 10, -15);
        scene.add(secondDirectionalLight);
        scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.6));
        
        // Initialize defaultVoxelGeometry based on localStorage or default
        updateBlockStyle(true); // true for initial load to prevent toast

        // Initialize previewVoxelMesh with the correct defaultVoxelGeometry
        previewVoxelMesh = new THREE.Mesh(defaultVoxelGeometry, previewVoxelMaterial);
        scene.add(previewVoxelMesh); updatePreviewVoxel(0,0,0,false);

        rebuildHelpers();

        window.addEventListener('resize', onResize);
        containerDiv.addEventListener('pointerdown', onPointerDown);
        containerDiv.addEventListener('pointermove', onPointerMove); // Dieser Listener verarbeitet jetzt alle Zeigerbewegungen
        containerDiv.addEventListener('pointerup', onPointerUp);
        containerDiv.addEventListener('pointercancel', onPointerUp);
        containerDiv.addEventListener('pointerleave', onPointerLeave);
        containerDiv.addEventListener('wheel', onMouseWheel, { passive: false });
        document.addEventListener('keydown', onKeyDown); document.addEventListener('keyup', onKeyUp);
        document.addEventListener('pointerlockchange', onPointerLockChange, false);
        // Der separate mousemove-Listener wurde hier entfernt, da onPointerMove ihn jetzt verarbeitet
        containerDiv.addEventListener('contextmenu', (e) => e.preventDefault());

        // --- Grid Size Slider Event Listener ---
        document.getElementById('grid-size-slider').addEventListener('input', (e) => {
            const oldGrid = GRID;
            const newGrid = parseInt(e.target.value);

            if (newGrid < oldGrid) {
                let voxelsWouldBeLost = false;
                for (const [id, data] of voxels.entries()) {
                    const p = parseKey(id);
                    if (p[0] >= newGrid || p[1] >= newGrid || p[2] >= newGrid) {
                        voxelsWouldBeLost = true;
                        break;
                    }
                }

                if (voxelsWouldBeLost) {
                    // Add a debounce or a flag to prevent rapid toast messages
                    const now = Date.now();
                    if (!this._lastGridSizeToastTime || (now - this._lastGridSizeToastTime > 2000)) { // 2 seconds debounce
                        showToast('Warnung', 'Gittergr√∂√üe kann nicht reduziert werden, da sonst vorhandene Voxel au√üerhalb des Rasters verloren gehen w√ºrden.', 'warning', 5000);
                        this._lastGridSizeToastTime = now;
                    }
                    e.target.value = oldGrid;
                    document.getElementById('grid-size-display').textContent = `${oldGrid}√ó${oldGrid}√ó${oldGrid}`;
                    return;
                }
            }
            
            const oldVoxelState = [];
            voxels.forEach((data, gKey) => {
                const [gx, gy, gz] = parseKey(gKey);
                oldVoxelState.push({ type: 'add', gx, gy, gz, color: data.color }); // Treat current voxels as 'adds' for undo
            });

            // Temporarily change GRID and clear/re-add voxels to get newVoxelState
            const tempOldGrid = GRID;
            GRID = newGrid;
            for (const chunk of chunks.values()) chunk.dispose(); chunks.clear(); voxels.clear();
            
            const newVoxelState = [];
            oldVoxelState.filter(v => v.gx < newGrid && v.gy < newGrid && v.gz < newGrid).forEach(v => {
                _addSingleVoxel(v.gx, v.gy, v.gz, v.color);
                newVoxelState.push({ type: 'add', gx: v.gx, gy: v.gy, gz: v.gz, color: v.color });
            });
            
            // Revert GRID to tempOldGrid before adding command to history,
            // as executeCommand will set the correct GRID
            GRID = tempOldGrid; 

            addCommand([{ type: 'resizeGrid', oldGrid: oldGrid, newGrid: newGrid, oldVoxelState: oldVoxelState, newVoxelState: newVoxelState }]);
            
            // Execute the command to apply the new grid size and state
            executeCommand(history[historyPointer], false);
        });

        // --- Custom Color Picker Logic ---
        const colorPickerSwatch = document.getElementById('color-picker-swatch');
        const customColorPaletteModal = document.getElementById('customColorPaletteModal');
        const moreColorsBtn = document.getElementById('moreColorsBtn');
        const hiddenNativeColorPicker = document.getElementById('hidden-native-color-picker');
        const commonColorSwatches = customColorPaletteModal.querySelectorAll('.color-grid .color-swatch-item:not(input[type="color"])');
        const closeColorPaletteModalBtn = document.getElementById('closeColorPaletteModalBtn');

        // Main color swatch click to open custom palette
        colorPickerSwatch.addEventListener('click', () => {
            customColorPaletteModal.showModal();
            // Ensure the hidden native picker's value is synced
            hiddenNativeColorPicker.value = currentColor;
            // Highlight the active color in the palette
            commonColorSwatches.forEach(swatch => {
                if (swatch.dataset.color === currentColor) {
                    swatch.classList.add('active');
                } else {
                    swatch.classList.remove('active');
                }
            });
            palettePresetBoxes.forEach(box => {
                if (box.value === currentColor) {
                    box.classList.add('active');
                } else {
                    box.classList.remove('active');
                }
            });
        });

        // Click on common color swatches in the palette
        commonColorSwatches.forEach(swatch => {
            swatch.addEventListener('click', (e) => {
                setActiveColor(e.target.dataset.color);
                customColorPaletteModal.close();
            });
        });

        // Preset color inputs in the main controls
        presetBoxes = [
            document.getElementById('color-preset-1'),
            document.getElementById('color-preset-2'),
            document.getElementById('color-preset-3')
        ];
        // Preset color inputs within the custom palette modal
        palettePresetBoxes = [
            document.getElementById('palette-color-preset-1'),
            document.getElementById('palette-color-preset-2'),
            document.getElementById('palette-color-preset-3')
        ];

        presetColors.forEach((color, i) => {
            // Event listeners for the main controls preset boxes
            const mainBox = presetBoxes[i];
            mainBox.value = color;
            mainBox.addEventListener('click', (e) => setActivePreset(i));
            mainBox.addEventListener('input', (e) => savePresetColor(i, e.target.value));

            // Event listeners for the palette modal preset boxes
            const paletteBox = palettePresetBoxes[i];
            paletteBox.value = color;
            // Clicking these in the palette should also set the active color and close the modal
            paletteBox.addEventListener('click', (e) => {
                setActivePreset(i);
                customColorPaletteModal.close();
            });
            // Input event for changing the preset color from within the palette
            paletteBox.addEventListener('input', (e) => savePresetColor(i, e.target.value));
        });

        // "More Colors" button click to open native picker
        moreColorsBtn.addEventListener('click', () => {
            hiddenNativeColorPicker.click();
        });

        // Hidden native color picker events
        hiddenNativeColorPicker.addEventListener('input', (e) => {
            // This fires as the user drags in the native picker
            setActiveColor(e.target.value);
        });
        hiddenNativeColorPicker.addEventListener('change', (e) => {
            // This fires when the user confirms selection (e.g., clicks OK or closes the native picker)
            setActiveColor(e.target.value);
            customColorPaletteModal.close(); // Close our custom palette once native picker is dismissed
        });

        closeColorPaletteModalBtn.addEventListener('click', () => customColorPaletteModal.close());
        customColorPaletteModal.addEventListener('cancel', () => customColorPaletteModal.close()); // Close on Escape key

        setActiveColor(currentColor); // Initialize the color swatch and active state

        document.getElementById('modeToggle').addEventListener('click', cycleMode);
        document.getElementById('current-mode').textContent = `Modus: ${currentMode}`;
        document.getElementById('blockStyleToggleBtn').addEventListener('click', () => { 
            currentBlockStyle = (currentBlockStyle === 'simple' ? 'detailed' : 'simple'); 
            updateBlockStyle(); 
        });

        document.getElementById('clearBtn').addEventListener('click', () => document.getElementById('clearConfirmationModal').showModal());
        document.getElementById('saveAndClearBtn').addEventListener('click', () => { saveJSON(); clearAll(); document.getElementById('clearConfirmationModal').close(); });
        document.getElementById('clearWithoutSaveBtn').addEventListener('click', () => { clearAll(); document.getElementById('clearConfirmationModal').close(); });
        document.getElementById('cancelClearBtn').addEventListener('click', () => document.getElementById('clearConfirmationModal').close());
        document.getElementById('clearConfirmationModal').addEventListener('cancel', () => document.getElementById('clearConfirmationModal').close());

        document.getElementById('fillLevelBtn').addEventListener('click', fillActiveLevel);
        document.getElementById('saveBtn').addEventListener('click', saveJSON);
        document.getElementById('loadBtn').addEventListener('click', () => document.getElementById('fileInput').click());
        document.getElementById('fileInput').addEventListener('change', loadJSON);
        document.getElementById('exportStlBtn').addEventListener('click', openStlExportModal);
        document.getElementById('confirmStlExportBtn').addEventListener('click', () => {
            const selectedUnit = document.querySelector('input[name="export-unit"]:checked').value;
            exportSTL(selectedUnit);
        });
        document.getElementById('cancelStlExportBtn').addEventListener('click', () => document.getElementById('exportStlModal').close());

        document.getElementById('undoBtn').addEventListener('click', undo);
        document.getElementById('redoBtn').addEventListener('click', redo);

        document.getElementById('fly-speed-slider').addEventListener('input', (e) => {
            moveSpeed = parseFloat(e.target.value); document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2); localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
        });

        document.getElementById('resetCameraBtn').addEventListener('click', resetCameraPosition);
        
        document.getElementById('loadImageTemplateBtn').addEventListener('click', loadImageTemplate);
        document.getElementById('imageFileInput').addEventListener('change', handleImageFileSelect);
        document.getElementById('removeImageTemplateBtn').addEventListener('click', removeImageTemplate);

        document.getElementById('toggleMeshViewBtn').addEventListener('click', toggleMeshView); // Neuer Button-Listener

        const mediaQuery = window.matchMedia('(max-width: 768px)');
        function handleMediaQueryChange(e) {
            isMobile = e.matches;
            const controlsPanel = document.getElementById('controls');
            const mobileControls = document.getElementById('mobile-controls');
            
            if (e.matches) {
                controlsPanel.classList.add('hidden');
                mobileControls.classList.remove('hidden');
                mobileControls.classList.add('flex');
                toastContainer.classList.remove('toast-end');
                toastContainer.classList.add('toast-top-center');
            }
            else {
                controlsPanel.classList.remove('hidden');
                controlsPanel.classList.add('flex');
                mobileControls.classList.add('hidden');
                mobileControls.classList.remove('flex');
                toastContainer.classList.remove('toast-top-center');
                toastContainer.classList.add('toast-end');
            }
            onResize();
            rebuildHelpers();
            const mobileModeIcon = document.getElementById('mobile-mode-icon');
            if (mobileModeIcon) {
                mobileModeIcon.textContent = ModeIcons[currentMode];
            }
        }
        mediaQuery.addListener(handleMediaQueryChange); handleMediaQueryChange(mediaQuery);

        document.getElementById('mobile-undo').addEventListener('click', (e) => { e.stopPropagation(); undo(); });
        document.getElementById('mobile-redo').addEventListener('click', (e) => { e.stopPropagation(); redo(); });
        document.getElementById('mobile-save').addEventListener('click', (e) => { e.stopPropagation(); saveJSON(); });
        document.getElementById('mobile-camera').addEventListener('click', (e) => { e.stopPropagation(); resetCameraPosition(); });
        document.getElementById('mobile-mode-toggle').addEventListener('click', (e) => { e.stopPropagation(); cycleMode(); });
        
        const mobileColorPickerBtn = document.getElementById('mobile-color-picker-btn');
        const mobileColorInput = document.getElementById('mobile-color-input');
        
        mobileColorPickerBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            mobileColorInput.click();
        });

        mobileColorInput.addEventListener('input', (e) => {
            setActiveColor(e.target.value); // Use the new function to set color
        });
        mobileColorInput.addEventListener('change', (e) => {
            setActiveColor(e.target.value); // Use the new function to set color
        });

        mobileColorInput.value = currentColor;

        document.getElementById('mobile-level-up').addEventListener('click', (e) => { e.stopPropagation(); moveDrawingLevel(1); });
        document.getElementById('mobile-level-down').addEventListener('click', (e) => { e.stopPropagation(); moveDrawingLevel(-1); });
        
        const mobileLoginLogoutBtn = document.getElementById('mobile-login-logout');
        mobileLoginLogoutBtn.addEventListener('click', (e) => { e.stopPropagation(); loginLogout(); });

        document.getElementById('grid-size-slider').value = GRID; document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`;
        document.getElementById('fly-speed-slider').value = moveSpeed; document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
        
        document.getElementById('mobile-mode-icon').textContent = ModeIcons[currentMode];

        const app = window.firebase.initializeApp(window.firebaseConfig);
        auth = window.firebase.getAuth(app); db = window.firebase.getFirestore(app);
        const loginLogoutBtn = document.getElementById('loginLogoutBtn');
        const uploadToHubBtn = document.getElementById('uploadToHubBtn');
        const userIdDisplay = document.getElementById('userIdDisplay');
        const goToHubBtn = document.getElementById('goToHubBtn');
        let projectLoadedFromUrl = false;
        
        // Try to load autosave first
        const loadedFromAutosave = loadAutosave();
        if (loadedFromAutosave) {
            projectLoadedFromUrl = true; // Prevent URL loading if autosave succeeded
        } else {
            // If autosave failed or didn't exist, ensure block style is set to default
            currentBlockStyle = 'simple';
            updateBlockStyle(true);
        }

        // Start autosave interval
        setInterval(saveAutosave, 60 * 1000); // Autosave every 60 seconds

        predefinedCategories.forEach(cat => { const opt = document.createElement('option'); opt.value = cat; opt.textContent = cat; document.getElementById('uploadCategory').appendChild(opt); });

        window.firebase.setPersistence(auth, window.firebase.browserLocalPersistence)
            .then(async () => {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    try { await window.firebase.signInWithCustomToken(auth, __initial_auth_token); }
                    catch (e) { showToast('Anmeldefehler', `Fehler beim Anmelden mit Token: ${e.message}. Bitte versuchen Sie es erneut.`, 'error', 5000); }
                } else {
                }

                window.firebase.onAuthStateChanged(auth, async (user) => {
                    currentUserId = user ? user.uid : null; currentUser = user;
                    loginLogoutBtn.textContent = user ? 'Abmelden' : 'Anmelden';
                    userIdDisplay.innerHTML = user ? `<img src="${user.photoURL || 'https://placehold.co/24x24/cccccc/000000?text=U'}" alt="User Avatar" class="w-6 h-6 rounded-full align-middle">` : '';
                    uploadToHubBtn.classList.toggle('hidden', !user);
                    mobileLoginLogoutBtn.textContent = user ? 'üö™' : 'üîë';
                    if (user) document.getElementById('authModal').close();

                    if (!projectLoadedFromUrl) { // Only load from URL if not already loaded from autosave
                        const urlParams = new URLSearchParams(window.location.search);
                        const modelId = urlParams.get('modelId'); const encodedJson = urlParams.get('projectJson');
                        if (modelId) { await loadProjectFromModelId(modelId); projectLoadedFromUrl = true; }
                        else if (encodedJson) {
                            try {
                                const decodedJson = decodeURIComponent(encodedJson);
                                loadProjectData(JSON.parse(decodedJson));
                                showToast('Projekt geladen', 'Projekt erfolgreich aus URL-Parameter geladen.', 'success', 5000);
                                projectLoadedFromUrl = true;
                            } catch (e) { showToast('Fehler', 'Fehler beim Laden des Projekts aus der URL. Ung√ºltige oder besch√§digte Projektdaten. Fehler: ' + e.message, 'error', 5000); resetToDefaultProject(); }
                        } else { projectRemixOf = ''; projectSourceJsonUrl = ''; }
                    }
                });
                animate();
            })
            .catch((e) => { showToast('Anmeldefehler', `Fehler bei der Anmeldungspersistenz: ${e.message}.`, 'error', 10000); animate(); });

        document.getElementById('goToHubBtn').addEventListener('click', () => window.open('https://hub.voxelshaper.com', '_blank'));
        loginLogoutBtn.addEventListener('click', loginLogout);
        document.getElementById('authModal').addEventListener('click', (e) => { if (e.target === document.getElementById('authModal')) closeAuthModal(); });
        document.getElementById('authModalCloseBtn').addEventListener('click', closeAuthModal);
        document.getElementById('signInGoogleBtn').addEventListener('click', window.signInWithGoogle);
        document.getElementById('signInGithubBtn').addEventListener('click', window.signInGithub);
        document.getElementById('emailSignInBtn').addEventListener('click', window.signInEmailPassword);
        document.getElementById('emailSignUpBtn').addEventListener('click', window.signUpEmailPassword);
        document.getElementById('showEmailLoginFormBtn').addEventListener('click', () => document.getElementById('emailLoginForm').classList.remove('hidden'));
        document.getElementById('uploadToHubBtn').addEventListener('click', openUploadModal);
        document.getElementById('uploadProjectModal').addEventListener('click', (e) => { if (e.target === document.getElementById('uploadProjectModal')) { document.getElementById('uploadProjectModal').close(); cvs.focus(); } });
        document.getElementById('uploadConfirmBtn').addEventListener('click', uploadProjectToHub);
        document.getElementById('uploadCancelBtn').addEventListener('click', () => { document.getElementById('uploadProjectModal').close(); cvs.focus(); });
    } catch (e) { showToast('Schwerer Fehler', `Ein unerwarteter Fehler ist aufgetreten: ${e.message}.`, 'error', 10000); }
};

const frustum = new THREE.Frustum(); const tempCameraMatrix = new THREE.Matrix4();
function animate() {
    requestAnimationFrame(animate);
    if (isPointerLocked) {
        if (firstMoveAfterLock) {
            // Jegliche akkumulierte Bewegung vor der Sperre verwerfen.
            // Dies verhindert einen "Sprung", wenn die Maus beim Dr√ºcken der rechten Maustaste bewegt wurde.
            mouseMovementX = 0;
            mouseMovementY = 0;
            firstMoveAfterLock = false;
        }
        
        // Rotation basierend auf akkumulierter Bewegung anwenden
        euler.y -= mouseMovementX * rotSpeed;
        euler.x -= mouseMovementY * rotSpeed;
        euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
        cam.quaternion.setFromEuler(euler);
        
        // Bewegungsspeicher f√ºr den n√§chsten Frame zur√ºcksetzen
        mouseMovementX = 0;
        mouseMovementY = 0; 

        // Restliche Bewegungslogik (w,s,a,d,e,q)
        const camDir = new THREE.Vector3(); cam.getWorldDirection(camDir);
        const rightDir = new THREE.Vector3().crossVectors(camDir, cam.up).normalize();
        const upVec = new THREE.Vector3(0, 1, 0); const currMoveSpeed = moveSpeed * 0.5;
        if (keyboard['w']) cam.position.addScaledVector(camDir, currMoveSpeed);
        if (keyboard['s']) cam.position.addScaledVector(camDir, -currMoveSpeed);
        if (keyboard['a']) cam.position.addScaledVector(rightDir, -currMoveSpeed);
        if (keyboard['d']) cam.position.addScaledVector(rightDir, currMoveSpeed);
        if (keyboard['e']) cam.position.addScaledVector(upVec, currMoveSpeed);
        if (keyboard['q']) cam.position.addScaledVector(upVec, -currMoveSpeed);
    }
    cam.updateMatrixWorld(); tempCameraMatrix.multiplyMatrices(cam.projectionMatrix, cam.matrixWorldInverse);
    frustum.setFromProjectionMatrix(tempCameraMatrix);
    for (const chunk of chunks.values()) chunk.instancedMesh.visible = frustum.intersectsBox(chunk.boundingBox);
    ren.render(scene, cam);
}
</script></body></html>
