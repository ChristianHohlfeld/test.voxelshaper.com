<!DOCTYPE html>
<html lang="de" data-theme="dark">
<head>
<meta charset="UTF-8">
<meta property="og:title" content="VoxelShaper ‚Äì Create in 3D, Effortlessly" />
<meta property="og:description" content="A powerful, intuitive voxel-based 3D editor ‚Äì made for makers, artists, and coders." />
<meta property="og:image" content="https://voxelshaper.com/preview.png" />
<meta property="og:url" content="https://voxelshaper.com/" />
<meta property="og:type" content="website" />
<meta name="viewport"
      content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover">
<link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAAANl..."/>

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="VoxelShaper ‚Äì Create in 3D, Effortlessly">
<meta name="twitter:description" content="A powerful, intuitive voxel-based 3D editor ‚Äì made for makers, artists, and coders.">
<meta name="twitter:image" content="https://voxelshaper.com/preview.png">
<title>VoxelShaper ‚Äì Voxel Editor & 3D Print Exporter</title>

<link href="https://cdn.jsdelivr.net/npm/daisyui@4.7.2/dist/full.min.css" rel="stylesheet" type="text/css" />
<script src="https://cdn.tailwindcss.com"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>


<style>
body {
    padding-top: env(safe-area-inset-top);
    padding-bottom: env(safe-area-inset-bottom);
    padding-left: env(safe-area-inset-left);
    padding-right: env(safe-area-inset-right);
    box-sizing: border-box;
    touch-action: auto; /* Allow default touch actions unless overridden by specific elements */
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
}
/* Ensure elements that should prevent double-tap zoom have touch-action: manipulation */
button, input, select, textarea, .modal-box {
    touch-action: manipulation;
}
#container, #voxelCanvas {
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
    -webkit-touch-callout: none;
    touch-action: none; /* Prevents all default touch actions like scroll/zoom on canvas */
}
/* Removed .touch-indicator styling as it's no longer displayed */
input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
input[type="color"]::-webkit-color-swatch { border: none; border-radius: 50%; }
input[type="color"]::-moz-color-swatch-wrapper { padding: 0; }
input[type="color"]::-moz-color-swatch { border: none; border-radius: 50%; }
.color-preset-box::-webkit-color-swatch-wrapper { padding: 0; }
.color-preset-box::-webkit-color-swatch { border: none; border-radius: 0.375rem; }
.color-preset-box::-moz-color-swatch-wrapper { padding: 0; }
.color-preset-box::-moz-color-swatch { border: none; border-radius: 0.375rem; }

#toast-container {
    position: fixed;
    z-index: 50;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    padding: 1rem;
    pointer-events: none;
}

#toast-container.toast-end {
    bottom: 1rem;
    right: 1rem;
    align-items: flex-end;
}

@media (max-width: 768px) {
    #toast-container {
        top: 1rem;
        left: 50%;
        transform: translateX(-50%);
        width: calc(100% - 2rem);
        max-width: 300px;
        align-items: center;
    }
    #toast-container.toast-end {
        bottom: auto;
        right: auto;
    }
}

.toast .alert {
    pointer-events: auto;
    opacity: 0;
    transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
    transform: translateY(20px);
}

.toast .alert.show {
    opacity: 1;
    transform: translateY(0);
}

@media (max-width: 768px) {
    .toast .alert {
        padding: 0.5rem 0.75rem;
        font-size: 0.875rem;
    }
    .toast .alert svg {
        width: 1.25rem;
        height: 1.25rem;
    }
    .toast .alert strong {
        font-size: 0.9rem;
    }
    .toast .alert span {
        font-size: 0.8rem;
    }
    .toast .alert .close-btn {
        font-size: 1rem;
        padding: 0.25rem;
    }
}
.mobile-btn {
    width: 64px;
    height: 64px;
    font-size: 2rem;
    border-radius: 50%;
    background-color: var(--fallback-b3, oklch(var(--b3)/1));
    color: var(--fallback-bc, oklch(var(--bc)/1));
    border: 2px solid var(--fallback-bc, oklch(var(--bc)/1));
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
    transition: background-color 0.2s, transform 0.2s;
}

.mobile-btn:hover {
    background-color: oklch(var(--bc)/0.2);
}

.mobile-btn:active {
    transform: scale(0.95);
}

#mobile-controls {
    gap: 1rem;
}
</style>
</head>
<body class="bg-base-100 min-h-screen text-base-content flex flex-col">
<button id="menuToggle" aria-label="Men√º umschalten" class="fixed top-4 right-4 z-[1500] w-10 h-10 text-xl leading-10 text-center bg-base-300 text-base-content border-none rounded-lg cursor-pointer shadow-md hover:bg-base-content/20 lg:hidden">‚ò∞</button>

<div id="controls" class="flex flex-wrap items-center justify-center gap-3 p-4 bg-base-200 border-b border-base-content/20 hidden md:flex">
    <label for="grid-size-slider" class="text-base-content">Gittergr√∂√üe:</label>
    <input type="range" id="grid-size-slider" min="5" max="180" value="10" aria-label="Gittergr√∂√üe anpassen" class="range range-xs w-36">
    <span id="grid-size-display" class="font-bold text-primary">10√ó10√ó10</span>
    
    <label for="color-picker" class="text-base-content">Farbe:</label>
    <input type="color" id="color-picker" value="#ffffff" aria-label="Aktuelle Farbe w√§hlen" class="input input-bordered w-10 h-10 p-0 rounded-full cursor-pointer border-base-content/20">
    <input type="color" id="color-preset-1" class="color-preset-box w-10 h-10 rounded-md border-2 border-base-content/20 cursor-pointer transition-all duration-200 hover:scale-110" value="#E4002B" aria-label="Voreingestellte Farbe 1">
    <input type="color" id="color-preset-2" class="color-preset-box w-10 h-10 rounded-md border-2 border-base-content/20 cursor-pointer transition-all duration-200 hover:scale-110" value="#00A040" aria-label="Voreingestellte Farbe 2">
    <input type="color" id="color-preset-3" class="color-preset-box w-10 h-10 rounded-md border-2 border-base-content/20 cursor-pointer flex items-center justify-center shadow-lg hover:bg-base-content/20" value="#0057B8" aria-label="Voreingestellte Farbe 3">

    <button id="modeToggle" aria-label="Modus wechseln" class="btn btn-sm btn-neutral">Modus wechseln</button><span id="current-mode" class="font-bold text-success min-w-40 text-center">Modus: Hinzuf√ºgen</span>
    <button id="clearBtn" aria-label="Alles l√∂schen" class="btn btn-sm btn-neutral">Alles l√∂schen</button>
    <button id="fillLevelBtn" aria-label="Ebene f√ºllen" class="btn btn-sm btn-neutral">Ebene f√ºllen</button>
    <button id="saveBtn" aria-label="Projekt speichern" aria-describedby="save-description" class="btn btn-sm btn-neutral">Projekt speichern</button>
    <div id="save-description" class="sr-only">Speichert das aktuelle Projekt als JSON-Datei</div>
    <button id="loadBtn" aria-label="Projekt laden" class="btn btn-sm btn-neutral">Projekt laden</button>
    <!-- Consolidated Export Button -->
    <button id="exportBtn" aria-label="Exportieren" class="btn btn-sm btn-primary">Exportieren</button>

    <label for="fly-speed-slider" class="text-base-content">Fluggeschwindigkeit:</label>
    <input type="range" id="fly-speed-slider" min="0.01" max="1.0" step="0.01" value="0.1" aria-label="Fluggeschwindigkeit anpassen" class="range range-xs w-36">
    <span id="fly-speed-display" class="font-bold text-primary">0.10</span>

    <button id="resetCameraBtn" aria-label="Kamera zur√ºcksetzen" class="btn btn-sm btn-neutral">Zur Szene zur√ºckkehen</button>

    <button id="loadImageTemplateBtn" aria-label="Bild als Vorlage laden" class="btn btn-sm btn-neutral">Bild als Vorlage laden</button>
    <button id="removeImageTemplateBtn" class="btn btn-sm btn-neutral hidden" aria-label="Bildvorlage entfernen">Bildvorlage entfernen</button>
    <input type="file" id="imageFileInput" accept="image/*" class="hidden">

    <button id="loginLogoutBtn" aria-label="Anmelden oder Abmelden" class="btn btn-sm btn-info">Anmelden</button>
    <span id="userIdDisplay" class="font-bold text-info ml-2 mr-2 whitespace-nowrap overflow-hidden text-ellipsis max-w-xs flex items-center gap-1"></span>
    <button id="uploadToHubBtn" aria-label="Auf Hub hochladen" class="btn btn-sm btn-warning">Auf Hub hochladen</button>
    <button id="goToHubBtn" aria-label="Zum VoxelShaper Hub wechseln" class="btn btn-sm btn-secondary">Zum Hub</button>
    <!-- Removed Share Link Button as requested -->
</div>

<div id="container" class="flex-1 relative border-2 border-transparent box-border overflow-hidden">
    <canvas id="voxelCanvas" class="w-full h-full block box-border"></canvas>
    <!-- Removed touch-indicator as per request -->
    <input type="file" id="fileInput" accept=".json" class="hidden">
</div>

<dialog id="clearConfirmationModal" class="modal">
    <div class="modal-box bg-base-200 text-base-content p-8 text-center shadow-xl max-w-md">
        <h3 class="font-bold text-lg text-primary mb-4">Projekt l√∂schen</h3>
        <p class="py-4">M√∂chten Sie das aktuelle Projekt speichern, bevor Sie alle Voxel l√∂schen?</p>
        <div class="modal-buttons flex justify-around gap-4 mt-6">
            <button id="saveAndClearBtn" class="confirm-save btn btn-success flex-1">Speichern & L√∂schen</button>
            <button id="clearWithoutSaveBtn" class="confirm-no-save btn btn-error flex-1">Ohne Speichern l√∂schen</button>
            <button id="cancelClearBtn" class="cancel btn btn-ghost flex-1">Abbrechen</button>
        </div>
    </div>
</dialog>

<dialog id="uploadProjectModal" class="modal">
    <div class="upload-modal-content modal-box bg-base-200 text-base-content p-8 shadow-xl max-w-xl w-11/12 text-left">
        <h3 class="font-bold text-lg text-primary text-center mb-6">Projekt auf Hub hochladen</h3>
        <label for="uploadTitle" class="label block mb-2 font-bold">Titel:</label>
        <input type="text" id="uploadTitle" placeholder="Ein aussagekr√§ftiger Titel f√ºr Ihr Projekt" maxlength="100" class="input input-bordered w-full bg-base-300 border-base-content/20 mb-4">

        <label for="uploadDescription" class="label block mb-2 font-bold">Beschreibung:</label>
        <textarea id="uploadDescription" placeholder="Beschreiben Sie Ihr Projekt kurz" maxlength="500" class="textarea textarea-bordered w-full bg-base-300 border-base-content/20 h-24 mb-4 resize-y"></textarea>

        <label for="uploadCategory" class="label block mb-2 font-bold">Kategorie:</label>
        <select id="uploadCategory" class="select select-bordered w-full bg-base-300 border-base-content/20 mb-4" required>
            <option value="" disabled selected>Kategorie ausw√§hlen</option>
        </select>

        <label for="uploadTags" class="label block mb-2 font-bold">Tags (Komma-getrennt):</label>
        <input type="text" id="uploadTags" placeholder="z.B. Haus, Baum, Auto, Geb√§ude" maxlength="100" class="input input-bordered w-full bg-base-300 border-base-content/20 mb-4">

        <label class="label block mb-2 font-bold">Sichtbarkeit:</label>
        <div class="radio-group flex gap-4 mb-4">
            <label class="flex items-center font-normal">
                <input type="radio" name="uploadVisibility" value="public" checked class="radio radio-primary mr-2"> √ñffentlich
            </label>
            <label class="flex items-center font-normal">
                <input type="radio" name="uploadVisibility" value="private" class="radio radio-primary mr-2"> Privat
            </label>
        </div>

        <div class="upload-modal-buttons flex justify-around gap-4 mt-6">
            <button id="uploadConfirmBtn" class="upload-confirm btn btn-success flex-1">Hochladen</button>
            <button id="uploadCancelBtn" class="upload-cancel btn btn-ghost flex-1">Abbrechen</button>
        </div>
    </div>
</dialog>

<dialog id="authModal" class="modal">
    <div class="auth-modal-content modal-box bg-base-200 text-base-content p-8 shadow-xl max-w-lg w-11/12 text-center">
        <h3 class="font-bold text-lg text-primary mb-6">Anmelden bei VoxelShaper Hub</h3>
        <div class="provider-buttons flex flex-col gap-3">
            <button id="signInGoogleBtn" class="google btn btn-error text-white">
                <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" alt="Google Icon" class="w-5 h-5">
                Mit Google anmelden
            </button>
            <button id="signInGithubBtn" class="github btn bg-neutral text-neutral-content hover:bg-neutral-focus">
                <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/github.svg" alt="GitHub Icon" class="w-5 h-5">
                Mit GitHub anmelden
            </button>
            <button id="showEmailLoginFormBtn" class="email btn btn-info">
                Mit E-Mail anmelden
            </button>
        </div>

        <div id="emailLoginForm" class="email-login-form mt-6 pt-6 border-t border-base-content/20 hidden">
            <form id="emailAuthForm">
                <input type="email" id="emailInput" placeholder="E-Mail" autocomplete="email" class="input input-bordered w-full bg-base-300 border-base-content/20 mb-3">
                <input type="password" id="passwordInput" placeholder="Passwort" autocomplete="current-password" class="input input-bordered w-full bg-base-300 border-base-content/20 mb-3">
                <button type="submit" id="emailSignInBtn" class="btn btn-primary w-full">Anmelden</button>
                <button type="button" id="emailSignUpBtn" class="btn btn-secondary w-full mt-2">Registrieren</button>
            </form>
        </div>

        <div class="close-button-container mt-6">
            <button id="authModalCloseBtn" class="btn btn-ghost">Schlie√üen</button>
        </div>
    </div>
</dialog>

<dialog id="glbExportModal" class="modal">
    <div class="modal-box bg-base-200 text-base-content p-8 text-left shadow-xl max-w-md w-11/12">
        <h3 class="font-bold text-lg text-primary text-center mb-6">GLB Export Optionen</h3>
        <div class="form-control mb-4">
            <label class="label cursor-pointer">
                <span class="label-text">Game-Ready Export</span> 
                <input type="checkbox" id="glbGameReady" class="checkbox checkbox-primary" checked />
            </label>
        </div>
        <div class="form-control mb-6">
            <label class="label">
                <span class="label-text">Pivot Punkt</span>
            </label>
            <select id="glbPivot" class="select select-bordered w-full bg-base-300 border-base-content/20">
                <option value="center">Mittelpunkt</option>
                <option value="floor-center" selected>Boden-Mittelpunkt</option>
            </select>
        </div>
        <div class="form-control mb-4">
            <label class="label cursor-pointer">
                <span class="label-text">Optimieren (Greedy Meshing)</span> 
                <input type="checkbox" id="glbOptimizeGreedy" class="checkbox checkbox-primary" checked />
            </label>
        </div>
        <div class="modal-buttons flex justify-around gap-4 mt-6">
            <button id="glbConfirmExportBtn" class="btn btn-success flex-1">Exportieren</button>
            <button id="glbCancelExportBtn" class="btn btn-ghost flex-1">Abbrechen</button>
        </div>
    </div>
</dialog>

<!-- Unified Export Options Modal -->
<dialog id="unifiedExportModal" class="modal">
    <div class="modal-box bg-base-200 text-base-content p-8 text-left shadow-xl max-w-md w-11/12">
        <h3 class="font-bold text-lg text-primary text-center mb-6">Export Optionen</h3>
        
        <div class="form-control mb-4">
            <label class="label font-bold">Exportformat:</label>
            <div class="flex flex-wrap gap-4">
                <label class="flex items-center">
                    <input type="radio" name="exportFormat" value="stl" class="radio radio-primary mr-2"> STL
                </label>
                <label class="flex items-center">
                    <input type="radio" name="exportFormat" value="obj" class="radio radio-primary mr-2" checked> OBJ
                </label>
                <label class="flex items-center">
                    <input type="radio" name="exportFormat" value="glb" class="radio radio-primary mr-2"> GLB
                </label>
                <label class="flex items-center">
                    <input type="radio" name="exportFormat" value="3mf" class="radio radio-primary mr-2"> 3MF
                </label>
            </div>
        </div>

        <div class="form-control mb-4">
            <label class="label">
                <span class="label-text font-bold">Voxel Gr√∂√üe (mm)</span>
            </label>
            <input type="number" id="exportVoxelSizeMM" class="input input-bordered w-full bg-base-300 border-base-content/20" value="10" min="1">
        </div>

        <div class="form-control mb-4">
            <label class="label font-bold">Einheiten:</label>
            <div class="flex flex-wrap gap-4">
                <label class="flex items-center">
                    <input type="radio" name="exportUnits" value="mm" class="radio radio-primary mr-2" checked> Millimeter (mm)
                </label>
                <label class="flex items-center">
                    <input type="radio" name="exportUnits" value="cm" class="radio radio-primary mr-2"> Zentimeter (cm)
                </label>
            </div>
        </div>

        <div class="form-control mb-6">
            <label class="label" for="exportFilename">
                <span class="label-text font-bold">Dateiname (ohne Erweiterung):</span>
            </label>
            <input type="text" id="exportFilename" placeholder="Mein_Voxel_Modell" class="input input-bordered w-full bg-base-300 border-base-content/20">
        </div>

        <div class="modal-buttons flex justify-around gap-4 mt-6">
            <button id="unifiedExportConfirmBtn" class="btn btn-success flex-1">Exportieren</button>
            <button id="unifiedExportCancelBtn" class="btn btn-ghost flex-1">Abbrechen</button>
        </div>
    </div>
</dialog>

<div id="toast-container" class="toast toast-end z-50"></div>

<div id="mobile-controls" class="hidden md:hidden flex-col gap-3 fixed bottom-4 right-4 z-[1000]">
    <button class="mobile-btn" id="mobile-undo" aria-label="R√ºckg√§ngig machen">‚Ü∫</button>
    <button class="mobile-btn" id="mobile-redo" aria-label="Wiederholen">‚Üª</button>
    <button class="mobile-btn" id="mobile-save" aria-label="Speichern">üíæ</button>
    <button class="mobile-btn" id="mobile-camera" aria-label="Kamera zur√ºcksetzen">üì∑</button>

    <button class="mobile-btn" id="mobile-mode-toggle" aria-label="Modus wechseln">
        <span id="mobile-mode-icon" class="fas fa-plus"></span>
    </button>

    <button class="mobile-btn" id="mobile-color-picker-btn" aria-label="Farbe ausw√§hlen">üé®</button>
    <input type="color" id="mobile-color-input" value="#ffffff" class="hidden w-0 h-0 opacity-0 absolute pointer-events-none">

    <button class="mobile-btn" id="mobile-axis-toggle" aria-label="Zeichenachse wechseln">
        <span id="mobile-axis-icon" class="fas fa-arrows-alt-v"></span>
    </button>
    <button class="mobile-btn" id="mobile-level-up" aria-label="Ebene erh√∂hen">‚¨ÜÔ∏è</button>
    <button class="mobile-btn" id="mobile-level-down" aria-label="Ebene verringern">‚¨áÔ∏è</button>

    <button class="mobile-btn" id="mobile-login-logout" aria-label="Anmelden oder Abmelden">üîë</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/GLTFExporter.js"></script>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import {
        getAuth,
        setPersistence,
        browserLocalPersistence,
        signInWithCustomToken,
        onAuthStateChanged,
        signOut,
        GoogleAuthProvider,
        GithubAuthProvider,
        signInWithPopup,
        createUserWithEmailAndPassword,
        signInWithEmailAndPassword
        /* Removed signInAnonymously import */
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import {
        getFirestore,
        doc,
        getDoc,
        collection,
        addDoc,
        serverTimestamp
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    window.firebase = {
        initializeApp,
        getAuth,
        signInWithCustomToken,
        onAuthStateChanged,
        setPersistence,
        browserLocalPersistence,
        signOut,
        GoogleAuthProvider,
        GithubAuthProvider,
        signInWithPopup,
        createUserWithEmailAndPassword,
        signInWithEmailAndPassword,
        /* Removed signInAnonymously from window.firebase */
        getFirestore,
        doc,
        getDoc,
        collection,
        addDoc,
        serverTimestamp
    };

    // Firebase configuration and initialization
    // The FIREBASE_API_KEY is now managed by the Canvas environment, so it's not hardcoded.
    const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {
        // Fallback or example config if not running in Canvas (replace with your actual config for local dev)
        apiKey: "YOUR_FIREBASE_API_KEY", 
        authDomain: "YOUR_PROJECT_ID.firebaseapp.com",
        projectId: "YOUR_PROJECT_ID",
        storageBucket: "YOUR_PROJECT_ID.appspot.com", 
        messagingSenderId: "YOUR_MESSAGING_SENDER_ID",
        appId: "YOUR_APP_ID",
        measurementId: "YOUR_MEASUREMENT_ID"
    };
    window.firebaseConfig = firebaseConfig;
</script>

<script>
// --- Constants ---
const VS = 1; // Voxel Size - represents the internal unit size in Three.js (e.g., 1 unit)
const HALF = VS * 0.5;
const CHUNK_SIZE = 16;
const VOX_BITS = 10;
const VOX_MASK = (1 << VOX_BITS) - 1;
const SHIFT_X  = VOX_BITS * 2;
const SHIFT_Y  = VOX_BITS;

// Helper to create a unique key for voxel coordinates
function key(x, y, z) { return ((x << SHIFT_X) | (y << SHIFT_Y) | z) >>> 0; }
// Helper to parse a key back into voxel coordinates
function parseKey(k) { return [(k >>> SHIFT_X) & VOX_MASK, (k >>> SHIFT_Y) & VOX_MASK, k & VOX_MASK]; }

const VOXEL_DRAG_THRESHOLD = 1;
const PINCH_ZOOM_MULT = 40;
const TAP_DIST_TH = 10;
const MOVE_PX = 10;
const DT_MS = 250;

const ROTATE_SPEED_TOUCH_MOBILE = 0.008;
const PAN_SPEED_TOUCH_MOBILE = 0.2;
const PINCH_ZOOM_MULT_MOBILE = 80;

const ROTATE_SPEED_TOUCH_DESKTOP = 0.004;
const PAN_SPEED_TOUCH_DESKTOP = 0.1;
const PINCH_ZOOM_MULT_DESKTOP = 40;

// --- Global Variables ---
let activePointers = new Map(); // Tracks active touch pointers
let gestureState = { type: 'none', startDist: 0, startMid: { x: 0, y: 0 }, lastMid: { x: 0, y: 0 }, lastDist: 0, startTime: 0, initialPointerCount: 0 };
let tapCandidate = null;
let doubleTapDragActive = false;
/* Removed touchIndicator variable as it's no longer used */

let scene, cam, ren, gridHelper, boxHelper; // Three.js core components
let rotSpeed = 0.004; // Camera rotation speed
let euler; // Euler angles for camera rotation
const voxels = new Map(); // Stores all active voxels: key(x,y,z) -> { color: hex }
const chunks = new Map(); // Stores VoxelChunk instances for efficient rendering

let cvs, containerDiv; // Canvas and its container HTML elements
let activeDrawingLevel = { x: 0, y: 0, z: 0 }; // Current drawing plane level
let currentDrawingAxis = 'y'; // Current drawing plane axis ('x', 'y', or 'z')

let currentColor = localStorage.getItem('voxelEditorColor') || '#ffffff'; // Currently selected voxel color
let moveSpeed = parseFloat(localStorage.getItem('voxelEditorFlySpeed') || '0.1'); // Camera movement speed
let GRID = parseInt(localStorage.getItem('voxelEditorGridSize') || '10'); // Grid size (e.g., 10x10x10)

// Initialize drawing levels from local storage or defaults
activeDrawingLevel.x = Number(localStorage.getItem('voxelEditorActiveDrawingLevelX') || '0');
if (!Number.isFinite(activeDrawingLevel.x)) activeDrawingLevel.x = 0;
activeDrawingLevel.x = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.x)));

activeDrawingLevel.y = Number(localStorage.getItem('voxelEditorActiveDrawingLevelY') || '0');
if (!Number.isFinite(activeDrawingLevel.y)) activeDrawingLevel.y = 0;
activeDrawingLevel.y = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.y)));

activeDrawingLevel.z = Number(localStorage.getItem('voxelEditorActiveDrawingLevelZ') || '0');
if (!Number.isFinite(activeDrawingLevel.z)) activeDrawingLevel.z = 0;
activeDrawingLevel.z = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.z)));

currentDrawingAxis = localStorage.getItem('voxelEditorCurrentDrawingAxis') || 'y';

// Color presets for quick selection
const presetColors = [
    localStorage.getItem('voxelPresetColor1') || '#E4002B',
    localStorage.getItem('voxelPresetColor2') || '#00A040',
    localStorage.getItem('voxelPresetColor3') || '#0057B8'
];
let activePresetIndex = -1;
let presetBoxes = [];

let mainDirectionalLight, fillDirectionalLight, hemisphereLight; // Scene lighting
let isShiftDragging = false; // Flag for Shift key pressed during drag
let isControlDragging = false; // Flag for Control key pressed during drag
let isPointerLocked = false; // Flag for pointer lock status
let lastActionVoxelCoords = null; // Coordinates of the last voxel interacted with
let initialClickPos = null; // Mouse down coordinates
let initialTargetVoxelCoords = null; // Target voxel coords at mouse down
let isDragging = false; // Flag for drag operation
let firstMoveAfterLock = true; // For pointer lock, ignores first movement
let mouseMovementX = 0; // Mouse movement in X for pointer lock
let mouseMovementY = 0; // Mouse movement in Y for pointer lock

// Flags to manage pointer intention for drawing vs. camera. Simplified from previous attempt.
let isDrawingPointer = false; // True if current primary pointer is for drawing (left click or single touch in drawing mode)
let isCameraPointer = false; // True if current primary pointer is for camera (right click or single touch in camera mode)
let fixedDrawingLayer = null; // Stores the fixed layer for the current drawing stroke

const dummy = new THREE.Object3D(); // Helper object for matrix transformations
const previewVoxelGeometry = new THREE.BoxGeometry(VS, VS, VS); // Geometry for the preview voxel
const previewVoxelMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5, depthTest: false });
previewVoxelMaterial.polygonOffset = true;
previewVoxelMaterial.polygonOffsetFactor = -1;
let previewVoxelMesh = new THREE.Mesh(previewVoxelGeometry, previewVoxelMaterial); // Mesh for the preview voxel

// Editor Modes
const Modes = {
    ADD: 'Hinzuf√ºgen',
    DELETE: 'L√∂schen',
    DRAW: 'Zeichnen',
};

// Icons for mobile mode toggle
const ModeIcons = {
    ADD: 'fas fa-plus',
    DELETE: 'fas fa-eraser',
    DRAW: 'fas fa-paint-brush'
};

// Icons for mobile axis toggle
const AxisIcons = {
    x: 'fas fa-arrows-alt-h',
    y: 'fas fa-arrows-alt-v',
    z: 'fas fa-arrows-alt'
};

let currentMode = Modes.ADD; // Current editor mode

let history = []; // Undo/redo history stack
let historyPointer = -1; // Current position in history
const MAX_HISTORY_SIZE = 100;

let currentStrokeVoxels = new Map(); // Voxels affected in current drawing stroke
let voxelsAtDragStart = null; // Snapshot of voxels before a drag operation

let previewLineInstancedMesh; // Instanced mesh for drawing line previews
const maxPreviewInstances = 180 * 3;
let previewLineVoxels = [];

let templateImageMesh = null; // Mesh for image template
let templateImageData = null; // Data for image template

let isMobile = window.matchMedia('(max-width: 768px)').matches; // Check if on mobile device

let initialDragVoxelWorldPos = null; // World position of voxel at drag start
let dragAxisLock = null; // Axis locked during drag (for straight lines)
let initialDragVoxelCoords = null; // Initial voxel coordinates during drag

// Project metadata
let projectTitle = '';
let projectDescription = '';
let projectCategory = 'Allgemein';
let projectTags = [];
let projectRemixOf = ''; // ID of the model this project was remixed from
let projectSourceJsonUrl = ''; // URL if loaded from a shared link
let projectVisibility = 'public';

const predefinedCategories = ["Spielzeug", "Dekoration", "Funktional", "Kunst", "Allgemein", "Charaktere", "Fahrzeuge", "Natur", "Architektur", "Abstrakt"];

// Firebase variables
let db, auth, currentUserId, currentUser;
const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id'; // Canvas environment app ID

/**
 * Utility function to download a Blob as a file.
 * @param {Blob} blob The Blob object to download.
 * @param {string} filename The name of the file.
 */
function downloadBlob(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

/**
 * Contains methods for VoxelShaper I/O operations (OBJ, etc.).
 */
const VoxelShaperIO = {
    voxToOBJ: function(voxModel, voxelSize, scaleFactor) {
        let obj = '# VoxelShaper OBJ Export\n';
        let mtls = '# VoxelShaper MTL Export\n';
        let vertexCount = 0;
        const materials = new Map();

        voxModel.voxels.forEach(v => {
            if (!materials.has(v.color)) {
                const matName = `material_${materials.size + 1}`;
                materials.set(v.color, matName);
                const c = new THREE.Color(v.color);
                mtls += `newmtl ${matName}\n`;
                mtls += `Kd ${c.r.toFixed(4)} ${c.g.toFixed(4)} ${c.b.toFixed(4)}\n`;
                mtls += `Ka ${c.r.toFixed(4)} ${c.g.toFixed(4)} ${c.b.toFixed(4)}\n`;
                mtls += `Ks 0.0 0.0 0.0\n`;
                mtls += `Ns 0.0\n`;
                mtls += `d 1.0\n`;
                mtls += `illum 1\n\n`;
            }
        });

        obj += `mtllib ${voxModel.filename}.mtl\n`; // Use provided filename for MTL reference

        obj += '# Vertex Normals\n';
        const normals = [
            new THREE.Vector3(0, 0, 1),
            new THREE.Vector3(0, 0, -1),
            new THREE.Vector3(1, 0, 0),
            new THREE.Vector3(-1, 0, 0),
            new THREE.Vector3(0, 1, 0),
            new THREE.Vector3(0, -1, 0)
        ];
        normals.forEach(n => {
            obj += `vn ${n.x.toFixed(4)} ${n.y.toFixed(4)} ${n.z.toFixed(4)}\n`;
        });
        obj += '\n';


        voxModel.voxels.forEach(v => {
            // Apply scaleFactor directly to vertex coordinates
            const x = v.x * voxelSize * scaleFactor;
            const y = v.y * voxelSize * scaleFactor;
            const z = v.z * voxelSize * scaleFactor;

            const currentVoxelScaledSize = voxelSize * scaleFactor;

            const verts = [
                [x, y, z],
                [x + currentVoxelScaledSize, y, z],
                [x, y + currentVoxelScaledSize, z],
                [x + currentVoxelScaledSize, y + currentVoxelScaledSize, z],
                [x, y, z + currentVoxelScaledSize],
                [x + currentVoxelScaledSize, y, z + currentVoxelScaledSize],
                [x, y + currentVoxelScaledSize, z + currentVoxelScaledSize],
                [x + currentVoxelScaledSize, y + currentVoxelScaledSize, z + currentVoxelScaledSize]
            ];

            const c = new THREE.Color(v.color); // Get color for the current voxel
            verts.forEach(vert => {
                // Add vertex position and color (r, g, b in 0-1 range)
                obj += `v ${vert[0].toFixed(4)} ${vert[1].toFixed(4)} ${vert[2].toFixed(4)} ${c.r.toFixed(4)} ${c.g.toFixed(4)} ${c.b.toFixed(4)}\n`;
            });

            const matName = materials.get(v.color);
            obj += `usemtl ${matName}\n`;

            const baseIdx = vertexCount;

            // Triangulate faces (convert quads to two triangles)
            // Three.js OBJExporter's face indexing (1-based) is different from 0-based array access here.
            // Vertices are typically emitted in a consistent order:
            // v1: (x,y,z), v2: (x+s,y,z), v3: (x,y+s,z), v4: (x+s,y+s,z)
            // v5: (x,y,z+s), v6: (x+s,y,z+s), v7: (x,y+s,z+s), v8: (x+s,y+s,z+s)

            // Faces are defined by vertex indices (1-based from the current object's vertex list)
            // And vertex normal indices (1-based from the global normal list)
            // Format: f v/vt/vn
            // We use f v//vn for simplicity as we don't have texture coords.

            // Front face (+Z normal: vn 1) - vertices 5,6,8,7
            obj += `f ${baseIdx + 5}//1 ${baseIdx + 6}//1 ${baseIdx + 8}//1\n`; // Triangle 1 (v5,v6,v8)
            obj += `f ${baseIdx + 5}//1 ${baseIdx + 8}//1 ${baseIdx + 7}//1\n`; // Triangle 2 (v5,v8,v7)

            // Back face (-Z normal: vn 2) - vertices 1,2,4,3
            obj += `f ${baseIdx + 1}//2 ${baseIdx + 2}//2 ${baseIdx + 4}//2\n`; // Triangle 1 (v1,v2,v4)
            obj += `f ${baseIdx + 1}//2 ${baseIdx + 4}//2 ${baseIdx + 3}//2\n`; // Triangle 2 (v1,v4,v3)

            // Right face (+X normal: vn 3) - vertices 2,6,8,4
            obj += `f ${baseIdx + 2}//3 ${baseIdx + 6}//3 ${baseIdx + 8}//3\n`; // Triangle 1 (v2,v6,v8)
            obj += `f ${baseIdx + 2}//3 ${baseIdx + 8}//3 ${baseIdx + 4}//3\n`; // Triangle 2 (v2,v8,v4)

            // Left face (-X normal: vn 4) - vertices 1,5,7,3
            obj += `f ${baseIdx + 1}//4 ${baseIdx + 5}//4 ${baseIdx + 7}//4\n`; // Triangle 1 (v1,v5,v7)
            obj += `f ${baseIdx + 1}//4 ${baseIdx + 7}//4 ${baseIdx + 3}//4\n`; // Triangle 2 (v1,v7,v3)

            // Top face (+Y normal: vn 5) - vertices 3,4,8,7
            obj += `f ${baseIdx + 3}//5 ${baseIdx + 4}//5 ${baseIdx + 8}//5\n`; // Triangle 1 (v3,v4,v8)
            obj += `f ${baseIdx + 3}//5 ${baseIdx + 8}//5 ${baseIdx + 7}//5\n`; // Triangle 2 (v3,v8,v7)

            // Bottom face (-Y normal: vn 6) - vertices 1,2,6,5
            obj += `f ${baseIdx + 1}//6 ${baseIdx + 2}//6 ${baseIdx + 6}//6\n`; // Triangle 1 (v1,v2,v6)
            obj += `f ${baseIdx + 1}//6 ${baseIdx + 6}//6 ${baseIdx + 5}//6\n`; // Triangle 2 (v1,v6,v5)

            vertexCount += 8;
        });

        return { obj: obj, mtl: mtls };
    },
    VoxModel: function(width, height, depth, voxels, filename) {
        this.width = width;
        this.height = height;
        this.depth = depth;
        this.voxels = voxels;
        this.filename = filename;
    }
};

/**
 * Calculates chunk coordinates from global voxel coordinates.
 * @param {number} gx Global X coordinate.
 * @param {number} gy Global Y coordinate.
 * @param {number} gz Global Z coordinate.
 * @returns {{cx: number, cy: number, cz: number}} Chunk coordinates.
 */
function getChunkCoords(gx, gy, gz) { return { cx: Math.floor(gx / CHUNK_SIZE), cy: Math.floor(gy / CHUNK_SIZE), cz: Math.floor(gz / CHUNK_SIZE) }; }
/**
 * Creates a string key for chunk coordinates.
 * @param {number} cx Chunk X coordinate.
 * @param {number} cy Chunk Y coordinate.
 * @param {number} cz Chunk Z coordinate.
 * @returns {string} Chunk key.
 */
function getChunkKey(cx, cy, cz) { return `${cx},${cy},${cz}`; }

/**
 * Represents a chunk of voxels for efficient instanced rendering.
*/
class VoxelChunk {
    constructor(chunkX, chunkY, chunkZ, chunkSize, scene) {
        this.chunkX = chunkX; this.chunkY = chunkY; this.chunkZ = chunkZ; this.scene = scene; this.chunkSize = chunkSize;
        this.offsetX = chunkX * chunkSize * VS; this.offsetY = chunkY * chunkSize * VS; this.offsetZ = chunkZ * chunkSize * VS;
        this.voxels = new Map(); // Stores local voxel keys to instance data { color, instanceId }
        this.globalToLocalInstanceIdMap = new Map(); // Maps global voxel key to instance ID
        const maxInstancesInChunk = chunkSize * chunkSize * chunkSize;
        const voxelBaseGeometry = new THREE.BoxGeometry(VS, VS, VS);
        const meshMaterial = new THREE.MeshLambertMaterial(); // Using Lambert material for simpler lighting
        this.instancedMesh = new THREE.InstancedMesh(voxelBaseGeometry, meshMaterial, maxInstancesInChunk);
        this.instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(maxInstancesInChunk * 3), 3);
        this.instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        this.instancedMesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
        this.instancedMesh.castShadow = true; this.instancedMesh.receiveShadow = true; this.instancedMesh.count = 0;
        this.instancedMesh.position.set(this.offsetX, this.offsetY, this.offsetZ);
        this.scene.add(this.instancedMesh);
        this.boundingBox = new THREE.Box3( // Bounding box for frustum culling
            new THREE.Vector3(this.offsetX, this.offsetY, this.offsetZ),
            new THREE.Vector3(this.offsetX + chunkSize * VS, this.offsetY + chunkSize * VS, this.offsetZ + chunkSize * VS)
        );

        // Define updateInstanceColor as an arrow function directly in the constructor
        // This ensures 'this' context is always correctly bound to the VoxelChunk instance.
        this.updateInstanceColor = (instanceId, hex) => {
            const c = new THREE.Color(hex);
            if (this.instancedMesh && this.instancedMesh.instanceColor) {
                this.instancedMesh.instanceColor.setXYZ(instanceId, c.r, c.g, c.b);
                this.instancedMesh.instanceColor.needsUpdate = true;
            } else {
                console.warn("Attempted to update instance color on disposed or uninitialized mesh.");
            }
        };
    }

    /**
     * Gets the local key for a voxel within this chunk.
     * @param {number} gx Global X coordinate.
     * @param {number} gy Global Y coordinate.
     * @param {number} gz Global Z coordinate.
     * @returns {number} Local voxel key.
     */
    getLocalKey(gx, gy, gz) { return key(gx % this.chunkSize, gy % this.chunkSize, gz % this.chunkSize); }

    /**
     * Adds a voxel to the chunk.
     * @param {number} gx Global X coordinate.
     * @param {number} gy Global Y coordinate.
     * @param {number} gz Global Z coordinate.
     * @param {string} colorHex Hex color string.
     */
    addVoxel(gx, gy, gz, colorHex) {
        const lKey = this.getLocalKey(gx, gy, gz); // Local key within chunk
        const gKey = key(gx, gy, gz); // Global key across all chunks
        if (this.voxels.has(lKey)) {
            // If voxel exists, update its color
            const instanceId = this.voxels.get(lKey).instanceId;
            this.voxels.set(lKey, { color: colorHex, instanceId });
            this.updateInstanceColor(instanceId, colorHex);
        } else {
            // If new voxel, add a new instance
            const instanceId = this.instancedMesh.count++;
            this.voxels.set(lKey, { color: colorHex, instanceId });
            this.globalToLocalInstanceIdMap.set(gKey, instanceId); // Map global key to instanceId
            // Set instance matrix (position within the chunk)
            dummy.position.set((gx % this.chunkSize) * VS + HALF, (gy % this.chunkSize) * VS + HALF, (gz % this.chunkSize) * VS + HALF);
            dummy.updateMatrix();
            this.instancedMesh.setMatrixAt(instanceId, dummy.matrix);
            this.updateInstanceColor(instanceId, colorHex);
            this.instancedMesh.instanceMatrix.needsUpdate = true;
            this.instancedMesh.instanceColor.needsUpdate = true;
        }
    }

    /**
     * Removes a voxel from the chunk.
     * @param {number} gx Global X coordinate.
     * @param {number} gy Global Y coordinate.
     * @param {number} gz Global Z coordinate.
     */
    removeVoxel(gx, gy, gz) {
        const lKey = this.getLocalKey(gx, gy, gz);
        const gKey = key(gx, gy, gz);
        if (!this.voxels.has(lKey)) return;

        const { instanceId: removedId } = this.voxels.get(lKey);
        this.voxels.delete(lKey);
        this.globalToLocalInstanceIdMap.delete(gKey);

        const lastId = this.instancedMesh.count - 1;
        if (removedId !== lastId) {
            // If the removed voxel is not the last one, move the last instance to its position
            let lastVoxelLKey = null;
            for (const [lk, data] of this.voxels.entries()) {
                if (data.instanceId === lastId) {
                    lastVoxelLKey = lk;
                    break;
                }
            }
            if (lastVoxelLKey !== null) {
                const tempMatrix = new THREE.Matrix4();
                this.instancedMesh.getMatrixAt(lastId, tempMatrix);
                this.instancedMesh.setMatrixAt(removedId, tempMatrix);
                this.updateInstanceColor(removedId, this.voxels.get(lastVoxelLKey).color);
                this.voxels.get(lastVoxelLKey).instanceId = removedId;
                const [lx, ly, lz] = parseKey(lastVoxelLKey);
                this.globalToLocalInstanceIdMap.set(key(this.chunkX * this.chunkSize + lx, this.chunkY * this.chunkSize + ly, this.chunkZ * this.chunkSize + lz), removedId);
            }
        }
        this.instancedMesh.count--; // Decrease instance count
        this.instancedMesh.instanceMatrix.needsUpdate = true;
        this.instancedMesh.instanceColor.needsUpdate = true;
    }

    /**
     * Recolors an existing voxel in the chunk.
     * @param {number} gx Global X coordinate.
     * @param {number} gy Global Y coordinate.
     * @param {number} gz Global Z coordinate.
     * @param {string} newColorHex New hex color string.
     */
    recolorVoxel(gx, gy, gz, newColorHex) {
        const lKey = this.getLocalKey(gx, gy, gz);
        if (!this.voxels.has(lKey)) return;

        const voxelData = this.voxels.get(lKey);
        voxelData.color = newColorHex; // Directly update the color property of the existing object

        // Now update the actual instance's color in the InstancedMesh
        this.updateInstanceColor(voxelData.instanceId, newColorHex);
    }

    /**
     * Disposes of the chunk's Three.js resources.
     */
    dispose() {
        this.scene.remove(this.instancedMesh);
        this.instancedMesh.geometry.dispose();
        this.instancedMesh.material.dispose();
        this.instancedMesh = null;
        this.voxels.clear();
        this.globalToLocalInstanceIdMap.clear();
    }
}

/**
 * Handles window resize events, updating camera aspect ratio and renderer size.
 */
function onResize() {
    cam.aspect = containerDiv.clientWidth / containerDiv.clientHeight;
    cam.updateProjectionMatrix();
    ren.setSize(containerDiv.clientWidth, containerDiv.clientHeight);
    ren.setPixelRatio(isMobile ? Math.min(1.5, window.devicePixelRatio) : window.devicePixelRatio);
}

/**
 * Handles multi-touch gestures for camera control (rotate, pan, zoom).
 */
function handleGesture() {
    const pointers = [...activePointers.values()];
    if (pointers.length === 0) return;

    if (pointers.length === 1) {
        // Single touch for rotation
        const p = pointers[0];
        const rotateSpeed = isMobile ? ROTATE_SPEED_TOUCH_MOBILE : ROTATE_SPEED_TOUCH_DESKTOP;
        
        euler.y += (p.x - gestureState.lastMid.x) * rotateSpeed;
        euler.x -= (p.y - gestureState.lastMid.y) * rotateSpeed;
        
        euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x)); // Clamp vertical rotation
        cam.quaternion.setFromEuler(euler); // Apply rotation
        gestureState.lastMid = { x: p.x, y: p.y };
        return;
    }

    if (pointers.length >= 2) {
        // Two or more touches for pinch zoom and pan
        const [p0, p1] = pointers;
        const midX = (p0.x + p1.x) * 0.5;
        const midY = (p0.y + p1.y) * 0.5;
        const dist = Math.hypot(p1.x - p0.x, p1.y - p0.y);

        if (gestureState.type === 'none') {
            // Determine if it's a pinch or pan gesture
            const dMid = Math.hypot(midX - gestureState.startMid.x, midY - gestureState.startMid.y);
            const PINCH_REL_TH = 0.05;
            const relDelta = Math.abs(dist - gestureState.startDist) / gestureState.startDist;
            if (relDelta > PINCH_REL_TH) {
                gestureState.type = 'pinch';
            } else if (dMid > MOVE_PX) {
                gestureState.type = 'pan';
            }
            return;
        } else if (gestureState.type === 'pinch') {
            // Pinch to zoom
            const pinchZoomMult = isMobile ? PINCH_ZOOM_MULT_MOBILE : PINCH_ZOOM_MULT_DESKTOP;
            const zoomDelta = (dist / gestureState.lastDist - 1) * pinchZoomMult * moveSpeed;
            cam.position.addScaledVector(cam.getWorldDirection(new THREE.Vector3()), zoomDelta);
            gestureState.lastDist = dist;
        } else if (gestureState.type === 'pan') {
            // Pan camera
            const panSpeed = isMobile ? PAN_SPEED_TOUCH_MOBILE : PAN_SPEED_TOUCH_DESKTOP;
            const dx = (midX - gestureState.lastMid.x) * panSpeed;
            const dy = (midY - gestureState.lastMid.y) * panSpeed;
            
            const right = new THREE.Vector3().crossVectors(cam.getWorldDirection(new THREE.Vector3()), cam.up).normalize();
            cam.position.addScaledVector(right, dx);
            cam.position.addScaledVector(new THREE.Vector3(0, 1, 0), dy); // Pan along world Y-axis
            
            gestureState.lastMid = { x: midX, y: p.y };
        }
    }
}

/**
 * Releases a pointer, updates active pointers, and resets gesture state if no pointers are left.
 * @param {number} id Pointer ID.
 * @param {string} eventType Type of event (e.g., 'pointerup').
 */
function releasePointer(id, eventType) {
    activePointers.delete(id);
    if (activePointers.size < 2) {
        gestureState.type = 'none';
        if (activePointers.size === 1) { // If one pointer left, reset lastMid for single-touch rotation
            const last = [...activePointers.values()][0];
            gestureState.lastMid = { x: last.x, y: last.y };
        }
    }
    if (activePointers.size === 0) {
        // Reset all touch-related state when no pointers are active
        doubleTapDragActive = false;
        lastActionVoxelCoords = null;
        initialDragVoxelWorldPos = null;
        dragAxisLock = null;
        initialDragVoxelCoords = null;
        previewLineInstancedMesh.count = 0; // Clear preview lines
        previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
        previewLineVoxels = [];
    }
}

/**
 * Rebuilds the grid helper and bounding box helper based on current grid size and drawing axis.
 */
function rebuildHelpers() {
    if (gridHelper) scene.remove(gridHelper);
    if (boxHelper) scene.remove(boxHelper);

    const size = GRID * VS;

    // Mobile always shows grid on Y=0 plane (simpler for touch)
    if (isMobile) {
        gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444 );
        gridHelper.position.set(size / 2, activeDrawingLevel.y * VS, size / 2);
    } else {
        // Desktop can change drawing plane axis
        if (currentDrawingAxis === 'y') {
            gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444 );
            gridHelper.position.set(size / 2, activeDrawingLevel.y * VS, size / 2);
        } else if (currentDrawingAxis === 'x') {
            gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444);
            gridHelper.rotation.z = Math.PI / 2; // Rotate for X-plane
            gridHelper.position.set(activeDrawingLevel.x * VS, size / 2, size / 2);
        } else if (currentDrawingAxis === 'z') {
            gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444);
            gridHelper.rotation.x = Math.PI / 2; // Rotate for Z-plane
            gridHelper.position.set(size / 2, size / 2, activeDrawingLevel.z * VS);
        }
    }
    scene.add(gridHelper);

    // Bounding box helper
    const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(size, size, size));
    boxHelper = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x00ffff }));
    boxHelper.position.set(size / 2, size / 2, size / 2);
    scene.add(boxHelper);

    // Update mobile axis icon
    const mobileAxisIcon = document.getElementById('mobile-axis-icon');
    if (mobileAxisIcon) {
        mobileAxisIcon.className = AxisIcons[currentDrawingAxis];
    }
}

/**
 * Updates grid helper position and saves drawing level/axis to local storage.
 */
function updateGridHelperPosition() {
    rebuildHelpers();
    localStorage.setItem('voxelEditorActiveDrawingLevelX', activeDrawingLevel.x);
    localStorage.setItem('voxelEditorActiveDrawingLevelY', activeDrawingLevel.y);
    localStorage.setItem('voxelEditorActiveDrawingLevelZ', activeDrawingLevel.z);
    localStorage.setItem('voxelEditorCurrentDrawingAxis', currentDrawingAxis);
}

/**
 * Cycles through the editor modes (ADD, DELETE, DRAW).
 */
function cycleMode() {
    const activeElement = document.activeElement;
    // Prevent mode cycling if an input element is focused
    if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'SELECT' || activeElement.tagName === 'TEXTAREA')) {
        cvs.focus(); // Set focus back to canvas
        return;
    }
    switch (currentMode) {
        case Modes.ADD: currentMode = Modes.DELETE; break;
        case Modes.DELETE: currentMode = Modes.DRAW; break;
        case Modes.DRAW: currentMode = Modes.ADD; break;
    }
    document.getElementById('current-mode').textContent = `Modus: ${currentMode}`;
    // Update mobile mode icon
    const mobileModeIcon = document.getElementById('mobile-mode-icon');
    if (mobileModeIcon) {
        mobileModeIcon.className = ModeIcons[currentMode];
    }
    lastActionVoxelCoords = null; // Clear last action for new mode
    updatePreviewVoxel(0, 0, 0, false); // Hide preview voxel
    previewLineInstancedMesh.count = 0; // Clear preview lines
    previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
    previewLineVoxels = [];
}

/**
 * Sets the active color preset and updates the color picker.
 * @param {number} index Index of the preset color.
 */
function setActivePreset(index) {
    if (index >= 0 && index < presetColors.length) {
        currentColor = presetColors[index];
        document.getElementById('color-picker').value = currentColor;
        const mobileColorInput = document.getElementById('mobile-color-input');
        if (mobileColorInput) mobileColorInput.value = currentColor;
        localStorage.setItem('voxelEditorColor', currentColor);
        // Apply active styling to the preset box
        presetBoxes.forEach((box, i) => {
            if (i === index) { box.classList.add('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'); }
            else { box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'); }
        });
        activePresetIndex = index;
        // Update preview voxel color if visible
        if (previewVoxelMesh.visible) {
            previewVoxelMaterial.color.set(currentColor);
        }
    }
}

/**
 * Saves a color to a preset slot in local storage.
 * @param {number} index Index of the preset slot.
 * @param {string} colorValue Hex color string.
 */
function savePresetColor(index, colorValue) {
    if (index >= 0 && index < presetColors.length) {
        presetColors[index] = colorValue;
        localStorage.setItem(`voxelPresetColor${index + 1}`, colorValue);
        // If the active preset color is changed, update current color
        if (activePresetIndex === index) {
            currentColor = colorValue;
            document.getElementById('color-picker').value = currentColor;
            const mobileColorInput = document.getElementById('mobile-color-input');
            if (mobileColorInput) mobileColorInput.value = currentColor;
            localStorage.setItem('voxelEditorColor', currentColor);
        }
    }
}

/**
 * Applies a given voxel state (used for undo/redo).
 * @param {Array<Object>} state Array of voxel objects {gx, gy, gz, color}.
 */
function applyVoxelState(state) {
    // Dispose all current chunks
    for (const chunk of chunks.values()) chunk.dispose();
    chunks.clear();
    voxels.clear();
    // Re-add voxels from the state
    state.forEach(v => _addSingleVoxel(v.gx, v.gy, v.gz, v.color));
}

/**
 * Adds a command to the history stack.
 * @param {string} type Type of command (e.g., 'batch', 'clearAll').
 * @param {Array<Object>} oldState State before the command.
 * @param {Array<Object>} newState State after the command.
 * @param {Object} commandData Additional data for the command (e.g., old/new grid size).
 */
function addCommand(type, oldState = null, newState = null, commandData = null) {
    // Clear redo history if a new command is added
    if (historyPointer < history.length - 1) history.splice(historyPointer + 1);
    history.push({ type, oldState, newState, commandData });
    historyPointer++;
    // Limit history size
    if (history.length > MAX_HISTORY_SIZE) {
        history.shift();
        historyPointer--;
    }
}

/**
 * Executes a command from the history stack.
 * @param {Object} command The command object.
 * @param {boolean} reverse True for undo, false for redo.
 */
function executeCommand(command, reverse = false) {
    const { type, oldState, newState, commandData } = command;
    switch (type) {
        case 'batch': applyVoxelState(reverse ? oldState : newState); break;
        case 'clearAll': clearAllInternal(true); if (reverse) applyVoxelState(oldState); break;
        case 'fillLevel': applyVoxelState(reverse ? oldState : newState); break;
        case 'resizeGrid':
            // Restore or apply grid size
            GRID = reverse ? commandData.oldGrid : commandData.newGrid;
            document.getElementById('grid-size-slider').value = GRID;
            document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`;
            localStorage.setItem('voxelEditorGridSize', GRID);
            applyVoxelState(reverse ? oldState : newState); // Apply voxel state after grid change
            break;
    }
    rebuildHelpers(); // Always rebuild helpers after state changes
}

/** Performs an undo operation. */
function undo() { if (historyPointer >= 0) { executeCommand(history[historyPointer], true); historyPointer--; } }
/** Performs a redo operation. */
function redo() { if (historyPointer < history.length - 1) { historyPointer++; executeCommand(history[historyPointer], false); } }

/**
 * Adds a single voxel to the global voxel map and the appropriate chunk.
 * @param {number} gx Global X coordinate.
 * @param {number} gy Global Y coordinate.
 * @param {number} gz Global Z coordinate.
 * @param {string} colorHex Hex color string.
 */
function _addSingleVoxel(gx, gy, gz, colorHex) {
    const gKey = key(gx, gy, gz);
    voxels.set(gKey, { color: colorHex }); // Store voxel data
    const { cx, cy, cz } = getChunkCoords(gx, gy, gz);
    const cKey = getChunkKey(cx, cy, cz);
    let chunk = chunks.get(cKey);
    if (!chunk) { // Create new chunk if it doesn't exist
        chunk = new VoxelChunk(cx, cy, cz, CHUNK_SIZE, scene);
        chunks.set(cKey, chunk);
    }
    chunk.addVoxel(gx, gy, gz, colorHex);
}

/**
 * Removes a single voxel from the global voxel map and its chunk.
 * @param {number} gx Global X coordinate.
 * @param {number} gy Global Y coordinate.
 * @param {number} gz Global Z coordinate.
 */
function _removeSingleVoxel(gx, gy, gz) {
    const gKey = key(gx, gy, gz);
    if (!voxels.has(gKey)) return; // Voxel not found

    voxels.delete(gKey);
    const { cx, cy, cz } = getChunkCoords(gx, gy, gz);
    const cKey = getChunkKey(cx, cy, cz);
    if (chunks.has(cKey)) {
        const chunk = chunks.get(cKey);
        chunk.removeVoxel(gx, gy, gz);
        if (chunk.instancedMesh.count === 0) { // If chunk becomes empty, dispose it
            chunk.dispose();
            chunks.delete(cKey);
        }
    }
}

/**
 * Recolors a single voxel.
 * @param {number} gx Global X coordinate.
 * @param {number} gy Global Y coordinate.
 * @param {number} gz Global Z coordinate.
 * @param {string} newColorHex New hex color string.
 */
function _recolorSingleVoxel(gx, gy, gz, newColorHex) {
    const gKey = key(gx, gy, gz);
    if (!voxels.has(gKey)) return;

    const voxelData = voxels.get(gKey); // Get the actual object reference
    voxelData.color = newColorHex; // Directly update the color property

    // Now update the actual instance's color in the InstancedMesh
    const { cx, cy, cz } = getChunkCoords(gx, gy, gz);
    const cKey = getChunkKey(cx, cy, cz);
    if (chunks.has(cKey)) {
        const chunk = chunks.get(cKey);
        const lKey = chunk.getLocalKey(gx, gy, gz);
        if (chunk.voxels.has(lKey)) {
            const instanceId = chunk.voxels.get(lKey).instanceId;
            chunk.updateInstanceColor(instanceId, newColorHex);
        }
    }
}

/**
 * Performs a voxel modification (add, delete, draw) at specified coordinates.
 * This is the core logic for applying changes based on the current mode.
 * @param {number} gx Global X coordinate.
 * @param {number} gy Global Y coordinate.
 * @param {number} gz Global Z coordinate.
 * @param {string} mode Current editor mode.
 * @param {string} newColor Color to apply if adding or drawing.
 */
function performVoxelModification(gx, gy, gz, mode, newColor) {
    // Clamp coordinates to grid boundaries
    gx = Math.max(0, Math.min(GRID - 1, gx));
    gy = Math.max(0, Math.min(GRID - 1, gy));
    gz = Math.max(0, Math.min(GRID - 1, gz));

    const gKey = key(gx, gy, gz);
    const hasVoxel = voxels.has(gKey);

    switch (mode) {
        case Modes.ADD:
            if (!hasVoxel) {
                _addSingleVoxel(gx, gy, gz, newColor);
            }
            break;
        case Modes.DELETE:
            if (hasVoxel) {
                _removeSingleVoxel(gx, gy, gz);
            }
            break;
        case Modes.DRAW:
            if (hasVoxel) {
                if (voxels.get(gKey).color !== newColor) { // Only recolor if color is different
                    _recolorSingleVoxel(gx, gy, gz, newColor);
                }
            }
            break;
    }
}

/**
 * Updates the position and visibility of the preview voxel.
 * @param {number} x X coordinate for preview.
 * @param {number} y Y coordinate for preview.
 * @param {number} z Z coordinate for preview.
 * @param {boolean} visible Whether the preview voxel should be visible.
 */
function updatePreviewVoxel(x, y, z, visible) {
    if (previewVoxelMesh) {
        if (visible) {
            // Ensure geometry size matches VS in case it changed
            if (previewVoxelMesh.geometry.parameters.width !== VS ||
                previewVoxelMesh.geometry.parameters.height !== VS ||
                previewVoxelMesh.geometry.parameters.depth !== VS) {
                previewVoxelMesh.geometry.dispose();
                previewVoxelMesh.geometry = new THREE.BoxGeometry(VS, VS, VS);
            }
            previewVoxelMesh.position.set(x * VS + HALF, y * VS + HALF, z * VS + HALF);
            previewVoxelMesh.visible = true;
            previewVoxelMaterial.color.set(currentColor);
            previewVoxelMaterial.opacity = (currentMode === Modes.DELETE) ? 0.2 : 0.5;
        } else {
            previewVoxelMesh.visible = false;
        }
    }
}

/**
 * Calculates the target voxel coordinates based on a raycast from screen coordinates.
 * @param {number} clientX Mouse/touch X coordinate.
 * @param {number} clientY Mouse/touch Y coordinate.
 * @returns {Object|null} Object containing gx, gy, gz, faceNormal, and hitExistingVoxel, or null if no intersection.
 */
function calculateRayTargetVoxelCoords(clientX, clientY) {
    if (isPointerLocked) return null; // No raycasting when pointer is locked (camera control mode)

    const rect = cvs.getBoundingClientRect();
    const mouse = new THREE.Vector2(
        ((clientX - rect.left) / rect.width) * 2 - 1,
        -((clientY - rect.top) / rect.height) * 2 + 1
    );

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, cam);

    let planeNormal = new THREE.Vector3();
    let planeConstant = 0;
    let targetLayer = activeDrawingLevel[currentDrawingAxis]; // Default to active drawing level

    // If there's a fixed drawing layer active, prioritize it
    if (fixedDrawingLayer !== null) {
        targetLayer = fixedDrawingLayer;
    }

    if (currentDrawingAxis === 'y') {
        planeNormal.set(0, 1, 0);
        planeConstant = -(targetLayer * VS);
    } else if (currentDrawingAxis === 'x') {
        planeNormal.set(1, 0, 0);
        planeConstant = -(targetLayer * VS);
    } else if (currentDrawingAxis === 'z') {
        planeNormal.set(0, 0, 1);
        planeConstant = -(targetLayer * VS);
    }

    const drawingPlane = new THREE.Plane(planeNormal, planeConstant);
    const intersectionPoint = new THREE.Vector3();

    // Try to intersect with the determined drawing plane
    if (raycaster.ray.intersectPlane(drawingPlane, intersectionPoint)) {
        if (!Number.isFinite(intersectionPoint.x) || !Number.isFinite(intersectionPoint.y) || !Number.isFinite(intersectionPoint.z)) {
            return null;
        }

        let gx = Math.floor(intersectionPoint.x / VS);
        let gy = Math.floor(intersectionPoint.y / VS);
        let gz = Math.floor(intersectionPoint.z / VS);

        // Force coordinates to the target layer (either fixed or active drawing level)
        if (currentDrawingAxis === 'y') gy = targetLayer;
        else if (currentDrawingAxis === 'x') gx = targetLayer;
        else if (currentDrawingAxis === 'z') gz = targetLayer;

        gx = Number(gx);
        gy = Number(gy);
        gz = Number(gz);

        if (!Number.isFinite(gx) || !Number.isFinite(gy) || !Number.isFinite(gz)) {
            return null;
        }

        // If fixedDrawingLayer IS null, we are in hover or initial click state.
        // In this case, we need to check for intersection with existing voxels to get face normal for ADD mode
        // or to correctly target an existing voxel for DELETE/DRAW.
        if (fixedDrawingLayer === null) {
            const objectsToIntersect = Array.from(chunks.values()).map(chunk => chunk.instancedMesh);
            if (templateImageMesh) {
                // Ensure raycasting for image template is not permanently disabled
                templateImageMesh.raycast = function() {}; 
            }
            const intersects = raycaster.intersectObjects(objectsToIntersect);

            if (intersects.length > 0) {
                const hit = intersects[0];
                const hitNormal = hit.face.normal.clone();
                const adjustedPoint = hit.point.clone().addScaledVector(hitNormal, -0.001); // Small offset to get voxel behind face
                
                return {
                    gx: Math.floor(adjustedPoint.x / VS),
                    gy: Math.floor(adjustedPoint.y / VS),
                    gz: Math.floor(adjustedPoint.z / VS),
                    faceNormal: hitNormal,
                    hitExistingVoxel: true
                };
            } else {
                 // If no existing voxel is hit, return the intersection with the active drawing plane
                 return { gx, gy, gz, faceNormal: null, hitExistingVoxel: false };
            }
        } else {
            // If fixedDrawingLayer is NOT null, it means we are in a drag operation and we should ONLY consider the plane.
            // We return the calculated point on the fixed plane, without checking for existing voxels under the cursor.
            return { gx, gy, gz, faceNormal: null, hitExistingVoxel: false };
        }
    }
    return null; // No intersection with any relevant plane
}

/**
 * Clears all voxels from the scene.
 * @param {boolean} fromHistory Internal flag to prevent adding to history during undo/redo.
 */
function clearAllInternal(fromHistory = false) {
    if (!fromHistory) {
        // Save current state for undo
        const oldState = [...voxels.entries()].map(([id, data]) => { const p = parseKey(id); return { gx: p[0], gy: p[1], gz: p[2], color: data.color }; });
        addCommand('clearAll', oldState, []);
    }
    // Dispose all chunks and clear voxel maps
    for (const chunk of chunks.values()) chunk.dispose();
    chunks.clear();
    voxels.clear();
    rebuildHelpers(); // Update helpers after clearing
}
/** Clears all voxels, including adding to history. */
function clearAll() { clearAllInternal(false); }

/** Fills the active drawing level with voxels of the current color. */
function fillActiveLevel() {
    // Save old state for undo
    const oldState = [...voxels.entries()].map(([id, data]) => { const p = parseKey(id); return { gx: p[0], gy: p[1], gz: p[2], color: data.color }; });
    
    // Remove existing voxels on the plane
    const voxelsToRemove = [];
    for (let x = 0; x < GRID; x++) {
        for (let z = 0; z < GRID; z++) {
            let gx, gy, gz;
            if (currentDrawingAxis === 'y') { gx = x; gy = activeDrawingLevel.y; gz = z; }
            else if (currentDrawingAxis === 'x') { gx = activeDrawingLevel.x; gy = x; gz = z; }
            else if (currentDrawingAxis === 'z') { gx = x; gy = z; gz = activeDrawingLevel.z; }
            const k = key(gx, gy, gz);
            if (voxels.has(k)) voxelsToRemove.push(k);
        }
    }
    voxelsToRemove.forEach(k => { const [gx, gy, gz] = parseKey(k); _removeSingleVoxel(gx, gy, gz); });

    // Add new voxels to fill the plane
    const newState = [];
    for (let x = 0; x < GRID; x++) {
        for (let z = 0; z < GRID; z++) {
            let gx, gy, gz;
            if (currentDrawingAxis === 'y') { gx = x; gy = activeDrawingLevel.y; gz = z; }
            else if (currentDrawingAxis === 'x') { gx = activeDrawingLevel.x; gy = x; gz = z; }
            else if (currentDrawingAxis === 'z') { gx = x; gy = z; gz = activeDrawingLevel.z; }
            _addSingleVoxel(gx, gy, gz, currentColor);
            newState.push({ gx, gy, gz, color: currentColor, dimX: 1, dimY: 1, dimZ: 1 });
        }
    }
    addCommand('fillLevel', oldState, newState); // Add to history
}

/** Saves the current project state as a JSON file. */
function saveJSON() {
    const data = {};
    voxels.forEach((value, k) => {
        const [gx, gy, gz] = parseKey(k);
        data[`${gx},${gy},${gz}`] = value.color;
    });

    const settings = {
        gridSize: GRID,
        cameraPosition: cam.position.toArray(),
        cameraQuaternion: cam.quaternion.toArray(),
        activeDrawingLevel: activeDrawingLevel,
        currentDrawingAxis: currentDrawingAxis,
        currentColor: currentColor,
        presetColors: presetColors,
        activePresetIndex: activePresetIndex,
        moveSpeed: moveSpeed,
        templateImageData: templateImageData
    };

    const fileContent = {
        title: projectTitle,
        description: projectDescription,
        category: projectCategory,
        tags: projectTags,
        remixOf: projectRemixOf,
        sourceJsonUrl: projectSourceJsonUrl,
        visibility: projectVisibility,
        fileName: `${projectTitle.replace(/\s+/g, "_") || "voxel_project"}.json`,
        timestamp: new Date().toISOString(),

        projectData: {
            settings: settings,
            voxels: data
        }
    };

    const blob = new Blob([JSON.stringify(fileContent, null, 2)], { type: 'application/json' });
    downloadBlob(blob, fileContent.fileName);
    showToast('Speichern erfolgreich', 'Projekt als JSON-Datei gespeichert.', 'success', 5000);
}

/** Resets the project to its default state. */
function resetToDefaultProject() {
    clearAllInternal(true); // Clear without adding to history
    GRID = 10;
    document.getElementById('grid-size-slider').value = GRID;
    document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`;
    localStorage.setItem('voxelEditorGridSize', GRID);

    currentColor = '#ffffff';
    document.getElementById('color-picker').value = currentColor;
    localStorage.setItem('voxelEditorColor', currentColor);
    const mobileColorInput = document.getElementById('mobile-color-input');
    if (mobileColorInput) mobileColorInput.value = currentColor;

    activeDrawingLevel = { x: 0, y: 0, z: 0 };
    currentDrawingAxis = 'y';
    localStorage.setItem('voxelEditorActiveDrawingLevelX', activeDrawingLevel.x);
    localStorage.setItem('voxelEditorActiveDrawingLevelY', activeDrawingLevel.y);
    localStorage.setItem('voxelEditorActiveDrawingLevelZ', activeDrawingLevel.z);
    localStorage.setItem('voxelEditorCurrentDrawingAxis', currentDrawingAxis);

    moveSpeed = 0.1;
    document.getElementById('fly-speed-slider').value = moveSpeed;
    document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
    localStorage.setItem('voxelEditorFlySpeed', moveSpeed);

    presetColors[0] = '#E4002B';
    presetColors[1] = '#00A040';
    presetColors[2] = '#0057B8';
    localStorage.setItem('voxelPresetColor1', presetColors[0]);
    localStorage.setItem('voxelPresetColor2', presetColors[1]);
    localStorage.setItem('voxelPresetColor3', presetColors[2]);
    presetBoxes.forEach((box, i) => { box.value = presetColors[i]; box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'); });
    activePresetIndex = -1;

    removeImageTemplate(true); // Remove template without showing toast
    history.length = 0; // Clear history
    historyPointer = -1;
    previewLineInstancedMesh.count = 0;
    previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
    previewLineVoxels = [];

    // Reset project metadata
    projectTitle = '';
    projectDescription = '';
    projectCategory = 'Allgemein';
    projectTags = [];
    projectRemixOf = '';
    projectSourceJsonUrl = '';
    projectVisibility = 'public';

    rebuildHelpers(); // Rebuild helpers for default grid
    resetCameraPosition(); // Reset camera
    showToast('Projekt zur√ºckgesetzt', 'Das Projekt wurde auf den Standardzustand zur√ºckgesetzt.', 'info', 5000);
}

/**
 * Loads project data from a JSON object.
 * @param {Object} projectData The project data object.
 */
function loadProjectData(projectData) {
    try {
        const loadedVoxels = projectData.projectData ? projectData.projectData.voxels : projectData.voxels;
        const loadedSettings = projectData.projectData ? projectData.projectData.settings : projectData.settings;
        
        clearAllInternal(true); // Clear current scene without adding to history
        removeImageTemplate(true); // Remove any existing image template

        // Load project metadata
        projectTitle = projectData.title || '';
        projectDescription = projectData.description || '';
        projectCategory = projectData.category || 'Allgemein';
        projectTags = Array.isArray(projectData.tags) ? projectData.tags : (typeof projectData.tags === 'string' ? projectData.tags.split(',').map(tag => tag.trim()).filter(tag => tag !== '') : []);
        projectRemixOf = projectData.remixOf || '';
        projectSourceJsonUrl = projectData.sourceJsonUrl || '';
        projectVisibility = projectData.visibility || 'public';

        if (loadedSettings) {
            // Load grid size
            GRID = loadedSettings.gridSize !== undefined ? loadedSettings.gridSize : 10;
            document.getElementById('grid-size-slider').value = GRID;
            document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`;
            localStorage.setItem('voxelEditorGridSize', GRID);
        }

        // Load voxels
        for (const k in loadedVoxels) {
            const colorValue = loadedVoxels[k];
            const parts = k.split(',').map(Number);
            if (parts.length === 3 && !isNaN(parts[0]) && !isNaN(parts[1]) && !isNaN(parts[2])) {
                const gx = parts[0];
                const gy = parts[1];
                const gz = parts[2];
                // Only add voxels that fit within the current GRID size
                if (gx >= 0 && gx < GRID && gy >= 0 && gy < GRID && gz >= 0 && gz < GRID) _addSingleVoxel(gx, gy, gz, colorValue);
            }
        }

        if (loadedSettings) {
            // Load camera position and rotation
            if (loadedSettings.cameraPosition) cam.position.fromArray(loadedSettings.cameraPosition);
            if (loadedSettings.cameraQuaternion) { cam.quaternion.fromArray(loadedSettings.cameraQuaternion); euler.setFromQuaternion(cam.quaternion, 'YXZ'); }
            
            // Load drawing level and axis
            if (loadedSettings.activeDrawingLevel) {
                activeDrawingLevel = {
                    x: Number(loadedSettings.activeDrawingLevel.x || 0),
                    y: Number(loadedSettings.activeDrawingLevel.y || 0),
                    z: Number(loadedSettings.activeDrawingLevel.z || 0)
                };
                // Ensure loaded levels are finite and within bounds
                if (!Number.isFinite(activeDrawingLevel.x)) activeDrawingLevel.x = 0;
                if (!Number.isFinite(activeDrawingLevel.y)) activeDrawingLevel.y = 0;
                if (!Number.isFinite(activeDrawingLevel.z)) activeDrawingLevel.z = 0;
                activeDrawingLevel.x = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.x)));
                activeDrawingLevel.y = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.y)));
                activeDrawingLevel.z = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.z)));
                localStorage.setItem('voxelEditorActiveDrawingLevelX', activeDrawingLevel.x);
                localStorage.setItem('voxelEditorActiveDrawingLevelY', activeDrawingLevel.y);
                localStorage.setItem('voxelEditorActiveDrawingLevelZ', activeDrawingLevel.z);
            }
            if (loadedSettings.currentDrawingAxis) { currentDrawingAxis = loadedSettings.currentDrawingAxis; localStorage.setItem('voxelEditorCurrentDrawingAxis', currentDrawingAxis); }
            updateGridHelperPosition(); // Rebuild grid helper based on new settings

            // Load current color
            currentColor = loadedSettings.currentColor || '#ffffff';
            document.getElementById('color-picker').value = currentColor;
            const mobileColorInput = document.getElementById('mobile-color-input');
            if (mobileColorInput) mobileColorInput.value = currentColor;

            // Load preset colors
            if (loadedSettings.presetColors) {
                for(let i = 0; i < loadedSettings.presetColors.length && i < presetColors.length; i++) {
                    presetColors[i] = loadedSettings.presetColors[i];
                    document.getElementById(`color-preset-${i + 1}`).value = presetColors[i];
                    localStorage.setItem(`voxelPresetColor${i + 1}`, presetColors[i]);
                }
            }
            setActivePreset(loadedSettings.activePresetIndex !== undefined ? loadedSettings.activePresetIndex : -1); // Set active preset

            // Load move speed
            if (loadedSettings.moveSpeed !== undefined) {
                moveSpeed = loadedSettings.moveSpeed;
                document.getElementById('fly-speed-slider').value = moveSpeed;
                document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
                localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
            }

            // Load image template
            if (loadedSettings.templateImageData) {
                templateImageData = loadedSettings.templateImageData;
                new THREE.TextureLoader().load(templateImageData.src, (texture) => {
                    const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true, depthWrite: false });
                    const geometry = new THREE.PlaneGeometry(templateImageData.scaledWidth, templateImageData.scaledHeight);
                    if (templateImageMesh) { scene.remove(templateImageMesh); templateImageMesh.geometry.dispose(); templateImageMesh.material.dispose(); }
                    templateImageMesh = new THREE.Mesh(geometry, material);
                    templateImageMesh.position.fromArray(templateImageData.position);
                    templateImageMesh.rotation.fromArray(templateImageData.rotation);
                    templateImageMesh.scale.fromArray(templateImageData.scale);
                    templateImageMesh.renderOrder = -1;
                    scene.add(templateImageMesh);
                    document.getElementById('removeImageTemplateBtn').classList.remove('hidden');
                }, undefined, (err) => {
                    console.error("Error loading template image:", err);
                    templateImageMesh = null;
                    templateImageData = null;
                    document.getElementById('removeImageTemplateBtn').classList.add('hidden');
                });
            }
        }
        history.length = 0; // Clear history after loading
        historyPointer = -1;
        previewLineInstancedMesh.count = 0;
        previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
        previewLineVoxels = [];
        resetCameraPosition(); // Reset camera to look at the loaded model
    } catch (error) {
        showToast('Fehler', 'Fehler beim Laden der Datei. Stellen Sie sicher, dass es sich um eine g√ºltige JSON-Datei handelt. Fehler: ' + error.message, 'error', 5000);
        resetToDefaultProject();
    }
}

/**
 * Loads a project from Firestore using a model ID.
 * @param {string} modelId The ID of the model to load.
 */
async function loadProjectFromModelId(modelId) {
    showToast('Lade Projekt', `Lade Projekt mit ID: ${modelId}...`, 'info', 5000);
    try {
        const docRef = window.firebase.doc(db, `artifacts/${appId}/public/data/models`, modelId); // Correct path for public models
        const docSnap = await window.firebase.getDoc(docRef);

        if (docSnap.exists()) {
            const pData = docSnap.data();
            const isPublic = pData.visibility === 'public';
            const isOwner = auth.currentUser && auth.currentUser.uid === pData.uploaderUid;

            if (isPublic || isOwner) {
                if (pData && pData.projectData) {
                    projectRemixOf = modelId; // Mark as remixed
                    projectSourceJsonUrl = window.location.href; // Store source URL
                    loadProjectData(pData);
                    showToast('Projekt geladen', `Projekt "${docSnap.data().title}" erfolgreich geladen.`, 'success', 5000);
                } else {
                    showToast('Fehler', 'Projektdaten im Dokument nicht gefunden.', 'error', 5000);
                    resetToDefaultProject();
                }
            } else {
                showToast('Zugriff verweigert', 'Sie haben keine Berechtigung, dieses private Projekt zu laden.', 'error', 5000);
                resetToDefaultProject();
            }
        } else {
            showToast('Projekt nicht gefunden', `Kein Projekt mit ID "${modelId}" gefunden.`, 'warning', 5000);
            resetToDefaultProject();
        }
    } catch (error) {
        if (error.code === 'permission-denied') {
            showToast('Zugriff verweigert', `Berechtigungsfehler beim Laden des Projekts. Stellen Sie sicher, dass das Modell √∂ffentlich ist oder Sie der Eigent√ºmer sind.`, 'error', 5000);
        } else {
            showToast('Fehler', `Fehler beim Laden des Projekts: ${error.message}`, 'error', 5000);
        }
        resetToDefaultProject();
    }
}


/** Loads a project from a selected JSON file. */
function loadJSON(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const projectData = JSON.parse(e.target.result);
            projectRemixOf = ''; // Clear remix info for local loads
            projectSourceJsonUrl = '';
            loadProjectData(projectData);
        } catch (error) {
            showToast('Fehler', 'Fehler beim Parsen der Datei. Stellen Sie sicher, dass es sich um eine g√ºltige JSON-Datei handelt. Fehler: ' + error.message, 'error', 5000);
            resetToDefaultProject();
        }
    };
    reader.readAsText(file);
}

/**
 * Builds a merged BufferGeometry from all voxels, optionally using greedy meshing.
 * @param {Map} voxelsData The map of voxels.
 * @param {number} voxelSize The internal unit size (VS).
 * @param {boolean} useGreedy True to use greedy meshing, false for individual cubes.
 * @param {number} scaleFactorPerVoxel The target size of each voxel in the final export units (e.g., 10 for 10mm).
 * @returns {THREE.BufferGeometry|THREE.Group} Merged geometry or a group of geometries per color.
 */
function buildMergedGeometry(voxelsData, voxelSize, useGreedy = false, scaleFactorPerVoxel = 1) {
    // The size of each voxel in the output mesh (e.g., if original VS=1, and scaleFactorPerVoxel=10mm, then box is 10x10x10)
    const currentVoxelExportSize = voxelSize * scaleFactorPerVoxel; 

    if (useGreedy) {
        return buildGreedyMeshGeometry(voxelsData, voxelSize, scaleFactorPerVoxel);
    } else {
        const geometriesToMerge = [];
        // Geometry for an individual voxel, sized according to the export scale.
        const tempBoxGeometry = new THREE.BoxGeometry(currentVoxelExportSize, currentVoxelExportSize, currentVoxelExportSize);

        voxelsData.forEach((data, k) => {
            const [x, y, z] = parseKey(k);
            // Position individual voxel based on original grid coords * scaled voxel size + half of voxel size for centering
            dummy.position.set(x * currentVoxelExportSize + (currentVoxelExportSize * 0.5), 
                                y * currentVoxelExportSize + (currentVoxelExportSize * 0.5), 
                                z * currentVoxelExportSize + (currentVoxelExportSize * 0.5));
            dummy.updateMatrix();
            const instanceGeometry = tempBoxGeometry.clone();
            instanceGeometry.applyMatrix4(dummy.matrix);
            
            // Add per-vertex color
            const c = new THREE.Color(data.color);
            const vtxColorArr = [];
            for (let j = 0; j < instanceGeometry.attributes.position.count; j++) {
                vtxColorArr.push(c.r, c.g, c.b);
            }
            instanceGeometry.setAttribute('color', new THREE.Float32BufferAttribute(vtxColorArr, 3));
            geometriesToMerge.push(instanceGeometry);
        });
        tempBoxGeometry.dispose(); // Dispose template geometry

        return geometriesToMerge.length > 0 ? THREE.BufferGeometryUtils.mergeBufferGeometries(geometriesToMerge, true) : new THREE.BufferGeometry();
    }
}


/**
 * Implements greedy meshing to merge coplanar quads of the same color.
 * Outputs a THREE.Group where each child is a mesh for a distinct color.
 * @param {Map} voxelsData The map of voxels.
 * @param {number} voxelSize The internal unit size (VS).
 * @param {number} scaleFactorPerVoxel The target size of each voxel in the final export units.
 * @returns {THREE.Group} A group containing merged meshes, one per color.
 */
function buildGreedyMeshGeometry(voxelsData, voxelSize, scaleFactorPerVoxel = 1) {
    const group = new THREE.Group();
    const materialCache = new Map(); // Store materials by color
    const currentVoxelExportSize = voxelSize * scaleFactorPerVoxel; // The size of a voxel in the target export units

    // Organize voxels by color
    const voxelsByColor = new Map();
    voxelsData.forEach((data, k) => {
        const [x, y, z] = parseKey(k);
        const color = data.color;
        if (!voxelsByColor.has(color)) {
            voxelsByColor.set(color, new Map());
        }
        voxelsByColor.get(color).set(k, { x, y, z });
    });

    voxelsByColor.forEach((colorVoxels, colorHex) => {
        const positions = [];
        const indices = [];
        const normals = []; 

        let nextVertexIndex = 0;

        // Iterate over each dimension (X, Y, Z) to find quads
        for (let d = 0; d < 3; ++d) { 
            const u = (d + 1) % 3; 
            const v = (d + 2) % 3; 

            const dimName_d = ['x', 'y', 'z'][d];
            const dimName_u = ['x', 'y', 'z'][u];
            const dimName_v = ['x', 'y', 'z'][v];

            // For each slice along the current dimension
            for (let i = 0; i <= GRID; ++i) { // Iterate up to and including GRID to catch outer faces
                const visitedPlane = new Set(); // Track cells on this specific plane slice
                
                // Construct a 2D heightmap for the current slice to find contiguous faces
                // Values: 0 = no boundary, 1 = boundary (face present)
                const heightMap = new Array(GRID * GRID).fill(0); 

                for (let j = 0; j < GRID; ++j) { 
                    for (let k = 0; k < GRID; ++k) { 
                        const coords1 = {}; coords1[dimName_d] = i; coords1[dimName_u] = j; coords1[dimName_v] = k;
                        const k1 = key(coords1.x, coords1.y, coords1.z);
                        const hasVoxelAt1 = colorVoxels.has(k1);

                        const coords2 = {}; coords2[dimName_d] = i - 1; coords2[dimName_u] = j; coords2[dimName_v] = k;
                        const k2 = key(coords2.x, coords2.y, coords2.z);
                        const hasVoxelAt2 = colorVoxels.has(k2);

                        // A face exists if there's a voxel on one side but not the other along this dimension
                        if (hasVoxelAt1 !== hasVoxelAt2) {
                            heightMap[j * GRID + k] = 1; // Mark as boundary
                        }
                    }
                }

                // Iterate through the heightMap to find and merge quads
                for (let j = 0; j < GRID; ++j) {
                    for (let k = 0; k < GRID; ++k) {
                        if (heightMap[j * GRID + k] === 1) { // Found an unvisited boundary pixel
                            let width = 1;
                            // Expand horizontally
                            while (j + width < GRID && heightMap[(j + width) * GRID + k] === 1) {
                                width++;
                            }

                            let height = 1;
                            // Expand vertically
                            while (k + height < GRID) {
                                let canExtend = true;
                                for (let col = 0; col < width; ++col) {
                                    if (heightMap[(j + col) * GRID + k + height] !== 1) {
                                        canExtend = false;
                                        break;
                                    }
                                }
                                if (canExtend) {
                                    height++;
                                } else {
                                    break;
                                }
                            }

                            // Mark the identified quad area as visited (0 in heightMap)
                            for (let mj = 0; mj < width; ++mj) {
                                for (let mk = 0; mk < height; ++mk) {
                                    heightMap[(j + mj) * GRID + k + mk] = 0;
                                }
                            }

                            // Define quad vertices based on calculated size and position
                            const v0 = new THREE.Vector3();
                            const v1 = new THREE.Vector3();
                            const v2 = new THREE.Vector3();
                            const v3 = new THREE.Vector3();

                            const currentFaceOffset = i * currentVoxelExportSize;
                            let normalDirection = hasVoxelAt1 ? 1 : -1; // Normal points out from the existing voxel

                            if (d === 0) { // X-axis aligned quad (normal is +/- X)
                                v0.set(currentFaceOffset, j * currentVoxelExportSize, k * currentVoxelExportSize);
                                v1.set(currentFaceOffset, j * currentVoxelExportSize, (k + height) * currentVoxelExportSize);
                                v2.set(currentFaceOffset, (j + width) * currentVoxelExportSize, (k + height) * currentVoxelExportSize);
                                v3.set(currentFaceOffset, (j + width) * currentVoxelExportSize, k * currentVoxelExportSize);
                                normals.push(normalDirection, 0, 0, normalDirection, 0, 0, normalDirection, 0, 0, normalDirection, 0, 0);
                            } else if (d === 1) { // Y-axis aligned quad (normal is +/- Y)
                                v0.set(j * currentVoxelExportSize, currentFaceOffset, k * currentVoxelExportSize);
                                v1.set(j * currentVoxelExportSize, currentFaceOffset, (k + height) * currentVoxelExportSize);
                                v2.set((j + width) * currentVoxelExportSize, currentFaceOffset, (k + height) * currentVoxelExportSize);
                                v3.set((j + width) * currentVoxelExportSize, currentFaceOffset, k * currentVoxelExportSize);
                                normals.push(0, normalDirection, 0, 0, normalDirection, 0, 0, normalDirection, 0, 0, 0, normalDirection, 0);
                            } else { // Z-axis aligned quad (normal is +/- Z)
                                v0.set(j * currentVoxelExportSize, k * currentVoxelExportSize, currentFaceOffset);
                                v1.set(j * currentVoxelExportSize, (k + height) * currentVoxelExportSize, currentFaceOffset);
                                v2.set((j + width) * currentVoxelExportSize, (k + height) * currentVoxelExportSize, currentFaceOffset);
                                v3.set((j + width) * currentVoxelExportSize, k * currentVoxelExportSize, currentFaceOffset);
                                normals.push(0, 0, normalDirection, 0, 0, normalDirection, 0, 0, normalDirection, 0, 0, normalDirection);
                            }

                            // Add vertices to positions array
                            positions.push(v0.x, v0.y, v0.z);
                            positions.push(v1.x, v1.y, v1.z);
                            positions.push(v2.x, v2.y, v2.z);
                            positions.push(v3.x, v3.y, v3.z);

                            // Triangulate the quad (two triangles)
                            // Order of vertices for CCW winding when looking from normal side:
                            // v0 -- v3
                            // |     |
                            // v1 -- v2
                            if (normalDirection === 1) { // Front-facing
                                indices.push(nextVertexIndex, nextVertexIndex + 1, nextVertexIndex + 2); // v0, v1, v2
                                indices.push(nextVertexIndex, nextVertexIndex + 0, nextVertexIndex + 2); // v0, v2, v3 (fixed order for triangulation)
                            } else { // Back-facing (reverse winding)
                                indices.push(nextVertexIndex, nextVertexIndex + 2, nextVertexIndex + 1); // v0, v2, v1
                                indices.push(nextVertexIndex, nextVertexIndex + 3, nextVertexIndex + 2); // v0, v3, v2 (fixed order for triangulation)
                            }
                            nextVertexIndex += 4; // 4 new vertices added
                        }
                    }
                }
            }
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
        geometry.setIndex(indices);

        let material = materialCache.get(colorHex);
        if (!material) {
            material = new THREE.MeshStandardMaterial({ color: new THREE.Color(colorHex) });
            materialCache.set(colorHex, material);
        }
        const mesh = new THREE.Mesh(geometry, material);
        group.add(mesh);
    });
    return group;
}


/** Exports the current voxel model as an STL file. */
async function exportSTL(filename, scaleFactorPerVoxel) {
    if (voxels.size === 0) { showToast('Export fehlgeschlagen', 'Keine Voxel zum Exportieren vorhanden!', 'warning', 5000); return; }
    showToast('Exportiere STL', 'Erzeuge STL-Modell...', 'info', 5000);

    // Build merged geometry (non-greedy for STL)
    const mergedGeometry = buildMergedGeometry(voxels, VS, false, scaleFactorPerVoxel);
    const tempMesh = new THREE.Mesh(mergedGeometry); // Create a temporary mesh for the exporter

    if (typeof THREE.STLExporter === 'undefined') { showToast('Export fehlgeschlagen', 'STLExporter-Bibliothek nicht geladen.', 'error', 5000); return; }
    
    const exporter = new THREE.STLExporter();
    const result = exporter.parse(tempMesh); // Parse the mesh into STL format

    const blob = new Blob([result], { type: 'application/octet-stream' });
    downloadBlob(blob, `${filename}.stl`);

    // Dispose temporary geometries and materials
    mergedGeometry.dispose();
    tempMesh.geometry = null; // Detach geometry before disposing mesh
    tempMesh.material = null;
    showToast('Export erfolgreich', 'STL-Modell erfolgreich exportiert!', 'success', 5000);
}

/** Exports the current voxel model as an OBJ file. */
async function exportOBJ(filename, scaleFactorPerVoxel) {
    if (voxels.size === 0) { showToast('Export fehlgeschlagen', 'Keine Voxel zum Exportieren vorhanden!', 'warning', 5000); return; }
    showToast('Exportiere OBJ', 'Erzeuge OBJ-Modell...', 'info', 5000);

    const voxelsToExport = [];
    let maxX = 0, maxY = 0, maxZ = 0;
    // Collect all voxels and determine max dimensions
    voxels.forEach((data, k) => {
        const [x, y, z] = parseKey(k);
        voxelsToExport.push({ x, y, z, color: data.color });
        maxX = Math.max(maxX, x);
        maxY = Math.max(maxY, y);
        maxZ = Math.max(maxZ, z);
    });

    const date = new Date();
    const dateStr = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')}`;
    const zipFilename = `${filename}_${dateStr}.zip`;
    const objMtlBaseFilename = `${filename}_${dateStr}`; // Name for .obj and .mtl inside the zip

    // Create a VoxelModel object and export to OBJ/MTL
    const voxModel = new VoxelShaperIO.VoxModel(maxX + 1, maxY + 1, maxZ + 1, voxelsToExport, objMtlBaseFilename); // Pass base filename
    const objData = VoxelShaperIO.voxToOBJ(voxModel, VS, scaleFactorPerVoxel); // Pass scaleFactor for scaling

    const zip = new JSZip();
    zip.file(`${objMtlBaseFilename}.obj`, objData.obj);
    zip.file(`${objMtlBaseFilename}.mtl`, objData.mtl);

    const blob = await zip.generateAsync({ type: "blob" });
    downloadBlob(blob, zipFilename);

    showToast('Export erfolgreich', 'OBJ-Modell erfolgreich mit Farben exportiert!', 'success', 5000);
}

/** Exports the current voxel model as a 3MF file. */
async function export3MF(filename, scaleFactorPerVoxel) {
    if (voxels.size === 0) {
        showToast('Export fehlgeschlagen', 'Keine Voxel zum Exportieren vorhanden!', 'warning', 5000);
        return;
    }
    showToast('Exportiere 3MF', 'Erzeuge 3MF-Modell...', 'info', 5000);

    const zip = new JSZip();

    // 1. [Content_Types].xml
    const contentTypesXml = `<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
    <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml" />
    <Default Extension="model" ContentType="application/vnd.ms-package.3dmanufacturing-3dmodel+xml" />
</Types>`;
    zip.file("[Content_Types].xml", contentTypesXml);

    // 2. _rels/.rels
    const relsXml = `<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
    <Relationship Target="/3D/3DModel.model" Id="rel-1" Type="http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel" />
</Relationships>`;
    zip.file("_rels/.rels", relsXml);

    // 3. 3D/3DModel.model (main 3D content)
    // For 3MF color export, using non-greedy merged geometry for per-vertex color.
    const mergedGeometry = buildMergedGeometry(voxels, VS, false, scaleFactorPerVoxel); 
    const tempMeshForBbox = new THREE.Mesh(mergedGeometry); // Create a temporary mesh to get bounding box

    // Calculate bounding box for part transform and scale
    const bbox = new THREE.Box3();
    bbox.setFromObject(tempMeshForBbox); // Use setFromObject to correctly get bounding box from mesh
    const size = new THREE.Vector3();
    bbox.getSize(size);

    // Units: millimeter (as defined by the model XML)
    const unitName = "millimeter"; // 3MF requires a unit name

    let meshHtml = '';
    const vertexColors = [];
    const colorsById = new Map(); // Maps hex color string to a unique ID for basematerials
    let colorIdCounter = 0;

    const positions = mergedGeometry.attributes.position.array;
    const colors = mergedGeometry.attributes.color ? mergedGeometry.attributes.color.array : null;
    const indices = mergedGeometry.index ? mergedGeometry.index.array : Array.from({length: positions.length / 3}, (_, i) => i);

    let verticesXml = '';
    for (let i = 0; i < positions.length; i += 3) {
        const x = positions[i];
        const y = positions[i+1];
        const z = positions[i+2];
        verticesXml += `<vertex x="${x.toFixed(4)}" y="${y.toFixed(4)}" z="${z.toFixed(4)}" />\n`;

        if (colors) {
            const r = Math.round(colors[i] * 255);
            const g = Math.round(colors[i+1] * 255);
            const b = Math.round(colors[i+2] * 255);
            const colorHex = `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase()}`;
            if (!colorsById.has(colorHex)) {
                colorsById.set(colorHex, colorIdCounter++);
                vertexColors.push({ id: colorsById.get(colorHex), value: colorHex });
            }
        }
    }

    let trianglesXml = '';
    for (let i = 0; i < indices.length; i += 3) {
        const v1 = indices[i];
        const v2 = indices[i+1];
        const v3 = indices[i+2];
        trianglesXml += `<triangle v1="${v1}" v2="${v2}" v3="${v3}"`;
        if (colors && colorsById.size > 0) {
            // Get original colors for each vertex of the triangle
            const c1_rgb = new THREE.Color().fromArray(colors, v1 * 3);
            const c2_rgb = new THREE.Color().fromArray(colors, v2 * 3);
            const c3_rgb = new THREE.Color().fromArray(colors, v3 * 3);

            // Convert to hex and get their material IDs
            const colorId_v1 = colorsById.get(`#${c1_rgb.getHexString().toUpperCase()}`);
            const colorId_v2 = colorsById.get(`#${c2_rgb.getHexString().toUpperCase()}`);
            const colorId_v3 = colorsById.get(`#${c3_rgb.getHexString().toUpperCase()}`);
            
            // Reference the base material and then the vertex colors for per-vertex coloring
            trianglesXml += ` materialid="1" p1="${colorId_v1}" p2="${colorId_v2}" p3="${colorId_v3}"`;
        }
        trianglesXml += ` />\n`;
    }

    meshHtml = `<mesh>
        <vertices>
            ${verticesXml}
        </vertices>
        <triangles>
            ${trianglesXml}
        </triangles>
    </mesh>`;

    const colorDefinitions = vertexColors.map(c => `<color id="${c.id}" value="${c.value}" />`).join('\n');

    const modelXml = `<?xml version="1.0" encoding="UTF-8"?>
<model unit="${unitName}" xml:lang="en-US" xmlns="http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel">
    <resources>
        <basematerials id="1">
            ${colorDefinitions}
        </basematerials>
        <object id="1" type="model">
            ${meshHtml}
        </object>
    </resources>
    <build>
        <item objectid="1" />
    </build>
</model>`;

    zip.file("3D/3DModel.model", modelXml);

    const blob = await zip.generateAsync({ type: "blob" });
    downloadBlob(blob, `${filename}.3mf`);

    // Dispose temporary geometries and meshes
    mergedGeometry.dispose();
    tempMeshForBbox.geometry = null; // Detach geometry
    tempMeshForBbox.material = null; // Detach material
    showToast('Export erfolgreich', '3MF-Modell erfolgreich exportiert! Farben sollten in Bambu Lab Studio korrekt angezeigt werden.', 'success', 5000);
}


/** Exports the current voxel model as a GLB file with configurable options. */
async function exportGLB(filename, baseScaleFactorUnits) {
    if (voxels.size === 0) {
        showToast('Export fehlgeschlagen', 'Keine Voxel zum Exportieren vorhanden!', 'warning', 5000);
        return;
    }
    // Open GLB specific options modal
    document.getElementById('glbExportModal').showModal();
    // Attach filename and baseScaleFactorUnits to the confirm button's click handler
    document.getElementById('glbConfirmExportBtn').onclick = () => performGlbExport(filename, baseScaleFactorUnits);
}

async function performGlbExport(filename, baseScaleFactorUnits) {
    document.getElementById('glbExportModal').close();
    showToast('Exportiere GLB', 'Erzeuge GLB-Modell...', 'info', 5000);

    const isGameReady = document.getElementById('glbGameReady').checked;
    const glbPivotOption = document.getElementById('glbPivot').value;
    const optimizeGreedy = document.getElementById('glbOptimizeGreedy').checked;

    const exportVoxelSizeMM = parseFloat(document.getElementById('exportVoxelSizeMM').value) || 10;

    if (typeof THREE.GLTFExporter === 'undefined') {
        showToast('Export fehlgeschlagen', 'GLTFExporter-Bibliothek nicht geladen. Bitte versuchen Sie es erneut.', 'error', 5000);
        return;
    }

    const exporter = new THREE.GLTFExporter();
    const tempGroup = new THREE.Group();
    const materialCache = new Map();

    // Calculate the final scale factor for GLB. GLB's base unit is meters.
    // The `baseScaleFactorUnits` converts internal VS units to the chosen output unit (mm or cm).
    // The `exportVoxelSizeMM` converts one internal voxel (1 VS) to its desired real-world size in mm.
    // So, if VS=1, exportVoxelSizeMM=10, baseScaleFactorUnits=1 (for mm output),
    // then (10mm / 1000) = 0.01 meters per voxel.
    // If baseScaleFactorUnits=0.1 (for cm output), then (10mm * 0.1 / 1000) = 0.001 meters per voxel in CM unit.
    // Let's simplify this: the scaleFactorPerVoxel for geometry building is `exportVoxelSizeMM / 1000` regardless of chosen export units,
    // as GLB is always in meters. The `baseScaleFactorUnits` is only for other formats.
    const finalVoxelScaleForGLB = exportVoxelSizeMM / 1000; // This is the size of each voxel in meters for GLB export.

    // Build geometry based on optimization preference
    const geometryGroup = buildMergedGeometry(voxels, VS, optimizeGreedy, finalVoxelScaleForGLB);

    if (geometryGroup.isGroup) { // If greedy meshing was used, add the group of meshes
        tempGroup.add(geometryGroup);
        geometryGroup.children.forEach(mesh => {
            if (mesh.isMesh) {
                const colorHex = `#${mesh.material.color.getHexString().toUpperCase()}`;
                const matName = `mat_${colorHex.substring(1)}`;
                mesh.material.name = matName;
                materialCache.set(colorHex, mesh.material); 
            }
        });
    } else { // If not greedy meshing, it's a single merged BufferGeometry
        // When not using greedy meshing, buildMergedGeometry returns a single merged geometry.
        // We need to create a mesh from this merged geometry and add it to the tempGroup.
        const mesh = new THREE.Mesh(geometryGroup, new THREE.MeshStandardMaterial({vertexColors: true})); // Use a material that respects vertex colors
        tempGroup.add(mesh);

        // For non-greedy, materials might not be in cache by color.
        // If there are multiple materials (e.g. if the original has per-voxel material)
        // ensure materials are properly collected or set.
        // For simplicity, for non-greedy, we assume a single material or vertex colors handled by GLTFExporter.
        // The GLTFExporter by default handles vertex colors if available.
    }


    // Apply transformations based on GLB options
    if (isGameReady) {
        // Recenter to origin (pivot)
        const bbox = new THREE.Box3().setFromObject(tempGroup);
        const center = new THREE.Vector3();
        bbox.getCenter(center);
        
        if (glbPivotOption === 'floor-center') {
            tempGroup.position.x -= center.x;
            tempGroup.position.y -= bbox.min.y; // Set floor to Y=0
            tempGroup.position.z -= center.z;
        } else if (glbPivotOption === 'center') {
            tempGroup.position.x -= center.x;
            tempGroup.position.y -= center.y;
            tempGroup.position.z -= center.z;
        }
        // Scale is already applied in `buildMergedGeometry` based on `finalVoxelScaleForGLB`.
    }

    exporter.parse(
        tempGroup,
        function (result) {
            const blob = new Blob([result], { type: 'model/gltf-binary' });
            downloadBlob(blob, `${filename}.glb`);
            showToast('Export erfolgreich', 'GLB-Modell erfolgreich exportiert!', 'success', 5000);
        },
        function (error) {
            showToast('Export fehlgeschlagen', `Fehler beim Exportieren des GLB-Modells: ${error.message}`, 'error', 5000);
        },
        { binary: true } // Export as GLB binary
    );

    // Dispose temporary geometries and materials after export
    materialCache.forEach(mat => mat.dispose());
    tempGroup.traverse(obj => {
        if (obj.isMesh && obj.geometry) {
            obj.geometry.dispose();
            // Don't dispose material here if it's shared/cached, just nullify reference
            obj.material = null; 
        }
    });
    // Remove all children from the tempGroup to ensure proper disposal
    while(tempGroup.children.length > 0){
        const object = tempGroup.children[0];
        tempGroup.remove(object);
    }
}


/**
 * Shows a toast notification.
 * @param {string} title Title of the toast.
 * @param {string} message Message content.
 * @param {string} type Type of toast ('info', 'success', 'error', 'warning').
 * @param {number} duration Duration in milliseconds.
 */
function showToast(title, message, type = 'info', duration = 5000) {
    const toast = document.createElement('div');
    toast.className = `alert shadow-lg ${type === 'info' ? 'alert-info' : type === 'success' ? 'alert-success' : type === 'error' ? 'alert-error' : type === 'warning' ? 'alert-warning' : ''}`;
    toast.innerHTML = `
        ${type === 'info' ? '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" class="stroke-current shrink-0 h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>' : ''}
        ${type === 'success' ? '<svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>' : ''}
        ${type === 'error' ? '<svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>' : ''}
        ${type === 'warning' ? '<svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>' : ''}
        <div><strong>${title}</strong><br><span>${message}</span></div><button class="close-btn btn btn-ghost btn-sm">&times;</button>`;
    toastContainer.appendChild(toast);
    void toast.offsetWidth; // Trigger reflow to apply transition
    toast.classList.add('show');
    toast.querySelector('.close-btn').addEventListener('click', () => {
        toast.classList.remove('show');
        toast.addEventListener('transitionend', () => toast.remove(), { once: true });
    });
    setTimeout(() => {
        if (toast.parentNode) { // Check if toast hasn't been manually closed
            toast.classList.remove('show');
            toast.addEventListener('transitionend', () => toast.remove(), { once: true });
        }
    }, duration);
}

/** Resets the camera position to a default view looking at the center of the grid. */
function resetCameraPosition() {
    cam.position.set(GRID * 1.0, GRID * 1.2, GRID * 1.5);
    cam.lookAt(GRID / 2, GRID / 2, GRID / 2);
    if (euler) euler.setFromQuaternion(cam.quaternion, 'YXZ'); // Update euler angles
}

/** Triggers the hidden file input for image templates. */
function loadImageTemplate() {
    document.getElementById('imageFileInput').click();
}

/**
 * Handles the selection of an image file for use as a template.
 * @param {Event} event The change event from the file input.
 */
function handleImageFileSelect(event) {
    const file = event.target.files[0];
    if (!file) {
        return;
    }
    const reader = new FileReader();
    reader.onload = (e) => {
        const base64Image = e.target.result;
        const img = new Image();
        img.onload = () => {
            const aspectRatio = img.width / img.height;
            const planeWidth = GRID * VS;
            const planeHeight = planeWidth / aspectRatio;

            // Dispose old template mesh if exists
            if (templateImageMesh) {
                scene.remove(templateImageMesh);
                templateImageMesh.geometry.dispose();
                templateImageMesh.material.dispose();
            }

            const texture = new THREE.TextureLoader().load(base64Image);
            const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true, depthWrite: false });
            const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
            templateImageMesh = new THREE.Mesh(geometry, material);

            // Position the image at the back of the grid, centered
            templateImageMesh.position.set((GRID * VS) / 2, (GRID * VS) / 2, -0.001); // Slightly offset to be behind voxels
            templateImageMesh.rotation.set(0, 0, 0);

            templateImageMesh.renderOrder = -1; // Render behind other objects
            scene.add(templateImageMesh);
            templateImageData = { // Store data for saving/loading
                src: base64Image,
                position: templateImageMesh.position.toArray(),
                rotation: templateImageMesh.rotation.toArray(),
                scale: [1, 1, 1], // Storing 1,1,1 for now, as plane size is direct
                scaledWidth: planeWidth,
                scaledHeight: planeHeight
            };
            document.getElementById('removeImageTemplateBtn').classList.remove('hidden');
            showToast('Bildvorlage geladen', 'Bild als Vorlage erfolgreich geladen.', 'success', 5000);
        };
        img.onerror = (err) => {
            showToast('Fehler', 'Bild konnte nicht geladen werden. Ung√ºltiges Bildformat?', 'error', 5000);
            templateImageMesh = null;
            templateImageData = null;
            document.getElementById('removeImageTemplateBtn').classList.add('hidden');
        };
        img.src = base64Image;
    };
    reader.onerror = (err) => {
        showToast('Fehler', 'Fehler beim Lesen der Bilddatei.', 'error', 5000);
    };
    reader.readAsDataURL(file);

    event.target.value = ''; // Clear file input
}

/**
 * Removes the image template from the scene.
 * @param {boolean} fromLoad Internal flag to suppress toast during project load.
 */
function removeImageTemplate(fromLoad = false) {
    if (templateImageMesh) {
        scene.remove(templateImageMesh);
        templateImageMesh.geometry.dispose();
        templateImageMesh.material.dispose();
        templateImageMesh = null;
        templateImageData = null;
        document.getElementById('removeImageTemplateBtn').classList.add('hidden');
        if (!fromLoad) showToast('Bildvorlage entfernt', 'Bildvorlage erfolgreich entfernt.', 'info', 5000);
    }
}

/** Logs the user in or out of Firebase. */
async function loginLogout() {
    if (auth.currentUser) {
        try {
            await window.firebase.signOut(auth);
            showToast('Abgemeldet', 'Sie wurden erfolgreich abgemeldet.', 'info', 5000);
        } catch (e) {
            showToast('Fehler beim Abmelden', `Fehler: ${e.message}`, 'error', 5000);
        }
    } else {
        openAuthModal(); // Open login modal if not logged in
    }
}

/** Opens the project upload modal. */
function openUploadModal() {
    if (!currentUserId) {
        openAuthModal(); // If not logged in, prompt login
        return;
    }
    if (voxels.size === 0) {
        showToast('Upload fehlgeschlagen', 'Die Szene ist leer. Bitte erstellen Sie zuerst ein Modell.', 'warning', 5000);
        return;
    }
    // Populate modal fields with current project metadata
    document.getElementById('uploadTitle').value = projectTitle;
    document.getElementById('uploadDescription').value = projectDescription;
    document.getElementById('uploadCategory').value = projectCategory;
    document.getElementById('uploadTags').value = projectTags.join(', ');
    document.querySelector(`input[name="uploadVisibility"][value="${projectVisibility}"]`).checked = true;
    
    // Populate category dropdown
    const uploadCategorySelect = document.getElementById('uploadCategory');
    uploadCategorySelect.innerHTML = '<option value="" disabled selected>Kategorie ausw√§hlen</option>';
    predefinedCategories.forEach(cat => {
        const opt = document.createElement('option');
        opt.value = cat;
        opt.textContent = cat;
        uploadCategorySelect.appendChild(opt);
    });
    uploadCategorySelect.value = projectCategory;
    
    document.getElementById('uploadProjectModal').showModal();
}

/** Uploads the current project to Firestore. */
async function uploadProjectToHub() {
    if (!currentUserId) {
        openAuthModal(); // If not logged in, prompt login
        return;
    }
    if (voxels.size === 0) {
        showToast('Upload fehlgeschlagen', 'Die Szene ist leer. Bitte erstellen Sie zuerst ein Modell.', 'warning', 5000);
        return;
    }

    // Get project details from modal inputs
    const title = document.getElementById('uploadTitle').value.trim();
    const description = document.getElementById('uploadDescription').value.trim();
    const category = document.getElementById('uploadCategory').value;
    const tags = document.getElementById('uploadTags').value.split(',').map(tag => tag.trim()).filter(tag => tag !== '');
    const visibility = document.querySelector(`input[name="uploadVisibility"]:checked`).value;

    if (!title) { showToast('Fehler', 'Bitte geben Sie einen Titel f√ºr Ihr Projekt ein.', 'warning', 5000); return; }
    if (!category) { showToast('Fehler', 'Bitte w√§hlen Sie eine Kategorie f√ºr Ihr Projekt aus.', 'warning', 5000); return; }

    showToast('Lade hoch...', 'Ihr Projekt wird hochgeladen. Bitte warten Sie...', 'info', 5000);

    try {
        // Prepare voxel data for Firestore
        const voxelMap = {};
        voxels.forEach((v, k) => {
            const [gx, gy, gz] = parseKey(k);
            voxelMap[`${gx},${gy},${gz}`] = v.color;
        });

        // Prepare settings for Firestore (templateImageData is null as it's not stored directly in Firestore)
        const firestoreSafeSettings = {
            gridSize: GRID,
            cameraPosition: cam.position.toArray(),
            cameraQuaternion: cam.quaternion.toArray(),
            activeDrawingLevel: activeDrawingLevel,
            currentDrawingAxis: currentDrawingAxis,
            currentColor: currentColor,
            presetColors: presetColors,
            activePresetIndex: activePresetIndex,
            moveSpeed: moveSpeed,
            templateImageData: null // Image data is not stored in Firestore document
        };

        // Construct the Firestore document
        const firestoreDocument = {
            title: title,
            description: description,
            category: category,
            tags: tags,
            visibility: visibility,
            remixOf: projectRemixOf || "",
            sourceJsonUrl: projectSourceJsonUrl || "",
            fileName: `${title.replace(/\s+/g, "_")}.json`,
            downloads: 0,
            rating: 0,
            ratingCount: 0,
            verified: false,
            userId: currentUserId,
            uploaderEmail: currentUser?.email || "",
            uploaderUid: currentUser?.uid || "",
            uploaderPhotoURL: currentUser?.photoURL || "",
            timestamp: window.firebase.serverTimestamp(),
            projectData: { // Nested project data structure
                description: description, // Redundant but kept for compatibility with older loads
                remixOf: projectRemixOf || "",
                sourceJsonUrl: projectSourceJsonUrl || "",
                settings: firestoreSafeSettings, // All settings go here
                // Redundant top-level settings fields are removed or linked to projectData.settings
                voxels: voxelMap
            }
        };

        // Add document to Firestore collection
        const docRef = await window.firebase.addDoc(window.firebase.collection(db, `artifacts/${appId}/public/data/models`), firestoreDocument);
        
        // Update local project metadata
        projectTitle = title;
        projectDescription = description;
        projectCategory = category;
        projectTags = tags;
        projectVisibility = visibility;
        // projectSourceJsonUrl is not set here as sharing functionality is removed.

        showToast('Erfolgreich hochgeladen', `Ihr Projekt wurde erfolgreich hochgeladen! ID: ${docRef.id}`, 'success', 5000);
    } catch (e) {
        showToast('Fehler beim Hochladen', `Fehler: ${e.message}`, 'error', 5000);
    } finally {
        document.getElementById('uploadProjectModal').close(); // Close modal
    }
}

/* Removed copyShareLink function as requested */

/** Opens the authentication modal. */
function openAuthModal() {
    document.getElementById('authModal').showModal();
    document.getElementById('emailLoginForm').classList.add('hidden'); // Hide email form initially
}

/** Closes the authentication modal. */
function closeAuthModal() {
    document.getElementById('authModal').close();
    cvs.focus(); // Focus back on canvas for controls
}

// Firebase Authentication Handlers (window functions for easy access from HTML)
window.signInWithGoogle = async function() {
    try {
        await window.firebase.signInWithPopup(auth, new window.firebase.GoogleAuthProvider());
        showToast('Anmeldung erfolgreich', 'Mit Google angemeldet.', 'success', 5000);
        closeAuthModal();
    } catch (e) {
        showToast('Anmeldefehler', `Google: ${e.message}`, 'error', 5000);
    }
}
window.signInWithGithub = async function() {
    try {
        await window.firebase.signInWithPopup(auth, new window.firebase.GithubAuthProvider());
        showToast('Anmeldung erfolgreich', 'Mit GitHub angemeldet.', 'success', 5000);
        closeAuthModal();
    } catch (e) {
        showToast('Anmelmelfehler', `GitHub: ${e.message}`, 'error', 5000);
    }
}
window.signInEmailPassword = async function() {
    const email = document.getElementById('emailInput').value;
    const password = document.getElementById('passwordInput').value;
    try {
        await window.firebase.signInWithEmailAndPassword(auth, email, password);
        showToast('Anmeldung erfolgreich', 'Mit E-Mail angemeldet.', 'success', 5000);
        closeAuthModal();
    }
     catch (e) {
        showToast('Anmeldefehler', `E-Mail: ${e.message}`, 'error', 5000);
    }
}
window.signUpEmailPassword = async function() {
    const email = document.getElementById('emailInput').value;
    const password = document.getElementById('passwordInput').value;
    try {
        await window.firebase.createUserWithEmailAndPassword(auth, email, password);
        showToast('Registrierung erfolgreich', 'Konto erstellt und angemeldet.', 'success', 5000);
        closeAuthModal();
    } catch (e) {
        showToast('Registrierungsfehler', `E-Mail: ${e.message}`, 'error', 5000);
    }
}

/** Closes all currently open modals. */
function closeAllModals() {
    const modals = ['clearConfirmationModal', 'uploadProjectModal', 'authModal', 'glbExportModal', 'unifiedExportModal'];
    modals.forEach(id => { const modal = document.getElementById(id); if (modal && modal.open) modal.close(); });
}
window.closeAllModals = closeAllModals; // Make available globally

/** Handles pointer lock state changes (for camera rotation via mouse). */
function onPointerLockChange() {
    if (document.pointerLockElement === cvs) {
        isPointerLocked = true;
        firstMoveAfterLock = true; // Reset mouse movement on first lock
        mouseMovementX = mouseMovementY = 0;
        updatePreviewVoxel(0,0,0,false); // Hide preview when in camera mode
        euler.setFromQuaternion(cam.quaternion, 'YXZ'); // Sync euler with camera quaternion
    }
    else {
        isPointerLocked = false;
    }
}

/**
 * Handles mouse wheel events for camera zoom or drawing level adjustment.
 * @param {Event} e The wheel event.
 */
function onMouseWheel(e) {
    e.preventDefault(); // Prevent page scrolling
    if (e.altKey) {
        // Alt + wheel adjusts drawing level or zooms camera (if mobile or no drawing axis change)
        if (!isMobile && (currentMode === Modes.ADD || currentMode === Modes.DRAW)) {
            if (e.shiftKey) { // Shift + Alt + wheel for Z axis
                activeDrawingLevel.z = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.z - Math.sign(e.deltaY)));
                currentDrawingAxis = 'z';
            } else if (e.ctrlKey) { // Ctrl + Alt + wheel for X axis
                activeDrawingLevel.x = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.x - Math.sign(e.deltaY)));
                currentDrawingAxis = 'x';
            } else { // Alt + wheel for Y axis
                activeDrawingLevel.y = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.y - Math.sign(e.deltaY)));
                currentDrawingAxis = 'y';
            }
            updateGridHelperPosition();
        } else {
            // If on mobile or not in ADD/DRAW mode, alt+wheel zooms camera
            cam.position.addScaledVector(cam.getWorldDirection(new THREE.Vector3()), e.deltaY * 0.005 * moveSpeed * 5);
        }
    } else {
        // Regular wheel adjusts fly speed
        moveSpeed = Math.max(0.01, Math.min(1.0, moveSpeed - Math.sign(e.deltaY) * 0.01));
        document.getElementById('fly-speed-slider').value = moveSpeed;
        document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
        localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
    }
}

const keyboard = {}; // Tracks pressed keys
/**
 * Handles key down events.
 * @param {Event} e The keyboard event.
 */
function onKeyDown(e) {
    // Prevent actions if a modal is open
    const activeModals = ['authModal', 'uploadProjectModal', 'clearConfirmationModal', 'glbExportModal', 'unifiedExportModal'].some(id => document.getElementById(id).open);
    if (activeModals) {
        if (e.key === 'Escape') { closeAllModals(); e.preventDefault(); }
        return;
    }
    keyboard[e.key.toLowerCase()] = true; // Mark key as pressed
    if (e.key === 'Shift') isShiftDragging = true;
    if (e.key === 'Control' || e.metaKey) isControlDragging = true; // Ctrl or Command key
    if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); } // Ctrl/Cmd + Z for undo
    if (((e.ctrlKey || e.metaKey) && e.key === 'y') || ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'Z')) { e.preventDefault(); redo(); } // Ctrl/Cmd + Y or Ctrl/Cmd + Shift + Z for redo
    if ((e.ctrlKey || e.metaKey) && e.key === 'd') e.preventDefault(); // Prevent default for Ctrl/Cmd + D (bookmark)
    if (e.key === 'Tab') { e.preventDefault(); cycleMode(); } // Tab to cycle modes
    // Number keys for color presets
    switch (e.key) { case '1': setActivePreset(0); break; case '2': setActivePreset(1); break; case '3': setActivePreset(2); break; }
}

/**
 * Handles key up events.
 * @param {Event} e The keyboard event.
 */
function onKeyUp(e) {
    keyboard[e.key.toLowerCase()] = false; // Mark key as released
    if (e.key === 'Shift') isShiftDragging = false;
    if (e.key === 'Control' || e.metaKey) isControlDragging = false;
}

/** Handles pointer leaving the canvas, ending any ongoing drag/stroke. */
function onPointerLeave(e) {
    // If a stroke was active, commit it to history
    if (pointerIsDown && isDragging && currentStrokeVoxels.size > 0) {
        const oldState = [];
        const newState = [];
        for (const [gKey, change] of currentStrokeVoxels.entries()) {
            const [gx, gy, gz] = parseKey(gKey);
            oldState.push({ gx, gy, gz, color: change.originalColor });
            newState.push({ gx, gy, gz, color: change.finalColor });
        }
        if (oldState.length > 0) {
            addCommand('batch', oldState, newState);
        }
    }
    // Reset all drag/touch related flags and states
    pointerIsDown = false;
    isDragging = false;
    isDrawingPointer = false; // Reset drawing intent
    isCameraPointer = false;  // Reset camera intent
    fixedDrawingLayer = null; // Release fixed drawing layer
    doubleTapDragActive = false;
    lastActionVoxelCoords = null;
    initialClickPos = null;
    initialTargetVoxelCoords = null;
    voxelsAtDragStart = null;
    currentStrokeVoxels.clear();
    updatePreviewVoxel(0, 0, 0, false); // Hide preview voxel
    previewLineInstancedMesh.count = 0; // Clear preview lines
    previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
    previewLineVoxels = [];
    dragAxisLock = null;
    initialDragVoxelCoords = null;
    
    if (e.pointerType === 'touch') {
        releasePointer(e.pointerId, e);
    }
}

let pointerIsDown = false; // Flag if primary pointer is down
let rightMouseButtonDown = false; // Flag if right mouse button is down
let lastX, lastY; // Last pointer coordinates for movement tracking
let suppressNextTap = false; // Prevents tap actions after a drag

/**
 * Gets all voxel coordinates along a line between two points.
 * Implements a 3D Bresenham-like algorithm.
 * @param {Object} start {gx, gy, gz} Start voxel coordinates.
 * @param {Object} end {gx, gy, gz} End voxel coordinates.
 * @returns {Array<Object>} Array of voxel coordinates {gx, gy, gz} along the line.
 */
function getVoxelsOnLine(start, end) {
    if (!start || !Number.isFinite(start.gx) || !Number.isFinite(start.gy) || !Number.isFinite(start.gz) ||
        !end || !Number.isFinite(end.gx) || !Number.isFinite(end.gy) || !Number.isFinite(end.gz)) {
        return []; // Return empty if start or end are invalid
    }
    const voxelsOnLine = [];
    let x1 = start.gx, y1 = start.gy, z1 = start.gz;
    let x2 = end.gx, y2 = end.gy, z2 = end.gz;

    let dx = Math.abs(x2 - x1), dy = Math.abs(y2 - y1), dz = Math.abs(z2 - z1);
    let sx = (x1 < x2) ? 1 : -1, sy = (y1 < y2) ? 1 : -1, sz = (z1 < z2) ? 1 : -1;

    let dm = Math.max(dx, dy, dz); // Longest axis

    let x = x1, y = y1, z = z1;
    let p1 = 2 * dy - dm, p2 = 2 * dz - dm; // Error terms

    for (let i = 0; i <= dm; i++) {
        // Add current voxel to the list, clamping to grid boundaries
        const clampedX = Math.max(0, Math.min(GRID - 1, x));
        const clampedY = Math.max(0, Math.min(GRID - 1, y));
        const clampedZ = Math.max(0, Math.min(GRID - 1, z));
        voxelsOnLine.push({ gx: clampedX, gy: clampedY, gz: clampedZ });
        
        // Update error terms and coordinates based on longest axis
        if (dm === dx) {
            y += sy * (p1 > 0); p1 += 2 * dy;
            z += sz * (p2 > 0); p2 += 2 * dz;
        } else if (dm === dy) {
            x += sx * (p1 > 0); p1 += 2 * dx;
            z += sz * (p2 > 0); p2 += 2 * dz;
        } else { // dm === dz
            x += sx * (p1 > 0); p1 += 2 * dy;
            y += sy * (p2 > 0); p2 += 2 * dx;
        }
        if (dm === dx) x += sx; else if (dm === dy) y += sy; else z += sz;
    }
    return voxelsOnLine;
}

/** Handles pointer up events. */
function onPointerUp(e) {
    // Right-click releases pointer lock
    if (e.button === 2) {
        rightMouseButtonDown = false;
        document.exitPointerLock();
        return;
    }
    
    // Calculate total movement distance
    const totalMovedDist = initialClickPos ? Math.hypot(e.clientX - initialClickPos.x, e.clientY - initialClickPos.y) : 0;
    const wasDrag = (totalMovedDist > MOVE_PX) || isDragging; // Determine if it was a drag or a click

    if (isDrawingPointer) { // Only process drawing-related actions if drawing intent was set on pointerdown
        if (wasDrag) {
            // It was a drag, commit the entire stroke to history
            if (currentStrokeVoxels.size > 0) {
                const oldState = [];
                const newState = [];
                for (const [gKey, change] of currentStrokeVoxels.entries()) {
                    const [gx, gy, gz] = parseKey(gKey);
                    oldState.push({ gx, gy, gz, color: change.originalColor });
                    newState.push({ gx, gy, gz, color: change.finalColor });
                }
                if (oldState.length > 0) {
                    addCommand('batch', oldState, newState);
                }
            }
        } else {
            // It was a click (no drag, or drag below threshold), perform single voxel modification
            // Note: The initial modification for a single tap/click is handled here.
            // For a drag, the first modification is handled when isDragging becomes true in onPointerMove.
            if (initialTargetVoxelCoords) { // Ensure there was a valid target at pointerdown
                const finalVoxelCoords = { ...initialTargetVoxelCoords };

                // If adding, and a face was hit, adjust to add to the next voxel
                const rawTargetAtDown = calculateRayTargetVoxelCoords(initialClickPos.x, initialClickPos.y);
                if (currentMode === Modes.ADD && rawTargetAtDown && rawTargetAtDown.hitExistingVoxel && rawTargetAtDown.faceNormal) {
                    finalVoxelCoords.gx = rawTargetAtDown.gx + rawTargetAtDown.faceNormal.x;
                    finalVoxelCoords.gy = rawTargetAtDown.gy + rawTargetAtDown.faceNormal.y;
                    finalVoxelCoords.gz = rawTargetAtDown.gz + rawTargetAtDown.faceNormal.z;
                    
                    finalVoxelCoords.gx = Math.max(0, Math.min(GRID - 1, finalVoxelCoords.gx));
                    finalVoxelCoords.gy = Math.max(0, Math.min(GRID - 1, finalVoxelCoords.gy));
                    finalVoxelCoords.gz = Math.max(0, Math.min(GRID - 1, finalVoxelCoords.gz));
                }
                // Ensure the single voxel modification respects the fixed drawing layer if one was set.
                // This is especially relevant if fixedDrawingLayer was set by the initial target but no drag occurred.
                if (fixedDrawingLayer !== null) {
                    finalVoxelCoords[currentDrawingAxis] = fixedDrawingLayer;
                }

                const gKey = key(finalVoxelCoords.gx, finalVoxelCoords.gy, finalVoxelCoords.gz);
                const initialColor = voxelsAtDragStart.has(gKey) ? voxelsAtDragStart.get(gKey).color : null;
                performVoxelModification(finalVoxelCoords.gx, finalVoxelCoords.gy, finalVoxelCoords.gz, currentMode, currentColor);
                const newColor = voxels.has(gKey) ? voxels.get(gKey).color : null;
                
                // Add to history if an actual change occurred
                if (initialColor !== newColor || (currentMode === Modes.ADD && initialColor === null && newColor !== null)) {
                    addCommand('batch', [{ gx: finalVoxelCoords.gx, gy: finalVoxelCoords.gy, gz: finalVoxelCoords.gz, color: initialColor }], [{ gx: finalVoxelCoords.gx, gy: finalVoxelCoords.gy, gz: finalVoxelCoords.gz, color: newColor }]);
                }
            }
        }
    }

    // Reset all flags and states at the end of pointer up
    pointerIsDown = false;
    isDragging = false;
    isDrawingPointer = false; // Reset drawing intent
    isCameraPointer = false;  // Reset camera intent
    fixedDrawingLayer = null; // Release fixed drawing layer
    doubleTapDragActive = false;
    lastActionVoxelCoords = null;
    initialClickPos = null;
    initialTargetVoxelCoords = null;
    voxelsAtDragStart = null;
    currentStrokeVoxels.clear();
    updatePreviewVoxel(0, 0, 0, false);
    previewLineInstancedMesh.count = 0;
    previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
    previewLineVoxels = [];
    dragAxisLock = null;
    initialDragVoxelCoords = null;
    
    if (e.pointerType === 'touch') {
        releasePointer(e.pointerId, e);
    }
}

/** Handles pointer down events. */
function onPointerDown(e) {
    // Right-click initiates camera control (pointer lock)
    if (e.button === 2) {
        e.preventDefault();
        rightMouseButtonDown = true;
        cvs.focus();
        cvs.requestPointerLock();
        return;
    }
    if (isPointerLocked) return; // Ignore input if pointer is locked

    // Alt + left-click acts as eyedropper
    if (e.button === 0 && e.altKey) {
        const hitResult = calculateRayTargetVoxelCoords(e.clientX, e.clientY);
        if (hitResult && hitResult.hitExistingVoxel) {
            const gKey = key(hitResult.gx, hitResult.gy, hitResult.gz);
            if (voxels.has(gKey)) {
                const pickedColor = voxels.get(gKey).color;
                currentColor = pickedColor; // Set current color to picked color
                document.getElementById('color-picker').value = pickedColor;
                const mobileColorInput = document.getElementById('mobile-color-input');
                if (mobileColorInput) mobileColorInput.value = pickedColor;
                localStorage.setItem('voxelEditorColor', pickedColor);
                // Remove active styling from presets
                presetBoxes.forEach(box => box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'));
                activePresetIndex = -1;
                showToast('Farbe aufgenommen', `Farbe: ${pickedColor}`, 'info', 2000);
            }
        }
        return; // Consume event if eyedropper
    }

    voxelsAtDragStart = new Map(voxels); // Take snapshot for undo/redo
    currentStrokeVoxels.clear();
    dragAxisLock = null;
    isDragging = false;
    initialDragVoxelCoords = null; // Clear from previous interactions

    initialClickPos = { x: e.clientX, y: e.clientY };
    pointerIsDown = true;

    // First, determine the raw raycast target to derive initial layer
    const rawRayHitTarget = calculateRayTargetVoxelCoords(e.clientX, e.clientY);
    if (!rawRayHitTarget || !Number.isFinite(rawRayHitTarget.gx) || !Number.isFinite(rawRayHitTarget.gy) || !Number.isFinite(rawRayHitTarget.gz)) {
        pointerIsDown = false; initialClickPos = null; initialTargetVoxelCoords = null;
        return;
    }

    // Determine the *actual* voxel coordinates that would be modified or used as the starting point for a drag.
    // This is initialTargetVoxelCoords.
    initialTargetVoxelCoords = { ...rawRayHitTarget };
    if (currentMode === Modes.ADD && rawRayHitTarget.hitExistingVoxel && rawRayHitTarget.faceNormal) {
        initialTargetVoxelCoords.gx += rawRayHitTarget.faceNormal.x;
        initialTargetVoxelCoords.gy += rawRayHitTarget.faceNormal.y;
        initialTargetVoxelCoords.gz += rawRayHitTarget.faceNormal.z;
        // Clamp these adjusted coordinates to ensure they are within bounds for fixedLayer calculation
        initialTargetVoxelCoords.gx = Math.max(0, Math.min(GRID - 1, initialTargetVoxelCoords.gx));
        initialTargetVoxelCoords.gy = Math.max(0, Math.min(GRID - 1, initialTargetVoxelCoords.gy));
        initialTargetVoxelCoords.gz = Math.max(0, Math.min(GRID - 1, initialTargetVoxelCoords.gz));
    }


    // Determine primary pointer intent
    if (e.pointerType === 'touch') {
        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY, pointerType: e.pointerType });
        
        if (activePointers.size > 1) { // Multi-touch always camera gesture
            isCameraPointer = true; // This is a camera gesture
            // Setup gestureState for pan/zoom
            const pointersArr = [...activePointers.values()];
            const [p0, p1] = pointersArr;
            const midX = (p0.x + p1.x) * 0.5; const midY = (p0.y + p1.y) * 0.5; const dist = Math.hypot(p1.x - p0.x, p1.y - p0.y);
            gestureState.type = 'none'; gestureState.startMid = gestureState.lastMid = { x: midX, y: midY };
            gestureState.startDist = gestureState.lastDist = dist;
            gestureState.initialPointerCount = activePointers.size;
            // Clear drawing-related states as this is a camera gesture
            currentStrokeVoxels.clear();
            previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
            updatePreviewVoxel(0, 0, 0, false);
            return;
        }
        // Single touch
        const isDrawingMode = (currentMode === Modes.ADD || currentMode === Modes.DELETE || currentMode === Modes.DRAW);
        if (isDrawingMode) {
             isDrawingPointer = true; // This is a drawing gesture
            // Set fixed drawing layer for this stroke using the *adjusted* initialTargetVoxelCoords
            if (currentDrawingAxis === 'y') fixedDrawingLayer = initialTargetVoxelCoords.gy;
            else if (currentDrawingAxis === 'x') fixedDrawingLayer = initialTargetVoxelCoords.gx;
            else if (currentDrawingAxis === 'z') fixedDrawingLayer = initialTargetVoxelCoords.gz;

            // No direct modification here. The modification will happen either onPointerUp for a click
            // or onPointerMove when a drag is detected.
            // lastActionVoxelCoords and initialDragVoxelCoords will be set then.
        } else {
            isCameraPointer = true; // Single touch, not in drawing mode, assumed to be camera rotation
            gestureState.type = 'rotate';
            gestureState.lastMid = { x: e.clientX, y: e.clientY };
            gestureState.initialPointerCount = activePointers.size;
        }
    } else if (e.pointerType === 'mouse' && e.button === 0) { // Mouse left click
        lastX = e.clientX;
        lastY = e.clientY;
        isDrawingPointer = true; // Mouse left click is for drawing

        // Set fixed drawing layer for this stroke using the *adjusted* initialTargetVoxelCoords
        if (currentDrawingAxis === 'y') fixedDrawingLayer = initialTargetVoxelCoords.gy;
        else if (currentDrawingAxis === 'x') fixedDrawingLayer = initialTargetVoxelCoords.gx;
        else if (currentDrawingAxis === 'z') fixedDrawingLayer = initialTargetVoxelCoords.gz;
        
        // No direct modification here. The modification will happen either onPointerUp for a click
        // or onPointerMove when a drag is detected.
        // lastActionVoxelCoords and initialDragVoxelCoords will be set then.
        
        updatePreviewVoxel(0, 0, 0, false); // Hide preview while dragging (it will be updated by onPointerMove)
        previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
    }
}

/** Handles pointer move events. */
function onPointerMove(e) {
    e.preventDefault();
    if (isPointerLocked) return;

    lastX = e.clientX;
    lastY = e.clientY;

    const currentMovedDist = initialClickPos ? Math.hypot(e.clientX - initialClickPos.x, e.clientY - initialClickPos.y) : 0;
    const shouldStartDrag = pointerIsDown && (currentMovedDist > MOVE_PX);

    // Handle camera gestures (multi-touch or single touch if isCameraPointer)
    if (isCameraPointer || (e.pointerType === 'touch' && activePointers.size > 1)) {
        if (e.pointerType === 'touch' && activePointers.has(e.pointerId)) {
            activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY, pointerType: e.pointerType });
        }
        handleGesture(); // Continue camera movement
        // Hide all drawing previews while in camera mode
        updatePreviewVoxel(0, 0, 0, false);
        previewLineInstancedMesh.count = 0;
        previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
        previewLineVoxels = [];
        return; // Important: Exit if it's a camera gesture
    }

    // Now handle drawing gestures (only if isDrawingPointer is true and pointer is down)
    if (isDrawingPointer && pointerIsDown) {
        let currentRayHit = calculateRayTargetVoxelCoords(e.clientX, e.clientY); // This now respects fixedDrawingLayer
        let currentTargetVoxelCoords = null;

        if (currentRayHit) {
            currentTargetVoxelCoords = { gx: currentRayHit.gx, gy: currentRayHit.gy, gz: currentRayHit.gz };
        }

        if (!currentTargetVoxelCoords) {
            // If no valid target voxel, stop drawing/preview, but keep pointerDown
            updatePreviewVoxel(0, 0, 0, false);
            previewLineInstancedMesh.count = 0;
            previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
            previewLineVoxels = [];
            return;
        }

        if (!isDragging && shouldStartDrag) {
            // Drag officially starts now
            isDragging = true;
            
            // Set initial drag coords and last action coords for line drawing
            initialDragVoxelCoords = { ...initialTargetVoxelCoords };
            lastActionVoxelCoords = { ...initialTargetVoxelCoords };
            
            // Perform the *first* voxel modification for the drag stroke here.
            // This ensures it happens once the drag officially begins.
            const gKey = key(initialTargetVoxelCoords.gx, initialTargetVoxelCoords.gy, initialTargetVoxelCoords.gz);
            const initialColor = voxelsAtDragStart.has(gKey) ? voxelsAtDragStart.get(gKey).color : null;
            performVoxelModification(initialTargetVoxelCoords.gx, initialTargetVoxelCoords.gy, initialTargetVoxelCoords.gz, currentMode, currentColor);
            const finalColor = voxels.has(gKey) ? voxels.get(gKey).color : null;
            currentStrokeVoxels.set(gKey, { originalColor: initialColor, finalColor: finalColor });
        }

        if (isDragging) {
            // Only draw line if the current target is different from the last action
            if (lastActionVoxelCoords.gx === currentTargetVoxelCoords.gx &&
                lastActionVoxelCoords.gy === currentTargetVoxelCoords.gy &&
                lastActionVoxelCoords.gz === currentTargetVoxelCoords.gz) {
                // No movement in voxel space, just update preview and return
                updatePreviewVoxel(currentTargetVoxelCoords.gx, currentTargetVoxelCoords.gy, currentTargetVoxelCoords.gz, true);
                return;
            }

            // Continue the stroke
            const startPointForLine = lastActionVoxelCoords;
            const endPointForLine = { ...currentTargetVoxelCoords };

            let pathVoxels = getVoxelsOnLine(startPointForLine, endPointForLine);

            // Filter out voxels that should not be affected by this stroke (e.g., if in DELETE/DRAW mode)
            if (currentMode === Modes.DELETE || currentMode === Modes.DRAW) {
                pathVoxels = pathVoxels.filter(voxel => voxelsAtDragStart.has(key(voxel.gx, voxel.gy, voxel.gz)));
            }

            for (let i = 0; i < pathVoxels.length; i++) {
                const voxel = pathVoxels[i];
                const gKey = key(voxel.gx, voxel.gy, voxel.gz);
                const initialColorOfStroke = voxelsAtDragStart.has(gKey) ? voxelsAtDragStart.get(gKey).color : null;
                performVoxelModification(voxel.gx, voxel.gy, voxel.gz, currentMode, currentColor);
                const finalColorAfterModification = voxels.has(gKey) ? voxels.get(gKey).color : null;

                if (!currentStrokeVoxels.has(gKey)) {
                     currentStrokeVoxels.set(gKey, { originalColor: initialColorOfStroke, finalColor: finalColorAfterModification });
                } else {
                    currentStrokeVoxels.get(gKey).finalColor = finalColorAfterModification;
                }
            }
            lastActionVoxelCoords = { ...endPointForLine };
            updatePreviewVoxel(currentTargetVoxelCoords.gx, currentTargetVoxelCoords.gy, currentTargetVoxelCoords.gz, true);
            previewLineInstancedMesh.count = 0;

        } else {
            // Pointer down, but not yet dragging (hovering before drag starts)
            updatePreviewVoxel(currentTargetVoxelCoords.gx, currentTargetVoxelCoords.gy, currentTargetVoxelCoords.gz, true);
            previewLineInstancedMesh.count = 0;
        }
    } else if (!pointerIsDown) { // Pointer is not down - normal hover preview
        previewLineInstancedMesh.count = 0;
        previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
        previewLineVoxels = [];

        let currentRayHit = calculateRayTargetVoxelCoords(e.clientX, e.clientY);
        if (currentRayHit) {
            let hoverPreviewCoords = { gx: currentRayHit.gx, gy: currentRayHit.gy, gz: currentRayHit.gz };
            if (currentMode === Modes.ADD && currentRayHit.faceNormal) {
                hoverPreviewCoords.gx += currentRayHit.faceNormal.x;
                hoverPreviewCoords.gy += currentRayHit.faceNormal.y;
                hoverPreviewCoords.gz += currentRayHit.faceNormal.z;
            }
            hoverPreviewCoords.gx = Math.max(0, Math.min(GRID - 1, hoverPreviewCoords.gx));
            hoverPreviewCoords.gy = Math.max(0, Math.min(GRID - 1, hoverPreviewCoords.gy));
            hoverPreviewCoords.gz = Math.max(0, Math.min(GRID - 1, hoverPreviewCoords.gz));

            let showPreview = false;
            const gKeyAtPreview = key(hoverPreviewCoords.gx, hoverPreviewCoords.gy, hoverPreviewCoords.gz);
            const hasVoxelAtPreview = voxels.has(gKeyAtPreview);

            if (currentMode === Modes.ADD) {
                if (!hasVoxelAtPreview) { showPreview = true; }
            } else if (currentMode === Modes.DELETE || currentMode === Modes.DRAW) {
                if (hasVoxelAtPreview) { showPreview = true; }
            }
            updatePreviewVoxel(hoverPreviewCoords.gx, hoverPreviewCoords.gy, hoverPreviewCoords.gz, showPreview);
        } else {
            updatePreviewVoxel(0, 0, 0, false);
        }
    }
}

/** Cycles the current drawing axis (X, Y, Z). */
function cycleDrawingAxis() {
    const axes = ['x', 'y', 'z'];
    const currentIndex = axes.indexOf(currentDrawingAxis);
    currentDrawingAxis = axes[(currentIndex + 1) % axes.length];
    updateGridHelperPosition();
    showToast('Zeichenachse', `Achse: ${currentDrawingAxis.toUpperCase()}`, 'info', 1500);
}

/**
 * Moves the active drawing level up or down along the current axis.
 * @param {number} direction 1 for up, -1 for down.
 */
function moveDrawingLevel(direction) {
    if (currentMode !== Modes.ADD && currentMode !== Modes.DRAW) {
        showToast('Hinweis', 'Ebenensteuerung nur im Hinzuf√ºgen- oder Zeichenmodus verf√ºgbar.', 'warning', 2000);
        return;
    }
    let level = activeDrawingLevel[currentDrawingAxis];

    if (!Number.isFinite(level)) { // Initialize if not a number
        level = 0;
        activeDrawingLevel[currentDrawingAxis] = level;
    }

    level += direction;
    level = Math.max(0, Math.min(GRID - 1, level)); // Clamp level to grid bounds
    activeDrawingLevel[currentDrawingAxis] = level;
    updateGridHelperPosition();
    showToast('Zeichenebene', `Ebene ${currentDrawingAxis.toUpperCase()}: ${level}`, 'info', 1500);
}

// --- Initialization ---
window.onload = async function() {
    closeAllModals(); // Close any modals that might be open on load

    try {
        // Get HTML elements
        cvs = document.getElementById('voxelCanvas');
        containerDiv = document.getElementById('container');
        // touchIndicator = document.getElementById('touch-indicator'); /* Removed touchIndicator element reference */
        toastContainer = document.getElementById('toast-container');

        // Three.js setup
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x282c34); // Dark background
        cam = new THREE.PerspectiveCamera(75, containerDiv.clientWidth / containerDiv.clientHeight, 0.1, 1000);
        resetCameraPosition(); // Initial camera position
        euler = new THREE.Euler(0, 0, 0, 'YXZ'); // Euler for camera rotation

        ren = new THREE.WebGLRenderer({ canvas: cvs, antialias: true });
        ren.setSize(containerDiv.clientWidth, containerDiv.clientHeight);
        isMobile = window.matchMedia('(max-width: 768px)').matches; // Check for mobile
        ren.setPixelRatio(isMobile ? Math.min(1.5, window.devicePixelRatio) : window.devicePixelRatio); // Pixel ratio for sharp rendering
        ren.shadowMap.enabled = true; // Enable shadows
        ren.shadowMap.type = THREE.PCFSoftShadowMap; // Soft shadows
      
        // Lighting
        scene.add(new THREE.AmbientLight(0x606060)); // General ambient light
        mainDirectionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        mainDirectionalLight.position.set(10, 20, 15);
        mainDirectionalLight.castShadow = true;
        // Shadow map settings
        mainDirectionalLight.shadow.mapSize.width = mainDirectionalLight.shadow.mapSize.height = 2048;
        mainDirectionalLight.shadow.camera.near = 0.5;
        mainDirectionalLight.shadow.camera.far = 50;
        mainDirectionalLight.shadow.camera.left = -30;
        mainDirectionalLight.shadow.camera.right = 30;
        mainDirectionalLight.shadow.camera.top = 30;
        mainDirectionalLight.shadow.camera.bottom = -30;
        mainDirectionalLight.shadow.bias = -0.0005;
        mainDirectionalLight.shadow.normalBias = 0.02;
        scene.add(mainDirectionalLight);

        const secondDirectionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
        secondDirectionalLight.position.set(-10, 10, -15);
        scene.add(secondDirectionalLight);
        scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.6)); // Hemisphere light for soft ambient

        // Preview Voxel and Line
        scene.add(previewVoxelMesh);
        updatePreviewVoxel(0,0,0,false); // Initially hide preview voxel
        previewLineInstancedMesh = new THREE.InstancedMesh(new THREE.BoxGeometry(VS, VS, VS), new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.3, depthTest: false }));
        previewLineInstancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        previewLineInstancedMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(maxPreviewInstances * 3), 3);
        previewLineInstancedMesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
        scene.add(previewLineInstancedMesh);
        
        rebuildHelpers(); // Build initial grid and box helpers

        // --- Event Listeners ---
        window.addEventListener('resize', onResize); // Handle window resize
        containerDiv.addEventListener('pointerdown', onPointerDown); // Mouse/touch down
        containerDiv.addEventListener('pointermove', onPointerMove); // Mouse/touch move
        containerDiv.addEventListener('pointerup', onPointerUp);     // Mouse/touch up
        containerDiv.addEventListener('pointercancel', onPointerUp); // Touch cancel
        containerDiv.addEventListener('pointerleave', onPointerLeave); // Mouse/touch leaves canvas
        containerDiv.addEventListener('wheel', onMouseWheel, { passive: false }); // Mouse wheel for zoom/level
        document.addEventListener('keydown', onKeyDown); // Keyboard press
        document.addEventListener('keyup', onKeyUp);     // Keyboard release
        document.addEventListener('pointerlockchange', onPointerLockChange, false); // Pointer lock state change
        containerDiv.addEventListener('mousemove', (e) => { // Mouse movement for pointer lock
            if (isPointerLocked) {
                mouseMovementX = e.movementX;
                mouseMovementY = e.movementY;
                e.preventDefault();
            }
        });
        containerDiv.addEventListener('contextmenu', (e) => e.preventDefault()); // Prevent right-click context menu

        // UI Controls event listeners
        document.getElementById('grid-size-slider').addEventListener('input', (e) => {
            const oldGrid = GRID;
            const newGrid = parseInt(e.target.value);

            if (newGrid < oldGrid) {
                // Warn if reducing grid size would lose voxels
                let voxelsWouldBeLost = false;
                for (const [id, data] of voxels.entries()) {
                    const p = parseKey(id);
                    if (p[0] >= newGrid || p[1] >= newGrid || p[2] >= newGrid) {
                        voxelsWouldBeLost = true;
                        break;
                    }
                }

                if (voxelsWouldBeLost) {
                    showToast('Warnung', 'Gittergr√∂√üe kann nicht reduziert werden, da sonst vorhandene Voxel au√üerhalb des Rasters verloren gehen w√ºrden.', 'warning', 5000);
                    e.target.value = oldGrid; // Reset slider value
                    document.getElementById('grid-size-display').textContent = `${oldGrid}√ó${oldGrid}√ó${oldGrid}`;
                    return;
                }
            }
            
            // Save old state for undo
            const oldVoxelState = [...voxels.entries()].map(([id, data]) => { const p = parseKey(id); return { gx: p[0], gy: p[1], gz: p[2], color: data.color }; });
            // Clear and re-add voxels to fit new grid
            for (const chunk of chunks.values()) chunk.dispose(); chunks.clear(); voxels.clear();
            oldVoxelState.filter(v => v.gx < newGrid && v.gy < newGrid && v.gz < newGrid).forEach(v => _addSingleVoxel(v.gx, v.gy, v.gz, v.color));
            
            GRID = newGrid;
            document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`;
            localStorage.setItem('voxelEditorGridSize', GRID);
            // Add resize command to history
            addCommand('resizeGrid', oldVoxelState, [...voxels.entries()].map(([id, data]) => { const p = parseKey(id); return { gx: p[0], gy: p[1], gz: p[2], color: data.color }; }), { oldGrid: oldGrid, newGrid: GRID });
            rebuildHelpers();
            resetCameraPosition();
        });

        document.getElementById('color-picker').addEventListener('input', (e) => {
            currentColor = e.target.value;
            localStorage.setItem('voxelEditorColor', currentColor);
            const mobileColorInput = document.getElementById('mobile-color-input');
            if (mobileColorInput) mobileColorInput.value = currentColor;
            presetBoxes.forEach(box => box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'));
            activePresetIndex = -1;
            if (previewVoxelMesh.visible) {
                previewVoxelMaterial.color.set(currentColor);
            }
        });

        // Setup color preset boxes
        presetBoxes = [document.getElementById('color-preset-1'), document.getElementById('color-preset-2'), document.getElementById('color-preset-3')];
        presetColors.forEach((color, i) => {
            const box = presetBoxes[i];
            box.value = color;
            box.addEventListener('click', (e) => setActivePreset(i));
            box.addEventListener('input', (e) => savePresetColor(i, e.target.value));
        });
        if (activePresetIndex !== -1) setActivePreset(activePresetIndex); // Restore active preset
        else document.getElementById('color-picker').value = currentColor;

        document.getElementById('modeToggle').addEventListener('click', cycleMode);
        document.getElementById('current-mode').textContent = `Modus: ${currentMode}`;

        // Clear confirmation modal
        document.getElementById('clearBtn').addEventListener('click', () => document.getElementById('clearConfirmationModal').showModal());
        document.getElementById('saveAndClearBtn').addEventListener('click', () => { saveJSON(); clearAll(); document.getElementById('clearConfirmationModal').close(); });
        document.getElementById('clearWithoutSaveBtn').addEventListener('click', () => { clearAll(); document.getElementById('clearConfirmationModal').close(); });
        document.getElementById('cancelClearBtn').addEventListener('click', () => document.getElementById('clearConfirmationModal').close());
        document.getElementById('clearConfirmationModal').addEventListener('cancel', () => document.getElementById('clearConfirmationModal').close());

        document.getElementById('fillLevelBtn').addEventListener('click', fillActiveLevel);
        document.getElementById('saveBtn').addEventListener('click', saveJSON);
        document.getElementById('loadBtn').addEventListener('click', () => document.getElementById('fileInput').click());
        document.getElementById('fileInput').addEventListener('change', loadJSON);
        
        // Unified Export Button Listener
        document.getElementById('exportBtn').addEventListener('click', () => {
            document.getElementById('exportFilename').value = projectTitle.replace(/\s+/g, '_') || 'voxel_model';
            document.getElementById('unifiedExportModal').showModal();
        });

        // Unified Export Modal Confirm Button Listener
        document.getElementById('unifiedExportConfirmBtn').addEventListener('click', () => {
            const format = document.querySelector('input[name="exportFormat"]:checked').value;
            const units = document.querySelector('input[name="exportUnits"]:checked').value;
            const filename = document.getElementById('exportFilename').value.trim() || 'voxel_model';
            const exportVoxelSizeMM = parseFloat(document.getElementById('exportVoxelSizeMM').value) || 10;

            let scaleFactorUnits = 1; // Default to 1 for mm (1 Three.js unit = 1mm in export)
            if (units === 'cm') {
                scaleFactorUnits = 0.1; // 1 Three.js unit = 0.1cm (equivalent to 1mm = 0.1cm)
            }

            document.getElementById('unifiedExportModal').close(); // Close unified modal first

            switch (format) {
                case 'stl':
                    exportSTL(filename, exportVoxelSizeMM * scaleFactorUnits); // Pass the final desired size per voxel
                    break;
                case 'obj':
                    exportOBJ(filename, exportVoxelSizeMM * scaleFactorUnits); // Pass the final desired size per voxel
                    break;
                case 'glb':
                    exportGLB(filename, exportVoxelSizeMM); // GLB handles its own scaling to meters, so pass only voxelSizeMM
                    break;
                case '3mf':
                    export3MF(filename, exportVoxelSizeMM); // 3MF also uses mm natively, so pass voxelSizeMM
                    break;
            }
        });
        document.getElementById('unifiedExportCancelBtn').addEventListener('click', () => {
            document.getElementById('unifiedExportModal').close();
            cvs.focus();
        });


        // GLB Export Modal Listeners (still needed for GLB-specific options)
        document.getElementById('glbCancelExportBtn').addEventListener('click', () => { document.getElementById('glbExportModal').close(); cvs.focus(); });
        document.getElementById('glbExportModal').addEventListener('click', (e) => { if (e.target === document.getElementById('glbExportModal')) { document.getElementById('glbExportModal').close(); cvs.focus(); } });

        document.getElementById('fly-speed-slider').addEventListener('input', (e) => {
            moveSpeed = parseFloat(e.target.value);
            document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
            localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
        });

        document.getElementById('resetCameraBtn').addEventListener('click', resetCameraPosition);
        document.getElementById('loadImageTemplateBtn').addEventListener('click', loadImageTemplate);
        document.getElementById('imageFileInput').addEventListener('change', handleImageFileSelect);
        document.getElementById('removeImageTemplateBtn').addEventListener('click', removeImageTemplate);
        // Removed copyShareLinkBtn listener

        // Mobile menu toggle
        document.getElementById('menuToggle').addEventListener('click', () => {
            const controlsPanel = document.getElementById('controls');
            controlsPanel.classList.toggle('hidden');
            if (!controlsPanel.classList.contains('hidden')) controlsPanel.classList.add('flex');
            else controlsPanel.classList.remove('flex');
        });

        // Media query for mobile/desktop layout
        const mediaQuery = window.matchMedia('(max-width: 768px)');
        function handleMediaQueryChange(e) {
            isMobile = e.matches;
            const controlsPanel = document.getElementById('controls');
            const mobileControls = document.getElementById('mobile-controls');
            const mobileAxisToggle = document.getElementById('mobile-axis-toggle');
            const mobileLevelUp = document.getElementById('mobile-level-up');
            const mobileLevelDown = document.getElementById('mobile-level-down');

            if (e.matches) { // Mobile view
                controlsPanel.classList.add('hidden');
                mobileControls.classList.remove('hidden');
                mobileControls.classList.add('flex');
                toastContainer.classList.remove('toast-end');
                toastContainer.classList.add('toast-top-center');
                
                mobileAxisToggle.classList.remove('hidden');
                mobileLevelUp.classList.remove('hidden');
                mobileLevelDown.classList.remove('hidden');
            }
            else { // Desktop view
                controlsPanel.classList.remove('hidden');
                controlsPanel.classList.add('flex');
                mobileControls.classList.add('hidden');
                mobileControls.classList.remove('flex');
                toastContainer.classList.remove('toast-top-center');
                toastContainer.classList.add('toast-end');

                mobileAxisToggle.classList.add('hidden'); // Hide axis/level controls on desktop as they are on alt+scroll
                mobileLevelUp.classList.add('hidden');
                mobileLevelDown.classList.add('hidden');
            }
            onResize(); // Adjust renderer size
            rebuildHelpers(); // Rebuild grid for new layout
            // Update mobile mode icon
            const mobileModeIcon = document.getElementById('mobile-mode-icon');
            if (mobileModeIcon) {
                mobileModeIcon.className = ModeIcons[currentMode];
            }
        }
        mediaQuery.addListener(handleMediaQueryChange); // Listen for media query changes
        handleMediaQueryChange(mediaQuery); // Initial check

        // Mobile controls event listeners
        document.getElementById('mobile-undo').addEventListener('click', (e) => { e.stopPropagation(); undo(); });
        document.getElementById('mobile-redo').addEventListener('click', (e) => { e.stopPropagation(); redo(); });
        document.getElementById('mobile-save').addEventListener('click', (e) => { e.stopPropagation(); saveJSON(); });
        document.getElementById('mobile-camera').addEventListener('click', (e) => { e.stopPropagation(); resetCameraPosition(); });
        document.getElementById('mobile-mode-toggle').addEventListener('click', (e) => { e.stopPropagation(); cycleMode(); });
        
        // Mobile color picker (hidden input for native color picker)
        const mobileColorPickerBtn = document.getElementById('mobile-color-picker-btn');
        const mobileColorInput = document.getElementById('mobile-color-input');
        
        mobileColorPickerBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            mobileColorInput.click();
        });

        mobileColorInput.addEventListener('input', (e) => {
            currentColor = e.target.value;
            localStorage.setItem('voxelEditorColor', currentColor);
            document.getElementById('color-picker').value = currentColor;
            presetBoxes.forEach(box => box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'));
            activePresetIndex = -1;
            if (previewVoxelMesh.visible) {
                previewVoxelMaterial.color.set(currentColor);
            }
        });
        mobileColorInput.addEventListener('change', (e) => { // Triggered when color picker is closed
            currentColor = e.target.value;
            localStorage.setItem('voxelEditorColor', currentColor);
            document.getElementById('color-picker').value = currentColor;
            presetBoxes.forEach(box => box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'));
            activePresetIndex = -1;
            if (previewVoxelMesh.visible) {
                previewVoxelMaterial.color.set(currentColor);
            }
        });

        mobileColorInput.value = currentColor; // Set initial value for mobile color input

        document.getElementById('mobile-axis-toggle').addEventListener('click', (e) => { e.stopPropagation(); cycleDrawingAxis(); });
        document.getElementById('mobile-level-up').addEventListener('click', (e) => { e.stopPropagation(); moveDrawingLevel(1); });
        document.getElementById('mobile-level-down').addEventListener('click', (e) => { e.stopPropagation(); moveDrawingLevel(-1); });

        document.getElementById('mobile-login-logout').addEventListener('click', (e) => { e.stopPropagation(); loginLogout(); });

        // Set initial UI values from localStorage
        document.getElementById('grid-size-slider').value = GRID;
        document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`;
        document.getElementById('color-picker').value = currentColor;
        document.getElementById('fly-speed-slider').value = moveSpeed;
        document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
        
        document.getElementById('mobile-mode-icon').className = ModeIcons[currentMode];
        document.getElementById('mobile-axis-icon').className = AxisIcons[currentDrawingAxis];

        // --- Firebase Initialization and Auth State Management ---
        const app = window.firebase.initializeApp(window.firebaseConfig);
        auth = window.firebase.getAuth(app);
        db = window.firebase.getFirestore(app);
        
        const loginLogoutBtn = document.getElementById('loginLogoutBtn');
        const uploadToHubBtn = document.getElementById('uploadToHubBtn');
        const userIdDisplay = document.getElementById('userIdDisplay');
        const goToHubBtn = document.getElementById('goToHubBtn');
        let projectLoadedFromUrl = false; // Flag to prevent multiple loads from URL

        // Populate upload categories
        predefinedCategories.forEach(cat => {
            const opt = document.createElement('option');
            opt.value = cat;
            opt.textContent = cat;
            document.getElementById('uploadCategory').appendChild(opt);
        });

        // Set Firebase persistence (keeps user logged in across sessions)
        window.firebase.setPersistence(auth, window.firebase.browserLocalPersistence)
            .then(async () => {
                // If custom token is provided by Canvas environment, sign in with it.
                // Otherwise, do NOT sign in anonymously. The user must explicitly log in.
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    try { await window.firebase.signInWithCustomToken(auth, __initial_auth_token); }
                    catch (e) { showToast('Anmeldefehler', `Fehler beim Anmelden mit Token: ${e.message}. Bitte versuchen Sie es erneut.`, 'error', 5000); }
                }

                // Listen for authentication state changes
                window.firebase.onAuthStateChanged(auth, async (user) => {
                    currentUserId = user ? user.uid : null;
                    currentUser = user; // Store full user object
                    loginLogoutBtn.textContent = user ? 'Abmelden' : 'Anmelden';
                    // Display user avatar/ID (only if logged in and has photoURL)
                    userIdDisplay.innerHTML = user ? `<img src="${user.photoURL || 'https://placehold.co/24x24/cccccc/000000?text=U'}" alt="User Avatar" class="w-6 h-6 rounded-full align-middle"> <span class="hidden sm:inline">${user.displayName || user.email || 'User'}</span>` : '';
                    
                    // "Auf Hub hochladen" button is always visible, but will prompt login if not logged in
                    uploadToHubBtn.classList.remove('hidden'); // Ensure button is always visible
                    document.getElementById('mobile-login-logout').textContent = user ? 'üö™' : 'üîë'; // Update mobile login icon
                    if (user) { document.getElementById('authModal').close(); } // Close auth modal if user logs in

                    // Load project from URL parameters only once after auth state is ready
                    if (!projectLoadedFromUrl) {
                        const urlParams = new URLSearchParams(window.location.search);
                        const modelId = urlParams.get('modelId');
                        // No longer supporting projectJson directly from URL due to length limits,
                        // instead, we rely on modelId pointing to Firestore.
                        if (modelId) {
                            // Logic for loading from modelId (if re-enabled in future) would go here
                            showToast('Hinweis', 'Das Laden von Projekten √ºber Model-ID ist derzeit deaktiviert. Bitte laden Sie Projekte manuell.', 'info', 5000);
                            projectLoadedFromUrl = true; // Mark as attempted
                        } else {
                            // If no modelId in URL, reset remix info
                            projectRemixOf = '';
                            projectSourceJsonUrl = '';
                        }
                    }
                });
                animate(); // Start rendering loop
            })
            .catch((e) => {
                showToast('Anmeldefehler', `Fehler bei der Anmeldungspersistenz: ${e.message}.`, 'error', 10000);
                animate(); // Still start rendering even if auth fails
            });

        // Other Firebase/Auth related UI listeners
        document.getElementById('goToHubBtn').addEventListener('click', () => window.open('https://hub.voxelshaper.com', '_blank'));
        document.getElementById('loginLogoutBtn').addEventListener('click', loginLogout);
        document.getElementById('authModal').addEventListener('click', (e) => { if (e.target === document.getElementById('authModal')) closeAuthModal(); }); // Close modal on backdrop click
        document.getElementById('authModalCloseBtn').addEventListener('click', closeAuthModal);
        document.getElementById('signInGoogleBtn').addEventListener('click', window.signInWithGoogle);
        document.getElementById('signInGithubBtn').addEventListener('click', window.signInGithub);
        document.getElementById('emailSignInBtn').addEventListener('click', window.signInEmailPassword);
        document.getElementById('emailSignUpBtn').addEventListener('click', window.signUpEmailPassword);
        document.getElementById('showEmailLoginFormBtn').addEventListener('click', () => document.getElementById('emailLoginForm').classList.remove('hidden'));
        document.getElementById('uploadToHubBtn').addEventListener('click', openUploadModal);
        document.getElementById('uploadProjectModal').addEventListener('click', (e) => { if (e.target === document.getElementById('uploadProjectModal')) { document.getElementById('uploadProjectModal').close(); cvs.focus(); } }); // Close modal on backdrop click
        document.getElementById('uploadConfirmBtn').addEventListener('click', uploadProjectToHub);
        document.getElementById('uploadCancelBtn').addEventListener('click', () => { document.getElementById('uploadProjectModal').close(); cvs.focus(); });

    } catch (e) {
        showToast('Schwerer Fehler', `Ein unerwarteter Fehler ist aufgetreten: ${e.message}.`, 'error', 10000);
    }
};

const frustum = new THREE.Frustum(); // For frustum culling
const tempCameraMatrix = new THREE.Matrix4(); // Temporary matrix for frustum calculation

/** Main animation loop for rendering the scene and camera movement. */
function animate() {
    requestAnimationFrame(animate);

    // Camera movement when pointer is locked (right-click drag)
    if (isPointerLocked) {
        if (firstMoveAfterLock) { // Ignore first movement after lock to prevent jump
            firstMoveAfterLock = false;
            mouseMovementX = mouseMovementY = 0;
            return;
        }
        // Apply mouse movement to Euler angles for rotation
        euler.y -= (mouseMovementX || 0) * rotSpeed;
        euler.x -= (mouseMovementY || 0) * rotSpeed;
        euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x)); // Clamp vertical rotation
        cam.quaternion.setFromEuler(euler); // Update camera quaternion from Euler

        mouseMovementX = mouseMovementY = 0; // Reset movements

        // Apply keyboard movement (WASDQE)
        const camDir = new THREE.Vector3(); cam.getWorldDirection(camDir); // Camera forward direction
        const rightDir = new THREE.Vector3().crossVectors(camDir, cam.up).normalize(); // Camera right direction
        const upVec = new THREE.Vector3(0, 1, 0); // World up direction
        const currMoveSpeed = moveSpeed * 0.5; // Current effective move speed
        if (keyboard['w']) cam.position.addScaledVector(camDir, currMoveSpeed);
        if (keyboard['s']) cam.position.addScaledVector(camDir, -currMoveSpeed);
        if (keyboard['a']) cam.position.addScaledVector(rightDir, -currMoveSpeed);
        if (keyboard['d']) cam.position.addScaledVector(rightDir, currMoveSpeed);
        if (keyboard['e']) cam.position.addScaledVector(upVec, currMoveSpeed); // Move up
        if (keyboard['q']) cam.position.addScaledVector(upVec, -currMoveSpeed); // Move down
    }

    // Frustum culling for chunks (hide chunks outside camera view)
    cam.updateMatrixWorld();
    tempCameraMatrix.multiplyMatrices(cam.projectionMatrix, cam.matrixWorldInverse);
    frustum.setFromProjectionMatrix(tempCameraMatrix);
    for (const chunk of chunks.values()) {
        chunk.instancedMesh.visible = frustum.intersectsBox(chunk.boundingBox);
    }

    ren.render(scene, cam); // Render the scene
}
</script></body></html>
