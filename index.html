<!DOCTYPE html>
<html lang="de" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VoxelShaper - Community 3D Modelle</title>
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='%2360a5fa' d='M12 2L2 7l10 5 10-5-10-5zm0 14.5l-10-5 10-5 10 5-10 5zM12 21.5l-10-5 10-5 10 5-10 5z'/%3E%3C/svg%3E" type="image/svg+xml">
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.7.2/dist/full.min.css" rel="stylesheet" type="text/css" />
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://www.google.com/recaptcha/api.js?render=6LeIxAcTAAAAAJcZVRqyHh71UMIEGNQ_MXjiZKhI"></script>
    <style>
        .voxel-detail-canvas, .voxel-preview-canvas {
            width: 100%;
            height: 600px;
            display: block;
            background-color: var(--fallback-b2, oklch(var(--b2)));
            border-radius: var(--rounded-box, 1rem);
            touch-action: none;
        }
        .voxel-preview-canvas {
            height: 208px;
        }

        @media (max-width: 768px) {
            .voxel-detail-canvas {
                height: 400px;
            }
        }
        .comment-card {
            border-bottom: 1px solid oklch(var(--bc) / 0.1);
            padding-bottom: 1rem;
            margin-bottom: 1rem;
        }
        .comment-card:last-child {
            border-bottom: none;
            padding-bottom: 0;
            margin-bottom: 0;
        }
        .stat .stat-value {
            white-space: normal;
            word-break: break-word;
            min-width: 0;
        }
        .stat {
            flex-grow: 1;
            flex-basis: 0;
            min-width: 120px;
            padding: 1rem;
        }
        .stat .stat-title {
            font-size: 0.875rem;
            line-height: 1.25rem;
            white-space: nowrap;
        }
        .stat .stat-value {
            font-size: 1.875rem;
            line-height: 2.25rem;
        }
        .stat .stat-figure i {
            font-size: 1.5rem;
        }
        .stats-container {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: space-around;
        }
        @media (min-width: 768px) {
            .stats-container {
                flex-wrap: nowrap;
                justify-content: space-between;
            }
            .stat {
                min-width: unset;
            }
        }
        .grecaptcha-badge {
            visibility: hidden !important;
        }

        [contenteditable]:hover:not(:focus) {
            background-color: oklch(var(--b3) / 0.5);
            border-radius: 0.25rem;
        }
        [contenteditable]:focus {
            outline: 2px solid oklch(var(--p));
            outline-offset: 2px;
            background-color: oklch(var(--b3));
        }
        .edit-icon, .edit-icon-desc {
            display: none;
        }
        [contenteditable]:hover + .edit-icon, [contenteditable]:focus + .edit-icon,
        [contenteditable]:hover + .edit-icon-desc, [contenteditable]:focus + .edit-icon-desc {
            display: inline-block !important;
        }

        .profile-section {
            background-color: var(--fallback-b2, oklch(var(--b2)));
            padding: 2rem;
            border-radius: var(--rounded-box, 1rem);
            box-shadow: var(--shadow-2);
        }
        .profile-avatar {
            width: 120px;
            height: 120px;
            font-size: 3rem;
        }

        .rating input {
            background-color: #f59e0b;
        }
        
        .rating:hover input,
        .rating input:hover ~ input,
        .rating input:checked ~ input {
            background-color: #9ca3af;
        }
    </style>
</head>
<body class="bg-base-100 min-h-screen text-base-content">
    <div class="navbar bg-base-200 border-b border-base-content/20 px-4 py-3 flex-wrap">
        <div class="flex-1">
            <a href="#" class="2xl font-black text-blue-400 tracking-tight" id="nav-home">
                <i class="fas fa-cube mr-2"></i>VoxelShaper
            </a>
            <div class="hidden md:flex ml-10">
                <a href="#" id="nav-discover" class="btn btn-ghost btn-sm">Entdecken</a>
                <a href="#" id="nav-popular" class="btn btn-ghost btn-sm">Beliebt</a>
                <a href="#" id="nav-new" class="btn btn-ghost btn-sm">Neu</a>
                <a href="#" id="nav-categories" class="btn btn-ghost btn-sm">Kategorien</a>
                <a href="#" id="nav-my-models" class="btn btn-ghost btn-sm hidden">Meine Modelle</a>
            </div>
        </div>
        <div class="flex-none gap-4 mt-2 md:mt-0 w-full md:w-auto justify-end">
            <div class="form-control flex-grow md:flex-grow-0 max-w-xs">
                <input type="text" id="search-input" placeholder="Modelle suchen..." class="input input-bordered w-full bg-base-300 border-base-content/20" aria-label="Modelle suchen" />
            </div>

            <label class="swap swap-rotate btn btn-ghost btn-circle" aria-label="Theme wechseln">
                <input type="checkbox" id="theme-toggle" />

                <svg
                    class="swap-on h-6 w-6 fill-current"
                    xmlns="http://www.w3.org/2000/svg"
                    viewBox="0 0 24 24">
                    <path
                        d="M5.64,17l-.71.71a1,1,0,0,0,0,1.41,1,1,0,0,0,1.41,0l.71-.71A1,1,0,0,0,5.64,17ZM5,12a1,1,0,0,0-1-1H3a1,1,0,0,0,0,2H4A1,1,0,0,0,5,12Zm7-7a1,1,0,0,0,1-1V3a1,1,0,0,0-2,0V4A1,1,0,0,0,12,5ZM5.64,7.05a1,1,0,0,0,.7.29,1,1,0,0,0,.71-.29,1,1,0,0,0,0-1.41l-.71-.71A1,1,0,0,0,4.93,6.34Zm12,.29a1,1,0,0,0,.7-.29l.71-.71a1,1,0,1,0-1.41-1.41L17,5.64a1,1,0,0,0,0,1.41A1,1,0,0,0,17.66,7.34ZM21,11H20a1,1,0,0,0,0,2h1a1,1,0,0,0,0-2Zm-9,8a1,1,0,0,0-1,1v1a1,1,0,0,0,2,0V20A1,1,0,0,0,12,19ZM18.36,17A1,1,0,0,0,17,18.36l.71.71a1,1,0,0,0,1.41,0,1,1,0,0,0,0-1.41ZM12,6.5A5.5,5.5,0,1,0,17.5,12,5.51,5.51,0,0,0,12,6.5Zm0,9A3.5,3.5,0,1,1,15.5,12,3.5,3.5,0,0,1,12,15.5Z" />
                </svg>

                <svg
                    class="swap-off h-6 w-6 fill-current"
                    xmlns="http://www.w3.org/2000/svg"
                    viewBox="0 0 24 24">
                    <path
                        d="M21.64,13a1,1,0,0,0-1.05-.14,8.05,8.05,0,0,1-3.37.73A8.15,8.15,0,0,1,9.08,5.49a8.59,8.59,0,0,1,.25-2A1,1,0,0,0,8,2.36,10.14,10.14,0,1,0,22,14.05,1,1,0,0,0,21.64,13Zm-9.5,6.69A8.14,8.14,0,0,1,7.08,5.22v.27A10.15,10.15,0,0,0,17.22,15.63a9.79,9.79,0,0,0,2.1-.22A8.11,8.11,0,0,1,12.14,19.73Z" />
                </svg>
            </label>
            
            <div class="dropdown dropdown-end">
                <div tabindex="0" role="button" class="btn btn-ghost btn-circle" aria-label="Benachrichtigungen">
                    <i class="fas fa-bell text-xl"></i>
                </div>
                <ul tabindex="0" class="dropdown-content z-[1] menu p-2 shadow bg-base-200 rounded-box w-64 mt-4">
                    <li class="text-center py-4 text-base-content/60">Keine Benachrichtigungen</li>
                </ul>
            </div>
            <div class="dropdown dropdown-end">
                <div tabindex="0" role="button" id="user-menu-button" class="btn btn-ghost btn-circle avatar placeholder" aria-label="Benutzermenü">
                    <div class="bg-neutral text-neutral-content rounded-full w-10 flex items-center justify-center">
                        <span><i class="fas fa-user text-lg"></i></span>
                    </div>
                </div>
                <ul tabindex="0" class="dropdown-content z-[1] menu p-2 shadow bg-base-200 rounded-box w-52 mt-4">
                    <li id="login-button"><a><i class="fas fa-sign-in-alt mr-2"></i>Anmelden</a></li>
                    <li id="profile-button" class="hidden"><a><i class="fas fa-user mr-2"></i>Profil</a></li>
                    <li id="logout-button" class="hidden"><a><i class="fas fa-sign-out-alt mr-2"></i>Abmelden</a></li>
                </ul>
            </div>
        </div>
    </div>

    <div id="main-content-view" class="container mx-auto px-4 py-8">
        <div class="flex justify-between items-center mb-8">
            <h1 class="text-3xl font-bold" id="main-content-title">Community-Modelle</h1>
            <button id="open-voxelshaper-main-button" class="btn btn-secondary">
                <i class="fas fa-external-link-alt mr-2"></i>VoxelShaper öffnen
            </button>
        </div>

        <div class="bg-base-200 rounded-lg p-4 mb-6">
            <div class="flex flex-col md:flex-row md:flex-wrap items-start md:items-center gap-4">
                <div class="form-control w-full md:w-auto">
                    <label class="label">
                        <span class="label-text text-base-content/60">Kategorie</span>
                    </label>
                    <div id="category-filter-buttons" class="flex flex-wrap gap-2">
                    </div>
                </div>

                <div class="form-control w-full max-w-xs">
                    <label class="label">
                        <span class="label-text text-base-content/60">Sortieren nach</span>
                    </label>
                    <select id="sort-by" class="select select-bordered w-full bg-base-300 border-base-content/20">
                        <option value="newest-desc">Neueste (absteigend)</option>
                        <option value="newest-asc">Neueste (aufsteigend)</option>
                        <option value="popular-desc">Beliebteste (absteigend)</option>
                        <option value="popular-asc">Beliebteste (aufsteigend)</option>
                        <option value="top-rated-desc">Am besten bewertet (absteigend)</option>
                        <option value="top-rated-asc">Am besten bewertet (aufsteigend)</option>
                    </select>
                </div>

                <div class="form-control w-full max-w-xs">
                    <label class="label">
                        <span class="label-text text-base-content/60">Status</span>
                    </label>
                    <select id="status-filter-select" class="select select-bordered w-full bg-base-300 border-base-content/20">
                        <option value="verified">Verifiziert</option>
                        <option value="all">Alle</option>
                    </select>
                </div>

            </div>
        </div>

        <div id="models-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
            </div>

        <div id="loading-sentinel" class="flex flex-col items-center justify-center mt-10">
            <span id="loading-spinner" class="loading loading-spinner loading-lg text-primary hidden"></span>
            <p id="no-more-models" class="text-base-content/60 mt-4 hidden">Keine weiteren Modelle verfügbar.</p>
        </div>
    </div>

    <div id="detail-content-view" class="container mx-auto px-4 py-8 hidden">
        <button id="back-to-overview-button" class="btn btn-ghost mb-6">
            <i class="fas fa-arrow-left mr-2"></i>Zurück zur Übersicht
        </button>

        <div id="model-detail-container" class="bg-base-200 rounded-xl p-6 shadow-xl">
            <div id="detail-loading-spinner" class="flex justify-center items-center h-64">
                <span class="loading loading-spinner loading-lg text-primary"></span>
            </div>

            <div id="model-not-found" class="text-center text-error text-xl p-8 hidden">
                Modell nicht gefunden. Die angeforderte Seite konnte nicht geladen werden.
            </div>

            <div id="model-content" class="hidden">
                <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
                    <div class="lg:col-span-2 flex flex-col gap-6">
                        <div class="rounded-xl overflow-hidden shadow-lg relative bg-base-300 flex items-center justify-center">
                            <canvas id="voxel-detail-canvas" class="voxel-detail-canvas"></canvas>
                            <div id="detail-preview-message" class="absolute inset-0 flex items-center justify-center text-base-content/60 text-sm hidden"></div>
                        </div>
                        <div class="stats stats-vertical lg:stats-horizontal shadow w-full bg-base-300 rounded-box stats-container">
                            <div class="stat">
                                <div class="stat-figure text-primary">
                                    <i class="fas fa-download text-2xl"></i>
                                </div>
                                <div class="stat-title">Downloads</div>
                                <div id="download-count" class="stat-value text-primary">0</div>
                            </div>
                            <div class="stat">
                                <div class="stat-figure text-secondary">
                                    <i class="fas fa-star text-2xl"></i>
                                </div>
                                <div class="stat-title">Bewertungen</div>
                                <div id="rating-count" class="stat-value text-secondary">0</div>
                            </div>
                            <div class="stat">
                                <div class="stat-figure text-info">
                                    <i class="fas fa-cube text-2xl"></i>
                                </div>
                                <div class="stat-title">Kategorie</div>
                                <div id="model-category" class="stat-value text-info"></div>
                            </div>
                        </div>
                    </div>

                    <div class="lg:col-span-1 flex flex-col gap-6">
                        <div>
                            <h1 id="model-title" class="text-4xl font-bold mb-2"></h1>
                            <div class="flex items-center text-base-content/60 text-sm mb-4 gap-x-4">
                                <div class="flex items-center">
                                    <div class="avatar mr-2">
                                        <div class="w-8 h-8 rounded-full bg-neutral text-neutral-content flex items-center justify-center text-lg" id="uploader-avatar">
                                            <i class="fas fa-user"></i>
                                        </div>
                                    </div>
                                    <span id="uploader-info"></span>
                                </div>
                                <span id="upload-date" class="ml-auto"></span>
                            </div>

                            <div class="flex items-center mb-4">
                                <div class="rating rating-md" id="detail-rating-stars"></div>
                                <span id="detail-rating-text" class="text-base-content/60 ml-2"></span>
                            </div>

                            <div class="flex flex-col sm:flex-row lg:flex-col gap-2 justify-start mb-4">
                                <button id="download-stl-button" class="btn btn-primary btn-lg w-full">
                                    <i class="fas fa-download mr-2"></i>STL Herunterladen
                                </button>
                                <button id="open-voxelshaper-button" class="btn btn-secondary btn-lg w-full">
                                    <i class="fas fa-external-link-alt mr-2"></i>In VoxelShaper öffnen
                                </button>
                                <button id="share-button" class="btn btn-info btn-lg w-full">
                                    <i class="fas fa-share-alt mr-2"></i>Teilen
                                </button>
                            </div>
                        </div>

                        <div>
                            <h2 class="text-2xl font-semibold mb-2">Beschreibung</h2>
                            <p id="model-description" class="text-base-content/80 leading-relaxed"></p>
                        </div>

                        <div id="admin-actions" class="flex flex-wrap gap-2 mt-4 hidden">
                            <h2 class="text-xl font-semibold w-full mb-2">Admin-Aktionen</h2>
                            <button id="verify-button" class="btn btn-success">
                                <i class="fas fa-check mr-2"></i>Verifizieren
                            </button>
                            <button id="revert-verify-button" class="btn btn-warning hidden">
                                <i class="fas fa-undo mr-2"></i>Verifizierung rückgängig
                            </button>
                            <button id="delete-button" class="btn btn-error">
                                <i class="fas fa-trash mr-2"></i>Löschen
                            </button>
                        </div>
                    </div>
                </div>

                <div class="mt-12">
                    <h2 class="text-3xl font-bold mb-6">Kommentare & Bewertungen</h2>
                    <div id="comments-list" class="bg-base-300 p-6 rounded-lg shadow-inner">
                        <p id="no-comments-message" class="text-base-content/60 text-center py-4 hidden">Noch keine Kommentare. Sei der Erste!</p>
                    </div>

                    <div class="mt-8 p-6 bg-base-300 rounded-lg shadow-inner">
                        <h3 class="text-2xl font-semibold mb-4">Ihre Bewertung & Kommentar</h3>
                        <div class="flex items-center mb-4">
                            <span class="mr-4 text-base-content/80">Ihre Bewertung:</span>
                            <div class="rating rating-md" id="user-rating-input">
                                <input type="radio" name="user-rating" class="mask mask-star-2" value="1" aria-label="1 Stern">
                                <input type="radio" name="user-rating" class="mask mask-star-2" value="2" aria-label="2 Sterne">
                                <input type="radio" name="user-rating" class="mask mask-star-2" value="3" aria-label="3 Sterne">
                                <input type="radio" name="user-rating" class="mask mask-star-2" value="4" aria-label="4 Sterne">
                                <input type="radio" name="user-rating" class="mask mask-star-2" value="5" aria-label="5 Sterne">
                            </div>
                        </div>
                        <textarea id="comment-input" class="textarea textarea-bordered w-full bg-base-200 border-base-content/20 h-32 mb-4" placeholder="Schreiben Sie hier Ihren Kommentar..."></textarea>
                        <button id="post-comment-button" class="btn btn-primary w-full">
                            <i class="fas fa-comment-alt mr-2"></i>Kommentar posten
                        </button>
                        <p id="comment-auth-message" class="text-info text-sm mt-2 text-center hidden">Bitte anmelden, um zu kommentieren.</p>
                        <p id="rating-edit-info" class="text-base-content/60 text-xs mt-2 text-center">
                            Sie können Ihre Bewertung jederzeit ändern, indem Sie einen neuen Kommentar mit einer neuen Sternebewertung abgeben.
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="profile-content-view" class="container mx-auto px-4 py-8 hidden">
        <button id="back-to-main-from-profile-button" class="btn btn-ghost mb-6">
            <i class="fas fa-arrow-left mr-2"></i>Zurück zur Hauptseite
        </button>

        <div class="profile-section flex flex-col items-center p-8 gap-6">
            <h1 class="text-4xl font-bold mb-4">Mein Profil</h1>
            <div class="avatar placeholder mb-4">
                <div class="profile-avatar rounded-full bg-neutral text-neutral-content flex items-center justify-center">
                    <span id="profile-avatar-initial" class="text-white"></span>
                    <img id="profile-avatar-img" src="" alt="Profilbild" class="w-full h-full object-cover rounded-full hidden">
                </div>
            </div>
            <div class="text-center">
                <p class="text-xl font-semibold mb-2" id="profile-email"></p>
                <p class="text-base-content/60 text-sm" id="profile-creation-date"></p>
            </div>
            <button id="delete-account-button" class="btn btn-error mt-8">
                <i class="fas fa-user-times mr-2"></i>Konto löschen
            </button>
        </div>
    </div>


    <footer class="footer p-10 bg-base-300 text-base-content mt-16">
        <div class="container mx-auto">
            <div class="grid grid-cols-1 md:grid-cols-4 gap-8">
                <div>
                    <h3 class="footer-title text-base-content">VoxelShaper</h3>
                    <p class="mt-4">Die Community für 3D-Voxelmodelle. Teile, entdecke und drucke einzigartige Kreationen.</p>
                    <div class="flex gap-4 mt-4">
                        <a href="#"><i class="fab fa-discord text-xl"></i></a>
                        <a href="#"><i class="fab fa-twitter text-xl"></i></a>
                        <a href="#"><i class="fab fa-instagram text-xl"></i></a>
                        <a href="#"><i class="fab fa-github text-xl"></i></a>
                    </div>
                </div>
                <div>
                    <h3 class="footer-title">Ressourcen</h3>
                    <a class="link link-hover mt-4">Blog</a>
                    <a class="link link-hover">Tutorials</a>
                    <a class="link link-hover">Dokumentation</a>
                    <a class="link link-hover">API</a>
                </div>
                <div>
                    <h3 class="footer-title">Community</h3>
                    <a class="link link-hover mt-4">Forum</a>
                    <a class="link link-hover">Events</a>
                    <a class="link link-hover">Mitwirkende</a>
                    <a class="link link-hover">Partner</a>
                </div>
                <div>
                    <h3 class="footer-title">Rechtliches</h3>
                    <a class="link link-hover mt-4">AGB</a>
                    <a class="link link-hover">Datenschutz</a>
                    <a class="link link-hover">Lizenzierung</a>
                    <a class="link link-hover">Cookie-Richtlinie</a>
                </div>
            </div>
            <div class="border-t border-base-content/20 mt-12 pt-6 text-center">
                <p>© 2023 VoxelShaper. Alle Rechte vorbehalten.</p>
            </div>
        </div>
    </footer>

    <dialog id="auth-modal" class="modal">
        <div class="modal-box bg-base-200">
            <h3 class="font-bold text-lg text-center">Anmeldung bei VoxelShaper</h3>
            <p class="py-4 text-center">Melde dich an, um Modelle zu bewerten, herunterzuladen und eigene Kreationen zu teilen.</p>
            <div class="modal-action flex flex-col items-center w-full">
                <form method="dialog" class="w-full">
                    <div class="flex flex-col gap-3 w-full">
                        <input id="email-input" type="email" placeholder="E-Mail" class="input input-bordered w-full bg-base-300 border-base-content/20" autocomplete="email" />
                        <input id="password-input" type="password" placeholder="Passwort" class="input input-bordered w-full bg-base-300 border-base-content/20" autocomplete="current-password" />
                        <button id="firebase-login" class="btn btn-primary w-full">
                            <i class="fas fa-sign-in-alt mr-2"></i> Anmelden
                        </button>
                        <button id="firebase-signup" class="btn btn-secondary w-full">
                            <i class="fas fa-user-plus mr-2"></i> Registrieren
                        </button>
                        <div class="divider text-base-content/60">ODER</div>
                        <button id="google-login" class="btn btn-info w-full">
                            <i class="fab fa-google mr-2"></i> Mit Google anmelden
                        </button>
                        <button id="github-login" class="btn w-full bg-neutral hover:bg-neutral-focus text-neutral-content border-none">
                            <i class="fab fa-github mr-2"></i> Mit GitHub anmelden
                        </button>
                        <button class="btn btn-outline w-full" onclick="document.getElementById('auth-modal').close()">Abbrechen</button>
                    </div>
                    <p id="auth-error-message" class="text-error text-sm mt-4 text-center hidden"></p>
                </form>
            </div>
        </div>
    </dialog>

    <dialog id="delete-confirm-modal" class="modal">
        <div class="modal-box bg-base-200">
            <h3 class="font-bold text-lg">Modell löschen bestätigen</h3>
            <p class="py-4">Möchten Sie das Modell "<span id="model-to-delete-title" class="font-semibold"></span>" wirklich löschen? Diese Aktion kann nicht rückgängig gemacht werden.</p>
            <div class="modal-action">
                <button id="confirm-delete-button" class="btn btn-error">Löschen</button>
                <button class="btn btn-outline" onclick="document.getElementById('delete-confirm-modal').close()">Abbrechen</button>
            </div>
        </div>
    </dialog>

    <dialog id="edit-comment-modal" class="modal">
        <div class="modal-box bg-base-200">
            <h3 class="font-bold text-lg">Kommentar bearbeiten</h3>
            <textarea id="edit-comment-input" class="textarea textarea-bordered w-full bg-base-300 border-base-content/20 h-32 my-4"></textarea>
            <div class="modal-action">
                <button id="save-comment-edit-button" class="btn btn-primary">Speichern</button>
                <button class="btn btn-outline" onclick="document.getElementById('edit-comment-modal').close()">Abbrechen</button>
            </div>
            <p id="edit-comment-error-message" class="text-error text-sm mt-2 hidden"></p>
        </div>
    </dialog>

    <dialog id="delete-comment-confirm-modal" class="modal">
        <div class="modal-box bg-base-200">
            <h3 class="font-bold text-lg">Kommentar löschen bestätigen</h3>
            <p class="py-4">Möchten Sie diesen Kommentar wirklich löschen? Diese Aktion kann nicht rückgängig gemacht werden.</p>
            <div class="modal-action">
                <button id="confirm-delete-comment-button" class="btn btn-error">Löschen</button>
                <button class="btn btn-outline" onclick="document.getElementById('delete-comment-confirm-modal').close()">Abbrechen</button>
            </div>
        </div>
    </dialog>

    <dialog id="delete-account-confirm-modal" class="modal">
        <div class="modal-box bg-base-200">
            <h3 class="font-bold text-lg text-error">Konto löschen bestätigen</h3>
            <p class="py-4 text-warning">
                Sind Sie sicher, dass Sie Ihr Konto löschen möchten?
                <br><br>
                Diese Aktion ist **ENDGÜLTIG** und kann nicht rückgängig gemacht werden.
                Ihre hochgeladenen Modelle bleiben weiterhin sichtbar, werden aber von Ihrem Konto getrennt. Sie können diese Modelle danach nicht mehr bearbeiten oder löschen.
            </p>
            <div class="modal-action flex flex-col sm:flex-row gap-2">
                <button id="confirm-delete-account-button" class="btn btn-error w-full sm:w-auto">Ja, Konto löschen</button>
                <button class="btn btn-outline w-full sm:w-auto" onclick="document.getElementById('delete-account-confirm-modal').close()">Abbrechen</button>
            </div>
        </div>
    </dialog>

    <div id="toast-container" class="toast toast-end z-50"></div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-app.js";
        import { 
            getAuth, 
            setPersistence,
            browserLocalPersistence, 
            signInWithEmailAndPassword, 
            createUserWithEmailAndPassword, 
            onAuthStateChanged,
            signOut,
            GoogleAuthProvider, 
            GithubAuthProvider,
            signInWithPopup,
            deleteUser
        } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-auth.js";
        import { 
            getFirestore, 
            collection, 
            addDoc, 
            serverTimestamp,
            query, 
            limit, 
            getDocs, 
            startAfter,
            where,
            doc, 
            getDoc,
            updateDoc,
            deleteDoc, 
            orderBy, 
            runTransaction, 
            onSnapshot, 
        } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyB9-mpyAu9W6oiVtB0fYG8E6YFvTAsjtAA", 
            authDomain: "voxelshaper.firebaseapp.com", 
            projectId: "voxelshaper",
            storageBucket: "voxelshaper.appspot.com", 
            messagingSenderId: "1053689247573",
            appId: "1:1053689247573:web:f7960c7f8c2e8849e8e1dc",
            measurementId: "G-QJ5CNKZ5DR"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        let currentUser = null;
        let currentUserId = null;
        let _isAdmin = false;
        let initialAuthCheckCompleted = false;

        const MODELS_PER_LOAD = 8;
        let lastVisible = null;
        let isLoadingModels = false; 
        let allModelsData = [];

        const loginButton = document.getElementById('login-button');
        const logoutButton = document.getElementById('logout-button');
        const profileButton = document.getElementById('profile-button');
        const userMenuButton = document.getElementById('user-menu-button');
        const authModal = document.getElementById('auth-modal');
        const firebaseLoginButton = document.getElementById('firebase-login');
        const firebaseSignupButton = document.getElementById('firebase-signup');
        const googleLoginButton = document.getElementById('google-login'); 
        const githubLoginButton = document.getElementById('github-login'); 
        const emailInput = document.getElementById('email-input');
        const passwordInput = document.getElementById('password-input');
        const authErrorMessage = document.getElementById('auth-error-message');
        const htmlElement = document.documentElement;
        const themeToggle = document.getElementById('theme-toggle');

        const openVoxelshaperMainButton = document.getElementById('open-voxelshaper-main-button');

        const modelsGrid = document.getElementById('models-grid');
        const loadingSpinner = document.getElementById('loading-spinner');
        const noMoreModelsMessage = document.getElementById('no-more-models');
        const loadingSentinel = document.getElementById('loading-sentinel'); 

        const sortBy = document.getElementById('sort-by');
        const categoryFilterButtonsContainer = document.getElementById('category-filter-buttons');
        let activeCategory = 'all';
        const statusFilterSelect = document.getElementById('status-filter-select');
        const statusFilterContainer = document.getElementById('status-filter-container');
        const searchInput = document.getElementById('search-input');
        const mainContentTitle = document.getElementById('main-content-title');

        const navDiscoverButton = document.getElementById('nav-discover');
        const navPopularButton = document.getElementById('nav-popular');
        const navNewButton = document.getElementById('nav-new');
        const navCategoriesButton = document.getElementById('nav-categories');
        const navHomeButton = document.getElementById('nav-home');
        const navMyModelsButton = document.getElementById('nav-my-models');
        let currentFilterView = 'community';

        const mainContentView = document.getElementById('main-content-view');
        const detailContentView = document.getElementById('detail-content-view');
        const backToOverviewButton = document.getElementById('back-to-overview-button');

        const detailLoadingSpinner = document.getElementById('detail-loading-spinner');
        const modelNotFoundMessage = document.getElementById('model-not-found');
        const modelContent = document.getElementById('model-content');

        const modelTitleElement = document.getElementById('model-title');
        const uploaderAvatarElement = document.getElementById('uploader-avatar');
        const uploaderInfoElement = document.getElementById('uploader-info');
        const uploadDateElement = document.getElementById('upload-date');
        const detailRatingStars = document.getElementById('detail-rating-stars');
        const detailRatingText = document.getElementById('detail-rating-text');
        const downloadCountElement = document.getElementById('download-count'); 
        const ratingCountElement = document.getElementById('rating-count'); 
        const modelCategoryElement = document.getElementById('model-category'); 

        const modelDescriptionElement = document.getElementById('model-description');

        const downloadStlButton = document.getElementById('download-stl-button'); 
        const openVoxelshaperButton = document.getElementById('open-voxelshaper-button'); 
        const shareButton = document.getElementById('share-button'); 

        const adminActionsDiv = document.getElementById('admin-actions');
        const verifyButton = document.getElementById('verify-button');
        const revertVerifyButton = document.getElementById('revert-verify-button');
        const deleteButton = document.getElementById('delete-button');

        const commentsList = document.getElementById('comments-list');
        const noCommentsMessage = document.getElementById('no-comments-message');
        const commentInput = document.getElementById('comment-input');
        const postCommentButton = document.getElementById('post-comment-button');
        const commentAuthMessage = document.getElementById('comment-auth-message');
        const userRatingInput = document.getElementById('user-rating-input');

        const editCommentModal = document.getElementById('edit-comment-modal');
        const editCommentInput = document.getElementById('edit-comment-input');
        const saveCommentEditButton = document.getElementById('save-comment-edit-button');
        const editCommentErrorMessage = document.getElementById('edit-comment-error-message');

        const deleteCommentConfirmModal = document.getElementById('delete-comment-confirm-modal');
        const confirmDeleteCommentButton = document.getElementById('confirm-delete-comment-button');
        let currentCommentToEdit = null;
        let currentCommentToDelete = null;

        const profileContentView = document.getElementById('profile-content-view');
        const backToMainFromProfileButton = document.getElementById('back-to-main-from-profile-button');
        const profileEmail = document.getElementById('profile-email');
        const profileCreationDate = document.getElementById('profile-creation-date');
        const profileAvatarInitial = document.getElementById('profile-avatar-initial');
        const profileAvatarImg = document.getElementById('profile-avatar-img');
        const deleteAccountButton = document.getElementById('delete-account-button');
        const deleteAccountConfirmModal = document.getElementById('delete-account-confirm-modal');
        const confirmDeleteAccountButton = document.getElementById('confirm-delete-account-button');

        const voxelDetailCanvas = document.getElementById('voxel-detail-canvas');
        const detailPreviewMessage = document.getElementById('detail-preview-message');
        let detailRenderer = null;

        const googleProvider = new GoogleAuthProvider();
        const githubProvider = new GithubAuthProvider(); 

        const predefinedCategories = ["Alle", "Spielzeug", "Dekoration", "Funktional", "Kunst", "Allgemein"];

        let lastFocusedElement = null;

        let modelIdToDelete = null; 

        let currentDetailModelData = null;

        let lastToastTime = 0;
        const MIN_TOAST_INTERVAL = 1500;

        function isAdmin() {
            return _isAdmin;
        }

        function showToast(message, type = 'info', duration = 3000) {
            const now = Date.now();
            if (now - lastToastTime < MIN_TOAST_INTERVAL) {
                return;
            }
            lastToastTime = now;

            const toastContainer = document.getElementById('toast-container');
            if (!toastContainer) {
                return;
            }

            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type} shadow-lg`;
            alertDiv.setAttribute('role', 'alert');
            alertDiv.innerHTML = `
                ${type === 'info' ? '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" class="stroke-current shrink-0 h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>' : ''}
                ${type === 'success' ? '<svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>' : ''}
                ${type === 'error' || type === 'warning' ? '<svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>' : ''}
                <span>${message}</span>
            `;
            toastContainer.appendChild(alertDiv);

            setTimeout(() => {
                alertDiv.remove();
            }, duration);
        }

        function hideMessage(element) {
            element.classList.add('hidden');
            element.textContent = '';
        }

        function getDaisyUICSSColorForThreeJS(selectedTheme) {
            const originalTheme = htmlElement.getAttribute('data-theme');
            htmlElement.setAttribute('data-theme', selectedTheme);

            void document.body.offsetHeight; 

            const computedColor = getComputedStyle(document.body).backgroundColor;
            
            htmlElement.setAttribute('data-theme', originalTheme); 

            let hexColor = '#000000';

            const canvas = document.createElement('canvas');
            canvas.width = 1;
            canvas.height = 1;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = computedColor;
            ctx.fillRect(0, 0, 1, 1);
            const pixelData = ctx.getImageData(0, 0, 1, 1).data;
            
            const toHex = (c) => c.toString(16).padStart(2, '0');
            hexColor = `#${toHex(pixelData[0])}${toHex(pixelData[1])}${toHex(pixelData[2])}`;

            let r = pixelData[0];
            let g = pixelData[1];
            let b = pixelData[2];

            const adjustmentFactor = 0.1;

            if (selectedTheme === 'dark') {
                r = Math.min(255, r + Math.round(r * adjustmentFactor));
                g = Math.min(255, g + Math.round(g * adjustmentFactor));
                b = Math.min(255, b + Math.round(b * adjustmentFactor));
            } else {
                r = Math.max(0, r - Math.round(r * adjustmentFactor));
                g = Math.max(0, g - Math.round(g * adjustmentFactor));
                b = Math.max(0, b - Math.round(b * adjustmentFactor));
            }

            hexColor = `#${toHex(r)}${toHex(g)}${toHex(b)}`;

            return hexColor;
        }

        class VoxelRenderer { 
            constructor(canvasElement, voxelsData, gridSize = 10, backgroundColor, messageElement = null, enableControls = false, enableAutoRotate = false) {
                this.canvas = canvasElement;
                this.voxelsData = voxelsData; 
                this.gridSize = gridSize;
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null; 
                this.animationFrameId = null;
                this.pivotGroup = null; 
                this.instancedMesh = null; 
                this.isAnimating = false; 
                this.autoRotateEnabled = enableAutoRotate; 
                this.backgroundColor = backgroundColor; 
                this.messageElement = messageElement; 
                this.enableControls = enableControls; 
                
                if (!this.enableControls) {
                    this.isDragging = false; 
                    this.hasMoved = false; 
                    this.dragThreshold = 5; 
                    this.startX = 0;
                    this.startY = 0;
                    this.lastX = undefined; 
                    this.lastY = undefined; 
                }

                this.init();
                this.bindEventListeners();
            }

            init() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(this.backgroundColor); 

                if (!this.canvas) {
                    console.error("VoxelRenderer: Canvas-Element ist null. Renderer kann nicht initialisiert werden.");
                    if (this.messageElement) {
                        this.messageElement.textContent = 'Vorschau nicht verfügbar: Canvas-Element nicht gefunden.';
                        this.messageElement.classList.remove('hidden');
                        this.messageElement.classList.add('text-error');
                    }
                    return;
                }

                try {
                    this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });
                } catch (e) {
                    console.error("VoxelRenderer: Fehler beim Initialisieren von WebGLRenderer:", e);
                    if (this.messageElement) {
                        this.messageElement.textContent = 'Vorschau nicht verfügbar: WebGL-Fehler.';
                        this.messageElement.classList.remove('hidden');
                        this.messageElement.classList.add('text-error');
                    }
                    return;
                }
                
                if (!this.renderer) {
                    console.error("VoxelRenderer: WebGLRenderer konnte nicht initialisiert werden.");
                     if (this.messageElement) {
                        this.messageElement.textContent = 'Vorschau nicht verfügbar: Renderer-Initialisierung fehlgeschlagen.';
                        this.messageElement.classList.remove('hidden');
                        this.messageElement.classList.add('text-error');
                    }
                    return;
                }

                this.renderer.setSize(this.canvas.clientWidth, this.canvas.clientHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);

                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                const aspect = this.canvas.clientWidth / this.canvas.clientHeight;
                this.camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000); 

                const ambientLight = new THREE.AmbientLight(0x606060); 
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); 
                directionalLight.position.set(2, 3, 1).normalize();
                directionalLight.castShadow = true;

                directionalLight.shadow.mapSize.width = 1024;
                directionalLight.shadow.mapSize.height = 1024;
                directionalLight.shadow.camera.near = 0.1;
                directionalLight.shadow.camera.far = 50;
                const shadowCameraSize = this.gridSize * 2; 
                directionalLight.shadow.camera.left = -shadowCameraSize;
                directionalLight.shadow.camera.right = shadowCameraSize;
                directionalLight.shadow.camera.top = shadowCameraSize;
                directionalLight.shadow.camera.bottom = -shadowCameraSize;
                
                this.scene.add(directionalLight);

                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true; 
                this.controls.dampingFactor = 0.05;
                this.controls.screenSpacePanning = false;
                this.controls.minDistance = 1;
                this.controls.maxDistance = 500;
                this.controls.enabled = this.enableControls; 
                this.controls.enableZoom = this.enableControls;
                this.controls.update(); 

                this.loadVoxels(); 
            }

            loadVoxels() {
                const voxelKeys = Object.keys(this.voxelsData || {}); 
                
                if (this.pivotGroup) {
                    this.scene.remove(this.pivotGroup);
                    this.pivotGroup.traverse((object) => {
                        if (object.isMesh) {
                            object.geometry.dispose();
                            object.material.dispose();
                        }
                    });
                    this.pivotGroup.clear();
                    this.pivotGroup = null;
                }
                this.instancedMesh = null; 

                if (!this.voxelsData || voxelKeys.length === 0) {
                    this.canvas.classList.add('hidden');
                    if (this.messageElement) {
                        this.messageElement.textContent = 'Keine 3D-Vorschau verfügbar (keine Voxeldaten)';
                        this.messageElement.classList.remove('hidden');
                    }
                    return; 
                } else {
                    this.canvas.classList.remove('hidden');
                    if (this.messageElement) {
                        this.messageElement.classList.add('hidden');
                    }
                }

                const voxelGeometry = new THREE.BoxGeometry(1, 1, 1);
                const dummy = new THREE.Object3D();
                const meshMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.7, metalness: 0.1 });

                const maxInstances = voxelKeys.length;
                const instancedMesh = new THREE.InstancedMesh(voxelGeometry, meshMaterial, maxInstances);
                instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(maxInstances * 3), 3);
                instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
                instancedMesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
                
                instancedMesh.castShadow = true;
                instancedMesh.receiveShadow = true;

                let instanceId = 0;
                let minX = Infinity, minY = Infinity, minZ = Infinity;
                let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

                for (const key of voxelKeys) { 
                    const parts = key.split(',').map(Number);
                    if (parts.length === 3) {
                        const [x, y, z] = parts;
                        const colorHex = this.voxelsData[key];
                        const color = new THREE.Color(colorHex);

                        dummy.position.set(x + 0.5, y + 0.5, z + 0.5); 
                        dummy.updateMatrix();
                        instancedMesh.setMatrixAt(instanceId, dummy.matrix);
                        instancedMesh.instanceColor.setXYZ(instanceId, color.r, color.g, color.b);
                        instanceId++;

                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        minZ = Math.min(minZ, z);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                        maxZ = Math.max(maxZ, z);
                    }
                }
                instancedMesh.count = instanceId;
                instancedMesh.instanceMatrix.needsUpdate = true;
                instancedMesh.instanceColor.needsUpdate = true;
                
                this.pivotGroup = new THREE.Group();
                this.scene.add(this.pivotGroup); 

                const modelBoundingBox = new THREE.Box3(
                    new THREE.Vector3(minX, minY, minZ),
                    new THREE.Vector3(maxX + 1, maxY + 1, maxZ + 1) 
                );
                const modelCenter = new THREE.Vector3();
                modelBoundingBox.getCenter(modelCenter);

                instancedMesh.position.sub(modelCenter);
                this.pivotGroup.add(instancedMesh); 
                this.instancedMesh = instancedMesh; 

                const centeredModelTarget = new THREE.Vector3(0, 0, 0);

                const boundingSphere = new THREE.Sphere();
                modelBoundingBox.getBoundingSphere(boundingSphere);
                const radius = boundingSphere.radius;

                const fov = this.camera.fov * (Math.PI / 180); 
                let distance = radius / Math.tan(fov / 2);

                distance *= 1.2; 

                const cameraOffset = new THREE.Vector3(1, 1, 1).normalize().multiplyScalar(distance);
                this.camera.position.copy(centeredModelTarget).add(cameraOffset); 
                this.camera.lookAt(centeredModelTarget); 
                this.camera.updateProjectionMatrix();

                this.controls.target.copy(centeredModelTarget);
                this.controls.update();
                this.renderer.render(this.scene, this.camera); 
            }

            startAnimation() {
                if (!this.isAnimating) {
                    this.isAnimating = true;
                    this.animationFrameId = requestAnimationFrame(this.animate.bind(this)); 
                }
            }

            stopAnimation() {
                if (this.isAnimating) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.isAnimating = false;
                }
            }

            startAutoRotation() {
                this.autoRotateEnabled = true;
            }

            stopAutoRotation() {
                this.autoRotateEnabled = false;
            }

            animate() {
                this.animationFrameId = requestAnimationFrame(this.animate.bind(this));
                
                if (this.controls) {
                    this.controls.update();
                }
                
                if (this.renderer && this.scene && this.camera) {
                    this.renderer.render(this.scene, this.camera);
                }

                if (this.autoRotateEnabled && this.pivotGroup && !this.isDragging) { 
                    this.pivotGroup.rotation.y += 0.005; 
                }
            }

            bindEventListeners() {
                if (!this.enableControls) { 
                    this.canvas.addEventListener('pointerdown', this.onPointerDown.bind(this));
                    this.canvas.addEventListener('pointermove', this.onPointerMove.bind(this));
                    this.canvas.addEventListener('pointerup', this.onPointerUp.bind(this));
                    this.canvas.addEventListener('pointerleave', this.onPointerLeave.bind(this));
                }

                this.onWindowResize = this.onWindowResize.bind(this);
                window.addEventListener('resize', this.onWindowResize);
            }

            onWindowResize() {
                const width = this.canvas.clientWidth;
                const height = this.canvas.clientHeight;
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(width, height);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.render(this.scene, this.camera);
            }

            dispose() {
                this.stopAnimation(); 
                window.removeEventListener('resize', this.onWindowResize); 

                if (!this.enableControls) { 
                    this.canvas.removeEventListener('pointerdown', this.onPointerDown.bind(this));
                    this.canvas.removeEventListener('pointermove', this.onPointerMove.bind(this));
                    this.canvas.removeEventListener('pointerup', this.onPointerUp.bind(this));
                    this.canvas.removeEventListener('pointerleave', this.onPointerLeave.bind(this));
                }

                this.scene.traverse((object) => {
                    if (object.isMesh) {
                        object.geometry.dispose();
                        object.material.dispose();
                        if (this.instancedMesh) {
                            this.instancedMesh.geometry.dispose();
                            this.instancedMesh.material.dispose();
                        }
                    } 
                });
                if (this.pivotGroup) {
                    this.scene.remove(this.pivotGroup);
                    this.pivotGroup.clear(); 
                }
                if (this.renderer) {
                    this.renderer.dispose();
                }
                if (this.controls) {
                    this.controls.dispose();
                }
            }

            onPointerDown(event) {
                if (event.button === 0 || event.pointerType === 'touch') {
                    this.startX = event.clientX;
                    this.startY = event.clientY;
                    this.hasMoved = false;
                    this.isDragging = false;
                    this.lastX = event.clientX;
                    this.lastY = event.clientY;
                    this.stopAutoRotation();
                    this.canvas.setPointerCapture(event.pointerId);
                    event.preventDefault();
                }
            }

            onPointerMove(event) {
                if (this.canvas.hasPointerCapture(event.pointerId) && this.pivotGroup) {
                    const currentX = event.clientX;
                    const currentY = event.clientY;
                    const deltaXFromStart = currentX - this.startX; 
                    const deltaYFromStart = currentY - this.startY; 

                    if (!this.hasMoved && Math.sqrt(deltaXFromStart * deltaXFromStart + deltaYFromStart * deltaYFromStart) > this.dragThreshold) {
                        this.hasMoved = true;
                    }

                    if (this.hasMoved) {
                        this.isDragging = true;
                        event.preventDefault();
                    }

                    if (this.lastX !== undefined && this.lastY !== undefined) {
                        const rotationDeltaX = currentX - this.lastX;
                        const rotationDeltaY = currentY - this.lastY;

                        if (event.pointerType === 'touch') {
                            if (Math.abs(rotationDeltaX) > Math.abs(rotationDeltaY)) {
                                this.pivotGroup.rotation.y += rotationDeltaX * 0.01; 
                            }
                        } else if (event.pointerType === 'mouse') {
                            if (this.isDragging) { 
                                this.pivotGroup.rotation.y += rotationDeltaX * 0.01; 
                            }
                        }
                    }
                    
                    this.lastX = currentX;
                    this.lastY = currentY;
                }
            }

            onPointerUp(event) {
                if (this.canvas.hasPointerCapture(event.pointerId)) {
                    this.canvas.releasePointerCapture(event.pointerId);
                }
                this.lastX = undefined;
                this.lastY = undefined;
                this.isDragging = false;

                const modelCard = this.canvas.closest('.model-card');
                if (modelCard) {
                    if (!isMobileDevice) {
                        const rect = modelCard.getBoundingClientRect();
                        if (event.clientX >= rect.left && event.clientX <= rect.right &&
                            event.clientY >= rect.top && event.clientY <= rect.bottom) {
                            if (!this.hasMoved) {
                                this.startAutoRotation();
                            }
                        } else {
                            this.stopAutoRotation();
                        }
                    } else {
                        if (intersectionObserver) {
                            const entry = intersectionObserver.takeRecords().find(e => e.target === modelCard);
                            if (entry && entry.isIntersecting && entry.intersectionRatio > 0.75) {
                                if (!this.hasMoved) {
                                    renderer.startAutoRotation();
                                }
                            } else {
                                renderer.stopAutoRotation();
                            }
                        }
                    }
                }
            }

            onPointerLeave(event) {
                if (this.canvas.hasPointerCapture(event.pointerId)) {
                    this.canvas.releasePointerCapture(event.pointerId);
                }
                this.isDragging = false;
                this.hasMoved = false;
                this.lastX = undefined;
                this.lastY = undefined;
                this.stopAutoRotation();
            }
        }

        const rendererInstances = new Map();
        const isMobileDevice = window.innerWidth <= 768; 

        let intersectionObserver;
        if (isMobileDevice) {
            intersectionObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    const modelId = entry.target.dataset.modelId;
                    const renderer = rendererInstances.get(modelId);

                    if (renderer) {
                        if (entry.isIntersecting && entry.intersectionRatio > 0.75) { 
                            if (!renderer.hasMoved) {
                                renderer.startAutoRotation();
                            }
                        } else {
                            renderer.stopAutoRotation();
                        }
                    }
                });
            }, { threshold: [0, 0.25, 0.5, 0.75, 1.0] }); 
        }

        function createModelCard(model) {
            const cardLink = document.createElement('a');
            cardLink.onclick = (event) => {
                const renderer = rendererInstances.get(model.id);
                if (renderer && renderer.hasMoved) {
                    event.preventDefault();
                    return;
                }
                event.preventDefault();
                showModelDetail(model.id);
            };
            cardLink.className = 'card bg-base-200 rounded-xl overflow-hidden border border-base-content/10 transition-transform duration-300 hover:translate-y-[-5px] hover:shadow-xl model-card block cursor-pointer';
            
            const rating = model.ratingCount > 0 ? (model.rating / model.ratingCount).toFixed(1) : '0.0';
            const canRate = currentUser && currentUser.uid !== model.uploaderUid;

            const uploadDate = model.timestamp ? new Date(model.timestamp.toDate()).toLocaleDateString('de-DE') : 'Unbekannt';

            let uploaderAvatarHtml;
            if (model.uploaderPhotoURL) {
                uploaderAvatarHtml = `<img src="${model.uploaderPhotoURL}" alt="Profilbild" class="w-full h-full object-cover rounded-full">`;
            } else if (model.email) { 
                uploaderAvatarHtml = `<span class="text-white">${model.uploaderEmail.charAt(0).toUpperCase()}</span>`; 
            } else {
                uploaderAvatarHtml = `<i class="fas fa-user"></i>`; 
            }

            const isUploaderOrAdmin = currentUser && (currentUser.uid === model.uploaderUid || isAdmin());

            cardLink.innerHTML = `
                <div class="h-52 flex items-center justify-center overflow-hidden relative text-base-content/60 text-sm text-center">
                    <div class="skeleton h-full w-full absolute inset-0 flex flex-col gap-2 p-4 justify-center items-center z-10" id="skeleton-${model.id}">
                        <div class="skeleton h-32 w-full"></div>
                        <div class="skeleton h-4 w-28"></div>
                        <div class="skeleton h-4 w-full"></div>
                    </div>
                    <canvas class="voxel-preview-canvas w-full h-full block opacity-0 absolute inset-0 z-0 transition-opacity duration-500"></canvas>
                    <div class="preview-message absolute inset-0 flex items-center justify-center text-error text-sm hidden"></div>
                </div>
                <div class="card-body p-4">
                    <div class="flex justify-between items-start">
                        <div class="flex flex-col flex-grow">
                            <div class="flex items-center gap-2">
                                <h2 class="card-title text-lg" contenteditable="${isUploaderOrAdmin}" data-model-id="${model.id}" data-field="title">${model.title}</h2>
                                ${isUploaderOrAdmin ? `<span class="edit-icon text-base-content/50 cursor-pointer hidden"><i class="fas fa-pencil-alt"></i></span>` : ''}
                                <span class="save-status text-xs text-base-content/40 ml-2 hidden"></span>
                            </div>
                            <p class="text-base-content/60 text-sm mt-2" contenteditable="${isUploaderOrAdmin}" data-model-id="${model.id}" data-field="description">${model.description}</p>
                            ${isUploaderOrAdmin ? `<span class="edit-icon-desc text-base-content/50 cursor-pointer hidden"><i class="fas fa-pencil-alt"></i></span>` : ''}
                                <span class="save-status-desc text-xs text-base-content/40 ml-2 hidden"></span>
                        </div>
                        <div class="flex flex-col items-end gap-2 ml-4">
                            <div class="badge badge-outline badge-primary">${model.category || 'Allgemein'}</div>
                            ${model.verified ? `<div class="badge badge-success">Verifiziert</div>` : `<div class="badge badge-info">Unverifiziert</div>`}
                        </div>
                    </div>
                    <div class="mt-4 flex flex-col sm:flex-row sm:justify-between items-start sm:items-center gap-4">
                        <div>
                            <div class="flex items-center whitespace-nowrap">
                                <div class="rating rating-sm" data-model-id="${model.id}" data-current-rating="${model.userRating || 0}">
                                    ${[1, 2, 3, 4, 5].map(i => `
                                        <input type="radio" name="rating-${model.id}" class="mask mask-star-2 ${canRate ? 'cursor-pointer' : 'cursor-default'}" value="${i}" ${model.userRating === i ? 'checked' : ''} ${canRate ? '' : 'disabled'} aria-label="${i} Sterne bewerten" />
                                    `).join('')}
                                </div>
                                <span class="text-base-content/60 ml-2">${rating} (${model.ratingCount || 0})</span>
                            </div>
                            <div class="text-base-content/60 text-sm mt-1">${model.downloads || 0} Downloads</div>
                        </div>
                    </div>
                    <div class="mt-4 flex items-center text-sm text-base-content/60">
                        <div class="avatar">
                            <div class="w-8 h-8 rounded-full bg-neutral text-neutral-content flex items-center justify-center text-lg">
                                ${uploaderAvatarHtml}
                            </div>
                        </div>
                        <span class="ml-2">${model.uploaderEmail ? model.uploaderEmail.split('@')[0] : 'Unbekannt'}</span>
                        <span class="ml-auto">${uploadDate}</span>
                    </div>
                </div>
            `;
            const ratingInputs = cardLink.querySelectorAll(`.rating-sm input[type="radio"]`);
            ratingInputs.forEach(input => {
                input.addEventListener('change', function(event) {
                    event.preventDefault();
                    event.stopPropagation();
                    if (canRate) {
                        const selectedRating = parseInt(this.value);
                        const currentModel = allModelsData.find(m => m.id === model.id);
                        if (currentModel) {
                            currentModel.userRating = selectedRating;
                        }
                        showToast('Bewertung für dieses Modell temporär gespeichert. Um sie dauerhaft zu speichern, gehen Sie zur Detailansicht und hinterlassen Sie einen Kommentar.', 'info', 5000);
                    } else {
                        showToast('Bitte melden Sie sich an oder bewerten Sie nicht Ihr eigenes Modell.', 'info');
                        const currentModel = allModelsData.find(m => m.id === model.id);
                        if (currentModel && currentModel.userRating) {
                            this.closest('.rating').querySelector(`input[value="${currentModel.userRating}"]`).checked = true;
                        } else {
                            this.closest('.rating').querySelectorAll('input[type="radio"]').forEach(radio => radio.checked = false);
                        }
                    }
                });
            });


            if (isUploaderOrAdmin) {
                const titleElement = cardLink.querySelector('h2[data-field="title"]');
                const descriptionElement = cardLink.querySelector('p[data-field="description"]');
                const titleEditIcon = cardLink.querySelector('.edit-icon');
                const descEditIcon = cardLink.querySelector('.edit-icon-desc');
                const titleSaveStatus = cardLink.querySelector('.save-status');
                const descSaveStatus = cardLink.querySelector('.save-status-desc');

                titleElement.addEventListener('mouseenter', () => titleEditIcon.classList.remove('hidden'));
                titleElement.addEventListener('mouseleave', () => { if (document.activeElement !== titleElement) titleEditIcon.classList.add('hidden'); });
                titleElement.addEventListener('focus', () => titleEditIcon.classList.remove('hidden'));
                titleElement.addEventListener('blur', () => titleEditIcon.classList.add('hidden'));

                descriptionElement.addEventListener('mouseenter', () => descEditIcon.classList.remove('hidden'));
                descriptionElement.addEventListener('mouseleave', () => { if (document.activeElement !== descriptionElement) descEditIcon.classList.add('hidden'); });
                descriptionElement.addEventListener('focus', () => descEditIcon.classList.remove('hidden'));
                descriptionElement.addEventListener('blur', () => descEditIcon.classList.add('hidden'));


                titleElement.addEventListener('blur', async (event) => {
                    const newTitle = event.target.textContent.trim();
                    if (newTitle !== model.title) {
                        await handleInPlaceEdit(model.id, 'title', newTitle, titleSaveStatus);
                    }
                });

                descriptionElement.addEventListener('blur', async (event) => {
                    const newDescription = event.target.textContent.trim();
                    if (newDescription !== model.description) {
                        await handleInPlaceEdit(model.id, 'description', newDescription, descSaveStatus);
                    }
                });

                titleElement.addEventListener('keydown', async (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        titleElement.blur();
                    }
                });

                descriptionElement.addEventListener('keydown', async (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        descriptionElement.blur();
                    }
                });

                titleElement.addEventListener('click', (event) => event.preventDefault());
                descriptionElement.addEventListener('click', (event) => event.preventDefault());
            }

            cardLink.dataset.modelId = model.id; 

            return cardLink;
        }

        function initPreviewRendererForCard(card, model) {
            const previewCanvas = card.querySelector('.voxel-preview-canvas');
            const skeletonElement = card.querySelector(`#skeleton-${model.id}`); 
            const previewMessageDiv = card.querySelector('.preview-message'); 
            const modelId = card.dataset.modelId;
            const voxelsData = model.projectData ? model.projectData.voxels : {};
            const gridSize = (model.projectData && model.projectData.settings && model.projectData.settings.gridSize) ? model.projectData.settings.gridSize : 10;
            
            let previewRendererInstance = null; 

            if (skeletonElement) skeletonElement.classList.remove('hidden');
            previewCanvas.classList.add('opacity-0'); 
            previewCanvas.classList.remove('opacity-100');
            if (previewMessageDiv) previewMessageDiv.classList.add('hidden');

            const currentTheme = htmlElement.getAttribute('data-theme');
            const threeJsBgColor = getDaisyUICSSColorForThreeJS(currentTheme);

            const resizeObserver = new ResizeObserver(entries => {
                for (let entry of entries) {
                    if (entry.target === previewCanvas) {
                        const { width, height } = entry.contentRect;
                        if (width > 0 && height > 0) {
                            resizeObserver.disconnect();
                            try {
                                previewRendererInstance = new VoxelRenderer(previewCanvas, voxelsData, gridSize, threeJsBgColor, previewMessageDiv, false, true); 
                                if (previewRendererInstance.renderer) {
                                    previewRendererInstance.renderer.render(previewRendererInstance.scene, previewRendererInstance.camera);

                                    if (skeletonElement) skeletonElement.classList.add('hidden');
                                    previewCanvas.classList.remove('opacity-0');
                                    previewCanvas.classList.add('opacity-100');
                                    if (previewMessageDiv) previewMessageDiv.classList.add('hidden');

                                    rendererInstances.set(model.id, previewRendererInstance);

                                    if (!isMobileDevice) {
                                        card.addEventListener('mouseenter', () => {
                                            if (previewRendererInstance) {
                                                previewRendererInstance.startAutoRotation();
                                            }
                                        });
                                        card.addEventListener('mouseleave', () => {
                                            if (previewRendererInstance) {
                                                previewRendererInstance.stopAutoRotation();
                                            }
                                        });
                                        previewRendererInstance.stopAutoRotation();
                                    } else {
                                        if (intersectionObserver) {
                                            intersectionObserver.observe(card); 
                                        }
                                        previewRendererInstance.stopAutoRotation();
                                    }

                                    previewRendererInstance.startAnimation();
                                } else {
                                    throw new Error("Renderer initialization failed.");
                                }

                            } catch (error) {
                                previewCanvas.classList.add('hidden'); 
                                if (skeletonElement) skeletonElement.classList.remove('hidden'); 
                                if (previewMessageDiv) {
                                    previewMessageDiv.textContent = 'Fehler beim Laden der Vorschau.';
                                    previewMessageDiv.classList.remove('hidden'); 
                                    previewMessageDiv.classList.add('text-error');
                                }
                                previewRendererInstance = null; 
                            }
                        }
                    }
                }
            });

            resizeObserver.observe(previewCanvas);
        }

        let infiniteScrollObserver;

        function setupInfiniteScrollObserver() {
            if (infiniteScrollObserver) {
                infiniteScrollObserver.disconnect();
            }

            infiniteScrollObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting && !isLoadingModels && lastVisible) {
                        fetchModels();
                    }
                });
            }, {
                root: null, 
                rootMargin: '0px',
                threshold: 0.1 
            });

            infiniteScrollObserver.observe(loadingSentinel);
        }

        async function fetchModels() {
            if (isLoadingModels) {
                return;
            }

            isLoadingModels = true;
            loadingSpinner.classList.remove('hidden');
            noMoreModelsMessage.classList.add('hidden'); 

            try {
                const modelsCollectionRef = collection(db, "models");
                const selectedCategory = activeCategory; 
                const selectedStatus = statusFilterSelect.value;
                const currentSortBy = sortBy.value; 
                const currentUserIsAdmin = isAdmin(); 
                const searchTerm = searchInput.value.toLowerCase().trim(); 

                let effectiveStatus = selectedStatus;
                if (!currentUserIsAdmin && effectiveStatus === 'all') {
                    effectiveStatus = 'verified';
                }

                let queriesToExecute = [];
                let baseConstraints = [];

                if (currentFilterView === 'my-models') {
                    if (currentUser) {
                        baseConstraints.push(where("uploaderUid", "==", currentUser.uid));
                        mainContentTitle.textContent = "Meine Modelle";
                    } else {
                        isLoadingModels = false;
                        loadingSpinner.classList.add('hidden');
                        noMoreModelsMessage.classList.remove('hidden');
                        return;
                    }
                } else {
                    mainContentTitle.textContent = "Community-Modelle";
                    if (!currentUserIsAdmin) {
                        baseConstraints.push(where("visibility", "==", "public"));
                    }
                }

                if (currentUserIsAdmin && effectiveStatus === 'all' && currentFilterView !== 'my-models') {
                    for (const verifiedValue of [true, false]) {
                        let constraints = [...baseConstraints];

                        if (selectedCategory !== 'all') {
                            constraints.push(where("category", "==", selectedCategory));
                        }

                        constraints.push(where("verified", "==", verifiedValue));

                        if (currentSortBy.startsWith('newest')) {
                            constraints.push(orderBy("timestamp", currentSortBy.endsWith('-asc') ? "asc" : "desc"));
                        }

                        if (lastVisible) {
                            constraints.push(startAfter(lastVisible));
                        }

                        constraints.push(limit(MODELS_PER_LOAD));
                        queriesToExecute.push(query(modelsCollectionRef, ...constraints));
                    }
                } else {
                    let queryConstraints = [...baseConstraints];

                    if (effectiveStatus === 'verified') {
                        queryConstraints.push(where("verified", "==", true));
                    } else if (effectiveStatus === 'unverified') {
                        queryConstraints.push(where("verified", "==", false));
                    }

                    if (selectedCategory !== 'all') {
                        queryConstraints.push(where("category", "==", selectedCategory));
                    }

                    if (currentSortBy.startsWith('newest')) {
                        queryConstraints.push(orderBy("timestamp", currentSortBy.endsWith('-asc') ? "asc" : "desc"));
                    }

                    if (lastVisible) {
                        queryConstraints.push(startAfter(lastVisible));
                    }

                    queryConstraints.push(limit(MODELS_PER_LOAD));
                    queriesToExecute.push(query(modelsCollectionRef, ...queryConstraints));
                }

                let allDocumentSnapshots = [];
                for (const q of queriesToExecute) {
                    try {
                        const snapshots = await getDocs(q);
                        allDocumentSnapshots.push(...snapshots.docs);
                    } catch (error) {
                        console.warn("Abfrage fehlgeschlagen, wahrscheinlich aufgrund von Berechtigungen:", q, error);
                    }
                }

                const uniqueModelIds = new Set();
                let fetchedModels = [];

                allDocumentSnapshots.forEach((doc) => {
                    if (!uniqueModelIds.has(doc.id)) {
                        uniqueModelIds.add(doc.id);
                        fetchedModels.push({ id: doc.id, ...doc.data() });
                    }
                });

                if (currentUser) {
                    for (let i = 0; i < fetchedModels.length; i++) {
                        const model = fetchedModels[i];
                        const ratingDocRef = doc(db, `models/${model.id}/ratings`, currentUser.uid);
                        const ratingDocSnap = await getDoc(ratingDocRef);
                        if (ratingDocSnap.exists()) {
                            fetchedModels[i].userRating = ratingDocSnap.data().rating;
                        }
                    }
                }

                let filteredModels = fetchedModels;
                if (searchTerm) {
                    filteredModels = fetchedModels.filter(model =>
                        model.title.toLowerCase().includes(searchTerm) ||
                        model.description.toLowerCase().includes(searchTerm)
                    );
                }

                if (!currentSortBy.startsWith('newest')) {
                    filteredModels.sort((a, b) => {
                        let cmp = 0;
                        if (currentSortBy.startsWith('popular')) {
                            cmp = (b.downloads || 0) - (a.downloads || 0);
                        } else if (currentSortBy.startsWith('top-rated')) {
                            const ra = a.ratingCount ? (a.rating / a.ratingCount) : 0;
                            const rb = b.ratingCount ? (b.rating / b.ratingCount) : 0;
                            cmp = rb - ra;
                        }
                        return currentSortBy.endsWith('-asc') ? -cmp : cmp;
                    });
                }

                if (filteredModels.length > 0) {
                    filteredModels.forEach(model => {
                        const newCard = createModelCard(model); 
                        modelsGrid.appendChild(newCard); 
                        initPreviewRendererForCard(newCard, model); 
                    });

                    if (allDocumentSnapshots.length > 0) {
                        lastVisible = allDocumentSnapshots[allDocumentSnapshots.length - 1];
                    } else {
                        lastVisible = null;
                    }
                } else {
                    if (!lastVisible || allDocumentSnapshots.length === 0) {
                        noMoreModelsMessage.classList.remove('hidden'); 
                    }
                    if (infiniteScrollObserver) {
                        infiniteScrollObserver.unobserve(loadingSentinel);
                        loadingSentinel.classList.add('hidden'); 
                    }
                }

                if (allDocumentSnapshots.length < MODELS_PER_LOAD) {
                    noMoreModelsMessage.classList.remove('hidden');
                    if (infiniteScrollObserver) {
                        infiniteScrollObserver.unobserve(loadingSentinel); 
                        loadingSentinel.classList.add('hidden');
                    }
                } else {
                    loadingSentinel.classList.remove('hidden'); 
                    if (infiniteScrollObserver) {
                        infiniteScrollObserver.observe(loadingSentinel); 
                    }
                }

                allModelsData = allModelsData.concat(filteredModels);

            } catch (error) {
                showToast(`Fehler beim Laden: ${error.message}`, 'error');
                loadingSentinel.classList.add('hidden'); 
            } finally {
                isLoadingModels = false;
                loadingSpinner.classList.add('hidden');
            }
        }


        function resetAndFetch() {
            modelsGrid.innerHTML = '';
            lastVisible = null;
            allModelsData = [];
            rendererInstances.forEach(renderer => { if (renderer) renderer.dispose(); });
            rendererInstances.clear();

            setActiveCategory(activeCategory);
            sortBy.value = 'newest-desc';
            searchInput.value = '';

            if (intersectionObserver && isMobileDevice) {
                intersectionObserver.disconnect();
                intersectionObserver = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        const modelId = entry.target.dataset.modelId;
                        const renderer = rendererInstances.get(modelId);
                        if (renderer) {
                            if (entry.isIntersecting && entry.intersectionRatio > 0.75) {
                                if (!renderer.hasMoved) {
                                    renderer.startAutoRotation();
                                }
                            } else {
                                renderer.stopAutoRotation();
                            }
                        }
                    });
                }, { threshold: [0, 0.25, 0.5, 0.75, 1.0] });
            }
            fetchModels();
        }


        async function updateUI(user) {
            if (user) {
                loginButton.classList.add('hidden');
                logoutButton.classList.remove('hidden');
                profileButton.classList.remove('hidden');
                navMyModelsButton.classList.remove('hidden');
                
                let avatarContent;
                if (user.photoURL) {
                    avatarContent = `<img src="${user.photoURL}" alt="Profilbild" class="w-full h-full object-cover rounded-full">`;
                } else if (user.email) { 
                    avatarContent = `<span class="text-white">${user.email.charAt(0).toUpperCase()}</span>`; 
                } else {
                    avatarContent = `<i class="fas fa-user text-lg"></i>`; 
                }

                userMenuButton.innerHTML = `
                    <div class="avatar">
                        <div class="w-10 rounded-full bg-primary flex items-center justify-center">
                            ${avatarContent}
                        </div>
                    </div>
                `;

                if (_isAdmin) {
                    if (!statusFilterSelect.querySelector('option[value="unverified"]')) {
                        const unverifiedOption = document.createElement('option');
                        unverifiedOption.value = 'unverified';
                        unverifiedOption.textContent = 'Unverifiziert';
                        statusFilterSelect.appendChild(unverifiedOption);
                    }
                } else {
                    const unverifiedOption = statusFilterSelect.querySelector('option[value="unverified"]');
                    if (unverifiedOption) { 
                        unverifiedOption.remove(); 
                    }
                    if (statusFilterSelect.value === 'unverified') {
                        statusFilterSelect.value = 'verified'; 
                    }
                }
                
                if (!mainContentView.classList.contains('hidden') && initialAuthCheckCompleted) {
                     resetAndFetch(); 
                }

            } else {
                loginButton.classList.remove('hidden');
                logoutButton.classList.add('hidden');
                profileButton.classList.add('hidden');
                navMyModelsButton.classList.add('hidden');
                
                userMenuButton.innerHTML = `
                    <div class="bg-neutral text-neutral-content rounded-full w-10 flex items-center justify-center">
                        <i class="fas fa-user text-lg"></i> </div>
                `;
                _isAdmin = false;
                const unverifiedOption = statusFilterSelect.querySelector('option[value="unverified"]');
                if (unverifiedOption) { unverifiedOption.remove(); }
                statusFilterSelect.value = 'verified';

                if (!mainContentView.classList.contains('hidden') && initialAuthCheckCompleted) {
                    resetAndFetch(); 
                }
            }

            if (currentDetailModelData) {
                if (_isAdmin) {
                    adminActionsDiv.classList.remove('hidden');
                    if (currentDetailModelData.verified) {
                        verifyButton.classList.add('hidden');
                        revertVerifyButton.classList.remove('hidden');
                    } else {
                        verifyButton.classList.remove('hidden');
                        revertVerifyButton.classList.add('hidden');
                    }
                } else {
                    adminActionsDiv.classList.add('hidden');
                }
            } else {
                adminActionsDiv.classList.add('hidden');
            }

            // Comment input and rating fields are always enabled/disabled based on login status.
            // The postCommentButton's behavior is now handled in submitFeedback for login check.
            commentInput.disabled = !currentUser;
            userRatingInput.querySelectorAll('input').forEach(input => input.disabled = !currentUser);
            // postCommentButton is explicitly not disabled by default anymore, its login check is on click.
            commentAuthMessage.classList.toggle('hidden', currentUser !== null);
            
            if (!currentUser) {
                userRatingInput.querySelectorAll('input').forEach(radio => radio.checked = false);
            }
        }


        function initializeCategoryOptions() {
            categoryFilterButtonsContainer.innerHTML = '';
            predefinedCategories.forEach(category => {
                const button = document.createElement('button');
                button.className = `btn btn-sm category-filter-btn ${category === activeCategory ? 'btn-active btn-primary' : 'btn-ghost'}`;
                button.textContent = category;
                button.dataset.category = category === 'Alle' ? 'all' : category;
                button.setAttribute('aria-pressed', category === activeCategory ? 'true' : 'false');
                categoryFilterButtonsContainer.appendChild(button);

                button.addEventListener('click', () => {
                    setActiveCategory(button.dataset.category);
                    resetAndFetch();
                });
            });
        }

        function setActiveCategory(category) {
            activeCategory = category;
            document.querySelectorAll('.category-filter-btn').forEach(btn => {
                if (btn.dataset.category === category) {
                    btn.classList.add('btn-active', 'btn-primary');
                    btn.classList.remove('btn-ghost');
                    btn.setAttribute('aria-pressed', 'true');
                } else {
                    btn.classList.remove('btn-active', 'btn-primary');
                    btn.classList.add('btn-ghost');
                    btn.setAttribute('aria-pressed', 'false');
                }
            });
        }

        setPersistence(auth, browserLocalPersistence)
            .then(() => {
                onAuthStateChanged(auth, async (user) => {
                    currentUser = user;
                    currentUserId = user?.uid || null;

                    if (user) {
                        try {
                            const userDocRef = doc(db, "users", user.uid);
                            const userDocSnap = await getDoc(userDocRef);
                            _isAdmin = (userDocSnap.exists() && userDocSnap.data().isAdmin === true);
                        } catch (error) {
                            _isAdmin = false;
                        }
                    } else {
                        _isAdmin = false;
                    }

                    updateUI(user);

                    if (!initialAuthCheckCompleted) {
                        initialAuthCheckCompleted = true;
                    }
                });
            })
            .catch((error) => {
                showToast(`Fehler bei der Anmeldebeständigkeit: ${error.message}. Die Funktionalität könnte eingeschränkt sein.`, 'error');
            });


        loginButton.addEventListener('click', (e) => {
            lastFocusedElement = e.currentTarget;
            hideMessage(authErrorMessage);
            authModal.showModal();
            emailInput.focus();
        });

        authModal.addEventListener('close', () => {
            if (lastFocusedElement) {
                lastFocusedElement.focus();
                lastFocusedElement = null;
            }
        });

        firebaseLoginButton.addEventListener('click', async (e) => {
            e.preventDefault();
            hideMessage(authErrorMessage);
            const email = emailInput.value;
            const password = passwordInput.value;

            try {
                await signInWithEmailAndPassword(auth, email, password);
                setTimeout(() => {
                    authModal.close(); 
                    showToast('Erfolgreich angemeldet!', 'success');
                }, 100); 
            } catch (error) {
                let errorMessage = "Anmeldung fehlgeschlagen. Bitte versuchen Sie es erneut.";
                if (error.code === 'auth/user-not-found' || error.code === 'auth/wrong-password' || error.code === 'auth/invalid-credential') {
                    errorMessage = "Ungültige E-Mail oder Passwort.";
                } else if (error.code === 'auth/invalid-email') {
                    errorMessage = "Ungültiges E-Mail-Format.";
                }
                showToast(errorMessage, 'error'); 
            }
        });

        firebaseSignupButton.addEventListener('click', async (e) => {
            e.preventDefault();
            hideMessage(authErrorMessage);
            const email = emailInput.value;
            const password = passwordInput.value; 

            try {
                await createUserWithEmailAndPassword(auth, email, password);
                setTimeout(() => {
                    authModal.close(); 
                    showToast('Registrierung erfolgreich! Sie sind jetzt angemeldet.', 'success');
                }, 100);
            } catch (error) {
                let errorMessage = "Registrierung fehlgeschlagen. Bitte versuchen Sie es erneut.";
                if (error.code === 'auth/email-already-in-use') {
                    errorMessage = "Diese E-Mail-Adresse wird bereits verwendet.";
                } else if (error.code === 'auth/weak-password') {
                    errorMessage = "Das Passwort sollte mindestens 6 Zeichen lang sein.";
                } else if (error.code === 'auth/invalid-email') {
                    errorMessage = "Ungültiges E-Mail-Format.";
                }
                showToast(errorMessage, 'error'); 
            }
        });

        googleLoginButton.addEventListener('click', async (e) => {
            e.preventDefault();
            hideMessage(authErrorMessage);
            try {
                const result = await signInWithPopup(auth, googleProvider);
                setTimeout(() => {
                    authModal.close(); 
                    showToast('Erfolgreich mit Google angemeldet!', 'success');
                }, 100);
            } catch (error) {
                let errorMessage = "Anmeldung fehlgeschlagen. Bitte versuchen Sie es erneut.";
                if (error.code === 'auth/popup-closed-by-user' || error.code === 'auth/cancelled-popup-request') {
                    errorMessage = "Anmeldung abgebrochen.";
                } else if (error.code === 'auth/operation-not-allowed') {
                    errorMessage = "Diese Anmeldemethode ist in Ihrem Firebase-Projekt nicht aktiviert. Bitte überprüfen Sie die Firebase Console.";
                } else if (error.code === 'auth/network-request-failed') {
                    errorMessage = "Netzwerkfehler. Bitte überprüfen Sie Ihre Internetverbindung.";
                } else if (error.code === 'auth/unauthorized-domain') {
                    errorMessage = `Fehler: Nicht autorisierte Domain. Bitte fügen Sie "${window.location.origin}" zu den autorisierten Domains in Ihrer Firebase Console (Authentifizierung -> Einstellungen) hinzu.`;
                }
                showToast(errorMessage, 'error'); 
            }
        });

        githubLoginButton.addEventListener('click', async (e) => {
            e.preventDefault();
            hideMessage(authErrorMessage);
            try {
                const result = await signInWithPopup(auth, githubProvider);
                setTimeout(() => {
                    authModal.close(); 
                    showToast('Erfolgreich mit GitHub angemeldet!', 'success');
                }, 100);
            } catch (error) {
                let errorMessage = "Anmeldung fehlgeschlagen. Bitte versuchen Sie es erneut.";
                if (error.code === 'auth/popup-closed-by-user' || error.code === 'auth/cancelled-popup-request') {
                    errorMessage = "Anmeldung abgebrochen.";
                } else if (error.code === 'auth/operation-not-allowed') {
                    errorMessage = "Diese Anmeldemethode ist in Ihrem Firebase-Projekt nicht aktiviert. Bitte überprüfen Sie die Firebase Console.";
                } else if (error.code === 'auth/network-request-failed') {
                    errorMessage = "Netzwerkfehler. Bitte überprüfen Sie Ihre Internetverbindung.";
                } else if (error.code === 'auth/unauthorized-domain') {
                    errorMessage = `Fehler: Nicht autorisierte Domain. Bitte fügen Sie "${window.location.origin}" zu den autorisierten Domains in Ihrer Firebase Console (Authentifizierung -> Einstellungen) hinzu.`;
                }
                showToast(errorMessage, 'error'); 
            }
        });


        logoutButton.addEventListener('click', async (e) => {
            e.preventDefault();
            try {
                await signOut(auth);
                showToast('Erfolgreich abgemeldet!', 'info');
            } catch (error) {
                showToast(`Fehler beim Abmelden: ${error.message}`, 'error');
            }
        });

        function createSceneFromVoxels(voxelsData) {
            const scene = new THREE.Scene();
            const scaleFactor = 10;
            const material = new THREE.MeshNormalMaterial();
            
            const geometries = [];

            let minX = Infinity, minY = Infinity, minZ = Infinity;
            let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

            for (const key in voxelsData) {
                const parts = key.split(',').map(Number);
                if (parts.length === 3) {
                    const [x, y, z] = parts;
                    minX = Math.min(minX, x);
                    minY = Math.min(minY, y);
                    minZ = Math.min(minZ, z);
                    maxX = Math.max(maxX, x);
                    maxY = Math.max(maxY, y);
                    maxZ = Math.max(maxZ, z);
                }
            }

            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            const centerZ = (minZ + maxZ) / 2;

            for (const key in voxelsData) {
                const parts = key.split(',').map(Number);
                if (parts.length === 3) {
                    const [x, y, z] = parts;
                    
                    const geometry = new THREE.BoxGeometry(scaleFactor, scaleFactor, scaleFactor);
                    
                    const posX = (x - centerX) * scaleFactor;
                    const posY = (y - centerY) * scaleFactor;
                    const posZ = (z - centerZ) * scaleFactor;
                    
                    const matrix = new THREE.Matrix4().makeTranslation(
                        posX + scaleFactor / 2, 
                        posY + scaleFactor / 2, 
                        posZ + scaleFactor / 2
                    );
                    
                    geometry.applyMatrix4(matrix);
                    geometries.push(geometry);
                }
            }

            if (geometries.length === 0) {
                return scene;
            }

            const mergedGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries(geometries);
            const mesh = new THREE.Mesh(mergedGeometry, material);
            scene.add(mesh);

            return scene;
        }


        async function handleDownload(modelId, modelTitle) {
            if (!auth.currentUser) { 
                lastFocusedElement = document.getElementById('download-stl-button');
                authModal.showModal();
                showToast('Bitte melden Sie sich an, um Modelle herunterzuladen.', 'info');
                return;
            }

            showToast(`Download von "${modelTitle}" als STL wird vorbereitet...`, 'info');

            try {
                const docRef = doc(db, "models", modelId);
                const docSnap = await getDoc(docRef);

                if (docSnap.exists()) {
                    const modelData = docSnap.data();
                    const voxelsData = modelData.projectData ? modelData.projectData.voxels : null;

                    if (voxelsData && Object.keys(voxelsData).length > 0) {
                        const sceneToExport = createSceneFromVoxels(voxelsData);
                        const exporter = new THREE.STLExporter();
                        const stlString = exporter.parse(sceneToExport);

                        const blob = new Blob([stlString], { type: 'text/plain' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `${modelTitle.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.stl`; 
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);

                        try {
                            await updateDoc(docRef, {
                                downloads: (modelData.downloads || 0) + 1
                            });
                            showToast(`"${modelTitle}.stl" erfolgreich heruntergeladen!`, 'success');
                            if (currentDetailModelData && currentDetailModelData.id === modelId) {
                                currentDetailModelData.downloads = (currentDetailModelData.downloads || 0) + 1;
                                document.getElementById('download-count').textContent = currentDetailModelData.downloads;
                            }
                        } catch (updateError) {
                            showToast(`STL-Download erfolgreich, aber Fehler beim Aktualisieren des Zählers: ${updateError.message}.`, 'warning');
                        }

                    } else {
                         showToast('Fehler beim Download: Keine Voxeldaten für STL-Export gefunden.', 'error');
                    }

                } else {
                    showToast('Fehler beim Download: Modell nicht gefunden.', 'error');
                }
            } catch (error) {
                showToast(`Fehler beim Download der STL-Datei: ${error.message}`, 'error');
            }
        }

        async function handleOpenOnVoxelShaper(modelId) {
            showToast(`Modell ${modelId} wird in VoxelShaper geöffnet!`, 'info');

            try {
                const docRef = doc(db, "models", modelId);
                const docSnap = await getDoc(docRef);

                if (docSnap.exists()) {
                    const editorUrl = `https://voxelshaper.com/?modelId=${modelId}`;
                    
                    if (isMobileDevice) {
                        window.location.href = editorUrl;
                    } else {
                        const a = document.createElement('a');
                        a.href = editorUrl;
                        a.target = '_blank'; 
                        a.rel = 'noopener noreferrer';
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                    }

                } else {
                    showToast('Fehler beim Öffnen: Modell nicht gefunden. Es wurde möglicherweise gelöscht oder die ID ist falsch.', 'error');
                }
            } catch (error) {
                showToast(`Fehler beim Öffnen des Modells: ${error.message}`, 'error');
            }
        }

        async function verifyModel(modelId) {
            if (!isAdmin()) {
                showToast('Keine Berechtigung zum Verifizieren von Modellen.', 'error');
                return;
            }
            try {
                const modelRef = doc(db, "models", modelId);
                await updateDoc(modelRef, { verified: true });
                showToast('Modell erfolgreich verifiziert!', 'success');
                if (currentDetailModelData && currentDetailModelData.id === modelId) {
                    currentDetailModelData.verified = true;
                    updateUI(currentUser);
                }
                getModelDetails(modelId);
            } catch (error) {
                showToast(`Fehler beim Verifizieren des Modells: ${error.message}`, 'error');
            }
        }

        async function revertVerification(modelId) {
            if (!isAdmin()) {
                showToast('Keine Berechtigung zum Rückgängigmachen der Verifizierung.', 'error');
                return;
            }
            try {
                const modelRef = doc(db, "models", modelId);
                await updateDoc(modelRef, { verified: false });
                showToast('Verifizierung erfolgreich rückgängig gemacht!', 'success');
                if (currentDetailModelData && currentDetailModelData.id === modelId) {
                    currentDetailModelData.verified = false;
                    updateUI(currentUser);
                }
                getModelDetails(modelId);
            } catch (error) {
                showToast(`Fehler beim Rückgängigmachen der Verifizierung: ${error.message}`, 'error');
            }
        }

        async function deleteModel(modelId) {
            if (!isAdmin()) {
                showToast('Keine Berechtigung zum Löschen von Modellen.', 'error');
                return;
            }
            try {
                await deleteDoc(doc(db, "models", modelId));
                showToast('Modell erfolgreich gelöscht!', 'success');
                
                showMainContent();
            }
            catch (error) {
                showToast(`Fehler beim Löschen des Modells: ${error.message}`, 'error');
            }
        }

        async function submitFeedback() {
            const commentText = commentInput.value.trim();
            const modelId = currentDetailModelData ? currentDetailModelData.id : null;
            const selectedRating = userRatingInput.querySelector('input:checked')?.value;

            if (!currentUser) {
                showToast('Bitte melden Sie sich an, um einen Kommentar zu hinterlassen.', 'info');
                authModal.showModal(); // Show the login dialog
                return;
            }
            if (!modelId) {
                showToast('Modell-ID nicht gefunden.', 'error');
                return;
            }
            if (!selectedRating) {
                showToast('Bitte wählen Sie eine Sternebewertung aus.', 'warning');
                return;
            }
            if (!commentText) {
                showToast('Bitte geben Sie einen Kommentartext ein.', 'warning');
                return;
            }

            // No longer disable the button here, as it's always clickable
            // postCommentButton.disabled = true;

            const modelRef = doc(db, "models", modelId);
            const ratingRef = doc(db, `models/${modelId}/ratings`, currentUser.uid); 
            const commentsCollectionRef = collection(db, `models/${modelId}/comments`);

            try {
                await runTransaction(db, async (transaction) => {
                    const modelDoc = await transaction.get(modelRef);
                    const ratingDoc = await transaction.get(ratingRef);

                    if (!modelDoc.exists()) {
                        throw new Error("Modell existiert nicht!");
                    }

                    const modelData = modelDoc.data();
                    
                    if (currentUser.uid === modelData.uploaderUid) {
                        throw new Error('self-rating');
                    }

                    let currentRatingSum = modelData.rating || 0;
                    let currentRatingCount = modelData.ratingCount || 0;
                    let oldRating = 0;

                    if (ratingDoc.exists()) {
                        oldRating = ratingDoc.data().rating;
                        currentRatingSum = currentRatingSum - oldRating + parseInt(selectedRating);
                    } else {
                        currentRatingSum = currentRatingSum + parseInt(selectedRating);
                        currentRatingCount = currentRatingCount + 1;
                    }

                    transaction.update(modelRef, {
                        rating: currentRatingSum,
                        ratingCount: currentRatingCount
                    });

                    transaction.set(ratingRef, {
                        rating: parseInt(selectedRating),
                        timestamp: serverTimestamp()
                    });

                    await addDoc(commentsCollectionRef, {
                        userId: currentUser.uid,
                        userName: currentUser.displayName || (currentUser.email ? currentUser.email.split('@')[0] : 'Anonym'),
                        userEmail: currentUser.email || null,
                        userPhotoURL: currentUser.photoURL || null,
                        commentText: commentText,
                        rating: parseInt(selectedRating),
                        timestamp: serverTimestamp()
                    });
                });

                showToast('Bewertung und Kommentar erfolgreich abgegeben!', 'success');
                commentInput.value = '';
                userRatingInput.querySelectorAll('input').forEach(radio => radio.checked = false);
                getModelDetails(modelId);

            } catch (error) {
                if (error.message === 'self-rating') {
                    showToast('Sie können Ihre eigenen Modelle nicht bewerten.', 'info');
                } else {
                    showToast(`Fehler beim Posten von Bewertung/Kommentar: ${error.message}`, 'error');
                }
            } finally {
                // The button is no longer explicitly re-enabled here, as it's never disabled by submitFeedback
            }
        }

        async function editComment(modelId, commentId, newText) {
            hideMessage(editCommentErrorMessage);
            if (!currentUser) {
                showToast('Sie müssen angemeldet sein, um Kommentare zu bearbeiten.', 'error');
                return;
            }
            if (!newText.trim()) {
                showToast('Kommentar darf nicht leer sein.', 'error');
                return;
            }

            const commentRef = doc(db, `models/${modelId}/comments`, commentId);
            try {
                const commentSnap = await getDoc(commentRef);
                if (!commentSnap.exists()) {
                    showToast('Kommentar nicht gefunden.', 'error');
                    return;
                }
                const commentData = commentSnap.data();

                if (commentData.userId !== currentUser.uid && !isAdmin()) {
                    showToast('Sie sind nicht berechtigt, diesen Kommentar zu bearbeiten.', 'error');
                    return;
                }

                await updateDoc(commentRef, {
                    commentText: newText.trim(),
                    timestamp: serverTimestamp()
                });
                showToast('Kommentar erfolgreich aktualisiert!', 'success');
                editCommentModal.close();
            } catch (error) {
                showToast(`Fehler beim Bearbeiten des Kommentars: ${error.message}`, 'error');
            }
        }

        async function deleteComment(modelId, commentId) {
            if (!currentUser) {
                showToast('Sie müssen angemeldet sein, um Kommentare zu löschen.', 'error');
                return;
            }

            const commentRef = doc(db, `models/${modelId}/comments`, commentId);
            try {
                const commentSnap = await getDoc(commentRef);
                if (!commentSnap.exists()) {
                    showToast('Kommentar nicht gefunden.', 'error');
                    return;
                }
                const commentData = commentSnap.data();

                if (commentData.userId !== currentUser.uid && !isAdmin()) {
                    showToast('Sie sind nicht berechtigt, diesen Kommentar zu löschen.', 'error');
                    return;
                }

                await deleteDoc(commentRef);
                showToast('Kommentar erfolgreich gelöscht!', 'success');
                deleteCommentConfirmModal.close();

                if (commentData.rating) {
                    const modelRef = doc(db, "models", modelId);
                    const ratingRef = doc(db, `models/${modelId}/ratings`, commentData.userId);

                    await runTransaction(db, async (transaction) => {
                        const modelDoc = await transaction.get(modelRef);
                        const userRatingDoc = await transaction.get(ratingRef);

                        if (modelDoc.exists()) {
                            const modelData = modelDoc.data();
                            let currentRatingSum = modelData.rating || 0;
                            let currentRatingCount = modelData.ratingCount || 0;
                            const deletedCommentRating = commentData.rating;

                            if (userRatingDoc.exists() && userRatingDoc.data().rating === deletedCommentRating) {
                                transaction.delete(ratingRef);
                                
                                currentRatingSum -= deletedCommentRating;
                                currentRatingCount -= 1;
                                
                                if (currentRatingSum < 0) currentRatingSum = 0;
                                if (currentRatingCount < 0) currentRatingCount = 0;

                                transaction.update(modelRef, {
                                    rating: currentRatingSum,
                                    ratingCount: currentRatingCount
                                });
                            }
                        }
                    });
                }

                if (!detailContentView.classList.contains('hidden') && currentDetailModelData.id === modelId) {
                    getModelDetails(modelId);
                } else if (!mainContentView.classList.contains('hidden')) {
                    resetAndFetch();
                }

            } catch (error) {
                showToast(`Fehler beim Löschen des Kommentars: ${error.message}`, 'error');
            }
        }


        async function handleInPlaceEdit(modelId, field, newValue, statusElement) {
            if (!currentUser) {
                showToast('Sie müssen angemeldet sein, um Änderungen vorzunehmen.', 'error');
                const element = document.querySelector(`[data-model-id="${modelId}"][data-field="${field}"]`);
                if (element) {
                    const modelRef = doc(db, "models", modelId);
                    const modelSnap = await getDoc(modelRef);
                    if (modelSnap.exists()) {
                        element.textContent = modelSnap.data()[field];
                    }
                }
                return;
            }

            const modelRef = doc(db, "models", modelId);
            const modelSnap = await getDoc(modelRef);
            if (!modelSnap.exists()) {
                showToast('Modell nicht gefunden.', 'error');
                return;
            }
            const modelData = modelSnap.data();

            if (currentUser.uid !== modelData.uploaderUid && !isAdmin()) {
                showToast('Keine Berechtigung zum Bearbeiten dieses Modells.', 'error');
                const element = document.querySelector(`[data-model-id="${modelId}"][data-field="${field}"]`);
                if (element) {
                    element.textContent = modelData[field];
                }
                return;
            }


            if (statusElement) {
                statusElement.textContent = 'Speichern...';
                statusElement.classList.remove('hidden');
                statusElement.classList.remove('text-success', 'text-error');
                statusElement.classList.add('text-base-content/40');
            }

            const updateData = {};
            updateData[field] = newValue;

            try {
                await updateDoc(modelRef, updateData);
                if (statusElement) {
                    statusElement.textContent = 'Gespeichert!';
                    statusElement.classList.remove('text-base-content/40');
                    statusElement.classList.add('text-success');
                }
                showToast(`"${field}" erfolgreich aktualisiert!`, 'success');
            } catch (error) {
                if (statusElement) {
                    statusElement.textContent = 'Fehler!';
                    statusElement.classList.remove('text-base-content/40');
                    statusElement.classList.add('text-error');
                }
                showToast(`Fehler beim Aktualisieren von "${field}": ${error.message}`, 'error');
            } finally {
                if (statusElement) {
                    setTimeout(() => {
                        statusElement.classList.add('hidden');
                        statusElement.textContent = '';
                    }, 2000);
                }
            }
        }


        document.getElementById('confirm-delete-button').addEventListener('click', () => {
            if (modelIdToDelete) {
                deleteModel(modelIdToDelete);
                document.getElementById('delete-confirm-modal').close();
                modelIdToDelete = null; 
            }
        });

        function showDeleteConfirmationModal(modelId, modelTitle) {
            modelIdToDelete = modelId;
            document.getElementById('model-to-delete-title').textContent = modelTitle;
            lastFocusedElement = document.getElementById('delete-button');
            document.getElementById('delete-confirm-modal').showModal();
            document.getElementById('confirm-delete-button').focus();
        }

        document.getElementById('delete-confirm-modal').addEventListener('close', () => {
            if (lastFocusedElement) {
                lastFocusedElement.focus();
                lastFocusedElement = null;
            }
        });


        sortBy.addEventListener('change', () => {
            resetAndFetch(); 
        });

        statusFilterSelect.addEventListener('change', () => {
            resetAndFetch();
        });

        searchInput.addEventListener('keyup', () => {
            const searchTerm = searchInput.value.toLowerCase().trim();
            const cards = modelsGrid.querySelectorAll('.model-card');
            cards.forEach(card => {
                const title = card.querySelector('.card-title').textContent.toLowerCase();
                const description = card.querySelector('p[data-field="description"]').textContent.toLowerCase();
                if (title.includes(searchTerm) || description.includes(searchTerm)) {
                    card.style.display = '';
                } else {
                    card.style.display = 'none';
                }
            });
            if (searchTerm === '' && modelsGrid.children.length !== allModelsData.length) {
                resetAndFetch();
            }
        });


        navDiscoverButton.addEventListener('click', (e) => {
            e.preventDefault();
            currentFilterView = 'community';
            sortBy.value = 'newest-desc';
            activeCategory = 'all';
            initializeCategoryOptions();
            statusFilterSelect.value = 'verified';
            showMainContent();
            resetAndFetch();
        });

        navPopularButton.addEventListener('click', (e) => {
            e.preventDefault();
            currentFilterView = 'community';
            sortBy.value = 'popular-desc';
            activeCategory = 'all';
            initializeCategoryOptions();
            statusFilterSelect.value = 'verified';
            showMainContent();
            resetAndFetch();
        });

        navNewButton.addEventListener('click', (e) => {
            e.preventDefault();
            currentFilterView = 'community';
            sortBy.value = 'newest-desc';
            activeCategory = 'all';
            initializeCategoryOptions();
            statusFilterSelect.value = 'verified';
            showMainContent();
            resetAndFetch();
        });

        navCategoriesButton.addEventListener('click', (e) => {
            e.preventDefault();
            currentFilterView = 'community';
            sortBy.value = 'newest-desc';
            activeCategory = 'all';
            initializeCategoryOptions();
            statusFilterSelect.value = 'verified';
            showMainContent();
            resetAndFetch();
        });

        navHomeButton.addEventListener('click', (e) => {
            e.preventDefault();
            showMainContent();
        });

        navMyModelsButton.addEventListener('click', (e) => {
            e.preventDefault();
            if (!currentUser) {
                showToast('Bitte melden Sie sich an, um Ihre Modelle anzuzeigen.', 'info');
                lastFocusedElement = e.currentTarget;
                authModal.showModal();
                return;
            }
            currentFilterView = 'my-models';
            sortBy.value = 'newest-desc';
            activeCategory = 'all';
            initializeCategoryOptions();
            statusFilterSelect.value = 'all';
            showMainContent();
            resetAndFetch();
        });

        openVoxelshaperMainButton.addEventListener('click', () => {
            const editorUrl = `https://voxelshaper.com/`;
            if (isMobileDevice) {
                window.location.href = editorUrl;
            } else {
                const a = document.createElement('a');
                a.href = editorUrl;
                a.target = '_blank'; 
                a.rel = 'noopener noreferrer';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            }
        });


        async function showModelDetail(modelId) {
            window.scrollTo(0, 0); 

            mainContentView.classList.add('hidden');
            profileContentView.classList.add('hidden');
            detailContentView.classList.remove('hidden');
            try {
                history.pushState({ view: 'detail', modelId: modelId }, '', `?modelId=${modelId}`);
            } catch (e) {
                showToast('Hinweis: Deep-Linking über die URL ist in dieser Umgebung möglicherweise eingeschränkt.', 'warning');
            }

            rendererInstances.forEach(renderer => { if (renderer) renderer.dispose(); });
            rendererInstances.clear();
            if (infiniteScrollObserver) {
                infiniteScrollObserver.disconnect();
            }

            await getModelDetails(modelId);
        }

        function showMainContent() {
            detailContentView.classList.add('hidden');
            profileContentView.classList.add('hidden');
            mainContentView.classList.remove('hidden');
            try {
                history.pushState({ view: 'main' }, '', window.location.pathname);
            } catch (e) {
            }

            if (detailRenderer) {
                detailRenderer.dispose();
                detailRenderer = null;
            }
            setupInfiniteScrollObserver();
            resetAndFetch();
        }

        function showProfilePage() {
            mainContentView.classList.add('hidden');
            detailContentView.classList.add('hidden');
            profileContentView.classList.remove('hidden');

            if (currentUser) {
                profileEmail.textContent = currentUser.email || 'N/A';
                if (currentUser.metadata && currentUser.metadata.creationTime) {
                    const creationDate = new Date(currentUser.metadata.creationTime).toLocaleDateString('de-DE');
                    profileCreationDate.textContent = `Mitglied seit: ${creationDate}`;
                } else {
                    profileCreationDate.textContent = '';
                }

                if (currentUser.photoURL) {
                    profileAvatarImg.src = currentUser.photoURL;
                    profileAvatarImg.classList.remove('hidden');
                    profileAvatarInitial.classList.add('hidden');
                } else if (currentUser.email) {
                    profileAvatarInitial.textContent = currentUser.email.charAt(0).toUpperCase();
                    profileAvatarInitial.classList.remove('hidden');
                    profileAvatarImg.classList.add('hidden');
                } else {
                    profileAvatarInitial.innerHTML = '<i class="fas fa-user"></i>';
                    profileAvatarInitial.classList.remove('hidden');
                    profileAvatarImg.classList.add('hidden');
                }
            }
        }

        window.addEventListener('popstate', (event) => {
            const urlParams = new URLSearchParams(window.location.search);
            const modelIdFromUrl = urlParams.get('modelId');

            if (modelIdFromUrl) {
                showModelDetail(modelIdFromUrl);
            } else if (event.state && event.state.view === 'profile') {
                showProfilePage();
            } else {
                showMainContent();
            }
        });

        async function getModelDetails(modelId) {
            detailLoadingSpinner.classList.remove('hidden');
            modelContent.classList.add('hidden');
            modelNotFoundMessage.classList.add('hidden');
            detailPreviewMessage.classList.add('hidden');

            try {
                const docRef = doc(db, "models", modelId);
                const docSnap = await getDoc(docRef);

                if (docSnap.exists()) {
                    const modelData = { id: docSnap.id, ...docSnap.data() };

                    if (currentUser) {
                        const ratingDocRef = doc(db, `models/${modelId}/ratings`, currentUser.uid);
                        const ratingDocSnap = await getDoc(ratingDocRef);
                        if (ratingDocSnap.exists()) {
                            modelData.userRating = ratingDocSnap.data().rating;
                        }
                    }
                    currentDetailModelData = modelData;
                    renderModelDetails(modelData);
                    loadComments(modelId);
                } else {
                    modelNotFoundMessage.classList.remove('hidden');
                }
            } catch (error) {
                showToast(`Fehler beim Laden der Modelldetails: ${error.message}`, 'error');
                modelNotFoundMessage.classList.remove('hidden');
            } finally {
                detailLoadingSpinner.classList.add('hidden');
            }
        }

        function renderModelDetails(model) {
            modelTitleElement.textContent = model.title;
            modelDescriptionElement.textContent = model.description;
            modelCategoryElement.textContent = model.category || 'Allgemein';
            downloadCountElement.textContent = model.downloads || 0;
            ratingCountElement.textContent = model.ratingCount || 0;

            let uploaderAvatarHtml;
            if (model.uploaderPhotoURL) {
                uploaderAvatarHtml = `<img src="${model.uploaderPhotoURL}" alt="Profilbild" class="w-full h-full object-cover rounded-full">`;
            } else if (model.uploaderEmail) { 
                uploaderAvatarHtml = `<span class="text-white">${model.uploaderEmail.charAt(0).toUpperCase()}</span>`; 
            } else {
                uploaderAvatarHtml = `<i class="fas fa-user"></i>`; 
            }
            uploaderAvatarElement.innerHTML = uploaderAvatarHtml;
            uploaderInfoElement.textContent = model.uploaderEmail ? model.uploaderEmail.split('@')[0] : 'Unbekannt';
            uploadDateElement.textContent = model.timestamp ? new Date(model.timestamp.toDate()).toLocaleDateString('de-DE') : 'Unbekannt';

            detailRatingStars.innerHTML = '';
            const averageRating = model.ratingCount > 0 ? (model.rating / model.ratingCount) : 0;
            detailRatingText.textContent = `${averageRating.toFixed(1)} (${model.ratingCount || 0} Bewertungen)`;

            userRatingInput.querySelectorAll('input[type="radio"]').forEach(radio => {
                radio.checked = (model.userRating === parseInt(radio.value));
            });
            updateUI(currentUser);

            for (let i = 1; i <= 5; i++) {
                const starIcon = document.createElement('i');
                starIcon.className = `fas fa-star text-warning ${i <= Math.round(averageRating) ? '' : 'opacity-30'}`;
                detailRatingStars.appendChild(starIcon);
            }

            modelContent.classList.remove('hidden'); 

            if (detailRenderer) {
                detailRenderer.dispose();
                detailRenderer = null;
            }

            const voxelsData = model.projectData ? model.projectData.voxels : {};
            const gridSize = (model.projectData && model.projectData.settings && model.projectData.settings.gridSize) ? model.projectData.settings.gridSize : 10;
            const currentTheme = htmlElement.getAttribute('data-theme');
            const threeJsBgColor = getDaisyUICSSColorForThreeJS(currentTheme);

            const detailCanvasResizeObserver = new ResizeObserver(entries => {
                for (let entry of entries) {
                    if (entry.target === voxelDetailCanvas) {
                        const { width, height } = entry.contentRect;
                        if (width > 0 && height > 0) {
                            detailCanvasResizeObserver.disconnect();

                            detailRenderer = new VoxelRenderer(voxelDetailCanvas, voxelsData, gridSize, threeJsBgColor, detailPreviewMessage, true, false);
                            if (detailRenderer.renderer) {
                                detailRenderer.startAnimation();

                                voxelDetailCanvas.classList.remove('hidden'); 
                                detailPreviewMessage.classList.add('hidden'); 
                            } else {
                                detailPreviewMessage.textContent = 'Vorschau nicht verfügbar: Renderer konnte nicht initialisiert werden.';
                                detailPreviewMessage.classList.remove('hidden');
                                voxelDetailCanvas.classList.add('hidden');
                            }
                        }
                    }
                }
            });

            detailCanvasResizeObserver.observe(voxelDetailCanvas);
        }

        function loadComments(modelId) {
            commentsList.innerHTML = '';
            noCommentsMessage.classList.add('hidden');

            const commentsCollectionRef = collection(db, `models/${modelId}/comments`);
            const q = query(commentsCollectionRef, orderBy('timestamp', 'desc'));

            onSnapshot(q, (snapshot) => {
                const comments = [];
                snapshot.forEach(doc => {
                    comments.push({ id: doc.id, ...doc.data() });
                });
                renderComments(comments, modelId);
            }, (error) => {
                showToast(`Fehler beim Laden der Kommentare: ${error.message}.`, 'error');
                commentsList.innerHTML = `<p class="text-error text-center py-4">Fehler beim Laden der Kommentare.</p>`;
            });
        }

        function renderComments(comments, modelId) {
            commentsList.innerHTML = '';
            if (comments.length === 0) {
                noCommentsMessage.classList.remove('hidden');
                return;
            }
            noCommentsMessage.classList.add('hidden');

            comments.forEach(comment => {
                const commentDiv = document.createElement('div');
                commentDiv.className = 'comment-card';

                let userAvatarHtml;
                if (comment.userPhotoURL) {
                    userAvatarHtml = `<img src="${comment.userPhotoURL}" alt="Profilbild" class="w-full h-full object-cover rounded-full">`;
                } else if (comment.userEmail) {
                    userAvatarHtml = `<span class="text-white">${comment.userEmail.charAt(0).toUpperCase()}</span>`;
                } else {
                    userAvatarHtml = `<i class="fas fa-user"></i>`;
                }

                const commentDate = comment.timestamp ? new Date(comment.timestamp.toDate()).toLocaleDateString('de-DE') : 'Unbekannt';
                const commentTime = comment.timestamp ? new Date(comment.timestamp.toDate()).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }) : '';

                const canEditOrDelete = currentUser && (comment.userId === currentUser.uid || isAdmin());

                commentDiv.innerHTML = `
                    <div class="flex items-start mb-2">
                        <div class="avatar mr-3">
                            <div class="w-10 h-10 rounded-full bg-neutral text-neutral-content flex items-center justify-center text-lg">
                                ${userAvatarHtml}
                            </div>
                        </div>
                        <div class="flex-grow">
                            <p class="font-semibold text-lg">${comment.userName || (comment.userEmail ? comment.userEmail.split('@')[0] : 'Anonym')}</p>
                            <div class="text-base-content/60 text-sm flex items-center">
                                <span>${commentDate} ${commentTime}</span>
                                ${comment.rating ? `
                                    <div class="rating rating-xs ml-2">
                                        ${[1, 2, 3, 4, 5].map(i => `
                                            <input type="radio" name="comment-rating-${comment.id}" class="mask mask-star-2" ${comment.rating >= i ? 'checked' : ''} disabled />
                                        `).join('')}
                                    </div>
                                    <span class="ml-1 text-xs text-base-content/50">(${comment.rating} Sterne)</span>
                                ` : ''}
                            </div>
                        </div>
                        ${canEditOrDelete ? `
                            <div class="flex gap-2 ml-auto">
                                <button class="btn btn-ghost btn-circle btn-sm edit-comment-btn" data-comment-id="${comment.id}" data-model-id="${modelId}" aria-label="Kommentar bearbeiten">
                                    <i class="fas fa-edit"></i>
                                </button>
                                <button class="btn btn-ghost btn-circle btn-sm delete-comment-btn" data-comment-id="${comment.id}" data-model-id="${modelId}" aria-label="Kommentar löschen">
                                    <i class="fas fa-trash-alt"></i>
                                </button>
                            </div>
                        ` : ''}
                    </div>
                    <p class="text-base-content/80 ml-12 comment-text-content">${comment.commentText}</p>
                `;
                commentsList.appendChild(commentDiv);
            });

            document.querySelectorAll('.edit-comment-btn').forEach(button => {
                button.onclick = (e) => {
                    const commentId = e.currentTarget.dataset.commentId;
                    const modelId = e.currentTarget.dataset.modelId;
                    const commentTextElement = e.currentTarget.closest('.comment-card').querySelector('.comment-text-content');
                    currentCommentToEdit = { modelId, commentId, commentText: commentTextElement.textContent };
                    editCommentInput.value = currentCommentToEdit.commentText;
                    editCommentModal.showModal();
                    editCommentInput.focus();
                };
            });

            document.querySelectorAll('.delete-comment-btn').forEach(button => {
                button.onclick = (e) => {
                    const commentId = e.currentTarget.dataset.commentId;
                    const modelId = e.currentTarget.dataset.modelId;
                    currentCommentToDelete = { modelId, commentId };
                    deleteCommentConfirmModal.showModal();
                };
            });
        }

        saveCommentEditButton.addEventListener('click', () => {
            if (currentCommentToEdit) {
                const newText = editCommentInput.value.trim();
                editComment(currentCommentToEdit.modelId, currentCommentToEdit.commentId, newText);
            }
        });

        confirmDeleteCommentButton.addEventListener('click', () => {
            if (currentCommentToDelete) {
                deleteComment(currentCommentToDelete.modelId, currentCommentToDelete.commentId);
            }
        });


        document.getElementById('share-button').addEventListener('click', async () => {
            const modelId = currentDetailModelData ? currentDetailModelData.id : null;
            if (!modelId) {
                showToast('Modell-ID nicht gefunden zum Teilen.', 'error');
                return;
            }
            const shareUrl = window.location.origin + window.location.pathname + `?modelId=${modelId}`; 

            if (navigator.share) {
                try {
                    await navigator.share({
                        title: currentDetailModelData ? currentDetailModelData.title : 'VoxelShaper Modell',
                        text: currentDetailModelData ? currentDetailModelData.description : 'Schau dir dieses 3D-Voxelmodell auf VoxelShaper an!',
                        url: shareUrl,
                    });
                    showToast('Modell erfolgreich geteilt!', 'success');
                } catch (error) {
                    showToast('Fehler beim Teilen des Modells.', 'error');
                }
            } else {
                try {
                    await navigator.clipboard.writeText(shareUrl);
                    showToast('Link in die Zwischenablage kopiert!', 'success');
                } catch (err) {
                    showToast('Fehler beim Kopieren des Links.', 'error');
                }
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            const savedTheme = localStorage.getItem('theme');
            const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

            let initialTheme = 'dark'; 
            if (savedTheme) {
                initialTheme = savedTheme;
            } else if (!systemPrefersDark) { 
                initialTheme = 'light';
            }

            htmlElement.setAttribute('data-theme', initialTheme);
            themeToggle.checked = (initialTheme === 'dark'); 

            initializeCategoryOptions();

            const urlParams = new URLSearchParams(window.location.search);
            const modelIdFromUrl = urlParams.get('modelId');

            if (modelIdFromUrl) {
                showModelDetail(modelIdFromUrl);
            } else {
                showMainContent();
            }

            themeToggle.addEventListener('change', () => {
                const isChecked = themeToggle.checked;
                const newTheme = isChecked ? 'dark' : 'light';
                htmlElement.setAttribute('data-theme', newTheme);
                localStorage.setItem('theme', newTheme);
                if (detailRenderer) {
                    const threeJsBgColor = getDaisyUICSSColorForThreeJS(newTheme);
                    detailRenderer.scene.background = new THREE.Color(threeJsBgColor);
                    detailRenderer.renderer.render(detailRenderer.scene, detailRenderer.camera);
                }
                rendererInstances.forEach(renderer => {
                    const threeJsBgColor = getDaisyUICSSColorForThreeJS(newTheme);
                    renderer.scene.background = new THREE.Color(threeJsBgColor);
                    if (renderer.renderer) {
                        renderer.renderer.render(renderer.scene, renderer.camera);
                    }
                });
            });

            document.getElementById('download-stl-button').addEventListener('click', () => {
                if (currentDetailModelData) {
                    handleDownload(currentDetailModelData.id, currentDetailModelData.title);
                } else {
                    showToast('Modellinformationen nicht geladen.', 'error');
                }
            });

            document.getElementById('open-voxelshaper-button').addEventListener('click', () => {
                if (currentDetailModelData) {
                    handleOpenOnVoxelShaper(currentDetailModelData.id);
                } else {
                    showToast('Modellinformationen nicht geladen.', 'error');
                }
            });

            postCommentButton.addEventListener('click', submitFeedback);

            verifyButton.addEventListener('click', () => {
                if (currentDetailModelData) {
                    verifyModel(currentDetailModelData.id);
                }
            });
            revertVerifyButton.addEventListener('click', () => {
                if (currentDetailModelData) {
                    revertVerification(currentDetailModelData.id);
                }
            });
            deleteButton.addEventListener('click', () => {
                if (currentDetailModelData) {
                    showDeleteConfirmationModal(currentDetailModelData.id, currentDetailModelData.title);
                }
            });

            backToOverviewButton.addEventListener('click', () => {
                showMainContent();
            });

            profileButton.addEventListener('click', (e) => {
                e.preventDefault();
                showProfilePage();
            });

            backToMainFromProfileButton.addEventListener('click', () => {
                showMainContent();
            });

            deleteAccountButton.addEventListener('click', () => {
                lastFocusedElement = deleteAccountButton;
                deleteAccountConfirmModal.showModal();
            });

            confirmDeleteAccountButton.addEventListener('click', async () => {
                if (currentUser) {
                    try {
                        await deleteUser(currentUser);
                        showToast('Konto erfolgreich gelöscht! Sie wurden abgemeldet.', 'success');
                        deleteAccountConfirmModal.close();
                        showMainContent();
                        signOut(auth);
                    } catch (error) {
                        let errorMessage = "Fehler beim Löschen des Kontos.";
                        if (error.code === 'auth/requires-recent-login') {
                            errorMessage = 'Bitte melden Sie sich erneut an und versuchen Sie es dann erneut. Diese Aktion erfordert eine aktuelle Authentifizierung.';
                        }
                        showToast(errorMessage, 'error');
                        deleteAccountConfirmModal.close();
                    }
                }
            });
        });
    </script>
</body>
</html>
