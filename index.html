<!DOCTYPE html>
<html lang="de" data-theme="dark">
<head>
<meta charset="UTF-8">
<meta property="og:title" content="VoxelShaper – Create in 3D, Effortlessly" />
<meta property="og:description" content="A powerful, intuitive voxel-based 3D editor – made for makers, artists, and coders." />
<meta property="og:image" content="https://voxelshaper.com/preview.png" />
<meta property="og:url" content="https://voxelshaper.com/" />
<meta property="og:type" content="website" />
<meta name="viewport"
      content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover">
<link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAAANl..."/>

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="VoxelShaper – Create in 3D, Effortlessly">
<meta name="twitter:description" content="A powerful, intuitive voxel-based 3D editor – made for makers, artists, and coders.">
<meta name="twitter:image" content="https://voxelshaper.com/preview.png">
<title>VoxelShaper – Voxel Editor & 3D Print Exporter</title>

<link href="https://cdn.jsdelivr.net/npm/daisyui@4.7.2/dist/full.min.css" rel="stylesheet" type="text/css" />
<script src="https://cdn.tailwindcss.com"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

<style>
/* Wichtig: HTML und Body auf 100% Höhe setzen und Standard-Padding/Margin entfernen */
html {
    height: 100%;
    overflow: hidden; /* Verhindert Scrollbars auf dem HTML-Element */
}

body {
    height: 100%; /* Stellt sicher, dass Body 100% der HTML-Höhe einnimmt */
    margin: 0; /* Entfernt Standard-Body-Margin */
    /* Die vorhandenen env() Paddings werden durch box-sizing: border-box innerhalb dieser 100% Höhe berücksichtigt */
    padding-top: env(safe-area-inset-top);
    padding-bottom: env(safe-area-inset-bottom);
    padding-left: env(safe-area-inset-left);
    padding-right: env(safe-area-inset-right);
    box-sizing: border-box;
    touch-action: auto;
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
    display: flex; /* Für Flexbox-Layout */
    flex-direction: column; /* Elemente untereinander anordnen */
}
#container, #voxelCanvas {
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
    -webkit-touch-callout: none;
    touch-action: none;
    /* FIX: Entfernt den weißen Rand */
    border: none;
}
/* ENTFERNT: .touch-indicator styles und animation */

input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
input[type="color"]::-webkit-color-swatch { border: none; border-radius: 50%; }
input[type="color"]::-moz-color-swatch-wrapper { padding: 0; }
input[type="color"]::-moz-color-swatch { border: none; border-radius: 50%; }
.color-preset-box::-webkit-color-swatch-wrapper { padding: 0; }
input[type="color"]::-webkit-color-swatch { border: none; border-radius: 50%; }
input[type="color"]::-moz-color-swatch-wrapper { padding: 0; }
input[type="color"]::-moz-color-swatch { border: none; border-radius: 50%; }
.color-preset-box::-webkit-color-swatch-wrapper { padding: 0; }
.color-preset-box::-webkit-color-swatch { border: none; border-radius: 0.375rem; }
.color-preset-box::-moz-color-swatch-wrapper { padding: 0; }
.color-preset-box::-moz-color-swatch { border: none; border-radius: 0.375rem; }

#toast-container {
    position: fixed;
    z-index: 50;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    padding: 1rem;
    pointer-events: none;
}

#toast-container.toast-end {
    bottom: 1rem;
    right: 1rem;
    align-items: flex-end;
}

@media (max-width: 768px) {
    #toast-container {
        top: 1rem;
        left: 50%;
        transform: translateX(-50%);
        width: calc(100% - 2rem);
        max-width: 300px;
        align-items: center;
    }
    #toast-container.toast-end {
        bottom: auto;
        right: auto;
    }
}

.toast .alert {
    pointer-events: auto;
    opacity: 0;
    transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
    transform: translateY(20px);
}

.toast .alert.show {
    opacity: 1;
    transform: translateY(0);
}

@media (max-width: 768px) {
    .toast .alert {
        padding: 0.5rem 0.75rem;
        font-size: 0.875rem;
    }
    .toast .alert svg {
        width: 1.25rem;
        height: 1.25rem;
    }
    .toast .alert strong {
        font-size: 0.9rem;
    }
    .toast .alert span {
        font-size: 0.8rem;
    }
    .toast .alert .close-btn {
        font-size: 1rem;
        padding: 0.25rem;
    }
}
.mobile-btn {
    width: 64px;
    height: 64px;
    font-size: 2rem;
    border-radius: 50%;
    background-color: var(--fallback-b3, oklch(var(--b3)/1));
    color: var(--fallback-bc, oklch(var(--bc)/1));
    border: 2px solid var(--fallback-bc, oklch(var(--bc)/1));
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
    transition: background-color 0.2s, transform 0.2s;
}

.mobile-btn:hover {
    background-color: oklch(var(--bc)/0.2);
}

.mobile-btn:active {
    transform: scale(0.95);
}

#mobile-controls {
    gap: 1rem;
}
</style>
</head>
<body class="bg-base-100 min-h-screen text-base-content flex flex-col">
<button id="menuToggle" aria-label="Menü umschalten" class="fixed top-4 right-4 z-[1500] w-10 h-10 text-xl leading-10 text-center bg-base-300 text-base-content border-none rounded-lg cursor-pointer shadow-md hover:bg-base-content/20 lg:hidden">☰</button>

<div id="controls" class="flex flex-wrap items-center justify-center gap-3 p-4 bg-base-200 border-b border-base-content/20 hidden md:flex">
    <label for="grid-size-slider" class="text-base-content">Gittergröße:</label>
    <input type="range" id="grid-size-slider" min="5" max="180" value="10" aria-label="Gittergröße anpassen" class="range range-xs w-36">
    <span id="grid-size-display" class="font-bold text-primary">10×10×10</span>
    
    <label for="color-picker" class="text-base-content">Farbe:</label>
    <input type="color" id="color-picker" value="#ffffff" aria-label="Aktuelle Farbe wählen" class="input input-bordered w-10 h-10 p-0 rounded-full cursor-pointer border-base-content/20">
    <input type="color" id="color-preset-1" class="color-preset-box w-10 h-10 rounded-md border-2 border-base-content/20 cursor-pointer transition-all duration-200 hover:scale-110" value="#E4002B" aria-label="Voreingestellte Farbe 1">
    <input type="color" id="color-preset-2" class="color-preset-box w-10 h-10 rounded-md border-2 border-base-content/20 cursor-pointer transition-all duration-200 hover:scale-110" value="#00A040" aria-label="Voreingestellte Farbe 2">
    <input type="color" id="color-preset-3" class="color-preset-box w-10 h-10 rounded-md border-2 border-base-content/20 cursor-pointer flex items-center justify-center shadow-lg hover:bg-base-content/20" value="#0057B8" aria-label="Voreingestellte Farbe 3">

    <button id="modeToggle" aria-label="Modus wechseln" class="btn btn-sm btn-neutral">Modus wechseln</button><span id="current-mode" class="font-bold text-success min-w-40 text-center">Modus: Hinzufügen</span>
    <button id="clearBtn" aria-label="Alles löschen" class="btn btn-sm btn-neutral">Alles löschen</button>
    <button id="fillLevelBtn" aria-label="Ebene füllen" class="btn btn-sm btn-neutral">Ebene füllen</button>
    <button id="saveBtn" aria-label="Projekt speichern" aria-describedby="save-description" class="btn btn-sm btn-neutral">Projekt speichern</button>
    <div id="save-description" class="sr-only">Speichert das aktuelle Projekt als JSON-Datei</div>
    <button id="loadBtn" aria-label="Projekt laden" class="btn btn-sm btn-neutral">Projekt laden</button>
    <button id="exportStlBtn" aria-label="STL Export" class="btn btn-sm btn-neutral">STL Export</button>

    <label for="fly-speed-slider" class="text-base-content">Fluggeschwindigkeit:</label>
    <input type="range" id="fly-speed-slider" min="0.01" max="1.0" step="0.01" value="0.1" aria-label="Fluggeschwindigkeit anpassen" class="range range-xs w-36">
    <span id="fly-speed-display" class="font-bold text-primary">0.10</span>

    <button id="resetCameraBtn" aria-label="Kamera zurücksetzen" class="btn btn-sm btn-neutral">Zur Szene zurückkehen</button>

    <button id="loadImageTemplateBtn" aria-label="Bild als Vorlage laden" class="btn btn-sm btn-neutral">Bild als Vorlage laden</button>
    <button id="removeImageTemplateBtn" class="btn btn-sm btn-neutral hidden" aria-label="Bildvorlage entfernen">Bildvorlage entfernen</button>
    <input type="file" id="imageFileInput" accept="image/*" class="hidden">

    <!-- ENTFERNT: Login, Upload, Hub Buttons -->
</div>

<div id="container" class="flex-1 relative border-0 box-border overflow-hidden touch-none">
    <canvas id="voxelCanvas" class="w-full h-full block box-border" tabindex="0"></canvas>
    <!-- ENTFERNT: touch-indicator div -->
    <input type="file" id="fileInput" accept=".json" class="hidden">
</div>

<dialog id="clearConfirmationModal" class="modal">
    <div class="modal-box bg-base-200 text-base-content p-8 text-center shadow-xl max-w-md">
        <h3 class="font-bold text-lg text-primary mb-4">Projekt löschen</h3>
        <p class="py-4">Möchten Sie das aktuelle Projekt speichern, bevor Sie alle Voxel löschen?</p>
        <div class="modal-buttons flex justify-around gap-4 mt-6">
            <button id="saveAndClearBtn" class="confirm-save btn btn-success flex-1">Speichern & Löschen</button>
            <button id="clearWithoutSaveBtn" class="confirm-no-save btn btn-error flex-1">Ohne Speichern löschen</button>
            <button id="cancelClearBtn" class="cancel btn btn-ghost flex-1">Abbrechen</button>
        </div>
    </div>
</dialog>

<!-- ENTFERNT: Alle weiteren Modals -->

<div id="toast-container" class="toast toast-end z-50"></div>

<div id="mobile-controls" class="hidden md:hidden flex-col gap-3 fixed bottom-4 right-4 z-[1000]">
    <button class="mobile-btn" id="mobile-undo" aria-label="Rückgängig machen">↺</button>
    <button class="mobile-btn" id="mobile-redo" aria-label="Wiederholen">↻</button>
    <button class="mobile-btn" id="mobile-save" aria-label="Speichern">💾</button>
    <button class="mobile-btn" id="mobile-camera" aria-label="Kamera zurücksetzen">📷</button>

    <button class="mobile-btn" id="mobile-mode-toggle" aria-label="Modus wechseln">
        <span id="mobile-mode-icon" class="fas fa-plus"></span>
    </button>

    <button class="mobile-btn" id="mobile-color-picker-btn" aria-label="Farbe auswählen">🎨</button>
    <input type="color" id="mobile-color-input" value="#ffffff" class="hidden w-0 h-0 opacity-0 absolute pointer-events-none">

    <button class="mobile-btn" id="mobile-axis-toggle" aria-label="Zeichenachse wechseln">
        <span id="mobile-axis-icon" class="fas fa-arrows-alt-v"></span>
    </button>
    <button class="mobile-btn" id="mobile-level-up" aria-label="Ebene erhöhen">⬆️</button>
    <button class="mobile-btn" id="mobile-level-down" aria-label="Ebene verringern">⬇️</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>

<script type="module">
    // ENTFERNT: Firebase Imports und Initialisierung für vereinfachte App
    // import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    // import { getAuth, setPersistence, browserLocalPersistence, signInWithCustomToken, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    // import { getFirestore, doc, getDoc, collection, addDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // ENTFERNT: window.firebase object
    // ENTFERNT: firebaseConfig

</script>

<script>
// Konstanten für Voxelgröße und Bitmaskierung
const VS = 1, HALF = VS * 0.5; // Voxelgröße und halbe Voxelgröße
const CHUNK_SIZE = 16; // Größe der Chunks für die Optimierung der Voxel-Speicherung
const VOX_BITS = 10; // Bits pro Voxelkoordinate für die Key-Generierung
const VOX_MASK = (1 << VOX_BITS) - 1; // Maske für Voxelkoordinaten
const SHIFT_X  = VOX_BITS * 2; // Shift-Wert für X-Koordinate
const SHIFT_Y  = VOX_BITS; // Shift-Wert für Y-Koordinate

// Funktion zur Generierung eines eindeutigen Keys für Voxel
function key(x, y, z) { return ((x << SHIFT_X) | (y << SHIFT_Y) | z) >>> 0; }
// Funktion zum Parsen eines Voxel-Keys zurück in Koordinaten
function parseKey(k) { return [(k >>> SHIFT_X) & VOX_MASK, (k >>> SHIFT_Y) & VOX_MASK, k & VOX_MASK]; }

// Konstanten für Maus-/Touch-Interaktion
const VOXEL_DRAG_THRESHOLD = 1;
const PINCH_ZOOM_MULT = 40;
const TAP_DIST_TH = 10; // Maximale Distanz für einen "Tap"
const MOVE_PX = 10; // Distanzschwelle für Drag-Erkennung
const DT_MS = 250; // Maximale Zeit für einen "Tap" (Millisekunden)

// Geschwindigkeiten für Touch-Steuerung auf Mobilgeräten und Desktop
const ROTATE_SPEED_TOUCH_MOBILE = 0.008; // Erhöht für direktere Reaktion
const PAN_SPEED_TOUCH_MOBILE = 0.2;
const PINCH_ZOOM_MULT_MOBILE = 80;

const ROTATE_SPEED_TOUCH_DESKTOP = 0.004;
const PAN_SPEED_TOUCH_DESKTOP = 0.1;
const PINCH_ZOOM_MULT_DESKTOP = 40;

// Globale Variablen für Touch-Interaktion
let activePointers = new Map(); // Speichert aktive Touch-Punkte
let gestureState = { type: 'none', startDist: 0, startMid: { x: 0, y: 0 }, lastMid: { x: 0, y: 0 }, lastDist: 0, startTime: 0, initialPointerCount: 0 };
let doubleTapDragActive = false; // Status für Doppeltipp-Drag

// Neue Flags zur besseren Unterscheidung von Touch-Gesten
let isDraggingForVoxelAction = false; // True, wenn ein Touch-Drag zum Voxel-Platzieren/Löschen dient
let isSingleTouchCameraRotating = false; // True, wenn ein Einzel-Touch die Kamera dreht

// Three.js Szenen-Variablen
let scene, cam, ren, gridHelper, boxHelper; // Szene, Kamera, Renderer, Gitterhelfer, Boxhelfer
let rotSpeed = 0.004; // Rotationsgeschwindigkeit der Kamera
let euler; // Euler-Winkel für die Kamera-Rotation
const voxels = new Map(); // Map zur Speicherung aller vorhandenen Voxel
const chunks = new Map(); // Map zur Speicherung der Voxel-Chunks für Performance

let cvs, containerDiv; // Canvas-Element und sein Container-Div
let activeDrawingLevel = { x: 0, y: 0, z: 0 }; // Aktuelle Zeichenebene
let currentDrawingAxis = 'y'; // Aktuelle Zeichenachse

// Aktuelle Farbe und Bewegungsgeschwindigkeit (aus LocalStorage geladen)
let currentColor = localStorage.getItem('voxelEditorColor') || '#ffffff';
let moveSpeed = parseFloat(localStorage.getItem('voxelEditorFlySpeed') || '0.1');
let GRID = parseInt(localStorage.getItem('voxelEditorGridSize') || '10'); // Größe des Voxel-Gitters

// Initialisierung der aktiven Zeichenebene basierend auf LocalStorage oder Standardwerten
activeDrawingLevel.x = Number(localStorage.getItem('voxelEditorActiveDrawingLevelX') || '0');
if (!Number.isFinite(activeDrawingLevel.x)) activeDrawingLevel.x = 0;
activeDrawingLevel.x = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.x)));

activeDrawingLevel.y = Number(localStorage.getItem('voxelEditorActiveDrawingLevelY') || '0');
if (!Number.isFinite(activeDrawingLevel.y)) activeDrawingLevel.y = 0;
activeDrawingLevel.y = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.y)));

activeDrawingLevel.z = Number(localStorage.getItem('voxelEditorActiveDrawingLevelZ') || '0');
if (!Number.isFinite(activeDrawingLevel.z)) activeDrawingLevel.z = 0;
activeDrawingLevel.z = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.z)));

currentDrawingAxis = localStorage.getItem('voxelEditorCurrentDrawingAxis') || 'y';

// Voreingestellte Farben (aus LocalStorage geladen)
const presetColors = [
    localStorage.getItem('voxelPresetColor1') || '#E4002B',
    localStorage.getItem('voxelPresetColor2') || '#00A040',
    localStorage.getItem('voxelPresetColor3') || '#0057B8'
];
let activePresetIndex = -1; // Index der aktiven voreingestellten Farbe
let presetBoxes = []; // HTML-Elemente für die voreingestellten Farben

let mainDirectionalLight, fillDirectionalLight, hemisphereLight; // Beleuchtung der Szene
let isShiftDragging = false; // Status für Shift-Drag (falls benötigt)
let isControlDragging = false; // Status für Control-Drag (falls benötigt)
let isPointerLocked = false; // Status für Pointer-Lock (Maussteuerung)
let lastActionVoxelCoords = null; // Letzte Voxelkoordinaten bei Aktionen
let initialClickPos = null; // Startposition des Klicks
let initialRayHitCoords = null; // Rohe Voxelkoordinaten des ersten Raycast-Treffers beim Klick/Touch
let isDragging = false; // Status für Dragging (generisch, wird für Maus und Voxel-Drag verwendet)
let firstMoveAfterLock = true; // Erster Maus-Move nach Pointer-Lock
let mouseMovementX = 0; // Mausbewegung in X-Richtung (für Pointer-Lock)
let mouseMovementY = 0; // Mausbewegung in Y-Richtung (für Pointer-Lock)

const dummy = new THREE.Object3D(); // Dummy-Objekt für InstancedMesh-Transformationen
const previewVoxelGeometry = new THREE.BoxGeometry(VS, VS, VS); // Geometrie für den Vorschau-Voxel
const previewVoxelMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5, depthTest: false }); // Material für den Vorschau-Voxel
previewVoxelMaterial.polygonOffset = true;
previewVoxelMaterial.polygonOffsetFactor = -1; // Versatz für korrekte Darstellung
let previewVoxelMesh = new THREE.Mesh(previewVoxelGeometry, previewVoxelMaterial); // Vorschau-Voxel-Mesh

// Definitions of Modes (ADD, DELETE, DRAW)
const Modes = {
    ADD: 'Hinzufügen',
    DELETE: 'Löschen',
    DRAW: 'Zeichnen',
};

// Icons corresponding to each Mode
const ModeIcons = {
    ADD: 'fas fa-plus',
    DELETE: 'fas fa-eraser',
    DRAW: 'fas fa-paint-brush'
};

// Icons corresponding to each Axis
const AxisIcons = {
    x: 'fas fa-arrows-alt-h',
    y: 'fas fa-arrows-alt-v',
    z: 'fas fa-arrows-alt'
};

let currentMode = Modes.ADD; // Aktueller Bearbeitungsmodus

let history = []; // Historie der Aktionen für Undo/Redo
let historyPointer = -1; // Aktueller Zeiger in der Historie
const MAX_HISTORY_SIZE = 100; // Maximale Größe der Historie

let currentStrokeVoxels = new Map(); // Voxel im aktuellen Zeichenstrich
let voxelsAtDragStart = null; // Voxel-Zustand zu Beginn eines Drags

let previewLineInstancedMesh; // Instanziiertes Mesh für Vorschau-Linien (z.B. beim Zeichnen)
const maxPreviewInstances = 180 * 3; // Maximale Instanzen für Vorschau-Linien
let previewLineVoxels = []; // Voxel in der Vorschau-Linie

let templateImageMesh = null; // Mesh für Bildvorlagen
let templateImageData = null; // Daten der Bildvorlage

let isMobile = window.matchMedia('(max-width: 768px)').matches; // Erkennung, ob es sich um ein Mobilgerät handelt

let initialDragVoxelWorldPos = null; // Weltposition des Voxels zu Beginn des Drags
let dragAxisLock = null; // Achsen-Sperre für Drag-Operationen
let initialDragVoxelCoords = null; // Voxelkoordinaten zu Beginn des Drags (der erste tatsächlich geänderte Voxel)
let initialDragYLevel = null; // Speichert die Y-Ebene zu Beginn eines Drag-Vorgangs im DRAW-Modus

// Projektmetadaten (Beibehalten für JSON-Speicherung, aber nicht mehr über UI bearbeitbar/anzeigbar)
let projectTitle = '';
let projectDescription = '';
let projectCategory = 'Allgemein';
let projectTags = [];
let projectRemixOf = '';
let projectSourceJsonUrl = '';
let projectVisibility = 'public';

// Hilfsfunktionen für Chunk-Koordinaten
function getChunkCoords(gx, gy, gz) { return { cx: Math.floor(gx / CHUNK_SIZE), cy: Math.floor(gy / CHUNK_SIZE), cz: Math.floor(gz / CHUNK_SIZE) }; }
function getChunkKey(cx, cy, cz) { return `${cx},${cy},${cz}`; }

// Klasse für Voxel-Chunks zur effizienten Verwaltung großer Modelle
class VoxelChunk {
    constructor(chunkX, chunkY, chunkZ, chunkSize, scene) {
        this.chunkX = chunkX; this.chunkY = chunkY; this.chunkZ = chunkZ; this.scene = scene; this.chunkSize = chunkSize;
        this.offsetX = chunkX * chunkSize * VS; this.offsetY = chunkY * chunkSize * VS; this.offsetZ = chunkZ * chunkSize * VS;
        this.voxels = new Map(); this.globalToLocalInstanceIdMap = new Map();
        const maxInstancesInChunk = chunkSize * chunkSize * chunkSize;
        const voxelBaseGeometry = new THREE.BoxGeometry(VS, VS, VS);
        const meshMaterial = new THREE.MeshLambertMaterial(); // Material für Voxel
        this.instancedMesh = new THREE.InstancedMesh(voxelBaseGeometry, meshMaterial, maxInstancesInChunk);
        this.instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(maxInstancesInChunk * 3), 3);
        this.instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        this.instancedMesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
        this.instancedMesh.castShadow = true; this.instancedMesh.receiveShadow = true; this.instancedMesh.count = 0;
        this.instancedMesh.position.set(this.offsetX, this.offsetY, this.offsetZ);
        this.scene.add(this.instancedMesh);
        this.boundingBox = new THREE.Box3(
            new THREE.Vector3(this.offsetX, this.offsetY, this.offsetZ),
            new THREE.Vector3(this.offsetX + chunkSize * VS, this.offsetY + chunkSize * VS, this.offsetZ + chunkSize * VS)
        );
    }
    getLocalKey(gx, gy, gz) { return key(gx % this.chunkSize, gy % this.chunkSize, gz % this.chunkSize); }
    addVoxel(gx, gy, gz, colorHex) {
        const lKey = this.getLocalKey(gx, gy, gz); const gKey = key(gx, gy, gz);
        if (this.voxels.has(lKey)) {
            const instanceId = this.voxels.get(lKey).instanceId;
            this.voxels.set(lKey, { color: colorHex, instanceId }); this.updateInstanceColor(instanceId, colorHex);
        } else {
            const instanceId = this.instancedMesh.count++;
            this.voxels.set(lKey, { color: colorHex, instanceId }); this.globalToLocalInstanceIdMap.set(gKey, instanceId);
            dummy.position.set((gx % this.chunkSize) * VS + HALF, (gy % this.chunkSize) * VS + HALF, (gz % this.chunkSize) * VS + HALF);
            dummy.updateMatrix(); this.instancedMesh.setMatrixAt(instanceId, dummy.matrix);
            this.updateInstanceColor(instanceId, colorHex);
            this.instancedMesh.instanceMatrix.needsUpdate = true; this.instancedMesh.instanceColor.needsUpdate = true;
        }
    }
    removeVoxel(gx, gy, gz) {
        const gKey = key(gx, gy, gz);
        const { cx, cy, cz } = getChunkCoords(gx, gy, gz); 
        const cKey = getChunkKey(cx, cy, cz);
        
        if (chunks.has(cKey)) {
            const chunk = chunks.get(cKey);
            const lKey = chunk.getLocalKey(gx, gy, gz); // Lokalen Schlüssel hier holen
            if (!chunk.voxels.has(lKey)) return; 

            const { instanceId: removedId } = chunk.voxels.get(lKey);
            
            chunk.voxels.delete(lKey); // Entfernen aus der lokalen Chunk-Map
            chunk.globalToLocalInstanceIdMap.delete(gKey); // Entfernen aus der globalToLocal Map des Chunks

            const lastId = chunk.instancedMesh.count - 1;
            if (removedId !== lastId) {
                let lastVoxelLKey = null;
                for (const [lk, data] of chunk.voxels.entries()) { 
                    if (data.instanceId === lastId) { 
                        lastVoxelLKey = lk; 
                        break; 
                    } 
                }
                if (lastVoxelLKey !== null) {
                    const tempMatrix = new THREE.Matrix4(); 
                    chunk.instancedMesh.getMatrixAt(lastId, tempMatrix);
                    chunk.instancedMesh.setMatrixAt(removedId, tempMatrix);
                    chunk.updateInstanceColor(removedId, chunk.voxels.get(lastVoxelLKey).color);
                    chunk.voxels.get(lastVoxelLKey).instanceId = removedId;
                    const [lx, ly, lz] = parseKey(lastVoxelLKey);
                    chunk.globalToLocalInstanceIdMap.set(key(chunk.chunkX * chunk.chunkSize + lx, chunk.chunkY * chunk.chunkSize + ly, chunk.chunkZ * chunk.chunkSize + lz), removedId);
                }
            }
            chunk.instancedMesh.count--;
            chunk.instancedMesh.instanceMatrix.needsUpdate = true; 
            chunk.instancedMesh.instanceColor.needsUpdate = true;
            
            // Erst hier aus der globalen voxels-Map löschen, nachdem der Chunk-Voxel erfolgreich behandelt wurde
            voxels.delete(gKey); 

            if (chunk.instancedMesh.count === 0) { 
                chunk.dispose(); 
                chunks.delete(cKey); 
            }
        } else {
            // Wenn der Chunk nicht existiert, aber der Voxel in der globalen Map ist, nur aus globaler Map löschen
            voxels.delete(gKey);
        }
    }
    recolorVoxel(gx, gy, gz, newColorHex) {
        const lKey = this.getLocalKey(gx, gy, gz);
        if (!this.voxels.has(lKey)) return;
        const { instanceId } = this.voxels.get(lKey);
        this.voxels.set(lKey, { color: newColorHex, instanceId: instanceId });
        this.updateInstanceColor(instanceId, newColorHex);
    }
    updateInstanceColor(instanceId, hex) {
        const c = new THREE.Color(hex); this.instancedMesh.instanceColor.setXYZ(instanceId, c.r, c.g, c.b);
        this.instancedMesh.instanceColor.needsUpdate = true;
    }
    dispose() {
        this.scene.remove(this.instancedMesh);
        this.instancedMesh.geometry.dispose(); this.instancedMesh.material.dispose();
        this.instancedMesh = null; this.voxels.clear(); this.globalToLocalInstanceIdMap.clear();
    }
}

// Handler für Größenänderungen des Fensters
function onResize() {
    cam.aspect = containerDiv.clientWidth / containerDiv.clientHeight; cam.updateProjectionMatrix();
    ren.setSize(containerDiv.clientWidth, containerDiv.clientHeight);
    ren.setPixelRatio(isMobile ? Math.min(1.5, window.devicePixelRatio) : window.devicePixelRatio);
}

// Funktion zur Handhabung von Touch-Gesten (Rotieren, Zoomen, Schwenken)
function handleGesture() {
    const pointers = [...activePointers.values()];
    if (pointers.length === 0) return;

    if (pointers.length === 1) {
        const p = pointers[0];
        const rotateSpeed = isMobile ? ROTATE_SPEED_TOUCH_MOBILE : ROTATE_SPEED_TOUCH_DESKTOP;
        
        // FIX: Invertiertes Links/Rechts-Rotationsproblem auf Mobilgeräten behoben
        euler.y -= (p.x - gestureState.lastMid.x) * rotateSpeed;
        euler.x -= (p.y - gestureState.lastMid.y) * rotateSpeed;
        
        euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
        cam.quaternion.setFromEuler(euler);
        gestureState.lastMid = { x: p.x, y: p.y };
        return;
    }

    if (pointers.length >= 2) {
        const [p0, p1] = pointers;
        const midX = (p0.x + p1.x) * 0.5;
        const midY = (p0.y + p1.y) * 0.5;
        const dist = Math.hypot(p1.x - p0.x, p1.y - p0.y);

        if (gestureState.type === 'none') {
            const dMid = Math.hypot(midX - gestureState.startMid.x, midY - gestureState.startMid.y);
            const PINCH_REL_TH = 0.05;
            const relDelta = Math.abs(dist - gestureState.startDist) / gestureState.startDist;
            if (relDelta > PINCH_REL_TH) {
                gestureState.type = 'pinch';
            } else if (dMid > MOVE_PX) {
                gestureState.type = 'pan';
            }
            return;
        } else if (gestureState.type === 'pinch') {
            const pinchZoomMult = isMobile ? PINCH_ZOOM_MULT_MOBILE : PINCH_ZOOM_MULT_DESKTOP;
            const zoomDelta = (dist / gestureState.lastDist - 1) * pinchZoomMult * moveSpeed;
            cam.position.addScaledVector(cam.getWorldDirection(new THREE.Vector3()), zoomDelta);
            gestureState.lastDist = dist;
        } else if (gestureState.type === 'pan') {
            const panSpeed = isMobile ? PAN_SPEED_TOUCH_MOBILE : PAN_SPEED_TOUCH_DESKTOP;
            const dx = (midX - gestureState.lastMid.x) * panSpeed;
            const dy = (midY - gestureState.lastMid.y) * panSpeed;
            
            const right = new THREE.Vector3().crossVectors(cam.getWorldDirection(new THREE.Vector3()), cam.up).normalize();
            cam.position.addScaledVector(right, dx);
            cam.position.addScaledVector(new THREE.Vector3(0, 1, 0), dy);
            
            gestureState.lastMid = { x: midX, y: midY };
        }
    }
}

// Funktion zum Freigeben eines Pointers (Touch-Punkt)
function releasePointer(id, eventType) {
    activePointers.delete(id);
    // Nur zurücksetzen, wenn keine Pointer mehr aktiv sind oder weniger als 2 (für Multi-Touch-Gesten)
    if (activePointers.size < 2) {
        gestureState.type = 'none';
        if (activePointers.size === 1) { // Wenn noch ein Finger aktiv ist, aktualisiere lastMid
            const last = [...activePointers.values()][0]; 
            gestureState.lastMid = { x: last.x, y: last.y }; 
        }
    }
    // Komplette Zurücksetzung, wenn keine Pointer mehr aktiv sind
    if (activePointers.size === 0) {
        doubleTapDragActive = false; 
        lastActionVoxelCoords = null; 
        // touchIndicator.style.display = 'none'; // ENTFERNT
        initialDragVoxelWorldPos = null; 
        dragAxisLock = null; 
        initialDragVoxelCoords = null;
        initialDragYLevel = null; 
        previewLineInstancedMesh.count = 0; 
        previewLineInstancedMesh.instanceMatrix.needsUpdate = true; 
        previewLineVoxels = [];

        // Flags für Touch-Gesten zurücksetzen
        isDraggingForVoxelAction = false;
        isSingleTouchCameraRotating = false;
    }
}

// Funktion zum Neuaufbau von Gitter- und Box-Helfern (visuelle Hilfslinien)
function rebuildHelpers() {
    if (gridHelper) scene.remove(gridHelper); if (boxHelper) scene.remove(boxHelper);
    const size = GRID * VS;
    if (isMobile) {
        gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444 ); gridHelper.position.set(size / 2, activeDrawingLevel.y * VS, size / 2);
    } else {
        if (currentDrawingAxis === 'y') {
            gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444 ); gridHelper.position.set(size / 2, activeDrawingLevel.y * VS, size / 2);
        } else if (currentDrawingAxis === 'x') {
            gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444); gridHelper.rotation.z = Math.PI / 2; gridHelper.position.set(activeDrawingLevel.x * VS, size / 2, size / 2);
        } else if (currentDrawingAxis === 'z') {
            gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444); gridHelper.rotation.x = Math.PI / 2; gridHelper.position.set(size / 2, size / 2, activeDrawingLevel.z * VS);
        }
    }
    scene.add(gridHelper);
    const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(size, size, size));
    boxHelper = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x00ffff }));
    boxHelper.position.set(size / 2, size / 2, size / 2); scene.add(boxHelper);

    const mobileAxisIcon = document.getElementById('mobile-axis-icon');
    if (mobileAxisIcon) {
        mobileAxisIcon.className = AxisIcons[currentDrawingAxis];
    }
}

// Aktualisiert die Position des Gitterhelfers und speichert sie im LocalStorage
function updateGridHelperPosition() {
    rebuildHelpers();
    localStorage.setItem('voxelEditorActiveDrawingLevelX', activeDrawingLevel.x);
    localStorage.setItem('voxelEditorActiveDrawingLevelY', activeDrawingLevel.y);
    localStorage.setItem('voxelEditorActiveDrawingLevelZ', activeDrawingLevel.z);
    localStorage.setItem('voxelEditorCurrentDrawingAxis', currentDrawingAxis);
}

// Wechselt den Bearbeitungsmodus (Hinzufügen, Löschen, Zeichnen)
function cycleMode() {
    const activeElement = document.activeElement;
    if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'SELECT' || activeElement.tagName === 'TEXTAREA')) {
        cvs.focus(); return;
    }
    switch (currentMode) {
        case Modes.ADD: currentMode = Modes.DELETE; break;
        case Modes.DELETE: currentMode = Modes.DRAW; break;
        case Modes.DRAW: currentMode = Modes.ADD; break;
    }
    document.getElementById('current-mode').textContent = `Modus: ${currentMode}`;
    const mobileModeIcon = document.getElementById('mobile-mode-icon');
    if (mobileModeIcon) {
        mobileModeIcon.className = ModeIcons[currentMode];
    }
    lastActionVoxelCoords = null; updatePreviewVoxel(0, 0, 0, false);
    previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
}

// Setzt eine voreingestellte Farbe als aktuelle Farbe
function setActivePreset(index) {
    if (index >= 0 && index < presetColors.length) {
        currentColor = presetColors[index];
        document.getElementById('color-picker').value = currentColor;
        const mobileColorInput = document.getElementById('mobile-color-input');
        if (mobileColorInput) mobileColorInput.value = currentColor;
        localStorage.setItem('voxelEditorColor', currentColor);
        presetBoxes.forEach((box, i) => {
            if (i === index) { box.classList.add('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'); }
            else { box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'); }
        });
        activePresetIndex = index;
        if (previewVoxelMesh.visible) {
            previewVoxelMaterial.color.set(currentColor);
        }
    }
}

// Speichert eine Farbe als Voreinstellung
function savePresetColor(index, colorValue) {
    if (index >= 0 && index < presetColors.length) {
        presetColors[index] = colorValue;
        localStorage.setItem(`voxelPresetColor${index + 1}`, colorValue);
        if (activePresetIndex === index) {
            currentColor = colorValue;
            document.getElementById('color-picker').value = currentColor;
            const mobileColorInput = document.getElementById('mobile-color-input');
            if (mobileColorInput) mobileColorInput.value = currentColor;
            localStorage.setItem('voxelEditorColor', currentColor);
        }
    }
}

// Wendet einen Voxel-Zustand an (für Undo/Redo)
function applyVoxelState(state) {
    for (const chunk of chunks.values()) chunk.dispose();
    chunks.clear(); voxels.clear();
    state.forEach(v => _addSingleVoxel(v.gx, v.gy, v.gz, v.color));
}

// Fügt einen Befehl zur Historie hinzu
function addCommand(type, oldState = null, newState = null, commandData = null) {
    if (historyPointer < history.length - 1) history.splice(historyPointer + 1);
    history.push({ type, oldState, newState, commandData }); historyPointer++;
    if (history.length > MAX_HISTORY_SIZE) { history.shift(); historyPointer--; }
}

// Führt einen Befehl aus (für Undo/Redo)
function executeCommand(command, reverse = false) {
    const { type, oldState, newState, commandData } = command;
    switch (type) {
        case 'batch': applyVoxelState(reverse ? oldState : newState); break;
        case 'clearAll': clearAllInternal(true); if (reverse) applyVoxelState(oldState); break;
        case 'fillLevel': applyVoxelState(reverse ? oldState : newState); break;
        case 'resizeGrid':
            GRID = reverse ? commandData.oldGrid : commandData.newGrid;
            document.getElementById('grid-size-slider').value = GRID;
            document.getElementById('grid-size-display').textContent = `${GRID}×${GRID}×${GRID}`;
            localStorage.setItem('voxelEditorGridSize', GRID);
            applyVoxelState(reverse ? oldState : newState); break;
    }
    rebuildHelpers();
}

// Undo-Funktion
function undo() { if (historyPointer >= 0) { executeCommand(history[historyPointer], true); historyPointer--; } }
// Redo-Funktion
function redo() { if (historyPointer < history.length - 1) { historyPointer++; executeCommand(history[historyPointer], false); } }

// Fügt einen einzelnen Voxel hinzu
function _addSingleVoxel(gx, gy, gz, colorHex) {
    const gKey = key(gx, gy, gz); voxels.set(gKey, { color: colorHex });
    const { cx, cy, cz } = getChunkCoords(gx, gy, gz); const cKey = getChunkKey(cx, cy, cz);
    let chunk = chunks.get(cKey);
    if (!chunk) { chunk = new VoxelChunk(cx, cy, cz, CHUNK_SIZE, scene); chunks.set(cKey, chunk); }
    chunk.addVoxel(gx, gy, gz, colorHex);
}

// Entfernt einen einzelnen Voxel
function _removeSingleVoxel(gx, gy, gz) {
    const gKey = key(gx, gy, gz);
    const { cx, cy, cz } = getChunkCoords(gx, gy, gz); 
    const cKey = getChunkKey(cx, cy, cz);
    
    if (chunks.has(cKey)) {
        const chunk = chunks.get(cKey);
        const lKey = chunk.getLocalKey(gx, gy, gz); // Lokalen Schlüssel hier holen
        if (!chunk.voxels.has(lKey)) { // Prüfen, ob der Voxel wirklich im Chunk ist
            // Wenn der Voxel nicht im Chunk ist, aber in der globalen Map, nur aus der globalen Map löschen
            if (voxels.has(gKey)) voxels.delete(gKey);
            return; 
        }

        const { instanceId: removedId } = chunk.voxels.get(lKey);
        
        chunk.voxels.delete(lKey); // Entfernen aus der lokalen Chunk-Map
        chunk.globalToLocalInstanceIdMap.delete(gKey); // Entfernen aus der globalToLocal Map des Chunks

        const lastId = chunk.instancedMesh.count - 1;
        if (removedId !== lastId) {
            let lastVoxelLKey = null;
            for (const [lk, data] of chunk.voxels.entries()) { 
                if (data.instanceId === lastId) { 
                    lastVoxelLKey = lk; 
                    break; 
                } 
            }
            if (lastVoxelLKey !== null) {
                const tempMatrix = new THREE.Matrix4(); 
                chunk.instancedMesh.getMatrixAt(lastId, tempMatrix);
                chunk.instancedMesh.setMatrixAt(removedId, tempMatrix);
                chunk.updateInstanceColor(removedId, chunk.voxels.get(lastVoxelLKey).color);
                chunk.voxels.get(lastVoxelLKey).instanceId = removedId;
                const [lx, ly, lz] = parseKey(lastVoxelLKey);
                chunk.globalToLocalInstanceIdMap.set(key(chunk.chunkX * chunk.chunkSize + lx, chunk.chunkY * chunk.chunkSize + ly, chunk.chunkZ * chunk.chunkSize + lz), removedId);
            }
        }
        chunk.instancedMesh.count--;
        chunk.instancedMesh.instanceMatrix.needsUpdate = true; 
        chunk.instancedMesh.instanceColor.needsUpdate = true;
        
        // Erst hier aus der globalen voxels-Map löschen, nachdem der Chunk-Voxel erfolgreich behandelt wurde
        voxels.delete(gKey); 

        if (chunk.instancedMesh.count === 0) { 
            chunk.dispose(); 
            chunks.delete(cKey); 
        }
    } else {
        // Wenn der Chunk nicht existiert, aber der Voxel in der globalen Map ist, nur aus globaler Map löschen
        if (voxels.has(gKey)) voxels.delete(gKey);
    }
}

// Färbt einen einzelnen Voxel neu
function _recolorSingleVoxel(gx, gy, gz, newColorHex) {
    const gKey = key(gx, gy, gz); if (!voxels.has(gKey)) return;
    voxels.set(gKey, { color: newColorHex });
    const { cx, cy, cz } = getChunkCoords(gx, gy, gz); const cKey = getChunkKey(cx, cy, cz);
    if (chunks.has(cKey)) chunks.get(cKey).recolorVoxel(gx, gy, gz, newColorHex);
}

// Führt eine Voxel-Modifikation durch (Hinzufügen, Löschen, Zeichnen)
function performVoxelModification(gx, gy, gz, mode, newColor) {
    const gKey = key(gx, gy, gz);
    const hasVoxel = voxels.has(gKey);

    gx = Math.max(0, Math.min(GRID - 1, gx));
    gy = Math.max(0, Math.min(GRID - 1, gy));
    gz = Math.max(0, Math.min(GRID - 1, gz));

    switch (mode) {
        case Modes.ADD:
            if (!hasVoxel) {
                _addSingleVoxel(gx, gy, gz, newColor);
            }
            break;
        case Modes.DELETE:
            if (hasVoxel) {
                _removeSingleVoxel(gx, gy, gz);
            }
            break;
        case Modes.DRAW:
            if (hasVoxel) {
                if (voxels.get(gKey).color !== newColor) {
                    _recolorSingleVoxel(gx, gy, gz, newColor);
                }
            }
            break;
    }
}

// Aktualisiert den Vorschau-Voxel
function updatePreviewVoxel(x, y, z, visible) {
    if (previewVoxelMesh) {
        if (visible) {
            if (previewVoxelMesh.geometry.parameters.width !== VS ||
                previewVoxelMesh.geometry.parameters.height !== VS ||
                previewVoxelMesh.geometry.parameters.depth !== VS) {
                previewVoxelMesh.geometry.dispose();
                previewVoxelMesh.geometry = new THREE.BoxGeometry(VS, VS, VS);
            }
            previewVoxelMesh.position.set(x * VS + HALF, y * VS + HALF, z * VS + HALF);
            previewVoxelMesh.visible = true;
            previewVoxelMaterial.color.set(currentColor);
            previewVoxelMaterial.opacity = (currentMode === Modes.DELETE) ? 0.2 : 0.5;
        } else {
            previewVoxelMesh.visible = false;
        }
    }
}

// Globale Variablen für Vorlagen (nur Bildvorlage behalten)
let templateInstancedMesh = null; // Nicht mehr für Voxel-Vorlagen verwendet
let templateVoxelMap = new Map(); // Nicht mehr für Voxel-Vorlagen verwendet

/**
 * Berechnet die rohen Voxelkoordinaten, die von einem Raycast getroffen wurden.
 * @param {number} clientX - X-Koordinate des Maus-/Touch-Ereignisses relativ zum Viewport.
 * @param {number} clientY - Y-Koordinate des Maus-/Touch-Ereignisses relativ zum Viewport.
 * @param {Map<number, boolean>} [excludeVoxelsMap] - Optional: Eine Map von Voxel-Keys, die ignoriert werden sollen (z.B. Voxel im aktuellen Zeichenstrich).
 * @param {number|null} [lockedYLevel=null] - Optional: Eine Y-KoEbene, auf die der Raycast im DRAW-Modus bevorzugt werden soll.
 * @returns {object|null} Voxelkoordinaten (gx, gy, gz), Normalenvektor (faceNormal, falls Voxel getroffen),
 * ob ein existierender Voxel (hitExistingVoxel) oder eine Vorlage (hitTemplate) getroffen wurde.
 */
function calculateRayTargetVoxelCoords(clientX, clientY, excludeVoxelsMap = null, lockedYLevel = null) {
    if (isPointerLocked) return null;

    const rect = cvs.getBoundingClientRect();
    const mouse = new THREE.Vector2(
        ((clientX - rect.left) / rect.width) * 2 - 1,
        -((clientY - rect.top) / rect.height) * 2 + 1
    );

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, cam);

    // 1. Priorität: Treffen der (entfernten) Voxel-Vorlage, falls noch irgendwo im Code referenziert
    // Da Voxel-Vorlagen entfernt wurden, wird dieser Block effektiv nichts tun.
    if (templateInstancedMesh && templateInstancedMesh.count > 0) {
        const templateIntersects = raycaster.intersectObject(templateInstancedMesh);
        for (const hit of templateIntersects) {
            const instanceMatrix = new THREE.Matrix4();
            templateInstancedMesh.getMatrixAt(hit.instanceId, instanceMatrix);
            const instancePosition = new THREE.Vector3().setFromMatrixPosition(instanceMatrix);

            const hitVoxelX = Math.round((instancePosition.x - HALF) / VS);
            const hitVoxelY = Math.round((instancePosition.y - HALF) / VS);
            const hitVoxelZ = Math.round((instancePosition.z - HALF) / VS);

            const hitKey = key(hitVoxelX, hitVoxelY, hitVoxelZ);
            if (excludeVoxelsMap && excludeVoxelsMap.has(hitKey)) {
                continue;
            }

            return { gx: hitVoxelX, gy: hitVoxelY, gz: hitVoxelZ, faceNormal: null, hitExistingVoxel: false, hitTemplate: true };
        }
    }

    // 2. Priorität: Treffen von existierenden Voxeln
    const objectsToIntersect = Array.from(chunks.values()).map(chunk => chunk.instancedMesh);
    if (templateImageMesh) {
        templateImageMesh.raycast = function() {}; // Bildvorlage soll nicht direkt Raycasts fangen
    }

    const intersects = raycaster.intersectObjects(objectsToIntersect);

    for (const hit of intersects) {
        const hitNormal = hit.face.normal.clone();
        const intersectionPoint = hit.point;

        if (!Number.isFinite(intersectionPoint.x) || !Number.isFinite(intersectionPoint.y) || !Number.isFinite(intersectionPoint.z)) {
            continue;
        }

        const epsilon = 0.001;
        const adjustedPoint = intersectionPoint.clone().addScaledVector(hitNormal, -epsilon);

        const hitVoxelX = Math.floor(adjustedPoint.x / VS);
        const hitVoxelY = Math.floor(adjustedPoint.y / VS);
        const hitVoxelZ = Math.floor(adjustedPoint.z / VS);
        
        const hitKey = key(hitVoxelX, hitVoxelY, hitVoxelZ);
        if (excludeVoxelsMap && excludeVoxelsMap.has(hitKey)) {
            continue;
        }

        const result = { gx: Number(hitVoxelX), gy: Number(hitVoxelY), gz: Number(hitVoxelZ), faceNormal: hitNormal, hitExistingVoxel: true, hitTemplate: false };
        if (!Number.isFinite(result.gx) || !Number.isFinite(result.gy) || !Number.isFinite(result.gz)) {
            continue;
        }
        return result;
    }

    // 3. Priorität: Treffen der Zeichenebene, wenn keine Voxel getroffen wurden
    let planeNormal = new THREE.Vector3();
    let planeConstant = 0;
    let targetY = activeDrawingLevel.y; // Standardmäßig die aktive Zeichenebene

    // Wenn ein lockedYLevel für den DRAW-Modus während eines Drags vorhanden ist,
    // überschreibe die Standard-Zeichenebene damit.
    if (lockedYLevel !== null && currentMode === Modes.DRAW && isDraggingForVoxelAction) { // Geändert: isDragging zu isDraggingForVoxelAction
        planeNormal.set(0, 1, 0); // Die Zeichenebene ist immer horizontal (Y-Achse)
        planeConstant = -(lockedYLevel * VS); // Verwende die übergebene Locked Y-Ebene
        const tempDrawingPlane = new THREE.Plane(planeNormal, planeConstant);
        const tempIntersectionPoint = new THREE.Vector3();

        if (raycaster.ray.intersectPlane(tempDrawingPlane, tempIntersectionPoint)) {
            // Wenn der Raycast die gelockte Y-Ebene trifft, gib diesen Treffer zurück
            let gx = Math.floor(tempIntersectionPoint.x / VS);
            let gy = lockedYLevel; // Hier ist die Y-Ebene die gelockte Ebene
            let gz = Math.floor(tempIntersectionPoint.z / VS);

            gx = Number(gx);
            gy = Number(gy);
            gz = Number(gz);

            if (Number.isFinite(gx) && Number.isFinite(gy) && Number.isFinite(gz)) {
                 // Vor dem Zurückgeben prüfen, ob dieser potentielle Voxel
                 // im Ausschluss-Map enthalten ist. Wenn ja, ignorieren.
                const potentialKey = key(gx, gy, gz);
                if (!excludeVoxelsMap || !excludeVoxelsMap.has(potentialKey)) {
                    return { gx, gy, gz, faceNormal: null, hitExistingVoxel: false, hitTemplate: false };
                }
            }
        }
        // Wenn die gelockte Y-Ebene nicht getroffen wurde oder der Voxel ausgeschlossen ist,
        // fahren wir mit der normalen aktiven Zeichenebene fort.
    }


    planeNormal.set(0, 1, 0); // Die Zeichenebene ist immer horizontal (Y-Achse)
    planeConstant = -(targetY * VS); // Verwende die angepasste Target-Y

    const drawingPlane = new THREE.Plane(planeNormal, planeConstant);
    const intersectionPoint = new THREE.Vector3();

    if (raycaster.ray.intersectPlane(drawingPlane, intersectionPoint)) {
        if (!Number.isFinite(intersectionPoint.x) || !Number.isFinite(intersectionPoint.y) || !Number.isFinite(intersectionPoint.z)) {
            return null;
        }

        let gx = Math.floor(intersectionPoint.x / VS);
        let gy = Math.floor(intersectionPoint.y / VS);
        let gz = Math.floor(intersectionPoint.z / VS);

        // Die Y-Koordinate ist bereits durch targetY gesetzt oder korrigiert,
        // daher hier nur noch die X/Z anpassen, wenn die Zeichenachse nicht Y ist.
        if (currentDrawingAxis === 'x') gx = activeDrawingLevel.x;
        else if (currentDrawingAxis === 'z') gz = activeDrawingLevel.z;
        // else if currentDrawingAxis === 'y', then gy remains targetY

        gx = Number(gx);
        gy = Number(gy); // gy ist hier schon korrekt (targetY)
        gz = Number(gz);

        if (!Number.isFinite(gx) || !Number.isFinite(gy) || !Number.isFinite(gz)) {
            return null;
        }
        const result = { gx, gy, gz, faceNormal: null, hitExistingVoxel: false, hitTemplate: false };
        return result;
    }
    return null;
}

// Interne Funktion zum vollständigen Löschen aller Voxel (mit optionaler Historien-Speicherung)
function clearAllInternal(fromHistory = false) {
    if (!fromHistory) {
        // Speichert den aktuellen Zustand für Undo
        const oldState = [...voxels.entries()].map(([id, data]) => { const p = parseKey(id); return { gx: p[0], gy: p[1], gz: p[2], color: data.color }; });
        addCommand('clearAll', oldState, []);
    }
    // Entsorgt alle Chunks und löscht Maps
    for (const chunk of chunks.values()) chunk.dispose();
    chunks.clear(); voxels.clear(); rebuildHelpers(); // Setzt Helfer und Gitter zurück
}
// Öffentliche Funktion zum Löschen aller Voxel
function clearAll() { clearAllInternal(false); }

// Füllt die aktive Zeichenebene mit Voxeln
function fillActiveLevel() {
    // Speichert den alten Zustand für Undo
    const oldState = [...voxels.entries()].map(([id, data]) => { const p = parseKey(id); return { gx: p[0], gy: p[1], gz: p[2], color: data.color }; });
    const voxelsToRemove = [];
    // Sammelt Voxel, die gelöscht werden müssen, wenn die Ebene gefüllt wird
    for (let x = 0; x < GRID; x++) { for (let z = 0; z < GRID; z++) {
        let gx, gy, gz;
        if (currentDrawingAxis === 'y') { gx = x; gy = activeDrawingLevel.y; gz = z; }
        else if (currentDrawingAxis === 'x') { gx = activeDrawingLevel.x; gy = x; gz = z; }
        else if (currentDrawingAxis === 'z') { gx = x; gy = z; gz = activeDrawingLevel.z; }
        const k = key(gx, gy, gz); if (voxels.has(k)) voxelsToRemove.push(k);
    }}
    // Entfernt die gesammelten Voxel
    voxelsToRemove.forEach(k => { const [gx, gy, gz] = parseKey(k); _removeSingleVoxel(gx, gy, gz); });
    const newState = [];
    // Fügt neue Voxel hinzu, um die Ebene zu füllen
    for (let x = 0; x < GRID; x++) { for (let z = 0; z < GRID; z++) {
        let gx, gy, gz;
        if (currentDrawingAxis === 'y') { gx = x; gy = activeDrawingLevel.y; gz = z; }
        else if (currentDrawingAxis === 'x') { gx = activeDrawingLevel.x; gy = x; gz = z; }
        else if (currentDrawingAxis === 'z') { gx = x; gy = z; gz = activeDrawingLevel.z; }
        _addSingleVoxel(gx, gy, gz, currentColor); newState.push({ gx, gy, gz, color: currentColor, dimX: 1, dimY: 1, dimZ: 1 });
    }}
    addCommand('fillLevel', oldState, newState); // Fügt den Befehl zur Historie hinzu
}

// Speichert das aktuelle Projekt als JSON-Datei
function saveJSON() {
    const data = {};
    voxels.forEach((value, k) => {
        const [gx, gy, gz] = parseKey(k);
        data[`${gx},${gy},${gz}`] = value.color;
    });

    const settings = {
        gridSize: GRID,
        cameraPosition: cam.position.toArray(),
        cameraQuaternion: cam.quaternion.toArray(),
        activeDrawingLevel: activeDrawingLevel,
        currentDrawingAxis: currentDrawingAxis,
        currentColor: currentColor,
        presetColors: presetColors,
        activePresetIndex: activePresetIndex,
        moveSpeed: moveSpeed,
        templateImageData: templateImageData
    };

    const fileContent = {
        title: projectTitle,
        description: projectDescription,
        category: projectCategory,
        tags: projectTags,
        remixOf: projectRemixOf,
        sourceJsonUrl: projectSourceJsonUrl,
        visibility: projectVisibility,
        fileName: `${projectTitle.replace(/\s+/g, "_") || "voxel_project"}.json`,
        timestamp: new Date().toISOString(),

        projectData: {
            settings: settings,
            voxels: data
        }
    };

    const blob = new Blob([JSON.stringify(fileContent, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = fileContent.fileName;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    showToast('Speichern erfolgreich', 'Projekt als JSON-Datei gespeichert.', 'success', 5000);
}

// Setzt das Projekt auf den Standardzustand zurück
function resetToDefaultProject() {
    clearAllInternal(true); GRID = 10;
    document.getElementById('grid-size-slider').value = GRID; document.getElementById('grid-size-display').textContent = `${GRID}×${GRID}×${GRID}`; localStorage.setItem('voxelEditorGridSize', GRID);
    currentColor = '#ffffff'; document.getElementById('color-picker').value = currentColor; localStorage.setItem('voxelEditorColor', currentColor);
    const mobileColorInput = document.getElementById('mobile-color-input');
    if (mobileColorInput) mobileColorInput.value = currentColor;

    activeDrawingLevel = { x: 0, y: 0, z: 0 }; currentDrawingAxis = 'y';
    localStorage.setItem('voxelEditorActiveDrawingLevelX', activeDrawingLevel.x);
    localStorage.setItem('voxelEditorActiveDrawingLevelY', activeDrawingLevel.y);
    localStorage.setItem('voxelEditorActiveDrawingLevelZ', activeDrawingLevel.z);
    localStorage.setItem('voxelEditorCurrentDrawingAxis', currentDrawingAxis);
    moveSpeed = 0.1; document.getElementById('fly-speed-slider').value = moveSpeed; document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2); localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
    presetColors[0] = '#E4002B'; presetColors[1] = '#00A040'; presetColors[2] = '#0057B8';
    localStorage.setItem('voxelPresetColor1', presetColors[0]); localStorage.setItem('voxelPresetColor2', presetColors[1]); localStorage.setItem('voxelPresetColor3', presetColors[2]);
    presetBoxes.forEach((box, i) => { box.value = presetColors[i]; box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'); });
    activePresetIndex = -1; removeImageTemplate(true); // removeTemplate() wurde entfernt
    history.length = 0; historyPointer = -1;
    previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
    projectTitle = ''; projectDescription = ''; projectCategory = 'Allgemein'; projectTags = []; projectRemixOf = ''; projectSourceJsonUrl = ''; projectVisibility = 'public';
    rebuildHelpers(); resetCameraPosition(); showToast('Projekt zurückgesetzt', 'Das Projekt wurde auf den Standardzustand zurückgesetzt.', 'info', 5000);
}

// Lädt Projektdaten aus einem übergebenen Objekt
function loadProjectData(projectData) {
    try {
        const loadedVoxels = projectData.projectData ? projectData.projectData.voxels : projectData.voxels;
        const loadedSettings = projectData.projectData ? projectData.projectData.settings : projectData.settings;
        clearAllInternal(true); removeImageTemplate(true); // removeTemplate() wurde entfernt

        // Setzt Projektmetadaten
        projectTitle = projectData.title || ''; projectDescription = projectData.description || '';
        projectCategory = projectData.category || 'Allgemein';
        projectTags = Array.isArray(projectData.tags) ? projectData.tags : (typeof projectData.tags === 'string' ? projectData.tags.split(',').map(tag => tag.trim()).filter(tag => tag !== '') : []);
        projectRemixOf = projectData.remixOf || ''; projectSourceJsonUrl = projectData.sourceJsonUrl || ''; projectVisibility = projectData.visibility || 'public';

        if (loadedSettings) {
            GRID = loadedSettings.gridSize !== undefined ? loadedSettings.gridSize : 10;
            document.getElementById('grid-size-slider').value = GRID; document.getElementById('grid-size-display').textContent = `${GRID}×${GRID}×${GRID}`; localStorage.setItem('voxelEditorGridSize', GRID);
        }
        // Lädt Voxel
        for (const k in loadedVoxels) {
            const colorValue = loadedVoxels[k]; const parts = k.split(',').map(Number);
            if (parts.length === 3 && !isNaN(parts[0]) && !isNaN(parts[1]) && !isNaN(parts[2])) {
                const gx = parts[0]; const gy = parts[1]; const gz = parts[2];
                if (gx >= 0 && gx < GRID && gy >= 0 && gy < GRID && gz >= 0 && gz < GRID) _addSingleVoxel(gx, gy, gz, colorValue);
            }
        }
        if (loadedSettings) {
            // Lädt Kamera-Position und -Rotation
            if (loadedSettings.cameraPosition) cam.position.fromArray(loadedSettings.cameraPosition);
            if (loadedSettings.cameraQuaternion) { cam.quaternion.fromArray(loadedSettings.cameraQuaternion); euler.setFromQuaternion(cam.quaternion, 'YXZ'); }
            if (loadedSettings.activeDrawingLevel) {
                activeDrawingLevel = {
                    x: Number(loadedSettings.activeDrawingLevel.x || 0),
                    y: Number(loadedSettings.activeDrawingLevel.y || 0),
                    z: Number(loadedSettings.activeDrawingLevel.z || 0)
                };
                if (!Number.isFinite(activeDrawingLevel.x)) activeDrawingLevel.x = 0;
                if (!Number.isFinite(activeDrawingLevel.y)) activeDrawingLevel.y = 0;
                if (!Number.isFinite(activeDrawingLevel.z)) activeDrawingLevel.z = 0;

                activeDrawingLevel.x = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.x)));
                activeDrawingLevel.y = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.y)));
                activeDrawingLevel.z = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.z)));

                localStorage.setItem('voxelEditorActiveDrawingLevelX', activeDrawingLevel.x);
                localStorage.setItem('voxelEditorActiveDrawingLevelY', activeDrawingLevel.y);
                localStorage.setItem('voxelEditorActiveDrawingLevelZ', activeDrawingLevel.z);
            }
            if (loadedSettings.currentDrawingAxis) { currentDrawingAxis = loadedSettings.currentDrawingAxis; localStorage.setItem('voxelEditorCurrentDrawingAxis', currentDrawingAxis); }
            updateGridHelperPosition();
            currentColor = loadedSettings.currentColor || '#ffffff'; document.getElementById('color-picker').value = currentColor;
            const mobileColorInput = document.getElementById('mobile-color-input');
            if (mobileColorInput) mobileColorInput.value = currentColor;

            if (loadedSettings.presetColors) {
                for(let i = 0; i < loadedSettings.presetColors.length && i < presetColors.length; i++) {
                    presetColors[i] = loadedSettings.presetColors[i]; document.getElementById(`color-preset-${i + 1}`).value = presetColors[i]; localStorage.setItem(`voxelPresetColor${i + 1}`, presetColors[i]);
                }
            }
            setActivePreset(loadedSettings.activePresetIndex !== undefined ? loadedSettings.activePresetIndex : -1);
            if (loadedSettings.moveSpeed !== undefined) {
                moveSpeed = loadedSettings.moveSpeed; document.getElementById('fly-speed-slider').value = moveSpeed; document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2); localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
            }
            if (loadedSettings.templateImageData) {
                templateImageData = loadedSettings.templateImageData;
                new THREE.TextureLoader().load(templateImageData.src, (texture) => {
                    const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true, depthWrite: false });
                    const geometry = new THREE.PlaneGeometry(templateImageData.scaledWidth, templateImageData.scaledHeight);
                    if (templateImageMesh) { scene.remove(templateImageMesh); templateImageMesh.geometry.dispose(); templateImageMesh.material.dispose(); }
                    templateImageMesh = new THREE.Mesh(geometry, material);
                    templateImageMesh.position.fromArray(templateImageData.position); templateImageMesh.rotation.fromArray(templateImageData.rotation); templateImageMesh.scale.fromArray(templateImageData.scale);
                    templateImageMesh.renderOrder = -1; scene.add(templateImageMesh);
                    document.getElementById('removeImageTemplateBtn').classList.remove('hidden');
                }, undefined, (err) => { templateImageMesh = null; templateImageData = null; document.getElementById('removeImageTemplateBtn').classList.add('hidden'); });
            }
        }
        history.length = 0; historyPointer = -1;
        previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
        resetCameraPosition();
    } catch (error) {
        showToast('Fehler', 'Fehler beim Laden der Datei. Stellen Sie sicher, dass es sich um eine gültige JSON-Datei handelt. Fehler: ' + error.message, 'error', 5000);
        resetToDefaultProject();
    }
}

// ENTFERNT: loadProjectFromModelId (nicht mehr relevant ohne Hub-Anbindung in UI)
/*
async function loadProjectFromModelId(modelId) { ... }
*/

// Lädt ein Projekt aus einer lokalen JSON-Datei
function loadJSON(event) {
    const file = event.target.files[0]; if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const projectData = JSON.parse(e.target.result);
            projectRemixOf = ''; projectSourceJsonUrl = ''; loadProjectData(projectData);
        } catch (error) {
            showToast('Fehler', 'Fehler beim Parsen der Datei. Stellen Sie sicher, dass es sich um eine gültige JSON-Datei handelt. Fehler: ' + error.message, 'error', 5000);
            resetToDefaultProject();
        }
    };
    reader.readAsText(file);
}

// Exportiert das Modell als STL-Datei
async function exportSTL() {
    if (voxels.size === 0) { showToast('Export fehlgeschlagen', 'Keine Voxel zum Exportieren vorhanden!', 'warning', 5000); return; }
    showToast('Exportiere STL', 'Erzeuge STL-Modell...', 'info', 5000);
    const geometriesToMerge = []; const tempBoxGeometry = new THREE.BoxGeometry(VS, VS, VS);
    voxels.forEach((data, k) => {
        const [x, y, z] = parseKey(k);
        dummy.position.set(x * VS + HALF, y * VS + HALF, z * VS + HALF); dummy.updateMatrix();
        const instanceGeometry = tempBoxGeometry.clone(); instanceGeometry.applyMatrix4(dummy.matrix);
        const c = new THREE.Color(data.color);
        const vtxColorArr = []; for (let j = 0; j < instanceGeometry.attributes.position.count; j++) vtxColorArr.push(c.r, c.g, c.b);
        instanceGeometry.setAttribute('color', new THREE.Float32BufferAttribute(vtxColorArr, 3));
        geometriesToMerge.push(instanceGeometry);
    });
    const mergedGeometry = geometriesToMerge.length > 0 ? THREE.BufferGeometryUtils.mergeBufferGeometries(geometriesToMerge, true) : new THREE.BufferGeometry();
    const tempMesh = new THREE.Mesh(mergedGeometry);
    if (typeof THREE.STLExporter === 'undefined') { showToast('Export fehlgeschlagen', 'STLExporter-Bibliothek nicht geladen.', 'error', 5000); return; }
    const exporter = new THREE.STLExporter(); const result = exporter.parse(tempMesh);
    const blob = new Blob([result], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'voxel_model.stl';
    document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
    tempBoxGeometry.dispose(); if (mergedGeometry) mergedGeometry.dispose();
    showToast('Export erfolgreich', 'STL-Modell erfolgreich exportiert!', 'success', 5000);
}

// Zeigt eine Toast-Benachrichtigung an
function showToast(title, message, type = 'info', duration = 5000) {
    const toast = document.createElement('div');
    toast.className = `alert shadow-lg ${type === 'info' ? 'alert-info' : type === 'success' ? 'alert-success' : type === 'error' ? 'alert-error' : type === 'warning' ? 'alert-warning' : ''}`;
    toast.innerHTML = `
        ${type === 'info' ? '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" class="stroke-current shrink-0 h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>' : ''}
        ${type === 'success' ? '<svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>' : ''}
        ${type === 'error' ? '<svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>' : ''}
        ${type === 'warning' ? '<svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>' : ''}
        <div><strong>${title}</strong><br><span>${message}</span></div><button class="close-btn btn btn-ghost btn-sm">&times;</button>`;
    toastContainer.appendChild(toast);
    void toast.offsetWidth; toast.classList.add('show');
    toast.querySelector('.close-btn').addEventListener('click', () => { toast.classList.remove('show'); toast.addEventListener('transitionend', () => toast.remove(), { once: true }); });
    setTimeout(() => { if (toast.parentNode) { toast.classList.remove('show'); toast.addEventListener('transitionend', () => toast.remove(), { once: true }); } }, duration);
}

// Setzt die Kamera auf die Standardposition zurück
function resetCameraPosition() {
    cam.position.set(GRID * 1.0, GRID * 1.2, GRID * 1.5); cam.lookAt(GRID / 2, GRID / 2, GRID / 2);
    if (euler) euler.setFromQuaternion(cam.quaternion, 'YXZ');
}

// Lädt eine Bildvorlage
function loadImageTemplate() {
    document.getElementById('imageFileInput').click();
}

// Handler für die Auswahl einer Bilddatei als Vorlage
function handleImageFileSelect(event) {
    const file = event.target.files[0];
    if (!file) {
        return;
    }
    const reader = new FileReader();
    reader.onload = (e) => {
        const base64Image = e.target.result;
        const img = new Image();
        img.onload = () => {
            const aspectRatio = img.width / img.height;
            const planeWidth = GRID * VS;
            const planeHeight = planeWidth / aspectRatio;

            if (templateImageMesh) {
                scene.remove(templateImageMesh);
                templateImageMesh.geometry.dispose();
                templateImageMesh.material.dispose();
            }

            const texture = new THREE.TextureLoader().load(base64Image);
            const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true, depthWrite: false });
            const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
            templateImageMesh = new THREE.Mesh(geometry, material);

            templateImageMesh.position.set((GRID * VS) / 2, (GRID * VS) / 2, -0.001);
            templateImageMesh.rotation.set(0, 0, 0);

            templateImageMesh.renderOrder = -1; scene.add(templateImageMesh);
            templateImageData = {
                src: base64Image,
                position: templateImageMesh.position.toArray(),
                rotation: templateImageMesh.rotation.toArray(),
                scale: [1, 1, 1],
                scaledWidth: planeWidth,
                scaledHeight: planeHeight
            };
            document.getElementById('removeImageTemplateBtn').classList.remove('hidden');
            showToast('Bildvorlage geladen', 'Bild als Vorlage erfolgreich geladen.', 'success', 5000);
        };
        img.onerror = (err) => {
            showToast('Fehler', 'Bild konnte nicht geladen werden. Ungültiges Bildformat?', 'error', 5000);
            templateImageMesh = null;
            templateImageData = null;
            document.getElementById('removeImageTemplateBtn').classList.add('hidden');
        };
        img.src = base64Image;
    };
    reader.onerror = (err) => {
        showToast('Fehler', 'Fehler beim Lesen der Bilddatei.', 'error', 5000);
    };
    reader.readAsDataURL(file);

    event.target.value = '';
}
// Entfernt die aktuelle Bildvorlage
function removeImageTemplate(fromLoad = false) {
    if (templateImageMesh) {
        scene.remove(templateImageMesh); templateImageMesh.geometry.dispose(); templateImageMesh.material.dispose();
        templateImageMesh = null; templateImageData = null; document.getElementById('removeImageTemplateBtn').classList.add('hidden');
        if (!fromLoad) showToast('Bildvorlage entfernt', 'Bildvorlage erfolgreich entfernt.', 'info', 5000);
    }
}

function getCurrentBlockDimensions() {
    return { dimX: 1, dimY: 1, dimZ: 1 };
}

// ENTFERNT: loginLogout (da Firebase-Login-UI entfernt)
/*
async function loginLogout() { ... }
*/

// ENTFERNT: uploadProjectToHub (da Upload-UI entfernt)
/*
async function uploadProjectToHub() { ... }
*/

// Schließt alle Modals (Liste angepasst, nur noch clearConfirmationModal)
function closeAllModals() {
    const modals = ['clearConfirmationModal']; 
    modals.forEach(id => { const modal = document.getElementById(id); if (modal && modal.open) modal.close(); });
}
window.closeAllModals = closeAllModals;

// Handler für Pointer-Lock-Änderungen
function onPointerLockChange() {
    if (document.pointerLockElement === cvs) { isPointerLocked = true; firstMoveAfterLock = true; mouseMovementX = mouseMovementY = 0; updatePreviewVoxel(0,0,0,false); euler.setFromQuaternion(cam.quaternion, 'YXZ'); }
    else { isPointerLocked = false; }
}

// Handler für Mausrad-Ereignisse
function onMouseWheel(e) {
    e.preventDefault();
    if (e.altKey) { // Wenn ALT-Taste gedrückt ist, steuert das Mausrad die Zeichenebene
        if (!isMobile && (currentMode === Modes.ADD || currentMode === Modes.DRAW)) {
            if (e.shiftKey) { activeDrawingLevel.z = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.z - Math.sign(e.deltaY))); currentDrawingAxis = 'z'; }
            else if (e.ctrlKey) { activeDrawingLevel.x = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.x - Math.sign(e.deltaY))); currentDrawingAxis = 'x'; }
            else { activeDrawingLevel.y = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.y - Math.sign(e.deltaY))); currentDrawingAxis = 'y'; }
            updateGridHelperPosition();
        } else { // Ansonsten, wenn kein Zeichenmodus oder Mobilgerät, zoomt die Kamera
            cam.position.addScaledVector(cam.getWorldDirection(new THREE.Vector3()), e.deltaY * 0.005 * moveSpeed * 5);
        }
    } else { // Wenn ALT-Taste nicht gedrückt ist, steuert das Mausrad die Fluggeschwindigkeit
        moveSpeed = Math.max(0.01, Math.min(1.0, moveSpeed - Math.sign(e.deltaY) * 0.01));
        document.getElementById('fly-speed-slider').value = moveSpeed; document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2); localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
    }
}

const keyboard = {}; // Speichert den Zustand der Tastaturtasten
// Handler für Tastendruck (Key Down)
function onKeyDown(e) {
    // Wenn ein Modal geöffnet ist, nur Escape-Taste zur Schließung erlauben
    const activeModals = ['clearConfirmationModal'].some(id => document.getElementById(id).open);
    if (activeModals) { if (e.key === 'Escape') { closeAllModals(); e.preventDefault(); } return; }
    keyboard[e.key.toLowerCase()] = true; // Setzt die Taste auf gedrückt
    if (e.key === 'Shift') isShiftDragging = true;
    if (e.key === 'Control' || e.metaKey) isControlDragging = true;
    if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); } // Undo mit Ctrl/Cmd + Z
    if (((e.ctrlKey || e.metaKey) && e.key === 'y') || ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'Z')) { e.preventDefault(); redo(); } // Redo mit Ctrl/Cmd + Y oder Ctrl/Cmd + Shift + Z
    if ((e.ctrlKey || e.metaKey) && e.key === 'd') e.preventDefault(); // Verhindert das Duplizieren von Tabs/Fenstern mit Ctrl/Cmd + D
    if (e.key === 'Tab') { e.preventDefault(); cycleMode(); } // Wechselt den Modus mit Tab
    // Aktiviert voreingestellte Farben mit den Tasten 1, 2, 3
    switch (e.key) { case '1': setActivePreset(0); break; case '2': setActivePreset(1); break; case '3': setActivePreset(2); break; }
}

// Handler für Tastenfreigabe (Key Up)
function onKeyUp(e) {
    keyboard[e.key.toLowerCase()] = false; // Setzt die Taste auf nicht gedrückt
    if (e.key === 'Shift') isShiftDragging = false;
    if (e.key === 'Control' || e.metaKey) isControlDragging = false;
}

// Handler, wenn der Pointer das Canvas verlässt
function onPointerLeave(e) {
    // Wenn ein Dragging aktiv ist und Voxel im aktuellen Strich sind, füge einen Batch-Befehl zur Historie hinzu
    if (pointerIsDown && isDragging && currentStrokeVoxels.size > 0) { // isDragging als generischer Drag-Indikator
        const oldState = [];
        const newState = [];
        for (const [gKey, change] of currentStrokeVoxels.entries()) {
            const [gx, gy, gz] = parseKey(gKey);
            oldState.push({ gx, gy, gz, color: change.originalColor });
            newState.push({ gx, gy, gz, color: change.finalColor });
        }
        if (oldState.length > 0) {
            addCommand('batch', oldState, newState);
        }
    }
    // Setzt alle Dragging- und Pointer-bezogenen Zustände zurück
    pointerIsDown = false; // Für Maus
    isDragging = false; // Generischer Drag-Flag
    isDraggingForVoxelAction = false; // Spezifischer Voxel-Drag-Flag zurücksetzen
    isSingleTouchCameraRotating = false; // Kamerarotations-Flag zurücksetzen

    doubleTapDragActive = false;
    lastActionVoxelCoords = null;
    initialClickPos = null;
    initialRayHitCoords = null;
    voxelsAtDragStart = null;
    currentStrokeVoxels.clear();
    updatePreviewVoxel(0, 0, 0, false); // Vorschau-Voxel ausblenden
    previewLineInstancedMesh.count = 0; // Vorschau-Linie ausblenden
    previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
    previewLineVoxels = [];
    dragAxisLock = null;
    initialDragVoxelCoords = null;
    initialDragYLevel = null; // Reset Y-level lock on leave
}

let pointerIsDown = false; // Ob ein Pointer gedrückt ist (Maus oder Touch)
let rightMouseButtonDown = false; // Ob die rechte Maustaste gedrückt ist
let lastX, lastY; // Letzte X/Y-Koordinaten des Pointers

// Berechnet alle Voxel, die auf einer Linie zwischen zwei Punkten liegen (Bresenham-ähnlich)
function getVoxelsOnLine(start, end) {
    if (!start || !Number.isFinite(start.gx) || !Number.isFinite(start.gy) || !Number.isFinite(start.gz) ||
        !end || !Number.isFinite(end.gx) || !Number.isFinite(end.gy) || !Number.isFinite(end.gz)) {
        return [];
    }
    const voxelsOnLine = [];
    let x1 = start.gx, y1 = start.gy, z1 = start.gz;
    let x2 = end.gx, y2 = end.gy, z2 = end.gz;
    let dx = Math.abs(x2 - x1), dy = Math.abs(y2 - y1), dz = Math.abs(z2 - z1);
    let sx = (x1 < x2) ? 1 : -1, sy = (y1 < y2) ? 1 : -1, sz = (z1 < z2) ? 1 : -1;
    let dm = Math.max(dx, dy, dz); // Längste Achse
    let x = x1, y = y1, z = z1;
    let p1 = 2 * dy - dm, p2 = 2 * dz - dm;

    for (let i = 0; i <= dm; i++) {
        // Stellt sicher, dass die Voxel innerhalb des Rasters bleiben
        const clampedX = Math.max(0, Math.min(GRID - 1, x));
        const clampedY = Math.max(0, Math.min(GRID - 1, y));
        const clampedZ = Math.max(0, Math.min(GRID - 1, z));
        voxelsOnLine.push({ gx: clampedX, gy: clampedY, gz: clampedZ });
        
        // Schritt-Logik für 3D-Bresenham
        if (dm === dx) { y += sy * (p1 > 0); p1 += 2 * dy; z += sz * (p2 > 0); p2 += 2 * dz; }
        else if (dm === dy) { x += sx * (p1 > 0); p1 += 2 * dx; z += sz * (p2 > 0); p2 += 2 * dz; }
        else { x += sx * (p1 > 0); p1 += 2 * dy; y += sy * (p2 > 0); p2 += 2 * dx; }
        if (dm === dx) x += sx; else if (dm === dy) y += sy; else z += sz;
    }
    return voxelsOnLine;
}

// Handler für Pointer Up (Maustaste oder Touch freigegeben)
function onPointerUp(e) {
    if (e.button === 2) { // Rechte Maustaste
        rightMouseButtonDown = false;
        document.exitPointerLock(); // Pointer-Lock beenden
        return;
    }
    
    // Berechnet die insgesamt zurückgelegte Distanz (für Tap-Erkennung)
    const totalMovedDist = initialClickPos ? Math.hypot(e.clientX - initialClickPos.x, e.clientY - initialClickPos.y) : 0;

    if (e.pointerType === 'touch') {
        releasePointer(e.pointerId, e); // Pointer für Touch-Ereignisse freigeben

        if (isSingleTouchCameraRotating) {
            isSingleTouchCameraRotating = false; // Kamerarotation beendet
            // Keine Voxel-Aktion, da es Kamerasteuerung war
            return;
        }

        if (isDraggingForVoxelAction) { // Es war ein Touch-Voxel-Drag
            if (currentStrokeVoxels.size > 0) {
                const oldState = [];
                const newState = [];
                for (const [gKey, change] of currentStrokeVoxels.entries()) {
                    const [gx, gy, gz] = parseKey(gKey);
                    oldState.push({ gx, gy, gz, color: change.originalColor });
                    newState.push({ gx, gy, gz, color: change.finalColor });
                }
                if (oldState.length > 0) {
                    addCommand('batch', oldState, newState);
                }
            }
        } else { // Es war ein Einzel-Touch, der weder Kamerarotation noch Voxel-Drag war -> Tap
            if (initialRayHitCoords && performance.now() - gestureState.startTime < DT_MS && totalMovedDist < TAP_DIST_TH) {
                // Führe Einzel-Voxel-Modifikation aus (Tap-Aktion)
                let finalVoxelCoords = { ...initialRayHitCoords };

                if (currentMode === Modes.ADD) {
                    if (initialRayHitCoords.hitTemplate) {
                        // Bei Treffer auf Vorlage, Aktion auf Vorlage (Voxel-Position der Vorlage)
                    } else if (initialRayHitCoords.faceNormal) {
                        // Voxel an der Seite des getroffenen Voxels hinzufügen
                        finalVoxelCoords.gx += initialRayHitCoords.faceNormal.x;
                        finalVoxelCoords.gy += initialRayHitCoords.faceNormal.y;
                        finalVoxelCoords.gz += initialRayHitCoords.faceNormal.z;
                    }
                }
                // Für DELETE/DRAW bleibt finalVoxelCoords die Position des getroffenen Voxels

                finalVoxelCoords.gx = Math.max(0, Math.min(GRID - 1, finalVoxelCoords.gx));
                finalVoxelCoords.gy = Math.max(0, Math.min(GRID - 1, finalVoxelCoords.gy));
                finalVoxelCoords.gz = Math.max(0, Math.min(GRID - 1, finalVoxelCoords.gz));

                const gKey = key(finalVoxelCoords.gx, finalVoxelCoords.gy, finalVoxelCoords.gz);
                const initialColor = voxelsAtDragStart.has(gKey) ? voxelsAtDragStart.get(gKey).color : null;
                
                performVoxelModification(finalVoxelCoords.gx, finalVoxelCoords.gy, finalVoxelCoords.gz, currentMode, currentColor);
                
                const newColor = voxels.has(gKey) ? voxels.get(gKey).color : null;
                if (initialColor !== newColor || (currentMode === Modes.ADD && initialColor === null && newColor !== null)) {
                    addCommand('batch', [{ gx: finalVoxelCoords.gx, gy: finalVoxelCoords.gy, gz: finalVoxelCoords.gz, color: initialColor }], [{ gx: finalVoxelCoords.gx, gy: finalVoxelCoords.gy, gz: finalVoxelCoords.gz, color: newColor }]);
                }
            }
        }
    } else { // Maus-Ereignis
        const wasDrag = totalMovedDist > MOVE_PX; // War es ein Maus-Drag?
        if (wasDrag) {
            if (currentStrokeVoxels.size > 0) {
                const oldState = [];
                const newState = [];
                for (const [gKey, change] of currentStrokeVoxels.entries()) {
                    const [gx, gy, gz] = parseKey(gKey);
                    oldState.push({ gx, gy, gz, color: change.originalColor });
                    newState.push({ gx, gy, gz, color: change.finalColor });
                }
                if (oldState.length > 0) {
                    addCommand('batch', oldState, newState);
                }
            }
        } else { // Maus-Klick (kein Drag)
            if (initialRayHitCoords) {
                let finalVoxelCoords = { ...initialRayHitCoords };
                if (currentMode === Modes.ADD) {
                    if (initialRayHitCoords.hitTemplate) {
                        // Aktion auf Vorlage
                    } else if (initialRayHitCoords.faceNormal) {
                        finalVoxelCoords.gx += initialRayHitCoords.faceNormal.x;
                        finalVoxelCoords.gy += initialRayHitCoords.faceNormal.y;
                        finalVoxelCoords.gz += initialRayHitCoords.faceNormal.z;
                    }
                }
                finalVoxelCoords.gx = Math.max(0, Math.min(GRID - 1, finalVoxelCoords.gx));
                finalVoxelCoords.gy = Math.max(0, Math.min(GRID - 1, finalVoxelCoords.gy));
                finalVoxelCoords.gz = Math.max(0, Math.min(GRID - 1, finalVoxelCoords.gz));

                const gKey = key(finalVoxelCoords.gx, finalVoxelCoords.gy, finalVoxelCoords.gz);
                const initialColor = voxelsAtDragStart.has(gKey) ? voxelsAtDragStart.get(gKey).color : null;
                performVoxelModification(finalVoxelCoords.gx, finalVoxelCoords.gy, finalVoxelCoords.gz, currentMode, currentColor);
                const newColor = voxels.has(gKey) ? voxels.get(gKey).color : null;
                if (initialColor !== newColor || (currentMode === Modes.ADD && initialColor === null && newColor !== null)) {
                    addCommand('batch', [{ gx: finalVoxelCoords.gx, gy: finalVoxelCoords.gy, gz: finalVoxelCoords.gz, color: initialColor }], [{ gx: finalVoxelCoords.gx, gy: finalVoxelCoords.gy, gz: finalVoxelCoords.gz, color: newColor }]);
                }
            }
        }
    }

    // Globale Reset-Flags nach jeder Pointer-Up-Aktion
    pointerIsDown = false;
    isDragging = false; // Generischer Drag-Flag
    isDraggingForVoxelAction = false;
    isSingleTouchCameraRotating = false;

    doubleTapDragActive = false;
    lastActionVoxelCoords = null;
    initialClickPos = null;
    initialRayHitCoords = null;
    voxelsAtDragStart = null;
    currentStrokeVoxels.clear();
    updatePreviewVoxel(0, 0, 0, false);
    previewLineInstancedMesh.count = 0; 
    previewLineInstancedMesh.instanceMatrix.needsUpdate = true; 
    previewLineVoxels = [];
    dragAxisLock = null;
    initialDragVoxelCoords = null;
    initialDragYLevel = null;
}


// Handler für Pointer Down (Maustaste oder Touch gedrückt)
function onPointerDown(e) {
    if (e.button === 2) { // Rechte Maustaste
        e.preventDefault();
        rightMouseButtonDown = true;
        cvs.focus();
        cvs.requestPointerLock(); // Pointer-Lock anfordern
        return;
    }
    if (isPointerLocked) return; // Keine Interaktion, wenn der Pointer gesperrt ist

    // Farbauswahl mit ALT-Taste
    if (e.button === 0 && e.altKey) { 
        const hitResult = calculateRayTargetVoxelCoords(e.clientX, e.clientY);
        if (hitResult && hitResult.hitExistingVoxel) { // Wenn ein existierender Voxel getroffen wird
            const gKey = key(hitResult.gx, hitResult.gy, hitResult.gz);
            if (voxels.has(gKey)) {
                const pickedColor = voxels.get(gKey).color; // Farbe des Voxels aufnehmen
                currentColor = pickedColor;
                document.getElementById('color-picker').value = pickedColor;
                const mobileColorInput = document.getElementById('mobile-color-input');
                if (mobileColorInput) mobileColorInput.value = pickedColor;
                localStorage.setItem('voxelEditorColor', pickedColor);
                presetBoxes.forEach(box => box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50')); activePresetIndex = -1;
                showToast('Farbe aufgenommen', `Farbe: ${pickedColor}`, 'info', 2000);
            }
        }
        return; 
    }

    // Robusteres Touch-Handling
    if (e.pointerType === 'touch') {
        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY, pointerType: e.pointerType });
        
        // Flags für neue Geste zurücksetzen
        isDraggingForVoxelAction = false;
        isSingleTouchCameraRotating = false;

        if (activePointers.size === 1) { // Erster Finger
            gestureState.type = 'none'; // Initialisiere Geste als "keine"
            gestureState.startMid = gestureState.lastMid = { x: e.clientX, y: e.clientY };
            gestureState.startTime = performance.now(); // Starte Zeit für Tap-Erkennung
            
            // Initialer Raycast für Tap/Drag Ziel. InitialRayHitCoords wird verwendet, wenn es ein Tap wird
            initialRayHitCoords = calculateRayTargetVoxelCoords(e.clientX, e.clientY);

        } else if (activePointers.size > 1) { // Multi-Touch (Geste für Pan/Zoom)
            initialRayHitCoords = null; // Kein Einzel-Voxel-Ziel bei Multi-Touch
            currentStrokeVoxels.clear();
            previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
            updatePreviewVoxel(0, 0, 0, false);
            doubleTapDragActive = false;
            isDragging = false; 
            initialDragVoxelCoords = null;
            initialDragYLevel = null; 

            const pointersArr = [...activePointers.values()];
            const [p0, p1] = pointersArr;
            const midX = (p0.x + p1.x) * 0.5; const midY = (p0.y + p1.y) * 0.5; const dist = Math.hypot(p1.x - p0.x, p1.y - p0.y);
            gestureState.type = 'none'; gestureState.startMid = gestureState.lastMid = { x: midX, y: midY };
            gestureState.startDist = gestureState.lastDist = dist;
            gestureState.initialPointerCount = activePointers.size;
        }
        voxelsAtDragStart = new Map(voxels); // Zustand für Undo/Redo festhalten
        currentStrokeVoxels.clear(); // Leeren des aktuellen Strichs
        return; // Beende, weitere Logik wird in onPointerMove oder onPointerUp behandelt
    }

    // Vorhandene Logik für Mausklick (linke Maustaste)
    voxelsAtDragStart = new Map(voxels); // Speichert den Voxel-Zustand zu Beginn des Drags
    currentStrokeVoxels.clear(); // Leert den aktuellen Zeichenstrich
    dragAxisLock = null;
    isDragging = false; // Wird auf true gesetzt, wenn sich ein Drag entwickelt
    initialDragVoxelCoords = null; // Wird beim Drag-Start gesetzt
    initialDragYLevel = null; // Initialisiert Y-Ebenen-Sperre für Drag

    initialClickPos = { x: e.clientX, y: e.clientY }; // Speichert die Startposition des Klicks
    pointerIsDown = true; // Für die Maus wird der Pointer sofort als gedrückt betrachtet

    // Berechnet die Voxelkoordinaten am Start des Klicks (roher Treffer)
    initialRayHitCoords = calculateRayTargetVoxelCoords(e.clientX, e.clientY);
    if (!initialRayHitCoords || !Number.isFinite(initialRayHitCoords.gx) || !Number.isFinite(initialRayHitCoords.gy) || !Number.isFinite(initialRayHitCoords.gz)) {
        pointerIsDown = false; initialClickPos = null; initialRayHitCoords = null;
        return;
    }
}

// Handler für Pointer Move (Maus oder Touch bewegt)
function onPointerMove(e) {
    e.preventDefault();
    if (isPointerLocked) return;

    if (e.pointerType === 'touch' && activePointers.has(e.pointerId)) {
        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY, pointerType: e.pointerType });

        if (activePointers.size === 1) { // Einzel-Touch
            const currentMovedDist = Math.hypot(e.clientX - gestureState.startMid.x, e.clientY - gestureState.startMid.y);
            
            if (!isSingleTouchCameraRotating && !isDraggingForVoxelAction) { // Wenn noch keine Geste festgelegt ist
                if (currentMovedDist > MOVE_PX) { // Bewegungsschwelle überschritten
                    if (currentMode === Modes.ADD || currentMode === Modes.DELETE || currentMode === Modes.DRAW) {
                        isDraggingForVoxelAction = true; // Starte Voxel-Drag
                        isDragging = true; // Generischen Drag-Flag setzen
                        // Initialen Voxel im Strich setzen
                        if (initialRayHitCoords) {
                            let firstActionCoords = { ...initialRayHitCoords };
                            if (currentMode === Modes.ADD && initialRayHitCoords.faceNormal && !initialRayHitCoords.hitTemplate) {
                                firstActionCoords.gx += initialRayHitCoords.faceNormal.x;
                                firstActionCoords.gy += initialRayHitCoords.faceNormal.y;
                                firstActionCoords.gz += initialRayHitCoords.faceNormal.z;
                            }
                            firstActionCoords.gx = Math.max(0, Math.min(GRID - 1, firstActionCoords.gx));
                            firstActionCoords.gy = Math.max(0, Math.min(GRID - 1, firstActionCoords.gy));
                            firstActionCoords.gz = Math.max(0, Math.min(GRID - 1, firstActionCoords.gz));

                            initialDragVoxelCoords = { ...firstActionCoords };
                            lastActionVoxelCoords = { ...firstActionCoords };

                            if (currentMode === Modes.DRAW) {
                                initialDragYLevel = initialDragVoxelCoords.gy;
                            }

                            const gKey = key(firstActionCoords.gx, firstActionCoords.gy, firstActionCoords.gz);
                            const initialColor = voxelsAtDragStart.has(gKey) ? voxelsAtDragStart.get(gKey).color : null;
                            performVoxelModification(firstActionCoords.gx, firstActionCoords.gy, firstActionCoords.gz, currentMode, currentColor);
                            const finalColor = voxels.has(gKey) ? voxels.get(gKey).color : null;
                            currentStrokeVoxels.set(gKey, { originalColor: initialColor, finalColor: finalColor });
                        }
                    } else {
                        isSingleTouchCameraRotating = true; // Starte Kamerarotation
                    }
                }
            }

            if (isSingleTouchCameraRotating) {
                handleGesture(); // Kamerarotation ausführen
                updatePreviewVoxel(0, 0, 0, false); // Vorschau ausblenden
                previewLineInstancedMesh.count = 0;
                previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
                previewLineVoxels = [];
                return; // Beende, um Voxel-Logik zu überspringen
            }
        } else if (activePointers.size > 1) { // Multi-Touch (Pan/Zoom)
            isDraggingForVoxelAction = false;
            isSingleTouchCameraRotating = false;
            isDragging = false; // Generischen Drag-Flag zurücksetzen

            handleGesture(); // Pan/Zoom ausführen
            updatePreviewVoxel(0, 0, 0, false); // Vorschau ausblenden
            previewLineInstancedMesh.count = 0;
            previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
            previewLineVoxels = [];
            return; // Beende, um Voxel-Logik zu überspringen
        }
    }

    lastX = e.clientX;
    lastY = e.clientY;

    const currentMovedDist = initialClickPos ? Math.hypot(e.clientX - initialClickPos.x, e.clientY - initialClickPos.y) : 0;
    const shouldStartDrag = pointerIsDown && (currentMovedDist > MOVE_PX);

    // Initialisiere isDragging für Maus-Ereignisse, wenn die Schwelle überschritten wird
    if (e.pointerType === 'mouse' && !isDragging && shouldStartDrag) {
        isDragging = true;
        // Für Maus: Initialen Voxel im Strich setzen, wenn Drag beginnt
        if (initialRayHitCoords) {
            let firstActionCoords = { ...initialRayHitCoords };
            if (currentMode === Modes.ADD && initialRayHitCoords.faceNormal && !initialRayHitCoords.hitTemplate) {
                firstActionCoords.gx += initialRayHitCoords.faceNormal.x;
                firstActionCoords.gy += initialRayHitCoords.faceNormal.y;
                firstActionCoords.gz += initialRayHitCoords.faceNormal.z;
            }
            firstActionCoords.gx = Math.max(0, Math.min(GRID - 1, firstActionCoords.gx));
            firstActionCoords.gy = Math.max(0, Math.min(GRID - 1, firstActionCoords.gy));
            firstActionCoords.gz = Math.max(0, Math.min(GRID - 1, firstActionCoords.gz));

            initialDragVoxelCoords = { ...firstActionCoords };
            lastActionVoxelCoords = { ...firstActionCoords };

            if (currentMode === Modes.DRAW) {
                initialDragYLevel = initialDragVoxelCoords.gy;
            }

            const gKey = key(firstActionCoords.gx, firstActionCoords.gy, firstActionCoords.gz);
            const initialColor = voxelsAtDragStart.has(gKey) ? voxelsAtDragStart.get(gKey).color : null;
            performVoxelModification(firstActionCoords.gx, firstActionCoords.gy, firstActionCoords.gz, currentMode, currentColor);
            const finalColor = voxels.has(gKey) ? voxels.get(gKey).color : null;
            currentStrokeVoxels.set(gKey, { originalColor: initialColor, finalColor: finalColor });
        }
    }

    let currentRayHit = calculateRayTargetVoxelCoords(
        e.clientX,
        e.clientY,
        (isDragging && e.pointerType === 'mouse') || isDraggingForVoxelAction ? currentStrokeVoxels : null, // Unterscheide Voxel-Drag-Typ
        ((isDragging && e.pointerType === 'mouse') || isDraggingForVoxelAction) && currentMode === Modes.DRAW ? initialDragYLevel : null
    ); 

    let targetForVoxelAction = null; 
    let voxelForPreview = null;     

    // Defensive Prüfung: Nur fortfahren, wenn currentRayHit gültig ist und seine Koordinaten Zahlen sind
    if (currentRayHit && 
        Number.isFinite(currentRayHit.gx) && 
        Number.isFinite(currentRayHit.gy) && 
        Number.isFinite(currentRayHit.gz)) 
    {
        // Bestimme targetForVoxelAction
        let gx_action = currentRayHit.gx;
        let gy_action = currentRayHit.gy;
        let gz_action = currentRayHit.gz;

        if (currentMode === Modes.ADD && currentRayHit.faceNormal && !currentRayHit.hitTemplate) {
            gx_action += currentRayHit.faceNormal.x;
            gy_action += currentRayHit.faceNormal.y;
            gz_action += currentRayHit.faceNormal.z;
        }
        if (((isDragging && e.pointerType === 'mouse') || isDraggingForVoxelAction) && currentMode === Modes.DRAW && initialDragYLevel !== null) {
            gy_action = initialDragYLevel;
        }
        gx_action = Math.max(0, Math.min(GRID - 1, gx_action));
        gy_action = Math.max(0, Math.min(GRID - 1, gy_action));
        gz_action = Math.max(0, Math.min(GRID - 1, gz_action));
        targetForVoxelAction = { gx: gx_action, gy: gy_action, gz: gz_action };


        // Bestimme voxelForPreview
        let gx_preview = currentRayHit.gx;
        let gy_preview = currentRayHit.gy;
        let gz_preview = currentRayHit.gz;

        if (currentMode === Modes.ADD && currentRayHit.faceNormal && !currentRayHit.hitTemplate) {
            gx_preview += currentRayHit.faceNormal.x;
            gy_preview += currentRayHit.faceNormal.y;
            gz_preview += currentRayHit.faceNormal.z;
        } else if (currentMode === Modes.ADD && currentRayHit.hitTemplate) {
            // Keine Anpassung, Vorschau an der Position des Template-Voxels
        } else if (currentMode === Modes.DELETE || currentMode === Modes.DRAW) {
             // Keine Anpassung, Vorschau an der Position des getroffenen Voxels
        }
        gx_preview = Math.max(0, Math.min(GRID - 1, gx_preview));
        gy_preview = Math.max(0, Math.min(GRID - 1, gy_preview));
        gz_preview = Math.max(0, Math.min(GRID - 1, gz_preview));
        voxelForPreview = { gx: gx_preview, gy: gy_preview, gz: gz_preview };
    }
    
    // Führe Aktionen aus, wenn der Pointer gedrückt ist und ein Ziel gefunden wurde UND es ein Drag für Voxel-Aktionen ist
    if (((pointerIsDown && e.pointerType === 'mouse') || isDraggingForVoxelAction) && targetForVoxelAction) { // Sicherstellen, dass targetForVoxelAction gültig ist
        // Kontinuierliche Voxel-Modifikation während des Drags
        const startPointForLine = lastActionVoxelCoords;
        const endPointForLine = { ...targetForVoxelAction };

        let pathVoxels = getVoxelsOnLine(startPointForLine, endPointForLine);

        if (currentMode === Modes.ADD) {
            pathVoxels = pathVoxels.filter(voxel => {
                const gKey = key(voxel.gx, voxel.gy, voxel.gz);
                const hasExistingVoxel = voxels.has(gKey);
                return !hasExistingVoxel; // Nur hinzufügen, wenn kein Voxel existiert (templateVoxelMap ist jetzt immer leer)
            });
        } else if (currentMode === Modes.DELETE || currentMode === Modes.DRAW) {
            pathVoxels = pathVoxels.filter(voxel => voxelsAtDragStart.has(key(voxel.gx, voxel.gy, voxel.gz)));
        }
        
        let lastProcessedVoxel = null; // Um den tatsächlich letzten bearbeiteten Voxel zu verfolgen
        for (let i = 0; i < pathVoxels.length; i++) {
            const voxel = pathVoxels[i];
            const gKey = key(voxel.gx, voxel.gy, voxel.gz);
            const initialColorOfStroke = voxelsAtDragStart.has(gKey) ? voxelsAtDragStart.get(gKey).color : null;
            
            performVoxelModification(voxel.gx, voxel.gy, voxel.gz, currentMode, currentColor);
            
            const finalColorAfterModification = voxels.has(gKey) ? voxels.get(gKey).color : null;

            if (!currentStrokeVoxels.has(gKey)) {
                 currentStrokeVoxels.set(gKey, { originalColor: initialColorOfStroke, finalColor: finalColorAfterModification });
            } else {
                currentStrokeVoxels.get(gKey).finalColor = finalColorAfterModification;
            }
            lastProcessedVoxel = voxel; // Dies ist der letzte erfolgreich modifizierte Voxel
        }

        // Aktualisiere lastActionVoxelCoords mit dem tatsächlich letzten bearbeiteten Voxel
        if (lastProcessedVoxel) {
            lastActionVoxelCoords = { ...lastProcessedVoxel };
        } else if (startPointForLine) {
            // Wenn keine Voxel modifiziert wurden (z.B. Filterung), aber ein Startpunkt existiert,
            // halte den Startpunkt bei, um zukünftige Lücken zu vermeiden.
            lastActionVoxelCoords = { ...startPointForLine };
        }
        
        updatePreviewVoxel(voxelForPreview.gx, voxelForPreview.gy, voxelForPreview.gz, true);
        previewLineInstancedMesh.count = 0; // Vorschau-Linie ausblenden
        
    } else { // Kein Pointer gedrückt oder Single-Touch ist Kamerarotation
        previewLineInstancedMesh.count = 0;
        previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
        previewLineVoxels = [];

        // Zeige Vorschau-Voxel nur, wenn keine Geste aktiv ist (d.h. nur Hover für Maus oder initialer Zustand für Touch)
        if (!isSingleTouchCameraRotating && !isDraggingForVoxelAction) {
            let hoverRayHit = calculateRayTargetVoxelCoords(
                e.clientX,
                e.clientY,
                null,
                currentMode === Modes.DRAW && initialDragYLevel !== null ? initialDragYLevel : null
            );

            let hoverVoxelForPreview = null;

            if (hoverRayHit && 
                Number.isFinite(hoverRayHit.gx) && 
                Number.isFinite(hoverRayHit.gy) && 
                Number.isFinite(hoverRayHit.gz)) {

                let gx_hover_preview = hoverRayHit.gx;
                let gy_hover_preview = hoverRayHit.gy;
                let gz_hover_preview = hoverRayHit.gz;

                if (currentMode === Modes.ADD && hoverRayHit.faceNormal && !hoverRayHit.hitTemplate) {
                    gx_hover_preview += hoverRayHit.faceNormal.x;
                    gy_hover_preview += hoverRayHit.faceNormal.y;
                    gz_hover_preview += hoverRayHit.faceNormal.z;
                }
                gx_hover_preview = Math.max(0, Math.min(GRID - 1, gx_hover_preview));
                gy_hover_preview = Math.max(0, Math.min(GRID - 1, gy_hover_preview));
                gz_hover_preview = Math.max(0, Math.min(GRID - 1, gz_hover_preview));
                hoverVoxelForPreview = { gx: gx_hover_preview, gy: gy_hover_preview, gz: gz_hover_preview };
            }

            if (hoverVoxelForPreview) {
                let showPreview = false;
                const gKeyAtPreview = key(hoverVoxelForPreview.gx, hoverVoxelForPreview.gy, hoverVoxelForPreview.gz);
                const hasVoxelAtPreview = voxels.has(gKeyAtPreview);
                const isTemplateVoxel = false; // templateVoxelMap ist jetzt immer leer

                if (currentMode === Modes.ADD) {
                    showPreview = !hasVoxelAtPreview || isTemplateVoxel;
                } else if (currentMode === Modes.DELETE || currentMode === Modes.DRAW) {
                    showPreview = hasVoxelAtPreview;
                }
                updatePreviewVoxel(hoverVoxelForPreview.gx, hoverVoxelForPreview.gy, hoverVoxelForPreview.gz, showPreview);
            } else {
                updatePreviewVoxel(0, 0, 0, false);
            }
        }
    }
}

// Wechselt die Zeichenachse
function cycleDrawingAxis() {
    const axes = ['x', 'y', 'z'];
    const currentIndex = axes.indexOf(currentDrawingAxis);
    currentDrawingAxis = axes[(currentIndex + 1) % axes.length];
    updateGridHelperPosition(); // Aktualisiert die Gitterhelfer-Position
    showToast('Zeichenachse', `Achse: ${currentDrawingAxis.toUpperCase()}`, 'info', 1500);
}

// Bewegt die Zeichenebene nach oben oder unten
function moveDrawingLevel(direction) {
    if (currentMode !== Modes.ADD && currentMode !== Modes.DRAW) {
        showToast('Hinweis', 'Ebenensteuerung nur im Hinzufügen- oder Zeichenmodus verfügbar.', 'warning', 2000);
        return;
    }
    let level = activeDrawingLevel[currentDrawingAxis];

    if (!Number.isFinite(level)) {
        level = 0;
        activeDrawingLevel[currentDrawingAxis] = level;
    }

    level += direction;
    level = Math.max(0, Math.min(GRID - 1, level)); // Klemmen innerhalb des Rasters
    activeDrawingLevel[currentDrawingAxis] = level;
    updateGridHelperPosition(); // Aktualisiert die Gitterhelfer-Position
    showToast('Zeichenebene', `Ebene ${currentDrawingAxis.toUpperCase()}: ${level}`, 'info', 1500);
}


window.onload = async function() {
    closeAllModals(); // Alle Modals beim Start schließen
    try {
        cvs = document.getElementById('voxelCanvas'); containerDiv = document.getElementById('container');
        // touchIndicator = document.getElementById('touch-indicator'); // ENTFERNT
        toastContainer = document.getElementById('toast-container');
        scene = new THREE.Scene(); scene.background = new THREE.Color(0x282c34); // Szene und Hintergrundfarbe
        cam = new THREE.PerspectiveCamera(75, containerDiv.clientWidth / containerDiv.clientHeight, 0.1, 1000); // Kamera
        resetCameraPosition(); euler = new THREE.Euler(0, 0, 0, 'YXZ'); // Kamera-Position und Euler-Winkel
        ren = new THREE.WebGLRenderer({ canvas: cvs, antialias: true }); // Renderer
        ren.setSize(containerDiv.clientWidth, containerDiv.clientHeight);
        isMobile = window.matchMedia('(max-width: 768px)').matches; // Mobilgerät-Erkennung
        ren.setPixelRatio(isMobile ? Math.min(1.5, window.devicePixelRatio) : window.devicePixelRatio); // Pixel-Verhältnis
        ren.shadowMap.enabled = true; ren.shadowMap.type = THREE.PCFSoftShadowMap; // Schatten aktivieren
      
        scene.add(new THREE.AmbientLight(0x606060)); // Umgebungslicht
        mainDirectionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // Haupt-Direktionslicht
        mainDirectionalLight.position.set(10, 20, 15); mainDirectionalLight.castShadow = true;
        mainDirectionalLight.shadow.mapSize.width = mainDirectionalLight.shadow.mapSize.height = 2048;
        mainDirectionalLight.shadow.camera.near = 0.5; mainDirectionalLight.shadow.camera.far = 50;
        mainDirectionalLight.shadow.camera.left = -30; mainDirectionalLight.shadow.camera.right = 30;
        mainDirectionalLight.shadow.camera.top = 30; mainDirectionalLight.shadow.camera.bottom = -30;
        mainDirectionalLight.shadow.bias = -0.0005; mainDirectionalLight.shadow.normalBias = 0.02;
        scene.add(mainDirectionalLight);
        const secondDirectionalLight = new THREE.DirectionalLight(0xffffff, 0.3); // Zweites Direktionslicht
        secondDirectionalLight.position.set(-10, 10, -15);
        scene.add(secondDirectionalLight);
        scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.6)); // Halbkugel-Licht
        
        scene.add(previewVoxelMesh); updatePreviewVoxel(0,0,0,false); // Fügt Vorschau-Voxel zur Szene hinzu
        previewLineInstancedMesh = new THREE.InstancedMesh(new THREE.BoxGeometry(VS, VS, VS), new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.3, depthTest: false }));
        previewLineInstancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        previewLineInstancedMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(maxPreviewInstances * 3), 3);
        previewLineInstancedMesh.instanceColor.setUsage(THREE.DynamicDrawUsage); scene.add(previewLineInstancedMesh);
        rebuildHelpers(); // Baut Gitter- und Box-Helfer auf

        // Canvas focus handling
        cvs.tabIndex = 0; // Macht Canvas fokussierbar
        cvs.focus();      // Gibt Canvas initialen Fokus
        containerDiv.addEventListener('pointerenter', () => {
            // Fokus nur setzen, wenn nicht bereits auf einem Input-Element fokussiert oder ein Modal geöffnet ist
            const activeElement = document.activeElement;
            const isModalOpen = ['clearConfirmationModal'].some(id => document.getElementById(id).open);
            if (!isModalOpen && activeElement && !activeElement.tagName.match(/^(INPUT|TEXTAREA|SELECT|BUTTON)$/)) {
                cvs.focus();
            }
        });


        // Event-Listener
        window.addEventListener('resize', onResize);
        containerDiv.addEventListener('pointerdown', onPointerDown);
        containerDiv.addEventListener('pointermove', onPointerMove);
        containerDiv.addEventListener('pointerup', onPointerUp);
        containerDiv.addEventListener('pointercancel', onPointerUp);
        containerDiv.addEventListener('pointerleave', onPointerLeave);
        containerDiv.addEventListener('wheel', onMouseWheel, { passive: false });
        document.addEventListener('keydown', onKeyDown); document.addEventListener('keyup', onKeyUp);
        document.addEventListener('pointerlockchange', onPointerLockChange, false);
        containerDiv.addEventListener('mousemove', (e) => {
            if (isPointerLocked) {
                mouseMovementX = e.movementX;
                mouseMovementY = e.movementY;
                e.preventDefault();
            }
        });
        containerDiv.addEventListener('contextmenu', (e) => e.preventDefault()); // Kontextmenü bei Rechtsklick verhindern

        // Gittergröße-Slider
        document.getElementById('grid-size-slider').addEventListener('input', (e) => {
            const oldGrid = GRID;
            const newGrid = parseInt(e.target.value);

            // Warnung, wenn Voxel beim Verkleinern des Rasters verloren gehen würden
            if (newGrid < oldGrid) {
                let voxelsWouldBeLost = false;
                for (const [id, data] of voxels.entries()) {
                    const p = parseKey(id);
                    if (p[0] >= newGrid || p[1] >= newGrid || p[2] >= newGrid) {
                        voxelsWouldBeLost = true;
                        break;
                    }
                }

                if (voxelsWouldBeLost) {
                    showToast('Warnung', 'Gittergröße kann nicht reduziert werden, da sonst vorhandene Voxel außerhalb des Rasters verloren gehen würden.', 'warning', 5000);
                    e.target.value = oldGrid;
                    document.getElementById('grid-size-display').textContent = `${oldGrid}×${oldGrid}×${oldGrid}`;
                    return;
                }
            }
            
            // Aktualisiert das Gitter und fügt Befehl zur Historie hinzu
            const oldVoxelState = [...voxels.entries()].map(([id, data]) => { const p = parseKey(id); return { gx: p[0], gy: p[1], gz: p[2], color: data.color }; });
            for (const chunk of chunks.values()) chunk.dispose(); chunks.clear(); voxels.clear();
            oldVoxelState.filter(v => v.gx < newGrid && v.gy < newGrid && v.gz < newGrid).forEach(v => _addSingleVoxel(v.gx, v.gy, v.gz, v.color));
            GRID = newGrid; document.getElementById('grid-size-display').textContent = `${GRID}×${GRID}×${GRID}`; localStorage.setItem('voxelEditorGridSize', GRID);
            addCommand('resizeGrid', oldVoxelState, [...voxels.entries()].map(([id, data]) => { const p = parseKey(id); return { gx: p[0], gy: p[1], gz: p[2], color: data.color }; }), { oldGrid: oldGrid, newGrid: GRID });
            rebuildHelpers(); resetCameraPosition();
        });

        // Farbauswahl
        document.getElementById('color-picker').addEventListener('input', (e) => {
            currentColor = e.target.value; localStorage.setItem('voxelEditorColor', currentColor);
            const mobileColorInput = document.getElementById('mobile-color-input');
            if (mobileColorInput) mobileColorInput.value = currentColor;
            presetBoxes.forEach(box => box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50')); activePresetIndex = -1;
            if (previewVoxelMesh.visible) {
                previewVoxelMaterial.color.set(currentColor);
            }
        });

        // Voreingestellte Farben
        presetBoxes = [document.getElementById('color-preset-1'), document.getElementById('color-preset-2'), document.getElementById('color-preset-3')];
        presetColors.forEach((color, i) => {
            const box = presetBoxes[i]; box.value = color;
            box.addEventListener('click', (e) => setActivePreset(i));
            box.addEventListener('input', (e) => savePresetColor(i, e.target.value));
        });
        if (activePresetIndex !== -1) setActivePreset(activePresetIndex); else document.getElementById('color-picker').value = currentColor;

        document.getElementById('modeToggle').addEventListener('click', cycleMode);
        document.getElementById('current-mode').textContent = `Modus: ${currentMode}`;

        // Clear-Bestätigungsmodal
        document.getElementById('clearBtn').addEventListener('click', () => document.getElementById('clearConfirmationModal').showModal());
        document.getElementById('saveAndClearBtn').addEventListener('click', () => { saveJSON(); clearAll(); document.getElementById('clearConfirmationModal').close(); });
        document.getElementById('clearWithoutSaveBtn').addEventListener('click', () => { clearAll(); document.getElementById('clearConfirmationModal').close(); });
        document.getElementById('cancelClearBtn').addEventListener('click', () => document.getElementById('clearConfirmationModal').close());
        document.getElementById('clearConfirmationModal').addEventListener('cancel', () => document.getElementById('clearConfirmationModal').close());

        document.getElementById('fillLevelBtn').addEventListener('click', fillActiveLevel);
        document.getElementById('saveBtn').addEventListener('click', saveJSON);
        document.getElementById('loadBtn').addEventListener('click', () => document.getElementById('fileInput').click());
        document.getElementById('fileInput').addEventListener('change', loadJSON);
        document.getElementById('exportStlBtn').addEventListener('click', exportSTL);

        // Fluggeschwindigkeits-Slider
        document.getElementById('fly-speed-slider').addEventListener('input', (e) => {
            moveSpeed = parseFloat(e.target.value); document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2); localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
        });

        document.getElementById('resetCameraBtn').addEventListener('click', resetCameraPosition);
        document.getElementById('loadImageTemplateBtn').addEventListener('click', loadImageTemplate);
        document.getElementById('imageFileInput').addEventListener('change', handleImageFileSelect);
        document.getElementById('removeImageTemplateBtn').addEventListener('click', removeImageTemplate);

        // Menü-Umschaltung für Mobilgeräte
        document.getElementById('menuToggle').addEventListener('click', () => {
            const controlsPanel = document.getElementById('controls');
            controlsPanel.classList.toggle('hidden');
            if (!controlsPanel.classList.contains('hidden')) controlsPanel.classList.add('flex');
            else controlsPanel.classList.remove('flex');
        });

        // Medienabfrage für responsive Anpassungen
        const mediaQuery = window.matchMedia('(max-width: 768px)');
        function handleMediaQueryChange(e) {
            isMobile = e.matches;
            const controlsPanel = document.getElementById('controls');
            const mobileControls = document.getElementById('mobile-controls');
            const mobileAxisToggle = document.getElementById('mobile-axis-toggle');
            const mobileLevelUp = document.getElementById('mobile-level-up');
            const mobileLevelDown = document.getElementById('mobile-level-down');

            if (e.matches) {
                controlsPanel.classList.add('hidden');
                mobileControls.classList.remove('hidden');
                mobileControls.classList.add('flex');
                toastContainer.classList.remove('toast-end');
                toastContainer.classList.add('toast-top-center');
                
                mobileAxisToggle.classList.remove('hidden');
                mobileLevelUp.classList.remove('hidden');
                mobileLevelDown.classList.remove('hidden');
            }
            else {
                controlsPanel.classList.remove('hidden');
                controlsPanel.classList.add('flex');
                mobileControls.classList.add('hidden');
                mobileControls.classList.remove('flex');
                toastContainer.classList.remove('toast-top-center');
                toastContainer.classList.add('toast-end');

                mobileAxisToggle.classList.add('hidden');
                mobileLevelUp.classList.add('hidden');
                mobileLevelDown.classList.add('hidden');
            }
            onResize();
            rebuildHelpers();
            const mobileModeIcon = document.getElementById('mobile-mode-icon');
            if (mobileModeIcon) {
                mobileModeIcon.className = ModeIcons[currentMode];
            }
        }
        mediaQuery.addListener(handleMediaQueryChange); handleMediaQueryChange(mediaQuery);

        // Mobile Steuerungs-Buttons
        document.getElementById('mobile-undo').addEventListener('click', (e) => { e.stopPropagation(); undo(); });
        document.getElementById('mobile-redo').addEventListener('click', (e) => { e.stopPropagation(); redo(); });
        document.getElementById('mobile-save').addEventListener('click', (e) => { e.stopPropagation(); saveJSON(); });
        document.getElementById('mobile-camera').addEventListener('click', (e) => { e.stopPropagation(); resetCameraPosition(); });
        document.getElementById('mobile-mode-toggle').addEventListener('click', (e) => { e.stopPropagation(); cycleMode(); });
        
        const mobileColorPickerBtn = document.getElementById('mobile-color-picker-btn');
        const mobileColorInput = document.getElementById('mobile-color-input');
        
        mobileColorPickerBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            mobileColorInput.click();
        });

        mobileColorInput.addEventListener('input', (e) => {
            currentColor = e.target.value;
            localStorage.setItem('voxelEditorColor', currentColor);
            document.getElementById('color-picker').value = currentColor;
            presetBoxes.forEach(box => box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'));
            activePresetIndex = -1;
            if (previewVoxelMesh.visible) {
                previewVoxelMaterial.color.set(currentColor);
            }
        });
        mobileColorInput.addEventListener('change', (e) => {
            currentColor = e.target.value;
            localStorage.setItem('voxelEditorColor', currentColor);
            document.getElementById('color-picker').value = currentColor;
            presetBoxes.forEach(box => box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'));
            activePresetIndex = -1;
            if (previewVoxelMesh.visible) {
                previewVoxelMaterial.color.set(currentColor);
            }
        });

        mobileColorInput.value = currentColor;

        document.getElementById('mobile-axis-toggle').addEventListener('click', (e) => { e.stopPropagation(); cycleDrawingAxis(); });
        document.getElementById('mobile-level-up').addEventListener('click', (e) => { e.stopPropagation(); moveDrawingLevel(1); });
        document.getElementById('mobile-level-down').addEventListener('click', (e) => { e.stopPropagation(); moveDrawingLevel(-1); });

        // ENTFERNT: Login-Button, Upload-Button, Hub-Link für Desktop und Mobile (da Firebase-Login-UI entfernt)
        // document.getElementById('loginLogoutBtn').addEventListener('click', loginLogout);
        // document.getElementById('uploadToHubBtn').addEventListener('click', openUploadModal);
        // document.getElementById('goToHubBtn').addEventListener('click', () => window.open('https://hub.voxelshaper.com', '_blank'));
        // document.getElementById('mobile-login-logout').addEventListener('click', ...);

        // ENTFERNT: Firebase-Initialisierung und Authentifizierungs-Logik
        // const app = window.firebase.initializeApp(window.firebaseConfig);
        // auth = window.firebase.getAuth(app); db = window.firebase.getFirestore(app);
        // ... (onAuthStateChanged, etc.)

        // Da Firebase entfernt wurde, kann die App nun direkt animieren
        animate();
    } catch (e) { showToast('Schwerer Fehler', `Ein unerwarteter Fehler ist aufgetreten: ${e.message}.`, 'error', 10000); }
};

const frustum = new THREE.Frustum(); const tempCameraMatrix = new THREE.Matrix4();
function animate() {
    requestAnimationFrame(animate);
    if (isPointerLocked) {
        if (firstMoveAfterLock) {
            firstMoveAfterLock = false;
            mouseMovementX = mouseMovementY = 0;
            return;
        }
        euler.y -= (mouseMovementX || 0) * rotSpeed;
        euler.x -= (mouseMovementY || 0) * rotSpeed;
        euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
        cam.quaternion.setFromEuler(euler);
        mouseMovementX = mouseMovementY = 0;
        const camDir = new THREE.Vector3(); cam.getWorldDirection(camDir);
        const rightDir = new THREE.Vector3().crossVectors(camDir, cam.up).normalize();
        const upVec = new THREE.Vector3(0, 1, 0); const currMoveSpeed = moveSpeed * 0.5;
        if (keyboard['w']) cam.position.addScaledVector(camDir, currMoveSpeed);
        if (keyboard['s']) cam.position.addScaledVector(camDir, -currMoveSpeed);
        if (keyboard['a']) cam.position.addScaledVector(rightDir, -currMoveSpeed);
        if (keyboard['d']) cam.position.addScaledVector(rightDir, currMoveSpeed);
        if (keyboard['e']) cam.position.addScaledVector(upVec, currMoveSpeed);
        if (keyboard['q']) cam.position.addScaledVector(upVec, -currMoveSpeed);
    }
    cam.updateMatrixWorld(); tempCameraMatrix.multiplyMatrices(cam.projectionMatrix, cam.matrixWorldInverse);
    frustum.setFromProjectionMatrix(tempCameraMatrix);
    for (const chunk of chunks.values()) chunk.instancedMesh.visible = frustum.intersectsBox(chunk.boundingBox);
    ren.render(scene, cam);
}
</script>
</body>
</html>
