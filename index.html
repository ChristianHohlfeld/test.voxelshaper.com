<!DOCTYPE html>
<html lang="de" data-theme="dark">
<head>
<meta charset="UTF-8">
<meta property="og:title" content="VoxelShaper – Create in 3D, Effortlessly" />
<meta property="og:description" content="A powerful, intuitive voxel-based 3D editor – made for makers, artists, and coders." />
<meta property="og:image" content="https://voxelshaper.com/preview.png" />
<meta property="og:url" content="https://voxelshaper.com/" />
<meta property="og:type" content="website" />
<meta name="viewport"
      content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover">
<link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAAANl..."/>

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="VoxelShaper – Create in 3D, Effortlessly">
<meta name="twitter:description" content="A powerful, intuitive voxel-based 3D editor – made for makers, artists, and coders.">
<meta name="twitter:image" content="https://voxelshaper.com/preview.png">
<title>VoxelShaper – Voxel Editor & 3D Print Exporter</title>

<link href="https://cdn.jsdelivr.net/npm/daisyui@4.7.2/dist/full.min.css" rel="stylesheet" type="text/css" />
<script src="https://cdn.tailwindcss.com"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

<style>
body {
    padding-top: env(safe-area-inset-top);
    padding-bottom: env(safe-area-inset-bottom);
    padding-left: env(safe-area-inset-left);
    padding-right: env(safe-area-inset-right);
    box-sizing: border-box;
    touch-action: auto;
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
}
#container, #voxelCanvas {
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
    -webkit-touch-callout: none;
    touch-action: none;
}
.touch-indicator { animation: pulse 0.5s; }
@keyframes pulse {
    0% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
    50% { transform: translate(-50%, -50%) scale(1.5); opacity: 0.2; }
    100% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
}
input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
input[type="color"]::-webkit-color-swatch { border: none; border-radius: 50%; }
input[type="color"]::-moz-color-swatch-wrapper { padding: 0; }
input[type="color"]::-moz-color-swatch { border: none; border-radius: 50%; }
.color-preset-box::-webkit-color-swatch-wrapper { padding: 0; }
.color-preset-box::-webkit-color-swatch { border: none; border-radius: 0.375rem; }
.color-preset-box::-moz-color-swatch-wrapper { padding: 0; }
.color-preset-box::-moz-color-swatch { border: none; border-radius: 0.375rem; }

#toast-container {
    position: fixed;
    z-index: 50;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    padding: 1rem;
    pointer-events: none;
}

#toast-container.toast-end {
    bottom: 1rem;
    right: 1rem;
    align-items: flex-end;
}

@media (max-width: 768px) {
    #toast-container {
        top: 1rem;
        left: 50%;
        transform: translateX(-50%);
        width: calc(100% - 2rem);
        max-width: 300px;
        align-items: center;
    }
    #toast-container.toast-end {
        bottom: auto;
        right: auto;
    }
}

.toast .alert {
    pointer-events: auto;
    opacity: 0;
    transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
    transform: translateY(20px);
}

.toast .alert.show {
    opacity: 1;
    transform: translateY(0);
}

@media (max-width: 768px) {
    .toast .alert {
        padding: 0.5rem 0.75rem;
        font-size: 0.875rem;
    }
    .toast .alert svg {
        width: 1.25rem;
        height: 1.25rem;
    }
    .toast .alert strong {
        font-size: 0.9rem;
    }
    .toast .alert span {
        font-size: 0.8rem;
    }
    .toast .alert .close-btn {
        font-size: 1rem;
        padding: 0.25rem;
    }
}
.mobile-btn {
    width: 64px;
    height: 64px;
    font-size: 2rem;
    border-radius: 50%;
    background-color: var(--fallback-b3, oklch(var(--b3)/1));
    color: var(--fallback-bc, oklch(var(--bc)/1));
    border: 2px solid var(--fallback-bc, oklch(var(--bc)/1));
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
    transition: background-color 0.2s, transform 0.2s;
}

.mobile-btn:hover {
    background-color: oklch(var(--bc)/0.2);
}

.mobile-btn:active {
    transform: scale(0.95);
}

.mobile-btn:disabled {
    background-color: var(--fallback-b2, oklch(var(--b2)/0.5));
    color: var(--fallback-bc, oklch(var(--bc)/0.5));
    cursor: not-allowed;
}


#mobile-controls {
    gap: 1rem;
}

.btn:disabled {
    cursor: not-allowed;
    background-color: oklch(var(--b2)/0.5) !important;
    color: oklch(var(--bc)/0.5) !important;
}

</style>
</head>
<body class="bg-base-100 min-h-screen text-base-content flex flex-col">
<button id="menuToggle" aria-label="Menü umschalten" class="fixed top-4 right-4 z-[1500] w-10 h-10 text-xl leading-10 text-center bg-base-300 text-base-content border-none rounded-lg cursor-pointer shadow-md hover:bg-base-content/20 lg:hidden">☰</button>

<div id="controls" class="flex flex-wrap items-center justify-center gap-3 p-4 bg-base-200 border-b border-base-content/20 hidden md:flex">
    <label for="grid-size-slider" class="text-base-content">Gittergröße:</label>
    <input type="range" id="grid-size-slider" min="5" max="180" value="10" aria-label="Gittergröße anpassen" class="range range-xs w-36">
    <span id="grid-size-display" class="font-bold text-primary">10×10×10</span>
    
    <label for="color-picker" class="text-base-content">Farbe:</label>
    <input type="color" id="color-picker" value="#ffffff" aria-label="Aktuelle Farbe wählen" class="input input-bordered w-10 h-10 p-0 rounded-full cursor-pointer border-base-content/20">
    <input type="color" id="color-preset-1" class="color-preset-box w-10 h-10 rounded-md border-2 border-base-content/20 cursor-pointer transition-all duration-200 hover:scale-110" value="#E4002B" aria-label="Voreingestellte Farbe 1">
    <input type="color" id="color-preset-2" class="color-preset-box w-10 h-10 rounded-md border-2 border-base-content/20 cursor-pointer transition-all duration-200 hover:scale-110" value="#00A040" aria-label="Voreingestellte Farbe 2">
    <input type="color" id="color-preset-3" class="color-preset-box w-10 h-10 rounded-md border-2 border-base-content/20 cursor-pointer flex items-center justify-center shadow-lg hover:bg-base-content/20" value="#0057B8" aria-label="Voreingestellte Farbe 3">

    <button id="modeToggle" aria-label="Modus wechseln" class="btn btn-sm btn-neutral">Modus wechseln</button><span id="current-mode" class="font-bold text-success min-w-40 text-center">Modus: Hinzufügen</span>
    <button id="clearBtn" aria-label="Alles löschen" class="btn btn-sm btn-neutral">Alles löschen</button>
    <button id="fillLevelBtn" aria-label="Ebene füllen" class="btn btn-sm btn-neutral">Ebene füllen</button>
    <button id="saveBtn" aria-label="Projekt speichern" aria-describedby="save-description" class="btn btn-sm btn-neutral">Projekt speichern</button>
    <div id="save-description" class="sr-only">Speichert das aktuelle Projekt als JSON-Datei</div>
    <button id="loadBtn" aria-label="Projekt laden" class="btn btn-sm btn-neutral">Projekt laden</button>
    <button id="exportStlBtn" aria-label="STL Export" class="btn btn-sm btn-neutral">STL Export</button>
    <button id="exportObjBtn" aria-label="OBJ Export" class="btn btn-sm btn-neutral">OBJ Export</button>
    <button id="exportGlbBtn" aria-label="GLB Export" class="btn btn-sm btn-neutral">GLB Export</button>

    <!-- New Undo/Redo/Play Buttons -->
    <div class="divider divider-horizontal"></div>
    <button id="undoBtn" aria-label="Rückgängig" class="btn btn-sm btn-neutral">↺</button>
    <button id="redoBtn" aria-label="Wiederholen" class="btn btn-sm btn-neutral">↻</button>
    <button id="playBtn" aria-label="Physik-Simulation starten/stoppen" class="btn btn-sm btn-accent"><i class="fas fa-play"></i></button>
    <div class="divider divider-horizontal"></div>
    
    <label for="fly-speed-slider" class="text-base-content">Fluggeschwindigkeit:</label>
    <input type="range" id="fly-speed-slider" min="0.01" max="1.0" step="0.01" value="0.1" aria-label="Fluggeschwindigkeit anpassen" class="range range-xs w-36">
    <span id="fly-speed-display" class="font-bold text-primary">0.10</span>

    <button id="resetCameraBtn" aria-label="Kamera zurücksetzen" class="btn btn-sm btn-neutral">Zur Szene zurückkehen</button>
    <button id="generateVoxelIdeaBtn" aria-label="Voxel-Idee generieren" class="btn btn-sm btn-primary">✨ Voxel-Idee generieren ✨</button>

    <button id="loadImageTemplateBtn" aria-label="Bild als Vorlage laden" class="btn btn-sm btn-neutral">Bild als Vorlage laden</button>
    <button id="removeImageTemplateBtn" class="btn btn-sm btn-neutral hidden" aria-label="Bildvorlage entfernen">Bildvorlage entfernen</button>
    <input type="file" id="imageFileInput" accept="image/*" class="hidden">

    <button id="loginLogoutBtn" aria-label="Anmelden oder Abmelden" class="btn btn-sm btn-info">Anmelden</button>
    <span id="userIdDisplay" class="font-bold text-info ml-2 mr-2 whitespace-nowrap overflow-hidden text-ellipsis max-w-xs flex items-center gap-1"></span>
    <button id="uploadToHubBtn" aria-label="Auf Hub hochladen" class="btn btn-sm btn-warning hidden">Auf Hub hochladen</button>
    <button id="goToHubBtn" aria-label="Zum VoxelShaper Hub wechseln" class="btn btn-sm btn-secondary">Zum Hub</button>
</div>

<div id="container" class="flex-1 relative border-2 border-transparent box-border overflow-hidden touch-none">
    <canvas id="voxelCanvas" class="w-full h-full block box-border"></canvas>
    <div id="touch-indicator" class="touch-indicator absolute w-10 h-10 rounded-full bg-blue-500/30 transform -translate-x-1/2 -translate-y-1/2 pointer-events-none hidden z-[2000]"></div>
    <input type="file" id="fileInput" accept=".json" class="hidden">
</div>

<dialog id="clearConfirmationModal" class="modal">
    <div class="modal-box bg-base-200 text-base-content p-8 text-center shadow-xl max-w-md">
        <h3 class="font-bold text-lg text-primary mb-4">Projekt löschen</h3>
        <p class="py-4">Möchten Sie das aktuelle Projekt speichern, bevor Sie alle Voxel löschen?</p>
        <div class="modal-buttons flex justify-around gap-4 mt-6">
            <button id="saveAndClearBtn" class="confirm-save btn btn-success flex-1">Speichern & Löschen</button>
            <button id="clearWithoutSaveBtn" class="confirm-no-save btn btn-error flex-1">Ohne Speichern löschen</button>
            <button id="cancelClearBtn" class="cancel btn btn-ghost flex-1">Abbrechen</button>
        </div>
    </div>
</dialog>

<dialog id="uploadProjectModal" class="modal">
    <div class="upload-modal-content modal-box bg-base-200 text-base-content p-8 shadow-xl max-w-xl w-11/12 text-left">
        <h3 class="font-bold text-lg text-primary text-center mb-6">Projekt auf Hub hochladen</h3>
        <label for="uploadTitle" class="label block mb-2 font-bold">Titel:</label>
        <input type="text" id="uploadTitle" placeholder="Ein aussagekräftiger Titel für Ihr Projekt" maxlength="100" class="input input-bordered w-full bg-base-300 border-base-content/20 mb-4">

        <label for="uploadDescription" class="label block mb-2 font-bold">Beschreibung:</label>
        <textarea id="uploadDescription" placeholder="Beschreiben Sie Ihr Projekt kurz" maxlength="500" class="textarea textarea-bordered w-full bg-base-300 border-base-content/20 h-24 mb-4 resize-y"></textarea>

        <label for="uploadCategory" class="label block mb-2 font-bold">Kategorie:</label>
        <select id="uploadCategory" class="select select-bordered w-full bg-base-300 border-base-content/20 mb-4" required>
            <option value="" disabled selected>Kategorie auswählen</option>
        </select>

        <label for="uploadTags" class="label block mb-2 font-bold">Tags (Komma-getrennt):</label>
        <input type="text" id="uploadTags" placeholder="z.B. Haus, Baum, Auto, Gebäude" maxlength="100" class="input input-bordered w-full bg-base-300 border-base-content/20 mb-4">

        <label class="label block mb-2 font-bold">Sichtbarkeit:</label>
        <div class="radio-group flex gap-4 mb-4">
            <label class="flex items-center font-normal">
                <input type="radio" name="uploadVisibility" value="public" checked class="radio radio-primary mr-2"> Öffentlich
            </label>
            <label class="flex items-center font-normal">
                <input type="radio" name="uploadVisibility" value="private" class="radio radio-primary mr-2"> Privat
            </label>
        </div>

        <div class="upload-modal-buttons flex justify-around gap-4 mt-6">
            <button id="uploadConfirmBtn" class="upload-confirm btn btn-success flex-1">Hochladen</button>
            <button id="uploadCancelBtn" class="upload-cancel btn btn-ghost flex-1">Abbrechen</button>
        </div>
    </div>
</dialog>

<dialog id="authModal" class="modal">
    <div class="auth-modal-content modal-box bg-base-200 text-base-content p-8 shadow-xl max-w-lg w-11/12 text-center">
        <h3 class="font-bold text-lg text-primary mb-6">Anmelden bei VoxelShaper Hub</h3>
        <div class="provider-buttons flex flex-col gap-3">
            <button id="signInGoogleBtn" class="google btn btn-error text-white">
                <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" alt="Google Icon" class="w-5 h-5">
                Mit Google anmelden
            </button>
            <button id="signInGithubBtn" class="github btn bg-neutral text-neutral-content hover:bg-neutral-focus">
                <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/github.svg" alt="GitHub Icon" class="w-5 h-5">
                Mit GitHub anmelden
            </button>
            <button id="showEmailLoginFormBtn" class="email btn btn-info">
                Mit E-Mail anmelden
            </button>
        </div>

        <div id="emailLoginForm" class="email-login-form mt-6 pt-6 border-t border-base-content/20 hidden">
            <form id="emailAuthForm">
                <input type="email" id="emailInput" placeholder="E-Mail" autocomplete="email" class="input input-bordered w-full bg-base-300 border-base-content/20 mb-3">
                <input type="password" id="passwordInput" placeholder="Passwort" autocomplete="current-password" class="input input-bordered w-full bg-base-300 border-base-content/20 mb-3">
                <button type="submit" id="emailSignInBtn" class="btn btn-primary w-full">Anmelden</button>
                <button type="button" id="emailSignUpBtn" class="btn btn-secondary w-full mt-2">Registrieren</button>
            </form>
        </div>

        <div class="close-button-container mt-6">
            <button id="authModalCloseBtn" class="btn btn-ghost">Schließen</button>
        </div>
    </div>
</dialog>

<dialog id="ideaGeneratorModal" class="modal">
    <div class="modal-box bg-base-200 text-base-content p-8 shadow-xl max-w-md">
        <h3 class="font-bold text-lg text-primary mb-4">✨ Voxel-Idee generieren ✨</h3>
        <p class="py-2">Geben Sie ein Thema oder Konzept ein, um eine Voxel-Modell-Idee zu generieren:</p>
        <textarea id="ideaPromptInput" placeholder="Z.B. 'Ein gemütliches Baumhaus', 'Ein futuristisches Raumschiff'" class="textarea textarea-bordered w-full bg-base-300 border-base-content/20 h-24 mb-4 resize-y"></textarea>
        <div id="ideaResultDisplay" class="bg-base-300 p-4 rounded-md mb-4 hidden overflow-auto max-h-40"></div>
        <div id="ideaLoadingIndicator" class="text-center py-4 hidden">
            <span class="loading loading-spinner loading-lg text-primary"></span>
            <p>Generiere Idee...</p>
        </div>
        <div class="modal-buttons flex justify-around gap-4 mt-6">
            <button id="generateIdeaConfirmBtn" class="btn btn-primary flex-1">Generieren</button>
            <button id="ideaGeneratorCloseBtn" class="btn btn-ghost flex-1">Schließen</button>
        </div>
    </div>
</dialog>

<div id="toast-container" class="toast toast-end z-50"></div>

<div id="mobile-controls" class="hidden md:hidden flex-col gap-3 fixed bottom-4 right-4 z-[1000]">
    <button class="mobile-btn" id="mobile-undo" aria-label="Rückgängig machen">↺</button>
    <button class="mobile-btn" id="mobile-redo" aria-label="Wiederholen">↻</button>
    <button class="mobile-btn" id="mobile-save" aria-label="Speichern">💾</button>
    <button class="mobile-btn" id="mobile-camera" aria-label="Kamera zurücksetzen">📷</button>

    <button class="mobile-btn" id="mobile-mode-toggle" aria-label="Modus wechseln">
        <span id="mobile-mode-icon" class="fas fa-plus"></span>
    </button>
    
    <button class="mobile-btn" id="mobile-play" aria-label="Physik-Simulation starten/stoppen"><i class="fas fa-play"></i></button>

    <button class="mobile-btn" id="mobile-color-picker-btn" aria-label="Farbe auswählen">🎨</button>
    <input type="color" id="mobile-color-input" value="#ffffff" class="hidden w-0 h-0 opacity-0 absolute pointer-events-none">

    <button class="mobile-btn" id="mobile-axis-toggle" aria-label="Zeichenachse wechseln">
        <span id="mobile-axis-icon" class="fas fa-arrows-alt-v"></span>
    </button>
    <button class="mobile-btn" id="mobile-level-up" aria-label="Ebene erhöhen">⬆️</button>
    <button class="mobile-btn" id="mobile-level-down" aria-label="Ebene verringern">⬇️</button>

    <button class="mobile-btn" id="mobile-generate-idea" aria-label="Voxel-Idee generieren">✨</button>
    <button class="mobile-btn" id="mobile-login-logout" aria-label="Anmelden oder Abmelden">🔑</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/GLTFExporter.js"></script>
<!-- Physics Engine -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import {
        getAuth,
        setPersistence,
        browserLocalPersistence,
        signInWithCustomToken,
        onAuthStateChanged,
        signOut,
        GoogleAuthProvider,
        GithubAuthProvider,
        signInWithPopup,
        createUserWithEmailAndPassword,
        signInWithEmailAndPassword
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import {
        getFirestore,
        doc,
        getDoc,
        collection,
        addDoc,
        serverTimestamp
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    window.firebase = {
        initializeApp,
        getAuth,
        signInWithCustomToken,
        onAuthStateChanged,
        setPersistence,
        browserLocalPersistence,
        signOut,
        GoogleAuthProvider,
        GithubAuthProvider,
        signInWithPopup,
        createUserWithEmailAndPassword,
        signInWithEmailAndPassword,
        getFirestore,
        doc,
        getDoc,
        collection,
        addDoc,
        serverTimestamp
    };

    const FIREBASE_API_KEY = "AIzaSyB9-mpyAu9W6oiVtB0fYG8E6YFvTAsjtAA"; 

    const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {
        apiKey: FIREBASE_API_KEY,
        authDomain: "voxelshaper.firebaseapp.com",
        projectId: "voxelshaper",
        storageBucket: "voxelshaper.firebasestorage.app", 
        messagingSenderId: "1053689247573",
        appId: "1:1053689247573:web:f7960c7f8c2e8849e8e1dc",
        measurementId: "G-QJCNKZ5DR"
    };
    window.firebaseConfig = firebaseConfig;
</script>

<script>
// Constants and Globals
const VS = 1, HALF = VS * 0.5;
const CHUNK_SIZE = 16;
const VOX_BITS = 10;
const VOX_MASK = (1 << VOX_BITS) - 1;
const SHIFT_X  = VOX_BITS * 2;
const SHIFT_Y  = VOX_BITS;

const AI_API_KEY = "AIzaSyD3uQ6BnGsliYAtR9r0jdBUq03KEfFO0"; 

function key(x, y, z) { return ((x << SHIFT_X) | (y << SHIFT_Y) | z) >>> 0; }
function parseKey(k) { return [(k >>> SHIFT_X) & VOX_MASK, (k >>> SHIFT_Y) & VOX_MASK, k & VOX_MASK]; }

const VOXEL_DRAG_THRESHOLD = 1;
const PINCH_ZOOM_MULT = 40;
const TAP_DIST_TH = 10;
const MOVE_PX = 10;
const DT_MS = 250;

const ROTATE_SPEED_TOUCH_MOBILE = 0.008;
const PAN_SPEED_TOUCH_MOBILE = 0.2;
const PINCH_ZOOM_MULT_MOBILE = 80;
const ROTATE_SPEED_TOUCH_DESKTOP = 0.004;
const PAN_SPEED_TOUCH_DESKTOP = 0.1;
const PINCH_ZOOM_MULT_DESKTOP = 40;

// THREE.js Scene variables
let scene, cam, ren, gridHelper, boxHelper;
let rotSpeed = 0.004;
let euler;
const voxels = new Map();
const chunks = new Map();
let cvs, containerDiv;
let activeDrawingLevel = { x: 0, y: 0, z: 0 };
let currentDrawingAxis = 'y';

// Editor State variables
let currentColor = localStorage.getItem('voxelEditorColor') || '#ffffff';
let moveSpeed = parseFloat(localStorage.getItem('voxelEditorFlySpeed') || '0.1');
let GRID = parseInt(localStorage.getItem('voxelEditorGridSize') || '10');
activeDrawingLevel.x = Number(localStorage.getItem('voxelEditorActiveDrawingLevelX') || '0');
if (!Number.isFinite(activeDrawingLevel.x)) activeDrawingLevel.x = 0;
activeDrawingLevel.x = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.x)));
activeDrawingLevel.y = Number(localStorage.getItem('voxelEditorActiveDrawingLevelY') || '0');
if (!Number.isFinite(activeDrawingLevel.y)) activeDrawingLevel.y = 0;
activeDrawingLevel.y = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.y)));
activeDrawingLevel.z = Number(localStorage.getItem('voxelEditorActiveDrawingLevelZ') || '0');
if (!Number.isFinite(activeDrawingLevel.z)) activeDrawingLevel.z = 0;
activeDrawingLevel.z = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.z)));
currentDrawingAxis = localStorage.getItem('voxelEditorCurrentDrawingAxis') || 'y';

const presetColors = [
    localStorage.getItem('voxelPresetColor1') || '#E4002B',
    localStorage.getItem('voxelPresetColor2') || '#00A040',
    localStorage.getItem('voxelPresetColor3') || '#0057B8'
];
let activePresetIndex = -1;
let presetBoxes = [];

let mainDirectionalLight;
let isPointerLocked = false;
let firstMoveAfterLock = true;
let mouseMovementX = 0;
let mouseMovementY = 0;

// Preview and Interaction variables
const dummy = new THREE.Object3D();
const previewVoxelGeometry = new THREE.BoxGeometry(VS, VS, VS);
const previewVoxelMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5, depthTest: false });
previewVoxelMaterial.polygonOffset = true;
previewVoxelMaterial.polygonOffsetFactor = -1;
let previewVoxelMesh = new THREE.Mesh(previewVoxelGeometry, previewVoxelMaterial);

const Modes = { ADD: 'Hinzufügen', DELETE: 'Löschen', DRAW: 'Zeichnen' };
const ModeIcons = { ADD: 'fas fa-plus', DELETE: 'fas fa-eraser', DRAW: 'fas fa-paint-brush' };
const AxisIcons = { x: 'fas fa-arrows-alt-h', y: 'fas fa-arrows-alt-v', z: 'fas fa-arrows-alt' };
let currentMode = Modes.ADD;

// New Undo/Redo System
let undoStack = [];
let redoStack = [];
const MAX_HISTORY_SIZE = 100;

// Voxel modification state
let currentStrokeVoxels = new Map();
let voxelsAtDragStart = null;
let lastActionVoxelCoords = null;
let initialClickPos = null;
let initialTargetVoxelCoords = null;
let isDragging = false;
let pointerIsDown = false;
let rightMouseButtonDown = false;

// Physics Simulation variables
let physicsWorld;
let physicsBodies = [];
let physicsMeshes = [];
let isPhysicsPlaying = false;
let sceneStateBeforePhysics = null;
let mouseConstraint = null;
let mouseTargetBody = null;

// Touch gesture state
let activePointers = new Map();
let gestureState = { type: 'none', startDist: 0, startMid: { x: 0, y: 0 }, lastMid: { x: 0, y: 0 }, lastDist: 0 };
let tapCandidate = null;
let touchIndicator;

// Template Image variables
let templateImageMesh = null;
let templateImageData = null;
let isMobile = window.matchMedia('(max-width: 768px)').matches;

// Project Metadata
let projectTitle = '';
let projectDescription = '';
let projectCategory = 'Allgemein';
let projectTags = [];
let projectRemixOf = '';
let projectSourceJsonUrl = '';
let projectVisibility = 'public';
const predefinedCategories = ["Spielzeug", "Dekoration", "Funktional", "Kunst", "Allgemein", "Charaktere", "Fahrzeuge", "Natur", "Architektur", "Abstrakt"];

// OBJ Exporter utility
const VoxelShaperIO = {
    voxToOBJ: function(voxModel, voxelSize) {
        let obj = '# VoxelShaper OBJ Export\n';
        let mtls = '# VoxelShaper MTL Export\n';
        let vertexCount = 0;
        const materials = new Map();
        voxModel.voxels.forEach(v => {
            if (!materials.has(v.color)) {
                const matName = `material_${materials.size + 1}`;
                materials.set(v.color, matName);
                const c = new THREE.Color(v.color);
                mtls += `newmtl ${matName}\n`;
                mtls += `Kd ${c.r.toFixed(4)} ${c.g.toFixed(4)} ${c.b.toFixed(4)}\n`;
                mtls += `Ka ${c.r.toFixed(4)} ${c.g.toFixed(4)} ${c.b.toFixed(4)}\n`;
                mtls += `Ks 0.0 0.0 0.0\nNs 0.0\nd 1.0\nillum 1\n\n`;
            }
        });
        obj += `mtllib voxel_model.mtl\n`;
        obj += '# Vertex Normals\n';
        const normals = [
            new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1), new THREE.Vector3(1, 0, 0),
            new THREE.Vector3(-1, 0, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, -1, 0)
        ];
        normals.forEach(n => { obj += `vn ${n.x.toFixed(4)} ${n.y.toFixed(4)} ${n.z.toFixed(4)}\n`; });
        obj += '\n';
        voxModel.voxels.forEach(v => {
            const x = v.x * voxelSize, y = v.y * voxelSize, z = v.z * voxelSize;
            const verts = [
                [x, y, z], [x + voxelSize, y, z], [x, y + voxelSize, z], [x + voxelSize, y + voxelSize, z],
                [x, y, z + voxelSize], [x + voxelSize, y, z + voxelSize], [x, y + voxelSize, z + voxelSize],
                [x + voxelSize, y + voxelSize, z + voxelSize]
            ];
            verts.forEach(vert => { obj += `v ${vert[0].toFixed(4)} ${vert[1].toFixed(4)} ${vert[2].toFixed(4)}\n`; });
            const matName = materials.get(v.color);
            obj += `usemtl ${matName}\n`;
            const baseIdx = vertexCount;
            obj += `f ${baseIdx + 5}//1 ${baseIdx + 6}//1 ${baseIdx + 8}//1 ${baseIdx + 7}//1\n`;
            obj += `f ${baseIdx + 1}//2 ${baseIdx + 3}//2 ${baseIdx + 4}//2 ${baseIdx + 2}//2\n`;
            obj += `f ${baseIdx + 2}//3 ${baseIdx + 6}//3 ${baseIdx + 8}//3 ${baseIdx + 4}//3\n`;
            obj += `f ${baseIdx + 1}//4 ${baseIdx + 3}//4 ${baseIdx + 7}//4 ${baseIdx + 5}//4\n`;
            obj += `f ${baseIdx + 3}//5 ${baseIdx + 4}//5 ${baseIdx + 8}//5 ${baseIdx + 7}//5\n`;
            obj += `f ${baseIdx + 1}//6 ${baseIdx + 5}//6 ${baseIdx + 6}//6 ${baseIdx + 2}//6\n`;
            vertexCount += 8;
        });
        return { obj: obj, mtl: mtls };
    },
    saveBlob: function(data, filename) {
        const objBlob = new Blob([data.obj], { type: 'text/plain' });
        const mtlBlob = new Blob([data.mtl], { type: 'text/plain' });
        const objUrl = URL.createObjectURL(objBlob);
        const mtlUrl = URL.createObjectURL(mtlBlob);
        const aObj = document.createElement('a');
        aObj.href = objUrl; aObj.download = filename; document.body.appendChild(aObj); aObj.click(); document.body.removeChild(aObj); URL.revokeObjectURL(objUrl);
        const aMtl = document.createElement('a');
        aMtl.href = mtlUrl; aMtl.download = filename.replace('.obj', '.mtl'); document.body.appendChild(aMtl); aMtl.click(); document.body.removeChild(aMtl); URL.revokeObjectURL(mtlUrl);
    },
    VoxModel: function(width, height, depth, voxels) { this.width = width; this.height = height; this.depth = depth; this.voxels = voxels; }
};

// Voxel Chunking System
function getChunkCoords(gx, gy, gz) { return { cx: Math.floor(gx / CHUNK_SIZE), cy: Math.floor(gy / CHUNK_SIZE), cz: Math.floor(gz / CHUNK_SIZE) }; }
function getChunkKey(cx, cy, cz) { return `${cx},${cy},${cz}`; }
class VoxelChunk {
    constructor(chunkX, chunkY, chunkZ, chunkSize, scene) {
        this.chunkX = chunkX; this.chunkY = chunkY; this.chunkZ = chunkZ; this.scene = scene; this.chunkSize = chunkSize;
        this.offsetX = chunkX * chunkSize * VS; this.offsetY = chunkY * chunkSize * VS; this.offsetZ = chunkZ * chunkSize * VS;
        this.voxels = new Map(); this.globalToLocalInstanceIdMap = new Map();
        const maxInstancesInChunk = chunkSize * chunkSize * chunkSize;
        const voxelBaseGeometry = new THREE.BoxGeometry(VS, VS, VS);
        const meshMaterial = new THREE.MeshLambertMaterial();
        this.instancedMesh = new THREE.InstancedMesh(voxelBaseGeometry, meshMaterial, maxInstancesInChunk);
        this.instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(maxInstancesInChunk * 3), 3);
        this.instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        this.instancedMesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
        this.instancedMesh.castShadow = true; this.instancedMesh.receiveShadow = true; this.instancedMesh.count = 0;
        this.instancedMesh.position.set(this.offsetX, this.offsetY, this.offsetZ);
        this.scene.add(this.instancedMesh);
        this.boundingBox = new THREE.Box3(
            new THREE.Vector3(this.offsetX, this.offsetY, this.offsetZ),
            new THREE.Vector3(this.offsetX + chunkSize * VS, this.offsetY + chunkSize * VS, this.offsetZ + chunkSize * VS)
        );
    }
    getLocalKey(gx, gy, gz) { return key(gx % this.chunkSize, gy % this.chunkSize, gz % this.chunkSize); }
    addVoxel(gx, gy, gz, colorHex) {
        const lKey = this.getLocalKey(gx, gy, gz); const gKey = key(gx, gy, gz);
        if (this.voxels.has(lKey)) {
            const instanceId = this.voxels.get(lKey).instanceId;
            this.voxels.set(lKey, { color: colorHex, instanceId }); this.updateInstanceColor(instanceId, colorHex);
        } else {
            const instanceId = this.instancedMesh.count++;
            this.voxels.set(lKey, { color: colorHex, instanceId }); this.globalToLocalInstanceIdMap.set(gKey, instanceId);
            dummy.position.set((gx % this.chunkSize) * VS + HALF, (gy % this.chunkSize) * VS + HALF, (gz % this.chunkSize) * VS + HALF);
            dummy.updateMatrix(); this.instancedMesh.setMatrixAt(instanceId, dummy.matrix);
            this.updateInstanceColor(instanceId, colorHex);
            this.instancedMesh.instanceMatrix.needsUpdate = true; this.instancedMesh.instanceColor.needsUpdate = true;
        }
    }
    removeVoxel(gx, gy, gz) {
        const lKey = this.getLocalKey(gx, gy, gz); const gKey = key(gx, gy, gz);
        if (!this.voxels.has(lKey)) return;
        const { instanceId: removedId } = this.voxels.get(lKey);
        this.voxels.delete(lKey); this.globalToLocalInstanceIdMap.delete(gKey);
        const lastId = this.instancedMesh.count - 1;
        if (removedId !== lastId) {
            let lastVoxelLKey = null;
            for (const [lk, data] of this.voxels.entries()) { if (data.instanceId === lastId) { lastVoxelLKey = lk; break; } }
            if (lastVoxelLKey !== null) {
                const tempMatrix = new THREE.Matrix4(); this.instancedMesh.getMatrixAt(lastId, tempMatrix);
                this.instancedMesh.setMatrixAt(removedId, tempMatrix);
                this.updateInstanceColor(removedId, this.voxels.get(lastVoxelLKey).color);
                this.voxels.get(lastVoxelLKey).instanceId = removedId;
                const [lx, ly, lz] = parseKey(lastVoxelLKey);
                this.globalToLocalInstanceIdMap.set(key(this.chunkX * this.chunkSize + lx, this.chunkY * this.chunkSize + ly, this.chunkZ * this.chunkSize + lz), removedId);
            }
        }
        this.instancedMesh.count--;
        this.instancedMesh.instanceMatrix.needsUpdate = true; this.instancedMesh.instanceColor.needsUpdate = true;
    }
    updateInstanceColor(instanceId, hex) { const c = new THREE.Color(hex); this.instancedMesh.instanceColor.setXYZ(instanceId, c.r, c.g, c.b); this.instancedMesh.instanceColor.needsUpdate = true; }
    dispose() {
        this.scene.remove(this.instancedMesh);
        this.instancedMesh.geometry.dispose(); this.instancedMesh.material.dispose();
        this.instancedMesh = null; this.voxels.clear(); this.globalToLocalInstanceIdMap.clear();
    }
}

// New Undo/Redo Functions
function saveState() {
    const state = [...voxels.entries()].map(([id, data]) => {
        const p = parseKey(id);
        return { gx: p[0], gy: p[1], gz: p[2], color: data.color };
    });
    undoStack.push(state);
    redoStack.length = 0; // Clear redo stack on new action
    if (undoStack.length > MAX_HISTORY_SIZE) {
        undoStack.shift();
    }
    updateUndoRedoButtons();
}

function undo() {
    if (undoStack.length <= 1) return; // Can't undo the initial state
    const currentState = undoStack.pop();
    redoStack.push(currentState);
    const previousState = undoStack[undoStack.length - 1];
    applyVoxelState(previousState);
    rebuildHelpers();
    updateUndoRedoButtons();
}

function redo() {
    if (redoStack.length === 0) return;
    const nextState = redoStack.pop();
    undoStack.push(nextState);
    applyVoxelState(nextState);
    rebuildHelpers();
    updateUndoRedoButtons();
}

function updateUndoRedoButtons() {
    document.getElementById('undoBtn').disabled = undoStack.length <= 1;
    document.getElementById('redoBtn').disabled = redoStack.length === 0;
    document.getElementById('mobile-undo').disabled = undoStack.length <= 1;
    document.getElementById('mobile-redo').disabled = redoStack.length === 0;
}

function applyVoxelState(state) {
    for (const chunk of chunks.values()) chunk.dispose();
    chunks.clear();
    voxels.clear();
    state.forEach(v => _addSingleVoxel(v.gx, v.gy, v.gz, v.color));
}

// Physics Functions
function initPhysics() {
    physicsWorld = new CANNON.World();
    physicsWorld.gravity.set(0, -10, 0);
    physicsWorld.broadphase = new CANNON.NaiveBroadphase();
    physicsWorld.solver.iterations = 10;
    const groundMaterial = new CANNON.Material("groundMaterial");
    const boundsSize = GRID * VS;
    // Floor
    const groundPlane = new CANNON.Plane();
    const groundBody = new CANNON.Body({ mass: 0, material: groundMaterial });
    groundBody.addShape(groundPlane);
    groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
    groundBody.position.set(0, 0, 0);
    physicsWorld.addBody(groundBody);
    // Ceiling
    const ceilPlane = new CANNON.Plane();
    const ceilBody = new CANNON.Body({ mass: 0, material: groundMaterial });
    ceilBody.addShape(ceilPlane);
    ceilBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 2);
    ceilBody.position.set(0, boundsSize, 0);
    physicsWorld.addBody(ceilBody);
    // Walls
    const wallNZBody = new CANNON.Body({ mass: 0, material: groundMaterial, shape: new CANNON.Plane() });
    wallNZBody.position.set(0, 0, 0);
    physicsWorld.addBody(wallNZBody);
    const wallPZBody = new CANNON.Body({ mass: 0, material: groundMaterial, shape: new CANNON.Plane() });
    wallPZBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), Math.PI);
    wallPZBody.position.set(0, 0, boundsSize);
    physicsWorld.addBody(wallPZBody);
    const wallNXBody = new CANNON.Body({ mass: 0, material: groundMaterial, shape: new CANNON.Plane() });
    wallNXBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), Math.PI / 2);
    wallNXBody.position.set(0, 0, 0);
    physicsWorld.addBody(wallNXBody);
    const wallPXBody = new CANNON.Body({ mass: 0, material: groundMaterial, shape: new CANNON.Plane() });
    wallPXBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -Math.PI / 2);
    wallPXBody.position.set(boundsSize, 0, 0);
    physicsWorld.addBody(wallPXBody);
}

function setControlsEnabled(enabled) {
    const controlsToDisable = [
        'grid-size-slider', 'color-picker', 'color-preset-1', 'color-preset-2', 'color-preset-3',
        'modeToggle', 'clearBtn', 'fillLevelBtn', 'saveBtn', 'loadBtn', 'exportStlBtn',
        'exportObjBtn', 'exportGlbBtn', 'generateVoxelIdeaBtn', 'loadImageTemplateBtn',
        'removeImageTemplateBtn', 'undoBtn', 'redoBtn', 'mobile-undo', 'mobile-redo', 'mobile-save',
        'mobile-mode-toggle', 'mobile-color-picker-btn', 'mobile-axis-toggle', 'mobile-level-up',
        'mobile-level-down', 'mobile-generate-idea'
    ];
    controlsToDisable.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.disabled = !enabled;
    });
}

function togglePhysics() {
    isPhysicsPlaying = !isPhysicsPlaying;
    const playBtnIcon = document.querySelector('#playBtn i');
    const mobilePlayBtnIcon = document.querySelector('#mobile-play i');

    if (isPhysicsPlaying) {
        playBtnIcon.classList.replace('fa-play', 'fa-stop');
        mobilePlayBtnIcon.classList.replace('fa-play', 'fa-stop');
        setControlsEnabled(false);
        sceneStateBeforePhysics = [...voxels.entries()].map(([id, data]) => {
            const p = parseKey(id); return { gx: p[0], gy: p[1], gz: p[2], color: data.color };
        });
        for (const chunk of chunks.values()) chunk.instancedMesh.visible = false;
        gridHelper.visible = false;
        previewVoxelMesh.visible = false;
        initPhysics();
        const voxelMaterial = new CANNON.Material("voxelMaterial");
        sceneStateBeforePhysics.forEach(voxel => {
            const geometry = new THREE.BoxGeometry(VS, VS, VS);
            const material = new THREE.MeshLambertMaterial({ color: voxel.color });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true; mesh.receiveShadow = true;
            const shape = new CANNON.Box(new CANNON.Vec3(HALF, HALF, HALF));
            const body = new CANNON.Body({ mass: 1, material: voxelMaterial, position: new CANNON.Vec3(voxel.gx * VS + HALF, voxel.gy * VS + HALF, voxel.gz * VS + HALF) });
            body.addShape(shape);
            body.angularDamping = 0.5;
            mesh.userData.physicsBody = body;
            body.userData = { mesh: mesh };
            physicsWorld.addBody(body);
            scene.add(mesh);
            physicsBodies.push(body);
            physicsMeshes.push(mesh);
        });
    } else {
        playBtnIcon.classList.replace('fa-stop', 'fa-play');
        mobilePlayBtnIcon.classList.replace('fa-stop', 'fa-play');
        setControlsEnabled(true);
        physicsMeshes.forEach(mesh => {
            scene.remove(mesh); mesh.geometry.dispose(); mesh.material.dispose();
        });
        physicsBodies.forEach(body => { physicsWorld.remove(body); });
        physicsMeshes = []; physicsBodies = []; physicsWorld = null;
        applyVoxelState(sceneStateBeforePhysics);
        sceneStateBeforePhysics = null;
        for (const chunk of chunks.values()) chunk.instancedMesh.visible = true;
        gridHelper.visible = true;
    }
}

// Core Voxel Operations
function _addSingleVoxel(gx, gy, gz, colorHex) {
    const gKey = key(gx, gy, gz); voxels.set(gKey, { color: colorHex });
    const { cx, cy, cz } = getChunkCoords(gx, gy, gz); const cKey = getChunkKey(cx, cy, cz);
    let chunk = chunks.get(cKey);
    if (!chunk) { chunk = new VoxelChunk(cx, cy, cz, CHUNK_SIZE, scene); chunks.set(cKey, chunk); }
    chunk.addVoxel(gx, gy, gz, colorHex);
}

function _removeSingleVoxel(gx, gy, gz) {
    const gKey = key(gx, gy, gz); if (!voxels.has(gKey)) return;
    voxels.delete(gKey);
    const { cx, cy, cz } = getChunkCoords(gx, gy, gz); const cKey = getChunkKey(cx, cy, cz);
    if (chunks.has(cKey)) {
        const chunk = chunks.get(cKey); chunk.removeVoxel(gx, gy, gz);
        if (chunk.instancedMesh.count === 0) { chunk.dispose(); chunks.delete(cKey); }
    }
}

function _recolorSingleVoxel(gx, gy, gz, newColorHex) {
    const gKey = key(gx, gy, gz); if (!voxels.has(gKey)) return;
    voxels.set(gKey, { color: newColorHex });
    const { cx, cy, cz } = getChunkCoords(gx, gy, gz); const cKey = getChunkKey(cx, cy, cz);
    if (chunks.has(cKey)) chunks.get(cKey).updateInstanceColor(chunks.get(cKey).globalToLocalInstanceIdMap.get(gKey), newColorHex);
}

function performVoxelModification(gx, gy, gz, mode, newColor) {
    const gKey = key(gx, gy, gz);
    const hasVoxel = voxels.has(gKey);
    gx = Math.max(0, Math.min(GRID - 1, gx));
    gy = Math.max(0, Math.min(GRID - 1, gy));
    gz = Math.max(0, Math.min(GRID - 1, gz));
    switch (mode) {
        case Modes.ADD: if (!hasVoxel) _addSingleVoxel(gx, gy, gz, newColor); break;
        case Modes.DELETE: if (hasVoxel) _removeSingleVoxel(gx, gy, gz); break;
        case Modes.DRAW: if (hasVoxel && voxels.get(gKey).color !== newColor) _recolorSingleVoxel(gx, gy, gz, newColor); break;
    }
}

// Editor Actions (integrated with new undo/redo)
function clearAll() {
    saveState();
    for (const chunk of chunks.values()) chunk.dispose();
    chunks.clear(); voxels.clear(); rebuildHelpers();
    saveState();
}

function fillActiveLevel() {
    saveState();
    const voxelsToRemove = [];
    for (let x = 0; x < GRID; x++) { for (let z = 0; z < GRID; z++) {
        let gx, gy, gz;
        if (currentDrawingAxis === 'y') { gx = x; gy = activeDrawingLevel.y; gz = z; }
        else if (currentDrawingAxis === 'x') { gx = activeDrawingLevel.x; gy = x; gz = z; }
        else if (currentDrawingAxis === 'z') { gx = x; gy = z; gz = activeDrawingLevel.z; }
        const k = key(gx, gy, gz); if (voxels.has(k)) voxelsToRemove.push(k);
    }}
    voxelsToRemove.forEach(k => { const [gx, gy, gz] = parseKey(k); _removeSingleVoxel(gx, gy, gz); });
    for (let x = 0; x < GRID; x++) { for (let z = 0; z < GRID; z++) {
        let gx, gy, gz;
        if (currentDrawingAxis === 'y') { gx = x; gy = activeDrawingLevel.y; gz = z; }
        else if (currentDrawingAxis === 'x') { gx = activeDrawingLevel.x; gy = x; gz = z; }
        else if (currentDrawingAxis === 'z') { gx = x; gy = z; gz = activeDrawingLevel.z; }
        _addSingleVoxel(gx, gy, gz, currentColor);
    }}
    saveState();
}

function loadProjectData(projectData) {
    try {
        const loadedVoxels = projectData.projectData ? projectData.projectData.voxels : projectData.voxels;
        const loadedSettings = projectData.projectData ? projectData.projectData.settings : projectData.settings;
        
        applyVoxelState([]); // Clear current state
        removeImageTemplate(true);
        
        projectTitle = projectData.title || ''; projectDescription = projectData.description || '';
        projectCategory = projectData.category || 'Allgemein';
        projectTags = Array.isArray(projectData.tags) ? projectData.tags : (typeof projectData.tags === 'string' ? projectData.tags.split(',').map(tag => tag.trim()).filter(tag => tag !== '') : []);
        projectRemixOf = projectData.remixOf || ''; projectSourceJsonUrl = projectData.sourceJsonUrl || ''; projectVisibility = projectData.visibility || 'public';
        if (loadedSettings) {
            GRID = loadedSettings.gridSize !== undefined ? loadedSettings.gridSize : 10;
            document.getElementById('grid-size-slider').value = GRID; document.getElementById('grid-size-display').textContent = `${GRID}×${GRID}×${GRID}`; localStorage.setItem('voxelEditorGridSize', GRID);
        }
        const stateToLoad = [];
        for (const k in loadedVoxels) {
            const colorValue = loadedVoxels[k]; const parts = k.split(',').map(Number);
            if (parts.length === 3 && !isNaN(parts[0]) && !isNaN(parts[1]) && !isNaN(parts[2])) {
                const gx = parts[0]; const gy = parts[1]; const gz = parts[2];
                if (gx >= 0 && gx < GRID && gy >= 0 && gy < GRID && gz >= 0 && gz < GRID) {
                     stateToLoad.push({gx, gy, gz, color: colorValue});
                }
            }
        }
        applyVoxelState(stateToLoad);

        if (loadedSettings) {
             if (loadedSettings.cameraPosition) cam.position.fromArray(loadedSettings.cameraPosition);
            if (loadedSettings.cameraQuaternion) { cam.quaternion.fromArray(loadedSettings.cameraQuaternion); euler.setFromQuaternion(cam.quaternion, 'YXZ'); }
            if (loadedSettings.activeDrawingLevel) {
                activeDrawingLevel = {
                    x: Number(loadedSettings.activeDrawingLevel.x || 0),
                    y: Number(loadedSettings.activeDrawingLevel.y || 0),
                    z: Number(loadedSettings.activeDrawingLevel.z || 0)
                };
            }
            if (loadedSettings.currentDrawingAxis) { currentDrawingAxis = loadedSettings.currentDrawingAxis; }
            currentColor = loadedSettings.currentColor || '#ffffff'; document.getElementById('color-picker').value = currentColor;
            if (loadedSettings.moveSpeed !== undefined) moveSpeed = loadedSettings.moveSpeed; document.getElementById('fly-speed-slider').value = moveSpeed; document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
        }
        undoStack = []; redoStack = []; saveState();
        rebuildHelpers();
        resetCameraPosition();
    } catch (error) {
        showToast('Fehler', 'Fehler beim Laden der Datei. Fehler: ' + error.message, 'error', 5000);
    }
}

// Event Handlers (Pointer, Keyboard, etc.)
function onPointerDown(e) {
    if (isPhysicsPlaying) {
        handlePhysicsPointerDown(e);
        return;
    }
    if (e.button === 2) {
        e.preventDefault(); rightMouseButtonDown = true; cvs.focus(); cvs.requestPointerLock();
        return;
    }
    if (isPointerLocked) return;
    if (e.button === 0 && e.altKey) { /* ... color picker logic ... */ return; }
    
    voxelsAtDragStart = new Map(voxels);
    currentStrokeVoxels.clear();
    isDragging = false;
    initialClickPos = { x: e.clientX, y: e.clientY };
    pointerIsDown = true;
    initialTargetVoxelCoords = calculateRayTargetVoxelCoords(e.clientX, e.clientY);
}

function onPointerMove(e) {
    if (isPhysicsPlaying) {
        handlePhysicsPointerMove(e);
        return;
    }
    if (isPointerLocked || !pointerIsDown) {
        // Update preview voxel on hover when not dragging
        const currentRayHit = calculateRayTargetVoxelCoords(e.clientX, e.clientY);
        if (currentRayHit) {
            let gx = currentRayHit.gx, gy = currentRayHit.gy, gz = currentRayHit.gz;
            if (currentMode === Modes.ADD && currentRayHit.faceNormal) {
                gx += currentRayHit.faceNormal.x; gy += currentRayHit.faceNormal.y; gz += currentRayHit.faceNormal.z;
            }
            gx = Math.max(0, Math.min(GRID - 1, gx)); gy = Math.max(0, Math.min(GRID - 1, gy)); gz = Math.max(0, Math.min(GRID - 1, gz));
            updatePreviewVoxel(gx, gy, gz, true);
        } else {
            updatePreviewVoxel(0, 0, 0, false);
        }
        return;
    }

    const currentMovedDist = initialClickPos ? Math.hypot(e.clientX - initialClickPos.x, e.clientY - initialClickPos.y) : 0;
    if (!isDragging && currentMovedDist > MOVE_PX) {
        isDragging = true;
    }
    
    if (isDragging) {
        const currentTarget = calculateRayTargetVoxelCoords(e.clientX, e.clientY);
        if (currentTarget) {
            let targetCoords = { gx: currentTarget.gx, gy: currentTarget.gy, gz: currentTarget.gz };
             if (currentMode === Modes.ADD && currentTarget.faceNormal) {
                targetCoords.gx += currentTarget.faceNormal.x; targetCoords.gy += currentTarget.faceNormal.y; targetCoords.gz += currentTarget.faceNormal.z;
            }
            targetCoords.gx = Math.max(0, Math.min(GRID - 1, targetCoords.gx));
            targetCoords.gy = Math.max(0, Math.min(GRID - 1, targetCoords.gy));
            targetCoords.gz = Math.max(0, Math.min(GRID - 1, targetCoords.gz));

            if (!lastActionVoxelCoords) lastActionVoxelCoords = initialTargetVoxelCoords;

            const pathVoxels = getVoxelsOnLine(lastActionVoxelCoords, targetCoords);
            pathVoxels.forEach(voxel => {
                const gKey = key(voxel.gx, voxel.gy, voxel.gz);
                if (!currentStrokeVoxels.has(gKey)) {
                     const originalColor = voxelsAtDragStart.has(gKey) ? voxelsAtDragStart.get(gKey).color : null;
                     currentStrokeVoxels.set(gKey, { originalColor });
                }
                performVoxelModification(voxel.gx, voxel.gy, voxel.gz, currentMode, currentColor);
            });
            lastActionVoxelCoords = targetCoords;
            updatePreviewVoxel(targetCoords.gx, targetCoords.gy, targetCoords.gz, true);
        }
    }
}

function onPointerUp(e) {
    if (isPhysicsPlaying) {
        handlePhysicsPointerUp(e);
        return;
    }
    if (e.button === 2) {
        rightMouseButtonDown = false; document.exitPointerLock();
        return;
    }
    
    if (pointerIsDown) {
        if (!isDragging && initialTargetVoxelCoords) { // It was a click, not a drag
            let finalCoords = { ...initialTargetVoxelCoords };
            if (currentMode === Modes.ADD && initialTargetVoxelCoords.faceNormal) {
                finalCoords.gx += initialTargetVoxelCoords.faceNormal.x;
                finalCoords.gy += initialTargetVoxelCoords.faceNormal.y;
                finalCoords.gz += initialTargetVoxelCoords.faceNormal.z;
            }
            finalCoords.gx = Math.max(0, Math.min(GRID - 1, finalCoords.gx));
            finalCoords.gy = Math.max(0, Math.min(GRID - 1, finalCoords.gy));
            finalCoords.gz = Math.max(0, Math.min(GRID - 1, finalCoords.gz));
            performVoxelModification(finalCoords.gx, finalCoords.gy, finalCoords.gz, currentMode, currentColor);
            saveState();
        } else if (isDragging && currentStrokeVoxels.size > 0) { // It was a drag
            saveState();
        }
    }

    pointerIsDown = false; isDragging = false; lastActionVoxelCoords = null; initialClickPos = null;
    initialTargetVoxelCoords = null; voxelsAtDragStart = null; currentStrokeVoxels.clear();
    updatePreviewVoxel(0, 0, 0, false);
}

function onKeyDown(e) {
    // ... existing keydown logic ...
    const activeElement = document.activeElement;
    const isEditingText = activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.isContentEditable);

    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z' && !isEditingText) { e.preventDefault(); undo(); }
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'y' && !isEditingText) { e.preventDefault(); redo(); }
    if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === 'z' && !isEditingText) { e.preventDefault(); redo(); }
    
    keyboard[e.key.toLowerCase()] = true;
}

function onKeyUp(e) {
    keyboard[e.key.toLowerCase()] = false;
}

// Physics Interaction Handlers
function handlePhysicsPointerDown(e) {
    const rect = cvs.getBoundingClientRect();
    const mouse = new THREE.Vector2(((e.clientX - rect.left) / rect.width) * 2 - 1, -((e.clientY - rect.top) / rect.height) * 2 + 1);
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, cam);
    const intersects = raycaster.intersectObjects(physicsMeshes);

    if (intersects.length > 0) {
        const hit = intersects[0];
        const hitBody = hit.object.userData.physicsBody;
        if (hitBody) {
            const hitPoint = hit.point;
            const bodyPoint = new CANNON.Vec3().copy(hitPoint).vsub(hitBody.position);
            
            // Create a kinematic body to act as the mouse anchor
            mouseTargetBody = new CANNON.Body({ mass: 0 });
            mouseTargetBody.position.copy(hitPoint);
            physicsWorld.addBody(mouseTargetBody);

            mouseConstraint = new CANNON.PointToPointConstraint(hitBody, bodyPoint, mouseTargetBody, new CANNON.Vec3(0,0,0));
            physicsWorld.addConstraint(mouseConstraint);
        }
    }
}

function handlePhysicsPointerMove(e) {
    if (mouseConstraint) {
        const rect = cvs.getBoundingClientRect();
        const mouse = new THREE.Vector2(((e.clientX - rect.left) / rect.width) * 2 - 1, -((e.clientY - rect.top) / rect.height) * 2 + 1);
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, cam);

        // Find intersection with a plane parallel to the camera view
        const plane = new THREE.Plane();
        const planePoint = new THREE.Vector3().copy(mouseTargetBody.position);
        plane.setFromNormalAndCoplanarPoint(cam.getWorldDirection(plane.normal), planePoint);

        const intersectionPoint = new THREE.Vector3();
        if (raycaster.ray.intersectPlane(plane, intersectionPoint)) {
            mouseTargetBody.position.copy(intersectionPoint);
        }
    }
}

function handlePhysicsPointerUp(e) {
    if(mouseConstraint) {
        physicsWorld.removeConstraint(mouseConstraint);
        physicsWorld.removeBody(mouseTargetBody);
        mouseConstraint = null;
        mouseTargetBody = null;
    }
}


// Utility and Helper Functions
/**
 * Gets all voxels on a 3D line between two points using Bresenham's line algorithm.
 * @param {object} start - The starting voxel coordinates {gx, gy, gz}.
 * @param {object} end - The ending voxel coordinates {gx, gy, gz}.
 * @returns {Array<object>} An array of voxel coordinate objects on the line.
 */
function getVoxelsOnLine(start, end) {
    const voxelsOnLine = [];
    let x1 = start.gx, y1 = start.gy, z1 = start.gz;
    const x2 = end.gx, y2 = end.gy, z2 = end.gz;

    const dx = Math.abs(x2 - x1);
    const dy = Math.abs(y2 - y1);
    const dz = Math.abs(z2 - z1);
    const sx = (x1 < x2) ? 1 : -1;
    const sy = (y1 < y2) ? 1 : -1;
    const sz = (z1 < z2) ? 1 : -1;

    voxelsOnLine.push({ gx: x1, gy: y1, gz: z1 });

    if (dx >= dy && dx >= dz) { // x is dominant axis
        let err1 = 2 * dy - dx;
        let err2 = 2 * dz - dx;
        while (x1 !== x2) {
            if (err1 >= 0) {
                y1 += sy;
                err1 -= 2 * dx;
            }
            if (err2 >= 0) {
                z1 += sz;
                err2 -= 2 * dx;
            }
            err1 += 2 * dy;
            err2 += 2 * dz;
            x1 += sx;
            voxelsOnLine.push({ gx: x1, gy: y1, gz: z1 });
        }
    } else if (dy >= dx && dy >= dz) { // y is dominant axis
        let err1 = 2 * dx - dy;
        let err2 = 2 * dz - dy;
        while (y1 !== y2) {
            if (err1 >= 0) {
                x1 += sx;
                err1 -= 2 * dy;
            }
            if (err2 >= 0) {
                z1 += sz;
                err2 -= 2 * dy;
            }
            err1 += 2 * dx;
            err2 += 2 * dz;
            y1 += sy;
            voxelsOnLine.push({ gx: x1, gy: y1, gz: z1 });
        }
    } else { // z is dominant axis
        let err1 = 2 * dx - dz;
        let err2 = 2 * dy - dz;
        while (z1 !== z2) {
            if (err1 >= 0) {
                x1 += sx;
                err1 -= 2 * dz;
            }
            if (err2 >= 0) {
                y1 += sy;
                err2 -= 2 * dz;
            }
            err1 += 2 * dx;
            err2 += 2 * dy;
            z1 += sz;
            voxelsOnLine.push({ gx: x1, gy: y1, gz: z1 });
        }
    }
    return voxelsOnLine;
}


function updatePreviewVoxel(x, y, z, visible) {
    if (isPhysicsPlaying) {
        previewVoxelMesh.visible = false;
        return;
    }
    if (previewVoxelMesh) {
        if (visible) {
            previewVoxelMesh.position.set(x * VS + HALF, y * VS + HALF, z * VS + HALF);
            previewVoxelMesh.visible = true;
            previewVoxelMaterial.color.set(currentColor);
            previewVoxelMaterial.opacity = (currentMode === Modes.DELETE) ? 0.2 : 0.5;
        } else {
            previewVoxelMesh.visible = false;
        }
    }
}

function calculateRayTargetVoxelCoords(clientX, clientY) {
    const rect = cvs.getBoundingClientRect();
    const mouse = new THREE.Vector2(
        ((clientX - rect.left) / rect.width) * 2 - 1,
        -((clientY - rect.top) / rect.height) * 2 + 1
    );
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, cam);
    const objectsToIntersect = Array.from(chunks.values()).map(chunk => chunk.instancedMesh);
    const intersects = raycaster.intersectObjects(objectsToIntersect);
    if (intersects.length > 0) {
        const hit = intersects[0];
        const hitNormal = hit.face.normal.clone();
        const intersectionPoint = hit.point;
        const epsilon = 0.001;
        const adjustedPoint = intersectionPoint.clone().addScaledVector(hitNormal, -epsilon);
        const hitVoxelX = Math.floor(adjustedPoint.x / VS);
        const hitVoxelY = Math.floor(adjustedPoint.y / VS);
        const hitVoxelZ = Math.floor(adjustedPoint.z / VS);
        return { gx: hitVoxelX, gy: hitVoxelY, gz: hitVoxelZ, faceNormal: hitNormal, hitExistingVoxel: true };
    } else {
        let planeNormal = new THREE.Vector3(); let planeConstant = 0;
        if (currentDrawingAxis === 'y') { planeNormal.set(0, 1, 0); planeConstant = -(activeDrawingLevel.y * VS); }
        else if (currentDrawingAxis === 'x') { planeNormal.set(1, 0, 0); planeConstant = -(activeDrawingLevel.x * VS); }
        else if (currentDrawingAxis === 'z') { planeNormal.set(0, 0, 1); planeConstant = -(activeDrawingLevel.z * VS); }
        const drawingPlane = new THREE.Plane(planeNormal, planeConstant);
        const intersectionPoint = new THREE.Vector3();
        if (raycaster.ray.intersectPlane(drawingPlane, intersectionPoint)) {
            let gx = Math.floor(intersectionPoint.x / VS); let gy = Math.floor(intersectionPoint.y / VS); let gz = Math.floor(intersectionPoint.z / VS);
            if (currentDrawingAxis === 'y') gy = activeDrawingLevel.y; else if (currentDrawingAxis === 'x') gx = activeDrawingLevel.x; else if (currentDrawingAxis === 'z') gz = activeDrawingLevel.z;
            return { gx, gy, gz, faceNormal: null, hitExistingVoxel: false };
        }
    }
    return null;
}

function rebuildHelpers() {
    if (gridHelper) scene.remove(gridHelper); if (boxHelper) scene.remove(boxHelper);
    const size = GRID * VS;
    if (currentDrawingAxis === 'y') {
        gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444 ); gridHelper.position.set(size / 2, activeDrawingLevel.y * VS, size / 2);
    } else if (currentDrawingAxis === 'x') {
        gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444); gridHelper.rotation.z = Math.PI / 2; gridHelper.position.set(activeDrawingLevel.x * VS, size / 2, size / 2);
    } else if (currentDrawingAxis === 'z') {
        gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444); gridHelper.rotation.x = Math.PI / 2; gridHelper.position.set(size / 2, size / 2, activeDrawingLevel.z * VS);
    }
    scene.add(gridHelper);
    const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(size, size, size));
    boxHelper = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x00ffff }));
    boxHelper.position.set(size / 2, size / 2, size / 2); scene.add(boxHelper);
}

function resetCameraPosition() {
    cam.position.set(GRID * 1.0, GRID * 1.2, GRID * 1.5); cam.lookAt(GRID / 2, GRID / 2, GRID / 2);
    if (euler) euler.setFromQuaternion(cam.quaternion, 'YXZ');
}

// Initialization and Animation Loop
window.onload = async function() {
    closeAllModals();
    try {
        cvs = document.getElementById('voxelCanvas'); containerDiv = document.getElementById('container');
        touchIndicator = document.getElementById('touch-indicator');
        toastContainer = document.getElementById('toast-container');
        scene = new THREE.Scene(); scene.background = new THREE.Color(0x282c34);
        cam = new THREE.PerspectiveCamera(75, containerDiv.clientWidth / containerDiv.clientHeight, 0.1, 1000);
        resetCameraPosition(); euler = new THREE.Euler(0, 0, 0, 'YXZ');
        ren = new THREE.WebGLRenderer({ canvas: cvs, antialias: true });
        ren.setSize(containerDiv.clientWidth, containerDiv.clientHeight);
        isMobile = window.matchMedia('(max-width: 768px)').matches;
        ren.setPixelRatio(isMobile ? Math.min(1.5, window.devicePixelRatio) : window.devicePixelRatio);
        ren.shadowMap.enabled = true; ren.shadowMap.type = THREE.PCFSoftShadowMap;
      
        scene.add(new THREE.AmbientLight(0x606060));
        mainDirectionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        mainDirectionalLight.position.set(10, 20, 15); mainDirectionalLight.castShadow = true;
        mainDirectionalLight.shadow.mapSize.width = mainDirectionalLight.shadow.mapSize.height = 2048;
        mainDirectionalLight.shadow.camera.near = 0.5; mainDirectionalLight.shadow.camera.far = 50;
        mainDirectionalLight.shadow.camera.left = -30; mainDirectionalLight.shadow.camera.right = 30;
        mainDirectionalLight.shadow.camera.top = 30; mainDirectionalLight.shadow.camera.bottom = -30;
        mainDirectionalLight.shadow.bias = -0.0005; mainDirectionalLight.shadow.normalBias = 0.02;
        scene.add(mainDirectionalLight);
        scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.6));
        
        scene.add(previewVoxelMesh);
        rebuildHelpers();

        // Event Listeners
        window.addEventListener('resize', onResize);
        containerDiv.addEventListener('pointerdown', onPointerDown);
        containerDiv.addEventListener('pointermove', onPointerMove);
        containerDiv.addEventListener('pointerup', onPointerUp);
        containerDiv.addEventListener('pointercancel', onPointerUp);
        containerDiv.addEventListener('pointerleave', onPointerUp); // Use same as pointerup
        containerDiv.addEventListener('wheel', onMouseWheel, { passive: false });
        document.addEventListener('keydown', onKeyDown); document.addEventListener('keyup', onKeyUp);
        document.addEventListener('pointerlockchange', onPointerLockChange, false);
        containerDiv.addEventListener('contextmenu', (e) => e.preventDefault());
        
        containerDiv.addEventListener('mousemove', (e) => {
            if (isPointerLocked) {
                mouseMovementX = e.movementX;
                mouseMovementY = e.movementY;
            }
        });

        // UI Element Listeners
        document.getElementById('grid-size-slider').addEventListener('input', (e) => {
            const newGrid = parseInt(e.target.value);
            // ... grid resize logic ...
            GRID = newGrid;
            document.getElementById('grid-size-display').textContent = `${GRID}×${GRID}×${GRID}`;
            localStorage.setItem('voxelEditorGridSize', GRID);
            rebuildHelpers();
            resetCameraPosition();
        });
        
        document.getElementById('clearBtn').addEventListener('click', () => { clearAll(); showToast('Gelöscht', 'Das Projekt wurde geleert.', 'info'); });
        document.getElementById('fillLevelBtn').addEventListener('click', fillActiveLevel);
        
        // New buttons
        document.getElementById('undoBtn').addEventListener('click', undo);
        document.getElementById('redoBtn').addEventListener('click', redo);
        document.getElementById('playBtn').addEventListener('click', togglePhysics);
        document.getElementById('mobile-undo').addEventListener('click', undo);
        document.getElementById('mobile-redo').addEventListener('click', redo);
        document.getElementById('mobile-play').addEventListener('click', togglePhysics);

        // ... rest of the setup logic from the original file ...
        document.getElementById('color-picker').addEventListener('input', (e) => { currentColor = e.target.value; localStorage.setItem('voxelEditorColor', currentColor); });
        document.getElementById('modeToggle').addEventListener('click', () => {
             const modes = Object.values(Modes);
             const currentIndex = modes.indexOf(currentMode);
             currentMode = modes[(currentIndex + 1) % modes.length];
             document.getElementById('current-mode').textContent = `Modus: ${currentMode}`;
        });
        document.getElementById('loadBtn').addEventListener('click', () => document.getElementById('fileInput').click());
        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => { try { loadProjectData(JSON.parse(ev.target.result)); } catch (err) { showToast('Fehler', 'Ungültige JSON-Datei', 'error'); }};
            reader.readAsText(file);
        });

        // Initialize undo/redo system
        saveState(); 

        animate();
    } catch (e) {
        console.error("Initialization failed:", e);
        showToast('Schwerer Fehler', `Ein unerwarteter Fehler ist aufgetreten: ${e.message}.`, 'error', 10000);
    }
};

function onResize() {
    cam.aspect = containerDiv.clientWidth / containerDiv.clientHeight; cam.updateProjectionMatrix();
    ren.setSize(containerDiv.clientWidth, containerDiv.clientHeight);
    ren.setPixelRatio(isMobile ? Math.min(1.5, window.devicePixelRatio) : window.devicePixelRatio);
}

function onMouseWheel(e) {
    e.preventDefault();
    if (e.altKey) { /* ... level changing logic ... */ } 
    else { cam.position.addScaledVector(cam.getWorldDirection(new THREE.Vector3()), e.deltaY * 0.005 * moveSpeed * 5); }
}

function onPointerLockChange() {
    isPointerLocked = document.pointerLockElement === cvs;
    firstMoveAfterLock = isPointerLocked;
}

const keyboard = {};
const frustum = new THREE.Frustum(); const tempCameraMatrix = new THREE.Matrix4();

function animate() {
    requestAnimationFrame(animate);

    if (isPhysicsPlaying) {
        physicsWorld.step(1/60);
        for(let i=0; i<physicsBodies.length; i++){
            physicsMeshes[i].position.copy(physicsBodies[i].position);
            physicsMeshes[i].quaternion.copy(physicsBodies[i].quaternion);
        }
    } 

    if (isPointerLocked) {
        if (firstMoveAfterLock) { 
            firstMoveAfterLock = false; 
            mouseMovementX = 0;
            mouseMovementY = 0;
            return; 
        }

        euler.y -= mouseMovementX * rotSpeed;
        euler.x -= mouseMovementY * rotSpeed;
        euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
        cam.quaternion.setFromEuler(euler);
        
        mouseMovementX = 0;
        mouseMovementY = 0;
    }
    
    // Camera flight controls (always active)
    const camDir = new THREE.Vector3(); cam.getWorldDirection(camDir);
    const rightDir = new THREE.Vector3().crossVectors(camDir, cam.up).normalize();
    const upVec = new THREE.Vector3(0, 1, 0); const currMoveSpeed = moveSpeed * 0.5;
    if (keyboard['w']) cam.position.addScaledVector(camDir, currMoveSpeed);
    if (keyboard['s']) cam.position.addScaledVector(camDir, -currMoveSpeed);
    if (keyboard['a']) cam.position.addScaledVector(rightDir, -currMoveSpeed);
    if (keyboard['d']) cam.position.addScaledVector(rightDir, currMoveSpeed);
    if (keyboard['e'] || keyboard[' ']) cam.position.addScaledVector(upVec, currMoveSpeed);
    if (keyboard['q'] || keyboard['shift']) cam.position.addScaledVector(upVec, -currMoveSpeed);

    cam.updateMatrixWorld(); tempCameraMatrix.multiplyMatrices(cam.projectionMatrix, cam.matrixWorldInverse);
    frustum.setFromProjectionMatrix(tempCameraMatrix);
    if(!isPhysicsPlaying) {
        for (const chunk of chunks.values()) chunk.instancedMesh.visible = frustum.intersectsBox(chunk.boundingBox);
    }
    ren.render(scene, cam);
}

// Dummy functions to avoid breaking the rest of the app for this example
function showToast(title, message, type) { console.log(`Toast: [${type}] ${title} - ${message}`); }
function cycleMode() {}
function saveJSON() {}
function loadJSON() {}
function exportSTL() {}
function exportOBJ() {}
function exportGLB() {}
function onPointerLeave() {}
function closeAllModals() {}
function removeImageTemplate(){}

</script>
</body>
</html>
