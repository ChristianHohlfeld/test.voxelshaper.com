<!DOCTYPE html>
<html lang="de" data-theme="dark">
<head>
<meta charset="UTF-8">
<meta property="og:title" content="VoxelShaper – Create in 3D, Effortlessly" />
<meta property="og:description" content="A powerful, intuitive voxel-based 3D editor – made for makers, artists, and coders." />
<meta property="og:image" content="https://voxelshaper.com/preview.png" />
<meta property="og:url" content="https://voxelshaper.com/" />
<meta property="og:type" content="website" />
<meta name="viewport"
      content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover">
<link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAAANl..."/>

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="VoxelShaper – Create in 3D, Effortlessly">
<meta name="twitter:description" content="A powerful, intuitive voxel-based 3D editor – made for makers, artists, and coders.">
<meta name="twitter:image" content="https://voxelshaper.com/preview.png">
<title>VoxelShaper – Voxel Editor & 3D Print Exporter</title>

<link href="https://cdn.jsdelivr.net/npm/daisyui@4.7.2/dist/full.min.css" rel="stylesheet" type="text/css" />
<script src="https://cdn.tailwindcss.com"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

<style>
/* Basic layout and reset for full screen experience */
html, body {
    height: 100%; /* Ensure html and body take full height */
    margin: 0;
    padding: 0;
}

body {
    padding-top: env(safe-area-inset-top);
    padding-bottom: env(safe-area-inset-bottom);
    padding-left: env(safe-area-inset-left);
    padding-right: env(safe-area-inset-right);
    box-sizing: border-box;
    touch-action: auto; /* Enable default touch actions for general scrolling, but none for canvas specifically */
    -webkit-user-select: none; /* Disable text selection */
    -moz-user-select: none;
    user-select: none;
    display: flex; /* Use flexbox for overall layout */
    flex-direction: column; /* Stack vertically */
    min-height: 100vh; /* Full viewport height */
    overflow: hidden; /* Prevent body scrollbar */
}

/* Canvas specific touch and selection disable */
#container, #voxelCanvas {
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
    -webkit-touch-callout: none; /* Disable long press context menu on iOS */
    touch-action: none; /* Disable all default touch actions on canvas for custom handling */
}

/* Color picker styling for consistent appearance */
input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
input[type="color"]::-webkit-color-swatch { border: none; border-radius: 50%; }
input[type="color"]::-moz-color-swatch-wrapper { padding: 0; }
input[type="color"]::-moz-color-swatch { border: none; border-radius: 50%; }
.color-preset-box::-webkit-color-swatch-wrapper { padding: 0; }
.color-preset-box::-webkit-color-swatch { border: none; border-radius: 0.375rem; }
.color-preset-box::-moz-color-swatch-wrapper { padding: 0; }
.color-preset-box::-moz-color-swatch { border: none; border-radius: 0.375rem; }

/* Toast notification container */
#toast-container {
    position: fixed;
    z-index: 50;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    padding: 1rem;
    pointer-events: none; /* Allow clicks to pass through container */
}

/* Toast position for desktop */
#toast-container.toast-end {
    bottom: 1rem;
    right: 1rem;
    align-items: flex-end;
}

/* Toast position for mobile (top-center) */
@media (max-width: 768px) {
    #toast-container {
        top: 1rem;
        left: 50%;
        transform: translateX(-50%);
        width: calc(100% - 2rem);
        max-width: 300px;
        align-items: center;
    }
    #toast-container.toast-end { /* Override for mobile */
        bottom: auto;
        right: auto;
    }
}

/* Toast animation */
.toast .alert {
    pointer-events: auto; /* Re-enable clicks on individual toasts */
    opacity: 0;
    transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
    transform: translateY(20px);
}

.toast .alert.show {
    opacity: 1;
    transform: translateY(0);
}

/* Mobile specific toast styling */
@media (max-width: 768px) {
    .toast .alert {
        padding: 0.5rem 0.75rem;
        font-size: 0.875rem;
    }
    .toast .alert svg {
        width: 1.25rem;
        height: 1.25rem;
    }
    .toast .alert strong {
        font-size: 0.9rem;
    }
    .toast .alert span {
        font-size: 0.8rem;
    }
    .toast .alert .close-btn {
        font-size: 1rem;
        padding: 0.25rem;
    }
}

/* Mobile floating action buttons */
.mobile-btn {
    width: 64px;
    height: 64px;
    font-size: 2rem;
    border-radius: 50%;
    background-color: var(--fallback-b3, oklch(var(--b3)/1));
    color: var(--fallback-bc, oklch(var(--bc)/1));
    border: 2px solid var(--fallback-bc, oklch(var(--bc)/1));
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
    transition: background-color 0.2s, transform 0.2s;
    text-align: center; /* Ensure text is centered */
    line-height: 1.2; /* Adjust line height for better text fit */
    font-size: 0.8rem; /* Smaller font size for text */
    padding: 0.2rem; /* Add padding for text */
}

.mobile-btn:hover {
    background-color: oklch(var(--bc)/0.2);
}

.mobile-btn:active {
    transform: scale(0.95);
}

#mobile-controls {
    gap: 1rem;
}
</style>
</head>
<body class="bg-base-100 min-h-screen text-base-content flex flex-col">
<!-- Menu toggle for mobile - appears on top right -->
<button id="menuToggle" aria-label="Menü umschalten" class="fixed top-4 right-4 z-[1500] w-10 h-10 text-xl leading-10 text-center bg-base-300 text-base-content border-none rounded-lg cursor: pointer shadow-md hover:bg-base-content/20 lg:hidden">☰</button>

<!-- Main control panel - hidden on mobile by default, shown on desktop -->
<div id="controls" class="flex flex-wrap items-center justify-center gap-3 p-4 bg-base-200 border-b border-base-content/20 hidden md:flex">
    <!-- Desktop Menu Toggle -->
    <button id="desktopMenuToggle" aria-label="Menü umschalten" class="btn btn-sm btn-neutral absolute top-2 right-2 hidden lg:block">Menü ausblenden</button>

    <!-- Grid Size Control -->
    <label for="grid-size-slider" class="text-base-content">Gittergröße:</label>
    <input type="range" id="grid-size-slider" min="5" max="180" value="10" aria-label="Gittergröße anpassen" class="range range-xs w-36">
    <span id="grid-size-display" class="font-bold text-primary">10×10×10</span>
    
    <!-- Color Picker and Presets -->
    <label for="color-picker" class="text-base-content">Farbe:</label>
    <input type="color" id="color-picker" value="#ffffff" aria-label="Aktuelle Farbe wählen" class="input input-bordered w-10 h-10 p-0 rounded-full cursor-pointer border-base-content/20">
    <input type="color" id="color-preset-1" class="color-preset-box w-10 h-10 rounded-md border-2 border-base-content/20 cursor-pointer transition-all duration-200 hover:scale-110" value="#E4002B" aria-label="Voreingestellte Farbe 1">
    <input type="color" id="color-preset-2" class="color-preset-box w-10 h-10 rounded-md border-2 border-base-content/20 cursor-pointer transition-all duration-200 hover:scale-110" value="#00A040" aria-label="Voreingestellte Farbe 2">
    <input type="color" id="color-preset-3" class="color-preset-box w-10 h-10 rounded-md border-2 border-base-content/20 cursor-pointer flex items-center justify-center shadow-lg hover:bg-base-content/20" value="#0057B8" aria-label="Voreingestellte Farbe 3">

    <!-- Mode Toggles and Basic Actions -->
    <button id="modeToggle" aria-label="Modus wechseln" class="btn btn-sm btn-neutral">Modus wechseln</button><span id="current-mode" class="font-bold text-success min-w-40 text-center">Modus: Hinzufügen</span>
    <button id="clearBtn" aria-label="Alles löschen" class="btn btn-sm btn-neutral">Alles löschen</button>
    <button id="fillLevelBtn" aria-label="Ebene füllen" class="btn btn-sm btn-neutral">Ebene füllen</button>
    
    <!-- File Operations: Save, Load, Export -->
    <button id="saveBtn" aria-label="Projekt speichern" aria-describedby="save-description" class="btn btn-sm btn-neutral">Projekt speichern</button>
    <div id="save-description" class="sr-only">Speichert das aktuelle Projekt als JSON-Datei</div>
    <button id="loadBtn" aria-label="Projekt laden" class="btn btn-sm btn-neutral">Projekt laden</button>
    <button id="exportBtn" aria-label="Modell exportieren" class="btn btn-sm btn-neutral">Export</button>

    <!-- Camera Controls -->
    <label for="fly-speed-slider" class="text-base-content">Fluggeschwindigkeit:</label>
    <input type="range" id="fly-speed-slider" min="0.01" max="1.0" step="0.01" value="0.1" aria-label="Fluggeschwindigkeit anpassen" class="range range-xs w-36">
    <span id="fly-speed-display" class="font-bold text-primary">0.10</span>
    <button id="resetCameraBtn" aria-label="Kamera zurücksetzen" class="btn btn-sm btn-neutral">Zur Szene zurückkehen</button>

    <!-- Image Template Load/Remove -->
    <button id="loadImageTemplateBtn" aria-label="Bild als Vorlage laden" class="btn btn-sm btn-neutral">Bild als Vorlage laden</button>
    <button id="removeImageTemplateBtn" class="btn btn-sm btn-neutral hidden" aria-label="Bildvorlage entfernen">Bildvorlage entfernen</button>
    <input type="file" id="imageFileInput" accept="image/*" class="hidden">

    <!-- User & Hub Controls -->
    <button id="loginLogoutBtn" aria-label="Anmelden oder Abmelden" class="btn btn-sm btn-info">Anmelden</button>
    <span id="userIdDisplay" class="font-bold text-info ml-2 mr-2 whitespace-nowrap overflow-hidden text-ellipsis max-w-xs flex items-center gap-1"></span>
    <button id="uploadToHubBtn" aria-label="Auf Hub hochladen" class="btn btn-sm btn-warning">Auf Hub hochladen</button>
    <button id="goToHubBtn" aria-label="Zum VoxelShaper Hub wechseln" class="btn btn-sm btn-secondary">Zum Hub</button>
</div>

<!-- Main 3D Canvas Container -->
<div id="container" class="flex-1 relative border-2 border-transparent box-border overflow-hidden touch-none">
    <canvas id="voxelCanvas" class="w-full h-full block box-border" tabindex="0"></canvas>
    <input type="file" id="fileInput" accept=".json" class="hidden">
</div>

<!-- Modals -->

<!-- Clear Confirmation Modal -->
<dialog id="clearConfirmationModal" class="modal">
    <div class="modal-box bg-base-200 text-base-content p-8 text-center shadow-xl max-w-md">
        <button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2" onclick="clearConfirmationModal.close()">✕</button>
        <h3 class="font-bold text-lg text-primary mb-4">Projekt löschen</h3>
        <p class="py-4">Möchten Sie das aktuelle Projekt speichern, bevor Sie alle Voxel löschen?</p>
        <div class="modal-buttons flex justify-around gap-4 mt-6">
            <button id="saveAndClearBtn" class="confirm-save btn btn-success flex-1">Speichern & Löschen</button>
            <button id="clearWithoutSaveBtn" class="confirm-no-save btn btn-error flex-1">Ohne Speichern löchen</button>
            <button id="cancelClearBtn" class="cancel btn btn-ghost flex-1">Abbrechen</button>
        </div>
    </div>
</dialog>

<!-- Upload Project Modal -->
<dialog id="uploadProjectModal" class="modal">
    <div class="upload-modal-content modal-box bg-base-200 text-base-content p-8 shadow-xl max-w-xl w-11/12 text-left">
        <button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2" onclick="uploadProjectModal.close()">✕</button>
        <h3 class="font-bold text-lg text-primary text-center mb-6">Projekt auf Hub hochladen</h3>
        <label for="uploadTitle" class="label block mb-2 font-bold">Titel:</label>
        <input type="text" id="uploadTitle" placeholder="Ein aussagekräftiger Titel für Ihr Projekt" maxlength="100" class="input input-bordered w-full bg-base-300 border-base-content/20 mb-4">

        <label for="uploadDescription" class="label block mb-2 font-bold">Beschreibung:</label>
        <textarea id="uploadDescription" placeholder="Beschreiben Sie Ihr Projekt kurz" maxlength="500" class="textarea textarea-bordered w-full bg-base-300 border-base-content/20 h-24 mb-4 resize-y"></textarea>

        <label for="uploadCategory" class="label block mb-2 font-bold">Kategorie:</label>
        <select id="uploadCategory" class="select select-bordered w-full bg-base-300 border-base-content/20 mb-4" required>
            <option value="" disabled selected>Kategorie auswählen</option>
        </select>

        <label for="uploadTags" class="label block mb-2 font-bold">Tags (Komma-getrennt):</label>
        <input type="text" id="uploadTags" placeholder="z.B. Haus, Baum, Auto, Gebäude" maxlength="100" class="input input-bordered w-full bg-base-300 border-base-content/20 mb-4">

        <label class="label block mb-2 font-bold">Sichtbarkeit:</label>
        <div class="radio-group flex gap-4 mb-4">
            <label class="flex items-center font-normal">
                <input type="radio" name="uploadVisibility" value="public" checked class="radio radio-primary mr-2"> Öffentlich
            </label>
            <label class="flex items-center font-normal">
                <input type="radio" name="uploadVisibility" value="private" class="radio radio-primary mr-2"> Privat
                </label>
        </div>

        <div class="upload-modal-buttons flex justify-around gap-4 mt-6">
            <button id="uploadConfirmBtn" class="upload-confirm btn btn-success flex-1">Hochladen</button>
            <button id="uploadCancelBtn" class="upload-cancel btn btn-ghost flex-1">Abbrechen</button>
        </div>
    </div>
</dialog>

<!-- Authentication Modal -->
<dialog id="authModal" class="modal">
    <div class="auth-modal-content modal-box bg-base-200 text-base-content p-8 shadow-xl max-w-lg w-11/12 text-center">
        <button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2" onclick="authModal.close()">✕</button>
        <h3 class="font-bold text-lg text-primary mb-6">Anmelden bei VoxelShaper Hub</h3>
        <div class="provider-buttons flex flex-col gap-3">
            <button id="signInGoogleBtn" class="google btn btn-error text-white">
                <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" alt="Google Icon" class="w-5 h-5">
                Mit Google anmelden
            </button>
            <button id="signInGithubBtn" class="github btn bg-neutral text-neutral-content hover:bg-neutral-focus">
                <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/github.svg" alt="GitHub Icon" class="w-5 h-5">
                Mit GitHub anmelden
            </button>
            <button id="showEmailLoginFormBtn" class="email btn btn-info">
                Mit E-Mail anmelden
            </button>
        </div>

        <div id="emailLoginForm" class="email-login-form mt-6 pt-6 border-t border-base-content/20 hidden">
            <form id="emailAuthForm">
                <input type="email" id="emailInput" placeholder="E-Mail" autocomplete="email" class="input input-bordered w-full bg-base-300 border-base-content/20 mb-3">
                <input type="password" id="passwordInput" placeholder="Passwort" autocomplete="current-password" class="input input-bordered w-full bg-base-300 border-base-content/20 mb-3">
                <button type="submit" id="emailSignInBtn" class="btn btn-primary w-full">Anmelden</button>
                <button type="button" id="emailSignUpBtn" class="btn btn-secondary w-full mt-2">Registrieren</button>
            </form>
        </div>

        <div class="close-button-container mt-6">
            <button id="authModalCloseBtn" class="btn btn-ghost">Schließen</button>
        </div>
    </div>
</dialog>

<!-- Export Options Modal (Combines all export formats and settings) -->
<dialog id="exportOptionsModal" class="modal">
    <div class="modal-box bg-base-200 text-base-content p-8 shadow-xl max-w-md">
        <button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2" onclick="exportOptionsModal.close()">✕</button>
        <h3 class="font-bold text-lg text-primary mb-4">Export Optionen</h3>
        
        <!-- Export Format Selection -->
        <div class="form-control mb-4">
            <label class="label"><span class="label-text">Format wählen:</span></label>
            <div class="flex flex-wrap gap-3">
                <label class="flex items-center">
                    <input type="radio" name="exportFormat" value="stl" class="radio radio-primary" />
                    <span class="ml-2">STL</span>
                </label>
                <label class="flex items-center">
                    <input type="radio" name="exportFormat" value="obj" class="radio radio-primary" checked />
                    <span class="ml-2">OBJ</span>
                </label>
                <label class="flex items-center">
                    <input type="radio" name="exportFormat" value="3mf" class="radio radio-primary" />
                    <span class="ml-2">3MF</span>
                </label>
                <label class="flex items-center">
                    <input type="radio" name="exportFormat" value="glb" class="radio radio-primary" />
                    <span class="ml-2">GLB</span>
                </label>
            </div>
        </div>

        <!-- Scale Unit Selection (for STL, OBJ, 3MF) -->
        <div class="form-control mb-4" id="scaleUnitOptions">
            <label class="label"><span class="label-text">Basiseinheit für Export:</span></label>
            <div class="flex gap-3">
                <label class="flex items-center">
                    <input type="radio" name="exportScaleUnit" value="mm" class="radio radio-primary" checked />
                    <span class="ml-2">Millimeter (mm)</span>
                </label>
                <label class="flex items-center">
                    <input type="radio" name="exportScaleUnit" value="cm" class="radio radio-primary" />
                    <span class="ml-2">Zentimeter (cm)</span>
                </label>
            </div>
        </div>

        <!-- Export Up Axis Selection (for STL, OBJ, 3MF) -->
        <div class="form-control mb-4" id="exportAxisOptions">
            <label class="label"><span class="label-text">Up-Achse für Export:</span></label>
            <div class="flex gap-3">
                <label class="flex items-center">
                    <input type="radio" name="exportUpAxis" value="Y" class="radio radio-primary" />
                    <span class="ml-2">Y-Up (Standard)</span>
                </label>
                <label class="flex items-center">
                    <input type="radio" name="exportUpAxis" value="Z" class="radio radio-primary" checked />
                    <span class="ml-2">Z-Up (3D-Drucker)</span>
                </label>
            </div>
        </div>

        <!-- GLB Specific Options -->
        <div id="glbSpecificOptions" class="hidden border-t border-base-content/20 pt-4 mt-4">
            <h4 class="font-semibold text-md mb-3">GLB Spezifische Optionen:</h4>
            <div class="form-control mb-4">
                <label class="label cursor-pointer">
                    <span class="label-text">Game-Ready Export (Optimiert für Spiele-Engines)</span>
                    <input type="checkbox" id="glbGameReadyToggle" class="toggle toggle-primary" checked />
                </label>
            </div>
            <div class="form-control mb-4">
                <label class="label">
                    <span class="label-text">Voxelgröße (mm):</span>
                </label>
                <input type="number" id="glbVoxelSizeInput" class="input input-bordered w-full bg-base-300" value="1" min="0.01" step="0.01">
            </div>
            <div class="form-control mb-4">
                <label class="label cursor-pointer">
                    <span class="label-text">Optimieren (Nach Farbe zusammenführen)</span>
                    <input type="checkbox" id="glbOptimizeToggle" class="toggle toggle-primary" checked />
                </label>
            </div>
        </div>

        <div class="modal-buttons flex justify-around gap-4 mt-6">
            <button id="confirmExportBtn" class="btn btn-success flex-1">Exportieren</button>
            <button id="cancelExportOptionsBtn" class="btn btn-ghost flex-1">Abbrechen</button>
        </div>
    </div>
</dialog>

<!-- Toast Container (for messages) -->
<div id="toast-container" class="toast toast-end z-50"></div>

<!-- Mobile Controls (hidden on desktop) -->
<div id="mobile-controls" class="hidden md:hidden flex-col gap-3 fixed bottom-4 right-4 z-[1000]">
    <button class="mobile-btn" id="mobile-undo" aria-label="Rückgängig machen">↺</button>
    <button class="mobile-btn" id="mobile-redo" aria-label="Wiederholen">↻</button>
    <button class="mobile-btn" id="mobile-save" aria-label="Speichern">💾</button>
    <button class="mobile-btn" id="mobile-camera" aria-label="Kamera zurücksetzen">📷</button>

    <button class="mobile-btn" id="mobile-mode-toggle" aria-label="Modus wechseln">
        <span id="mobile-mode-text">Hinzufügen</span>
    </button>

    <button class="mobile-btn" id="mobile-color-picker-btn" aria-label="Farbe auswählen">🎨</button>
    <input type="color" id="mobile-color-input" value="#ffffff" class="hidden w-0 h-0 opacity-0 absolute">

    <button class="mobile-btn" id="mobile-login-logout" aria-label="Anmelden oder Abmelden">🔑</button>
    <button class="mobile-btn" id="mobile-upload-hub" aria-label="Auf Hub hochladen">⬆️</button>
    <button class="mobile-btn" id="mobile-go-hub" aria-label="Zum VoxelShaper Hub wechseln">🌐</button>
</div>

<!-- Three.js and other libraries -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/GLTFExporter.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

<script type="module">
    // Firebase imports
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import {
        getAuth,
        setPersistence,
        browserLocalPersistence,
        signInWithCustomToken,
        onAuthStateChanged,
        signOut,
        GoogleAuthProvider,
        GithubAuthProvider,
        signInWithPopup,
        createUserWithEmailAndPassword,
        signInWithEmailAndPassword
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import {
        getFirestore,
        doc,
        getDoc,
        collection,
        addDoc,
        serverTimestamp
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // Expose Firebase modules to the global window object for use in non-module scripts
    window.firebase = {
        initializeApp,
        getAuth,
        signInWithCustomToken,
        onAuthStateChanged,
        setPersistence,
        browserLocalPersistence,
        signOut,
        GoogleAuthProvider,
        GithubAuthProvider,
        signInWithPopup,
        createUserWithEmailAndPassword,
        signInWithEmailAndPassword,
        getFirestore,
        doc,
        getDoc,
        collection,
        addDoc,
        serverTimestamp
    };

    // Firebase configuration - using hardcoded config as per user's "prod file"
    const firebaseConfig = {
        apiKey: "AIzaSyB9-mpyAu9W6oiVtB0fYG8E6YFvTAsjtAA", 
        authDomain: "voxelshaper.firebaseapp.com", 
        projectId: "voxelshaper",
        storageBucket: "voxelshaper.appspot.com", 
        messagingSenderId: "1053689247573",
        appId: "1:1053689247573:web:f7960c7f8c2e8849e8e1dc",
        measurementId: "G-QJ5CNKZ5DR"
    };
    window.firebaseConfig = firebaseConfig; // Make config accessible globally
</script>

<script>
// Voxel constants
const VS = 1, HALF = VS * 0.5; // Voxel Size and Half Voxel Size
const CHUNK_SIZE = 16; // Size of a voxel chunk (e.g., 16x16x16 voxels)
const VOX_BITS = 10; // Number of bits to represent a single coordinate (max 1024 range)
const VOX_MASK = (1 << VOX_BITS) - 1; // Mask for extracting coordinate from key
const SHIFT_X = VOX_BITS * 2; // Bit shift for X coordinate in key
const SHIFT_Y = VOX_BITS; // Bit shift for Y coordinate in key

// Utility to create a unique key for voxel coordinates (x,y,z)
function key(x, y, z) { return ((x << SHIFT_X) | (y << SHIFT_Y) | z) >>> 0; }
// Utility to parse a unique key back into voxel coordinates
function parseKey(k) { return [(k >>> SHIFT_X) & VOX_MASK, (k >>> VOX_BITS) & VOX_MASK, k & VOX_MASK]; }
// Get chunk coordinates from global voxel coordinates
function getChunkCoords(x, y, z) { return { cx: Math.floor(x / CHUNK_SIZE), cy: Math.floor(y / CHUNK_SIZE), cz: Math.floor(z / CHUNK_SIZE) }; } // Updated to use x,y,z
// Get string key for a chunk
function getChunkKey(cx, cy, cz) { return `${cx},${cy},${cz}`; }


const VOXEL_DRAG_THRESHOLD = 1;
const PINCH_ZOOM_MULT = 40;
const TAP_DIST_TH = 10;
const MOVE_PX = 10;
const DT_MS = 250;

const ROTATE_SPEED_TOUCH_MOBILE = 0.008;
const PAN_SPEED_TOUCH_MOBILE = 0.2;
const PINCH_ZOOM_MULT_MOBILE = 80;

const ROTATE_SPEED_TOUCH_DESKTOP = 0.004;
const PAN_SPEED_TOUCH_DESKTOP = 0.1; 
const PINCH_ZOOM_MULT_DESKTOP = 40;


let activePointers = new Map();
let gestureState = { type: 'none', startDist: 0, startMid: { x: 0, y: 0 }, lastMid: { x: 0, y: 0 }, lastDist: 0, startTime: 0, initialPointerCount: 0 };
let tapCandidate = null;
let doubleTapDragActive = false;

let scene, cam, ren, gridHelper, boxHelper;
let rotSpeed = 0.004;
let euler;
const voxels = new Map();
const chunks = new Map();

let cvs, containerDiv;
let activeDrawingLevel = { x: 0, y: 0, z: 0 };
let currentDrawingAxis = 'y';

let currentColor = localStorage.getItem('voxelEditorColor') || '#ffffff';
let moveSpeed = parseFloat(localStorage.getItem('voxelEditorFlySpeed') || '0.1');
let GRID = parseInt(localStorage.getItem('voxelEditorGridSize') || '10');

activeDrawingLevel.x = Number(localStorage.getItem('voxelEditorActiveDrawingLevelX') || '0');
if (!Number.isFinite(activeDrawingLevel.x)) activeDrawingLevel.x = 0;
activeDrawingLevel.x = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.x)));

activeDrawingLevel.y = Number(localStorage.getItem('voxelEditorActiveDrawingLevelY') || '0');
if (!Number.isFinite(activeDrawingLevel.y)) activeDrawingLevel.y = 0;
activeDrawingLevel.y = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.y)));

activeDrawingLevel.z = Number(localStorage.getItem('voxelEditorActiveDrawingLevelZ') || '0');
if (!Number.isFinite(activeDrawingLevel.z)) activeDrawingLevel.z = 0;
activeDrawingLevel.z = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.z)));

currentDrawingAxis = localStorage.getItem('voxelEditorCurrentDrawingAxis') || 'y';

const presetColors = [
    localStorage.getItem('voxelPresetColor1') || '#E4002B',
    localStorage.getItem('voxelPresetColor2') || '#00A040',
    localStorage.getItem('voxelPresetColor3') || '#0057B8'
];
let activePresetIndex = -1;
let presetBoxes = [];

let mainDirectionalLight, fillDirectionalLight, hemisphereLight;
let isShiftDragging = false;
let isControlDragging = false;
let isPointerLocked = false;
let lastActionVoxelCoords = null;
let initialClickPos = null;
let initialTargetVoxelCoords = null;
let isDragging = false;
let firstMoveAfterLock = true;
let mouseMovementX = 0;
let mouseMovementY = 0;

const dummy = new THREE.Object3D();
const previewVoxelGeometry = new THREE.BoxGeometry(VS, VS, VS);
const previewVoxelMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5, depthTest: false });
previewVoxelMaterial.polygonOffset = true;
previewVoxelMaterial.polygonOffsetFactor = -1;
let previewVoxelMesh = new THREE.Mesh(previewVoxelGeometry, previewVoxelMaterial);

const Modes = {
    ADD: 'Hinzufügen',
    DELETE: 'Löschen',
    DRAW: 'Zeichnen',
};

const ModeIcons = {
    ADD: 'fas fa-plus',
    DELETE: 'fas fa-eraser',
    DRAW: 'fas fa-paint-brush'
};

const AxisIcons = {
    x: 'fas fa-arrows-alt-h',
    y: 'fas fa-arrows-alt-v',
    z: 'fas fa-arrows-alt'
};

let currentMode = Modes.ADD;

let history = [];
let historyPointer = -1;
const MAX_HISTORY_SIZE = 100;

let currentStrokeVoxels = new Map();
let voxelsAtDragStart = null;

let previewLineInstancedMesh;
const maxPreviewInstances = 180 * 3;
let previewLineVoxels = [];

let templateImageMesh = null;
let templateImageData = null;

let isMobile = window.matchMedia('(max-width: 768px)').matches;

let initialDragVoxelWorldPos = null;
let dragAxisLock = null;
let initialDragVoxelCoords = null;

let projectTitle = '';
let projectDescription = '';
let projectCategory = 'Allgemein';
let projectTags = [];
let projectRemixOf = '';
let projectSourceJsonUrl = '';
let projectVisibility = 'public';

const predefinedCategories = ["Spielzeug", "Dekoration", "Funktional", "Kunst", "Allgemein", "Charaktere", "Fahrzeuge", "Natur", "Architektur", "Abstrakt"];

let lastTapTime = 0;
let lastTapCoords = { x: 0, y: 0 };
const DOUBLE_TAP_TIME_THRESHOLD = 300; // ms
const DOUBLE_TAP_DIST_THRESHOLD = 20; // pixels

class VoxelChunk {
    constructor(chunkX, chunkY, chunkZ, chunkSize, scene) {
        this.chunkX = chunkX; this.chunkY = chunkY; this.chunkZ = chunkZ; this.scene = scene; this.chunkSize = chunkSize;
        this.offsetX = chunkX * chunkSize * VS; this.offsetY = chunkY * chunkSize * VS; this.offsetZ = chunkZ * chunkSize * VS;
        this.voxels = new Map(); this.globalToLocalInstanceIdMap = new Map();
        const maxInstancesInChunk = chunkSize * chunkSize * chunkSize;
        const voxelBaseGeometry = new THREE.BoxGeometry(VS, VS, VS);
        const meshMaterial = new THREE.MeshLambertMaterial();
        this.instancedMesh = new THREE.InstancedMesh(voxelBaseGeometry, meshMaterial, maxInstancesInChunk);
        this.instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(maxInstancesInChunk * 3), 3);
        this.instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        this.instancedMesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
        this.instancedMesh.castShadow = true; this.instancedMesh.receiveShadow = true; this.instancedMesh.count = 0;
        this.instancedMesh.position.set(this.offsetX, this.offsetY, this.offsetZ);
        this.scene.add(this.instancedMesh);
        this.boundingBox = new THREE.Box3(
            new THREE.Vector3(this.offsetX, this.offsetY, this.offsetZ),
            new THREE.Vector3(this.offsetX + chunkSize * VS, this.offsetY + chunkSize * VS, this.offsetZ + chunkSize * VS)
        );
    }
    getLocalKey(gx, gy, gz) { return key(gx % this.chunkSize, gy % this.chunkSize, gz % this.chunkSize); }
    addVoxel(gx, gy, gz, colorHex) {
        const lKey = this.getLocalKey(gx, gy, gz); const gKey = key(gx, gy, gz);
        if (this.voxels.has(lKey)) {
            const instanceId = this.voxels.get(lKey).instanceId;
            this.voxels.set(lKey, { color: colorHex, instanceId }); this.updateInstanceColor(instanceId, colorHex);
        } else {
            const instanceId = this.instancedMesh.count++;
            this.voxels.set(lKey, { color: colorHex, instanceId }); this.globalToLocalInstanceIdMap.set(gKey, instanceId);
            dummy.position.set((gx % this.chunkSize) * VS + HALF, (gy % this.chunkSize) * VS + HALF, (gz % this.chunkSize) * VS + HALF);
            dummy.updateMatrix(); this.instancedMesh.setMatrixAt(instanceId, dummy.matrix);
            this.updateInstanceColor(instanceId, colorHex);
            this.instancedMesh.instanceMatrix.needsUpdate = true; this.instancedMesh.instanceColor.needsUpdate = true;
        }
    }
    removeVoxel(gx, gy, gz) {
        const lKey = this.getLocalKey(gx, gy, gz); const gKey = key(gx, gy, gz);
        if (!this.voxels.has(lKey)) return;
        const { instanceId: removedId } = this.voxels.get(lKey);
        this.voxels.delete(lKey); this.globalToLocalInstanceIdMap.delete(gKey);
        const lastId = this.instancedMesh.count - 1;
        if (removedId !== lastId) {
            let lastVoxelLKey = null;
            for (const [lk, data] of this.voxels.entries()) { if (data.instanceId === lastId) { lastVoxelLKey = lk; break; } }
            if (lastVoxelLKey !== null) {
                const tempMatrix = new THREE.Matrix4(); this.instancedMesh.getMatrixAt(lastId, tempMatrix);
                this.instancedMesh.setMatrixAt(removedId, tempMatrix);
                this.updateInstanceColor(removedId, this.voxels.get(lastVoxelLKey).color);
                this.voxels.get(lastVoxelLKey).instanceId = removedId;
                const [lx, ly, lz] = parseKey(lastVoxelLKey);
                this.globalToLocalInstanceIdMap.set(key(this.chunkX * this.chunkSize + lx, this.chunkY * this.chunkSize + ly, this.chunkZ * this.chunkSize + lz), removedId);
            }
        }
        this.instancedMesh.count--;
        this.instancedMesh.instanceMatrix.needsUpdate = true; this.instancedMesh.instanceColor.needsUpdate = true;
    }
    recolorVoxel(gx, gy, gz, newColorHex) {
        const lKey = this.getLocalKey(gx, gy, gz);
        if (!this.voxels.has(lKey)) return;
        const { instanceId } = this.voxels.get(lKey);
        this.voxels.set(lKey, { color: newColorHex }); // Only update color, instanceId remains the same
        this.updateInstanceColor(instanceId, newColorHex);
    }
    updateInstanceColor(instanceId, hex) {
        const c = new THREE.Color(hex); this.instancedMesh.instanceColor.setXYZ(instanceId, c.r, c.g, c.b);
        this.instancedMesh.instanceColor.needsUpdate = true;
    }
    dispose() {
        this.scene.remove(this.instancedMesh);
        this.instancedMesh.geometry.dispose(); this.instancedMesh.material.dispose();
        this.instancedMesh = null; this.voxels.clear(); this.globalToLocalInstanceIdMap.clear();
    }
}

function onResize() {
    cam.aspect = containerDiv.clientWidth / containerDiv.clientHeight; cam.updateProjectionMatrix();
    ren.setSize(containerDiv.clientWidth, containerDiv.clientHeight);
    ren.setPixelRatio(isMobile ? Math.min(1.5, window.devicePixelRatio) : window.devicePixelRatio);
}

function handleGesture() {
    const pointers = [...activePointers.values()];
    if (pointers.length === 0) return;

    if (pointers.length === 1) {
        const p = pointers[0];
        const rotateSpeed = isMobile ? ROTATE_SPEED_TOUCH_MOBILE : ROTATE_SPEED_TOUCH_DESKTOP;
        
        euler.y += (p.x - gestureState.lastMid.x) * rotateSpeed;
        euler.x -= (p.y - gestureState.lastMid.y) * rotateSpeed;
        
        euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
        cam.quaternion.setFromEuler(euler);
        gestureState.lastMid = { x: p.x, y: p.y };
        return;
    }

    if (pointers.length >= 2) {
        const [p0, p1] = pointers;
        const midX = (p0.x + p1.x) * 0.5;
        const midY = (p0.y + p1.y) * 0.5;
        const dist = Math.hypot(p1.x - p0.x, p1.y - p0.y);

        if (gestureState.type === 'none') {
            const dMid = Math.hypot(midX - gestureState.startMid.x, midY - gestureState.startMid.y);
            const PINCH_REL_TH = 0.05;
            const relDelta = Math.abs(dist - gestureState.startDist) / gestureState.startDist;
            if (relDelta > PINCH_REL_TH) {
                gestureState.type = 'pinch';
            } else if (dMid > MOVE_PX) {
                gestureState.type = 'pan';
            }
            return;
        } else if (gestureState.type === 'pinch') {
            const pinchZoomMult = isMobile ? PINCH_ZOOM_MULT_MOBILE : PINCH_ZOOM_MULT_DESKTOP;
            const zoomDelta = (dist / gestureState.lastDist - 1) * pinchZoomMult * moveSpeed;
            cam.position.addScaledVector(cam.getWorldDirection(new THREE.Vector3()), zoomDelta);
            gestureState.lastDist = dist;
        } else if (gestureState.type === 'pan') {
            const panSpeed = isMobile ? PAN_SPEED_TOUCH_MOBILE : PAN_SPEED_TOUCH_DESKTOP;
            const dx = (midX - gestureState.lastMid.x) * panSpeed;
            const dy = (midY - gestureState.lastMid.y) * panSpeed;
            
            const right = new THREE.Vector3().crossVectors(cam.getWorldDirection(new THREE.Vector3()), cam.up).normalize();
            cam.position.addScaledVector(right, dx);
            cam.position.addScaledVector(new THREE.Vector3(0, 1, 0), dy);
            
            gestureState.lastMid = { x: midX, y: midY };
        }
    }
}

function releasePointer(id, eventType) {
    activePointers.delete(id);
    if (activePointers.size < 2) {
        gestureState.type = 'none';
        if (activePointers.size === 1) { const last = [...activePointers.values()][0]; gestureState.lastMid = { x: last.x, y: last.y }; }
    }
    if (activePointers.size === 0) {
        doubleTapDragActive = false; lastActionVoxelCoords = null; 
        initialDragVoxelWorldPos = null; dragAxisLock = null; initialDragVoxelCoords = null;
        previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
    }
}

function rebuildHelpers() {
    if (gridHelper) scene.remove(gridHelper);
    if (boxHelper) scene.remove(boxHelper);

    const size = GRID * VS;

    if (isMobile) {
        // On mobile, grid helper is always fixed to y-axis for simplicity as per user request
        gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444 );
        gridHelper.position.set(size / 2, activeDrawingLevel.y * VS, size / 2);
    } else {
        if (currentDrawingAxis === 'y') {
            gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444 );
            gridHelper.position.set(size / 2, activeDrawingLevel.y * VS, size / 2);
        } else if (currentDrawingAxis === 'x') {
            gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444);
            gridHelper.rotation.z = Math.PI / 2;
            gridHelper.position.set(activeDrawingLevel.x * VS, size / 2, size / 2);
        } else if (currentDrawingAxis === 'z') {
            gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444);
            gridHelper.rotation.x = Math.PI / 2;
            gridHelper.position.set(size / 2, size / 2, activeDrawingLevel.z * VS);
        }
    }
    scene.add(gridHelper);

    const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(size, size, size));
    boxHelper = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x00ffff }));
    boxHelper.position.set(size / 2, size / 2, size / 2);
    scene.add(boxHelper);
}

function updateGridHelperPosition() {
    rebuildHelpers();
    localStorage.setItem('voxelEditorActiveDrawingLevelX', activeDrawingLevel.x);
    localStorage.setItem('voxelEditorActiveDrawingLevelY', activeDrawingLevel.y);
    localStorage.setItem('voxelEditorActiveDrawingLevelZ', activeDrawingLevel.z);
    localStorage.setItem('voxelEditorCurrentDrawingAxis', currentDrawingAxis);
}

function cycleMode() {
    const activeElement = document.activeElement;
    if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'SELECT' || activeElement.tagName === 'TEXTAREA')) {
        cvs.focus();
        return;
    }
    switch (currentMode) {
        case Modes.ADD: currentMode = Modes.DELETE; break;
        case Modes.DELETE: currentMode = Modes.DRAW; break;
        case Modes.DRAW: currentMode = Modes.ADD; break;
    }
    document.getElementById('current-mode').textContent = `Modus: ${currentMode}`;
    const mobileModeText = document.getElementById('mobile-mode-text');
    if (mobileModeText) {
        mobileModeText.textContent = currentMode;
    }
    lastActionVoxelCoords = null;
    updatePreviewVoxel(0, 0, 0, false);
    previewLineInstancedMesh.count = 0;
    previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
    previewLineVoxels = [];
}

function setActivePreset(index) {
    if (index >= 0 && index < presetColors.length) {
        currentColor = presetColors[index];
        document.getElementById('color-picker').value = currentColor;
        const mobileColorInput = document.getElementById('mobile-color-input');
        if (mobileColorInput) mobileColorInput.value = currentColor;
        localStorage.setItem('voxelEditorColor', currentColor);
        presetBoxes.forEach((box, i) => {
            if (i === index) { box.classList.add('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'); }
            else { box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'); }
        });
        activePresetIndex = index;
        if (previewVoxelMesh.visible) {
            previewVoxelMaterial.color.set(currentColor);
        }
    }
}

function savePresetColor(index, colorValue) {
    if (index >= 0 && index < presetColors.length) {
        presetColors[index] = colorValue;
        localStorage.setItem(`voxelPresetColor${index + 1}`, colorValue);
        if (activePresetIndex === index) {
            currentColor = colorValue;
            document.getElementById('color-picker').value = currentColor;
            const mobileColorInput = document.getElementById('mobile-color-input');
            if (mobileColorInput) mobileColorInput.value = currentColor;
            localStorage.setItem('voxelEditorColor', currentColor);
        }
    }
}

function applyVoxelState(state) {
    for (const chunk of chunks.values()) chunk.dispose();
    chunks.clear();
    voxels.clear();
    state.forEach(v => _addSingleVoxel(v.x, v.y, v.z, v.color)); // Changed v.gx,v.gy,v.gz to v.x,v.y,v.z
}

function addCommand(type, oldState = null, newState = null, commandData = null) {
    if (historyPointer < history.length - 1) history.splice(historyPointer + 1);
    history.push({ type, oldState, newState, commandData });
    historyPointer++;
    if (history.length > MAX_HISTORY_SIZE) {
        history.shift();
        historyPointer--;
    }
}

function executeCommand(command, reverse = false) {
    const { type, oldState, newState, commandData } = command;
    switch (type) {
        case 'batch':
            applyVoxelState(reverse ? oldState : newState);
            break;
        case 'clearAll':
            clearAllInternal(true);
            if (reverse) applyVoxelState(oldState);
            break;
        case 'fillLevel':
            applyVoxelState(reverse ? oldState : newState);
            break;
        case 'resizeGrid':
            GRID = reverse ? commandData.oldGrid : commandData.newGrid;
            document.getElementById('grid-size-slider').value = GRID;
            document.getElementById('grid-size-display').textContent = `${GRID}×${GRID}×${GRID}`;
            localStorage.setItem('voxelEditorGridSize', GRID);
            applyVoxelState(reverse ? oldState : newState);
            break;
    }
    rebuildHelpers();
}

function undo() { if (historyPointer >= 0) { executeCommand(history[historyPointer], true); historyPointer--; } }
function redo() { if (historyPointer < history.length - 1) { historyPointer++; executeCommand(history[historyPointer], false); } }

function _addSingleVoxel(x, y, z, colorHex) { // Changed gx,gy,gz to x,y,z
    const gKey = key(x, y, z);
    voxels.set(gKey, { color: colorHex });
    const { cx, cy, cz } = getChunkCoords(x, y, z); // Changed gx,gy,gz to x,y,z
    const cKey = getChunkKey(cx, cy, cz);
    let chunk = chunks.get(cKey);
    if (!chunk) {
        chunk = new VoxelChunk(cx, cy, cz, CHUNK_SIZE, scene);
        chunks.set(cKey, chunk);
    }
    chunk.addVoxel(x, y, z, colorHex); // Changed gx,gy,gz to x,y,z
}

function _removeSingleVoxel(x, y, z) { // Changed gx,gy,gz to x,y,z
    const gKey = key(x, y, z);
    if (!voxels.has(gKey)) return;
    voxels.delete(gKey);
    const { cx, cy, cz } = getChunkCoords(x, y, z); // Changed gx,gy,gz to x,y,z
    const cKey = getChunkKey(cx, cy, cz);
    if (chunks.has(cKey)) {
        const chunk = chunks.get(cKey);
        chunk.removeVoxel(x, y, z); // Changed gx,gy,gz to x,y,z
        if (chunk.instancedMesh.count === 0) {
            chunk.dispose();
            chunks.delete(cKey);
        }
    }
}

function _recolorSingleVoxel(x, y, z, newColorHex) { // Changed gx,gy,gz to x,y,z
    const gKey = key(x, y, z);
    if (!voxels.has(gKey)) return;
    voxels.set(gKey, { color: newColorHex });
    const { cx, cy, cz } = getChunkCoords(x, y, z); // Changed gx,gy,gz to x,y,z
    const cKey = getChunkKey(cx, cy, cz);
    if (chunks.has(cKey)) chunks.get(cKey).recolorVoxel(x, y, z, newColorHex); // Changed gx,gy,gz to x,y,z
}

function performVoxelModification(x, y, z, mode, newColor) { // Changed gx,gy,gz to x,y,z
    const gKey = key(x, y, z); // Changed gx,gy,gz to x,y,z
    const hasVoxel = voxels.has(gKey);

    x = Math.max(0, Math.min(GRID - 1, x)); // Changed gx to x
    y = Math.max(0, Math.min(GRID - 1, y)); // Changed gy to y
    z = Math.max(0, Math.min(GRID - 1, z)); // Changed gz to z

    switch (mode) {
        case Modes.ADD:
            if (!hasVoxel) {
                _addSingleVoxel(x, y, z, newColor);
            }
            break;
        case Modes.DELETE:
            if (hasVoxel) {
                _removeSingleVoxel(x, y, z);
            }
            break;
        case Modes.DRAW:
            if (hasVoxel) {
                if (voxels.get(gKey).color !== newColor) {
                    _recolorSingleVoxel(x, y, z, newColor);
                }
            }
            break;
    }
}

function updatePreviewVoxel(x, y, z, visible) {
    if (previewVoxelMesh) {
        if (visible) {
            if (previewVoxelMesh.geometry.parameters.width !== VS ||
                previewVoxelMesh.geometry.parameters.height !== VS ||
                previewVoxelMesh.geometry.parameters.depth !== VS) {
                previewVoxelMesh.geometry.dispose();
                previewVoxelMesh.geometry = new THREE.BoxGeometry(VS, VS, VS);
            }
            previewVoxelMesh.position.set(x * VS + HALF, y * VS + HALF, z * VS + HALF);
            previewVoxelMesh.visible = true;
            previewVoxelMaterial.color.set(currentColor);
            previewVoxelMaterial.opacity = (currentMode === Modes.DELETE) ? 0.2 : 0.5;
        } else {
            previewVoxelMesh.visible = false;
        }
    }
}

function calculateRayTargetVoxelCoords(clientX, clientY) {
    if (isPointerLocked) return null;

    const rect = cvs.getBoundingClientRect();
    const mouse = new THREE.Vector2(
        ((clientX - rect.left) / rect.width) * 2 - 1,
        -((clientY - rect.top) / rect.height) * 2 + 1
    );

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, cam);

    const objectsToIntersect = Array.from(chunks.values()).map(chunk => chunk.instancedMesh);
    if (templateImageMesh) {
        templateImageMesh.raycast = function() {};
    }

    const intersects = raycaster.intersectObjects(objectsToIntersect);

    // Try to find a hit on an existing voxel
    let hitResult = null;
    if (intersects.length > 0) {
        // Filter intersections if dragging to avoid hitting newly placed voxels in the current stroke.
        const effectiveIntersects = isDragging ? intersects.filter(hit => {
            const hitVoxelKey = key( // Changed gx,gy,gz to x,y,z
                Math.floor(hit.point.x / VS),
                Math.floor(hit.point.y / VS),
                Math.floor(hit.point.z / VS)
            );
            return !currentStrokeVoxelKeys.has(hitVoxelKey);
        }) : intersects;

        if (effectiveIntersects.length > 0) {
            const hit = effectiveIntersects[0];
            const hitNormal = hit.face.normal.clone();
            const intersectionPoint = hit.point;

            if (!Number.isFinite(intersectionPoint.x) || !Number.isFinite(intersectionPoint.y) || !Number.isFinite(intersectionPoint.z)) {
                return null;
            }

            const epsilon = 0.001; // Small offset to ensure we're inside the hit voxel
            let adjustedPoint = intersectionPoint.clone().addScaledVector(hitNormal, -epsilon);

            let hitVoxelX = Math.floor(adjustedPoint.x / VS);
            let hitVoxelY = Math.floor(adjustedPoint.y / VS);
            let hitVoxelZ = Math.floor(adjustedPoint.z / VS);

            // Apply projection for ADD mode, otherwise use the hit voxel's coordinates directly
            if (currentMode === Modes.ADD) {
                 hitVoxelX += hitNormal.x;
                 hitVoxelY += hitNormal.y;
                 hitVoxelZ += hitNormal.z;
            }
            
            // Clamp projected/hit coordinates to grid boundaries
            hitVoxelX = Math.max(0, Math.min(GRID - 1, hitVoxelX));
            hitVoxelY = Math.max(0, Math.min(GRID - 1, hitVoxelY));
            hitVoxelZ = Math.max(0, Math.min(GRID - 1, hitVoxelZ));

            hitResult = { x: Number(hitVoxelX), y: Number(hitVoxelY), z: Number(hitVoxelZ), faceNormal: hitNormal, hitExistingVoxel: true }; // Changed gx,gy,gz to x,y,z
            if (!Number.isFinite(hitResult.x) || !Number.isFinite(hitResult.y) || !Number.isFinite(hitResult.z)) { // Changed gx,gy,gz to x,y,z
                hitResult = null;
            }
        }
    }

    // If no *valid* voxel was hit, proceed based on mode
    if (hitResult === null) {
        if (currentMode === Modes.ADD) {
            // For ADD mode, if no voxel is hit, intersect with a stable drawing plane.
            let planeNormal = new THREE.Vector3();
            let planeConstant = 0; // Default to 0, will be adjusted by activeDrawingLevel

            if (currentDrawingAxis === 'y') {
                planeNormal.set(0, 1, 0);
                planeConstant = -(activeDrawingLevel.y * VS);
            } else if (currentDrawingAxis === 'x') {
                planeNormal.set(1, 0, 0);
                planeConstant = -(activeDrawingLevel.x * VS);
            } else if (currentDrawingAxis === 'z') {
                planeNormal.set(0, 0, 1);
                planeConstant = -(activeDrawingLevel.z * VS);
            }

            const drawingPlane = new THREE.Plane(planeNormal, planeConstant);
            const intersectionPoint = new THREE.Vector3();

            if (raycaster.ray.intersectPlane(drawingPlane, intersectionPoint)) {
                if (!Number.isFinite(intersectionPoint.x) || !Number.isFinite(intersectionPoint.y) || !Number.isFinite(intersectionPoint.z)) {
                    return null;
                }

                let x = Math.floor(intersectionPoint.x / VS); // Changed gx to x
                let y = Math.floor(intersectionPoint.y / VS); // Changed gy to y
                let z = Math.floor(intersectionPoint.z / VS); // Changed gz to z

                // Crucially, snap to the activeDrawingLevel for the current axis.
                if (currentDrawingAxis === 'y') y = activeDrawingLevel.y; // Changed gy to y
                else if (currentDrawingAxis === 'x') x = activeDrawingLevel.x; // Changed gx to x
                else if (currentDrawingAxis === 'z') z = activeDrawingLevel.z; // Changed gz to z

                // Clamp these coordinates to ensure they are within grid bounds
                x = Math.max(0, Math.min(GRID - 1, x)); // Changed gx to x
                y = Math.max(0, Math.min(GRID - 1, y)); // Changed gy to y
                z = Math.max(0, Math.min(GRID - 1, z)); // Changed gz to z
                
                hitResult = { x: x, y: y, z: z, faceNormal: null, hitExistingVoxel: false };
            }
        }
        // For DELETE or DRAW modes, if no existing voxel is hit, hitResult remains null.
        // This prevents operations on empty space for these modes.
    }
    return hitResult; // Return the final hit result or null
}

function clearAllInternal(fromHistory = false) {
    if (!fromHistory) {
        const oldState = [...voxels.entries()].map(([id, data]) => { const p = parseKey(id); return { x: p[0], y: p[1], z: p[2], color: data.color }; }); // Changed gx,gy,gz to x,y,z
        addCommand('clearAll', oldState, []);
    }
    for (const chunk of chunks.values()) chunk.dispose();
    chunks.clear();
    voxels.clear();
    rebuildHelpers();
}
function clearAll() { clearAllInternal(false); }

function fillActiveLevel() {
    const oldState = [...voxels.entries()].map(([id, data]) => { const p = parseKey(id); return { x: p[0], y: p[1], z: p[2], color: data.color }; }); // Changed gx,gy,gz to x,y,z
    const voxelsToRemove = [];
    for (let x = 0; x < GRID; x++) {
        for (let z = 0; z < GRID; z++) {
            let cx, cy, cz; // Renamed for clarity, not to conflict with x,y,z as voxel coords
            if (currentDrawingAxis === 'y') { cx = x; cy = activeDrawingLevel.y; cz = z; }
            else if (currentDrawingAxis === 'x') { cx = activeDrawingLevel.x; cy = x; cz = z; }
            else if (currentDrawingAxis === 'z') { cx = x; cy = z; cz = activeDrawingLevel.z; }
            const k = key(cx, cy, cz); // Changed gx,gy,gz to x,y,z
            if (voxels.has(k)) voxelsToRemove.push(k);
        }
    }
    voxelsToRemove.forEach(k => { const p = parseKey(k); _removeSingleVoxel(p[0], p[1], p[2]); }); // Changed gx,gy,gz to x,y,z

    const newState = [];
    for (let x = 0; x < GRID; x++) {
        for (let z = 0; z < GRID; z++) {
            let cx, cy, cz; // Renamed for clarity
            if (currentDrawingAxis === 'y') { cx = x; cy = activeDrawingLevel.y; cz = z; }
            else if (currentDrawingAxis === 'x') { cx = activeDrawingLevel.x; cy = x; cz = z; }
            else if (currentDrawingAxis === 'z') { cx = x; cy = z; cz = activeDrawingLevel.z; }
            _addSingleVoxel(cx, cy, cz, currentColor); // Changed gx,gy,gz to x,y,z
            newState.push({ x: cx, y: cy, z: cz, color: currentColor, dimX: 1, dimY: 1, dimZ: 1 }); // Changed gx,gy,gz to x,y,z
        }
    }
    addCommand('fillLevel', oldState, newState);
}

function saveJSON() {
    const data = {};
    voxels.forEach((value, k) => {
        const p = parseKey(k);
        data[`${p[0]},${p[1]},${p[2]}`] = value.color;
    });

    const settings = {
        gridSize: GRID,
        cameraPosition: cam.position.toArray(),
        cameraQuaternion: cam.quaternion.toArray(),
        activeDrawingLevel: activeDrawingLevel,
        currentDrawingAxis: currentDrawingAxis,
        currentColor: currentColor,
        presetColors: presetColors,
        activePresetIndex: activePresetIndex,
        moveSpeed: moveSpeed,
        templateImageData: templateImageData
    };

    const fileContent = {
        title: projectTitle,
        description: projectDescription,
        category: projectCategory,
        tags: projectTags,
        remixOf: projectRemixOf,
        sourceJsonUrl: projectSourceJsonUrl,
        visibility: projectVisibility,
        fileName: `${projectTitle.replace(/\s+/g, "_") || "voxel_project"}.json`,
        timestamp: new Date().toISOString(),

        projectData: {
            settings: settings,
            voxels: data
        }
    };

    downloadBlob(new Blob([JSON.stringify(fileContent, null, 2)], { type: 'application/json' }), fileContent.fileName);
    showToast('Speichern erfolgreich', 'Projekt als JSON-Datei gespeichert.', 'success', 5000);
}

function resetToDefaultProject() {
    clearAllInternal(true);
    GRID = 10;
    document.getElementById('grid-size-slider').value = GRID;
    document.getElementById('grid-size-display').textContent = `${GRID}×${GRID}×${GRID}`;
    localStorage.setItem('voxelEditorGridSize', GRID);

    currentColor = '#ffffff';
    document.getElementById('color-picker').value = currentColor;
    localStorage.setItem('voxelEditorColor', currentColor);
    const mobileColorInput = document.getElementById('mobile-color-input');
    if (mobileColorInput) mobileColorInput.value = currentColor;

    activeDrawingLevel = { x: 0, y: 0, z: 0 };
    currentDrawingAxis = 'y';
    localStorage.setItem('voxelEditorActiveDrawingLevelX', activeDrawingLevel.x);
    localStorage.setItem('voxelEditorActiveDrawingLevelY', activeDrawingLevel.y);
    localStorage.setItem('voxelEditorActiveDrawingLevelZ', activeDrawingLevel.z);
    localStorage.setItem('voxelEditorCurrentDrawingAxis', currentDrawingAxis);

    moveSpeed = 0.1;
    document.getElementById('fly-speed-slider').value = moveSpeed;
    document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
    localStorage.setItem('voxelEditorEditorFlySpeed', moveSpeed);

    presetColors[0] = '#E4002B';
    presetColors[1] = '#00A040';
    presetColors[2] = '#0057B8';
    localStorage.setItem('voxelPresetColor1', presetColors[0]);
    localStorage.setItem('voxelPresetColor2', presetColors[1]);
    localStorage.setItem('voxelPresetColor3', presetColors[2]);
    presetBoxes.forEach((box, i) => { box.value = presetColors[i]; box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'); });
    activePresetIndex = -1;
    removeImageTemplate(true);

    history.length = 0;
    historyPointer = -1;

    previewLineInstancedMesh.count = 0;
    previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
    previewLineVoxels = [];

    projectTitle = ''; projectDescription = ''; projectCategory = 'Allgemein'; projectTags = []; projectRemixOf = ''; projectSourceJsonUrl = ''; projectVisibility = 'public';

    rebuildHelpers();
    resetCameraPosition();
    showToast('Projekt zurückgesetzt', 'Das Projekt wurde auf den Standardzustand zurückgesetzt.', 'info', 5000);
}

function loadProjectData(projectData) {
    try {
        const loadedVoxels = projectData.projectData ? projectData.projectData.voxels : projectData.voxels;
        const loadedSettings = projectData.projectData ? projectData.projectData.settings : projectData.settings; // Corrected: Use projectData.projectData.settings
        clearAllInternal(true);
        removeImageTemplate(true);

        projectTitle = projectData.title || '';
        projectDescription = projectData.description || '';
        projectCategory = projectData.category || 'Allgemein';
        projectTags = Array.isArray(projectData.tags) ? projectData.tags : (typeof projectData.tags === 'string' ? projectData.tags.split(',').map(tag => tag.trim()).filter(tag => tag !== '') : []);
        projectRemixOf = projectData.remixOf || '';
        projectSourceJsonUrl = projectData.sourceJsonUrl || '';
        projectVisibility = projectData.visibility || 'public';

        if (loadedSettings) {
            GRID = loadedSettings.gridSize !== undefined ? loadedSettings.gridSize : 10;
            document.getElementById('grid-size-slider').value = GRID;
            document.getElementById('grid-size-display').textContent = `${GRID}×${GRID}×${GRID}`;
            localStorage.setItem('voxelEditorGridSize', GRID);
        }
        for (const k in loadedVoxels) {
            const colorValue = loadedVoxels[k];
            const parts = k.split(',').map(Number);
            if (parts.length === 3 && !isNaN(parts[0]) && !isNaN(parts[1]) && !isNaN(parts[2])) {
                const x = parts[0];
                const y = parts[1];
                const z = parts[2];
                if (x >= 0 && x < GRID && y >= 0 && y < GRID && z >= 0 && z < GRID) _addSingleVoxel(x, y, z, colorValue);
            }
        }
        if (loadedSettings) {
            if (loadedSettings.cameraPosition) cam.position.fromArray(loadedSettings.cameraPosition);
            if (loadedSettings.cameraQuaternion) { cam.quaternion.fromArray(loadedSettings.cameraQuaternion); euler.setFromQuaternion(cam.quaternion, 'YXZ'); }
            if (loadedSettings.activeDrawingLevel) {
                activeDrawingLevel = {
                    x: Number(loadedSettings.activeDrawingLevel.x || 0),
                    y: Number(loadedSettings.activeDrawingLevel.y || 0),
                    z: Number(loadedSettings.activeDrawingLevel.z || 0)
                };
                if (!Number.isFinite(activeDrawingLevel.x)) activeDrawingLevel.x = 0;
                if (!Number.isFinite(activeDrawingLevel.y)) activeDrawingLevel.y = 0;
                if (!Number.isFinite(activeDrawingLevel.z)) activeDrawingLevel.z = 0;

                activeDrawingLevel.x = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.x)));
                activeDrawingLevel.y = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.y)));
                activeDrawingLevel.z = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.z)));

                localStorage.setItem('voxelEditorActiveDrawingLevelX', activeDrawingLevel.x);
                localStorage.setItem('voxelEditorActiveDrawingLevelY', activeDrawingLevel.y);
                localStorage.setItem('voxelEditorActiveDrawingLevelZ', activeDrawingLevel.z);
            }
            if (loadedSettings.currentDrawingAxis) { currentDrawingAxis = loadedSettings.currentDrawingAxis; localStorage.setItem('voxelEditorCurrentDrawingAxis', currentDrawingAxis); }
            updateGridHelperPosition();
            currentColor = loadedSettings.currentColor || '#ffffff';
            document.getElementById('color-picker').value = currentColor;
            const mobileColorInput = document.getElementById('mobile-color-input');
            if (mobileColorInput) mobileColorInput.value = currentColor;

            if (loadedSettings.presetColors) {
                for(let i = 0; i < loadedSettings.presetColors.length && i < presetColors.length; i++) {
                    presetColors[i] = loadedSettings.presetColors[i];
                    document.getElementById(`color-preset-${i + 1}`).value = presetColors[i];
                    localStorage.setItem(`voxelPresetColor${i + 1}`, presetColors[i]);
                }
            }
            setActivePreset(loadedSettings.activePresetIndex !== undefined ? loadedSettings.activePresetIndex : -1);
            if (loadedSettings.moveSpeed !== undefined) {
                moveSpeed = loadedSettings.moveSpeed;
                document.getElementById('fly-speed-slider').value = moveSpeed;
                document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
                localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
            }
            if (loadedSettings.templateImageData) {
                templateImageData = loadedSettings.templateImageData;
                new THREE.TextureLoader().load(templateImageData.src, (texture) => {
                    const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true, depthWrite: false });
                    const geometry = new THREE.PlaneGeometry(templateImageData.scaledWidth, templateImageData.scaledHeight);
                    if (templateImageMesh) { scene.remove(templateImageMesh); templateImageMesh.geometry.dispose(); templateImageMesh.material.dispose(); }
                    templateImageMesh = new THREE.Mesh(geometry, material);
                    templateImageMesh.position.fromArray(templateImageData.position);
                    templateImageMesh.rotation.fromArray(templateImageData.rotation);
                    templateImageMesh.scale.fromArray(templateImageData.scale);
                    templateImageMesh.renderOrder = -1;
                    scene.add(templateImageMesh);
                    document.getElementById('removeImageTemplateBtn').classList.remove('hidden');
                }, undefined, (err) => {
                    templateImageMesh = null; templateImageData = null; document.getElementById('removeImageTemplateBtn').classList.add('hidden');
                });
            }
        }
        history.length = 0;
        historyPointer = -1;

        previewLineInstancedMesh.count = 0;
        previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
        previewLineVoxels = [];
        resetCameraPosition();
    } catch (error) {
        showToast('Fehler', 'Fehler beim Laden der Datei. Stellen Sie sicher, dass es sich um gültige JSON-Datei handelt! Fehler: ' + error.message, 'error', 5000);
        resetToDefaultProject();
    }
}

async function loadProjectFromModelId(modelId) {
    showToast('Lade Projekt', `Lade Projekt mit ID: ${modelId}...`, 'info', 5000);
    try {
        // Corrected path to match Firestore rules: /models/{modelId}
        const docRef = window.firebase.doc(db, "models", modelId);
        const docSnap = await window.firebase.getDoc(docRef);

        if (docSnap.exists()) {
            const pData = docSnap.data();
            // The rules allow read only if public and verified. If docSnap.exists(), it means the read was allowed by rules.
            // We still check for projectData structure here.
            if (pData && pData.projectData) {
                projectRemixOf = modelId;
                projectSourceJsonUrl = window.location.href;
                loadProjectData(pData);
                showToast('Projekt geladen', `Projekt "${docSnap.data().title}" erfolgreich geladen.`, 'success', 5000);
            } else {
                showToast('Fehler', 'Projektdaten im Dokument nicht gefunden.', 'error', 5000);
                resetToDefaultProject();
            }
        } else {
            // This case means the document doesn't exist OR the user doesn't have permission to read it.
            // The Firestore rules will prevent docSnap.exists() from being true if permission is denied.
            showToast('Projekt nicht gefunden', `Kein Projekt mit ID "${modelId}" gefunden oder Sie haben keine Berechtigung, es zu lesen.`, 'warning', 5000);
            resetToDefaultProject();
        }
    } catch (error) {
        // Handle Firestore permission errors specifically
        if (error.code === 'permission-denied') {
            showToast('Zugriff verweigert', `Berechtigungsfehler beim Laden des Projekts. Stellen Sie sicher, dass das Modell öffentlich und verifiziert ist oder Sie der Eigentümer sind.`, 'error', 5000);
        } else {
            showToast('Fehler', `Fehler beim Laden des Projekts: ${error.message}`, 'error', 5000);
        }
        resetToDefaultProject();
    }
}

function loadJSON(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const projectData = JSON.parse(e.target.result);
            projectRemixOf = '';
            projectSourceJsonUrl = '';
            loadProjectData(projectData);
        } catch (error) {
            showToast('Fehler', 'Fehler beim Parsen der Datei. Stellen Sie sicher, dass it is a valid JSON file. Error: ' + error.message, 'error', 5000);
            resetToDefaultProject();
        }
    };
    reader.readAsText(file);
}

function buildMergedGeometry(optimizeMesh = false, effectiveVoxelSize = VS) {
    const tempBoxGeometry = new THREE.BoxGeometry(effectiveVoxelSize, effectiveVoxelSize, effectiveVoxelSize);
    
    // If optimizing, return an array of geometries grouped by color
    if (optimizeMesh) {
        const geometriesByColor = new Map(); // Map: colorHex -> Array of geometries
        voxels.forEach((data, k) => {
            const p = parseKey(k); // p is [x,y,z]
            const color = data.color;
            if (!geometriesByColor.has(color)) {
                geometriesByColor.set(color, []);
            }
            dummy.position.set(p[0] * effectiveVoxelSize + effectiveVoxelSize * 0.5,
                                p[1] * effectiveVoxelSize + effectiveVoxelSize * 0.5,
                                p[2] * effectiveVoxelSize + effectiveVoxelSize * 0.5);
            dummy.updateMatrix();
            const instanceGeometry = tempBoxGeometry.clone();
            instanceGeometry.applyMatrix4(dummy.matrix);
            geometriesByColor.get(color).push(instanceGeometry);
        });

        const mergedColorGeometries = [];
        geometriesByColor.forEach((geoms, colorHex) => {
            if (geoms.length > 0) {
                const merged = THREE.BufferGeometryUtils.mergeBufferGeometries(geoms, true); // true for merging coincident vertices
                if (merged) {
                    // Add color attribute to the merged geometry for GLB vertex colors or simply for tracking
                    const c = new THREE.Color(colorHex);
                    const vtxColorArr = [];
                    for (let j = 0; j < merged.attributes.position.count; j++) {
                        vtxColorArr.push(c.r, c.g, c.b);
                    }
                    merged.setAttribute('color', new THREE.Float32BufferAttribute(vtxColorArr, 3));
                    mergedColorGeometries.push({ geometry: merged, colorHex: colorHex });
                }
                geoms.forEach(g => g.dispose()); // Dispose individual geometries
            }
        });
        tempBoxGeometry.dispose();
        return mergedColorGeometries; // Returns array of {geometry, colorHex}
    } else {
        // Non-optimized path: merge all into a single geometry, preserving per-vertex colors
        const allGeometries = [];
        voxels.forEach((data, k) => {
            const p = parseKey(k); // p is [x,y,z]
            dummy.position.set(p[0] * effectiveVoxelSize + effectiveVoxelSize * 0.5,
                                p[1] * effectiveVoxelSize + effectiveVoxelSize * 0.5,
                                p[2] * effectiveVoxelSize + effectiveVoxelSize * 0.5);
            dummy.updateMatrix();
            const instanceGeometry = tempBoxGeometry.clone();
            instanceGeometry.applyMatrix4(dummy.matrix);

            const c = new THREE.Color(data.color);
            const vtxColorArr = [];
            for (let j = 0; j < instanceGeometry.attributes.position.count; j++) {
                vtxColorArr.push(c.r, c.g, c.b);
            }
            instanceGeometry.setAttribute('color', new THREE.Float32BufferAttribute(vtxColorArr, 3));
            allGeometries.push(instanceGeometry);
        });

        const mergedGeometry = allGeometries.length > 0 ? THREE.BufferGeometryUtils.mergeBufferGeometries(allGeometries, true) : new THREE.BufferGeometry();
        allGeometries.forEach(g => g.dispose()); // Dispose individual geometries
        tempBoxGeometry.dispose();
        return { geometry: mergedGeometry, colorHex: null }; // Returns single {geometry, colorHex} object (colorHex is null)
    }
}

function downloadBlob(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

// Function to apply axis transformation
function applyAxisTransform(geometry, upAxis) {
    if (upAxis === 'Z') {
        // Rotate from Y-up (Three.js default) to Z-up: Rotate -90 degrees around X axis
        geometry.rotateX(-Math.PI / 2);
    }
    // If upAxis is 'Y', no transformation needed as Three.js is Y-up by default
}

async function exportSTL(exportScaleUnit, exportUpAxis) {
    if (voxels.size === 0) { showToast('Export fehlgeschlagen', 'Keine Voxel zum Exportieren vorhanden!', 'warning', 5000); return; }
    showToast('Exportiere STL', 'Erzeuge STL-Modell...', 'info', 5000);

    const effectiveVoxelSize = exportScaleUnit === 'mm' ? VS : VS / 10;
    const { geometry: mergedGeometry } = buildMergedGeometry(false, effectiveVoxelSize); 
    
    // Apply axis transform before creating the mesh for export
    applyAxisTransform(mergedGeometry, exportUpAxis);

    const tempMesh = new THREE.Mesh(mergedGeometry);

    if (typeof THREE.STLExporter === 'undefined') { showToast('Export fehlgeschlagen', 'STLExporter-Bibliothek nicht geladen.', 'error', 5000); return; }
    const exporter = new THREE.STLExporter();
    const result = exporter.parse(tempMesh);

    downloadBlob(new Blob([result], { type: 'application/octet-stream' }), 'voxel_model.stl');
    
    if (mergedGeometry) mergedGeometry.dispose();
    tempMesh.geometry.dispose();
    if (tempMesh.material) tempMesh.material.dispose();

    showToast('Export erfolgreich', `STL-Modell erfolgreich in ${exportScaleUnit} exportiert!`, 'success', 5000);
}

async function exportOBJ(exportScaleUnit, exportUpAxis) {
    if (voxels.size === 0) { 
        showToast('Export fehlgeschlagen', 'Keine Voxel zum Exportieren vorhanden!', 'warning', 5000); 
        return; 
    }
    showToast('Exportiere OBJ', 'Erzeuge optimiertes OBJ-Modell...', 'info', 5000);

    const effectiveVoxelSize = exportScaleUnit === 'mm' ? VS : VS / 10;
    const mergedColorGeometries = buildMergedGeometry(true, effectiveVoxelSize);
    
    let objContent = `# VoxelShaper OBJ Export\n`;
    let mtlContent = `# VoxelShaper MTL Export\n`;
    let vertexOffset = 0;
    const materialNames = new Map();

    if (mergedColorGeometries.length > 0) {
        objContent += `mtllib voxel_model.mtl\n`;

        objContent += `# Vertex Normals\n`;
        objContent += `vn 0.0000 0.0000 1.0000 # 1: +Z\n`;
        objContent += `vn 0.0000 0.0000 -1.0000 # 2: -Z\n`;
        objContent += `vn 1.0000 0.0000 0.0000 # 3: +X\n`;
        objContent += `vn -1.0000 0.0000 0.0000 # 4: -X\n`;
        objContent += `vn 0.0000 1.0000 0.0000 # 5: +Y\n`;
        objContent += `vn 0.0000 -1.0000 0.0000 # 6: -Y\n`;
        objContent += '\n';

        mergedColorGeometries.forEach(({ geometry, colorHex }, index) => {
            if (!geometry || !geometry.attributes.position || geometry.attributes.position.count === 0) {
                console.warn(`Skipping empty geometry for color ${colorHex}`);
                if (geometry) geometry.dispose();
                return;
            }

            // Apply axis transform to each geometry before processing
            applyAxisTransform(geometry, exportUpAxis);
            
            const matName = `material_${colorHex.replace('#', '')}`;
            materialNames.set(colorHex, matName);

            const c = new THREE.Color(colorHex);
            mtlContent += `newmtl ${matName}\n`;
            mtlContent += `Kd ${c.r.toFixed(4)} ${c.g.toFixed(4)} ${c.b.toFixed(4)}\n`;
            mtlContent += `Ka ${c.r.toFixed(4)} ${c.g.toFixed(4)} ${c.b.toFixed(4)}\n`;
            mtlContent += `Ks 0.0 0.0 0.0\n`;
            mtlContent += `Ns 0.0\n`;
            mtlContent += `d 1.0\n`;
            mtlContent += `illum 1\n\n`;

            objContent += `g object_${index}\n`;
            objContent += `usemtl ${matName}\n`;

            const positions = geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                objContent += `v ${positions[i].toFixed(4)} ${positions[i+1].toFixed(4)} ${positions[i+2].toFixed(4)}\n`;
            }

            const indices = geometry.index ? geometry.index.array : Array.from({ length: positions.length / 3 }, (_, i) => i);
            const positionAttribute = geometry.attributes.position;

            for (let i = 0; i < indices.length; i += 3) {
                const v1_idx = indices[i] + 1 + vertexOffset;
                const v2_idx = indices[i+1] + 1 + vertexOffset;
                const v3_idx = indices[i+2] + 1 + vertexOffset;

                const p1 = new THREE.Vector3().fromBufferAttribute(positionAttribute, indices[i]);
                const p2 = new THREE.Vector3().fromBufferAttribute(positionAttribute, indices[i+1]);
                const p3 = new THREE.Vector3().fromBufferAttribute(positionAttribute, indices[i+2]);

                const cb = new THREE.Vector3().subVectors(p3, p2);
                const ab = new THREE.Vector3().subVectors(p1, p2);
                const faceNormal = cb.cross(ab).normalize();

                let normalIndex = 1;
                if (Math.abs(faceNormal.x) > Math.abs(faceNormal.y) && Math.abs(faceNormal.x) > Math.abs(faceNormal.z)) {
                    normalIndex = faceNormal.x > 0 ? 3 : 4;
                } else if (Math.abs(faceNormal.y) > Math.abs(faceNormal.z)) {
                    normalIndex = faceNormal.y > 0 ? 5 : 6;
                } else {
                    normalIndex = faceNormal.z > 0 ? 1 : 2;
                }
                
                objContent += `f ${v1_idx}//${normalIndex} ${v2_idx}//${normalIndex} ${v3_idx}//${normalIndex}\n`;
            }
            vertexOffset += positions.length / 3;
            geometry.dispose();
        });
    } else {
        const { geometry: mergedGeometrySingle } = buildMergedGeometry(false, effectiveVoxelSize);
        if (mergedGeometrySingle && mergedGeometrySingle.attributes.position && mergedGeometrySingle.attributes.position.count > 0) {
            applyAxisTransform(mergedGeometrySingle, exportUpAxis); // Apply transform here too

            objContent += `mtllib voxel_model.mtl\n`;
            objContent += `# Vertex Normals\n`;
            objContent += `vn 0.0000 0.0000 1.0000 # 1: +Z\n`;
            objContent += `vn 0.0000 0.0000 -1.0000 # 2: -Z\n`;
            objContent += `vn 1.0000 0.0000 0.0000 # 3: +X\n`;
            objContent += `vn -1.0000 0.0000 0.0000 # 4: -X\n`;
            objContent += `vn 0.0000 1.0000 0.0000 # 5: +Y\n`;
            objContent += `vn 0.0000 -1.0000 0.0000 # 6: -Y\n`;
            objContent += '\n';

            const positions = mergedGeometrySingle.attributes.position.array;
            const indices = mergedGeometrySingle.index ? mergedGeometrySingle.index.array : Array.from({ length: positions.length / 3 }, (_, i) => i);

            const tempMaterialName = `material_default`;
            mtlContent += `newmtl ${tempMaterialName}\n`;
            mtlContent += `Kd 1.0 1.0 1.0\nKa 1.0 1.0 1.0\nKs 0.0 0.0 0.0\nNs 0.0\nd 1.0\nillum 1\n\n`;
            objContent += `usemtl ${tempMaterialName}\n`;

            for (let i = 0; i < positions.length; i += 3) {
                objContent += `v ${positions[i].toFixed(4)} ${positions[i+1].toFixed(4)} ${positions[i+2].toFixed(4)}\n`;
            }
            
            const positionAttribute = mergedGeometrySingle.attributes.position;
            for (let i = 0; i < indices.length; i += 3) {
                const v1_idx = indices[i] + 1;
                const v2_idx = indices[i+1] + 1;
                const v3_idx = indices[i+2] + 1;

                const p1 = new THREE.Vector3().fromBufferAttribute(positionAttribute, indices[i]);
                const p2 = new THREE.Vector3().fromBufferAttribute(positionAttribute, indices[i+1]);
                const p3 = new THREE.Vector3().fromBufferAttribute(positionAttribute, indices[i+2]);

                const cb = new THREE.Vector3().subVectors(p3, p2);
                const ab = new THREE.Vector3().subVectors(p1, p2);
                const faceNormal = cb.cross(ab).normalize();

                let normalIndex = 1;
                if (Math.abs(faceNormal.x) > Math.abs(faceNormal.y) && Math.abs(faceNormal.x) > Math.abs(faceNormal.z)) {
                    normalIndex = faceNormal.x > 0 ? 3 : 4;
                } else if (Math.abs(faceNormal.y) > Math.abs(faceNormal.z)) {
                    normalIndex = faceNormal.y > 0 ? 5 : 6;
                } else {
                    normalIndex = faceNormal.z > 0 ? 1 : 2;
                }
                objContent += `f ${v1_idx}//${normalIndex} ${v2_idx}//${normalIndex} ${v3_idx}//${normalIndex}\n`;
            }
            mergedGeometrySingle.dispose();
        }
    }

    const zip = new JSZip();
    zip.file("voxel_model.obj", objContent);
    zip.file("voxel_model.mtl", mtlContent);

    const now = new Date();
    const dateStr = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}_${now.getHours().toString().padStart(2, '0')}-${now.getMinutes().toString().padStart(2, '0')}-${now.getSeconds().toString().padStart(2, '0')}`;
    const filename = `voxelshaper_export_${dateStr}.zip`;

    const content = await zip.generateAsync({ type: "blob", compression: "DEFLATE" });
    downloadBlob(content, filename);

    showToast('Export erfolgreich', `OBJ-Modell erfolgreich in ${exportScaleUnit} exportiert und als ZIP verpackt!`, 'success', 5000);
}

async function export3MF(exportScaleUnit, exportUpAxis) {
    if (voxels.size === 0) {
        showToast('Export fehlgeschlagen', 'Keine Voxel zum Exportieren vorhanden!', 'warning', 5000);
        return;
    }
    showToast('Exportiere 3MF', 'Erzeuge 3MF-Modell mit Farben...', 'info', 5000);

    try {
        if (typeof JSZip === 'undefined') {
            showToast('Export fehlgeschlagen', 'JSZip-bibliothek nicht geladen.', 'error', 5000);
            return;
        }

        const zip = new JSZip();

        const contentTypesXml = `<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
    <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
    <Default Extension="model" ContentType="application/vnd.ms-package.3dmanufacturing-3dmodel+xml"/>
    <Default Extension="png" ContentType="image/png"/>
    <Default Extension="jpg" ContentType="image/jpeg"/>
    <Default Extension="xml" ContentType="application/xml"/>
</Types>`;
        zip.file("[Content_Types].xml", contentTypesXml);

        const relsXml = `<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
    <Relationship Target="/3D/3DModel.model" Id="rel-1" Type="http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel"/>
</Relationships>`;
        zip.file("_rels/.rels", relsXml);

        const effectiveVoxelSize = exportScaleUnit === 'mm' ? VS : VS / 10;

        const mergedColorGeometries = buildMergedGeometry(true, effectiveVoxelSize);

        let modelXml = `<?xml version="1.0" encoding="UTF-8"?>
<model unit="${exportScaleUnit}" xml:lang="en-US" xmlns="http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel" xmlns:material="http://schemas.microsoft.com/3dmanufacturing/material/2015/02">
    <resources>`;
        
        let colorPaletteId = 0;
        let colorIndexMap = new Map();
        modelXml += `<material:colorgroup id="1">`; // Define a single color group
        mergedColorGeometries.forEach(({ colorHex }) => {
            modelXml += `<material:color color="${colorHex}"/>`;
            colorIndexMap.set(colorHex, colorPaletteId++);
        });
        modelXml += `</material:colorgroup>`;

        let objectIdCounter = 1;
        const tempBoxGeometry = new THREE.BoxGeometry(effectiveVoxelSize, effectiveVoxelSize, effectiveVoxelSize);


        mergedColorGeometries.forEach(({ geometry: mergedGeometryForColor, colorHex }) => {
            if (!mergedGeometryForColor || mergedGeometryForColor.attributes.position.count === 0) {
                 console.warn(`Skipping empty geometry for color ${colorHex}`);
                if (mergedGeometryForColor) mergedGeometryForColor.dispose();
                return;
            }

            // Apply axis transform to each geometry before processing
            applyAxisTransform(mergedGeometryForColor, exportUpAxis);

            const positions = mergedGeometryForColor.attributes.position.array;
            const indices = mergedGeometryForColor.index ? mergedGeometryForColor.index.array : Array.from({ length: positions.length / 3 }, (_, i) => i);

            modelXml += `<object id="${objectIdCounter + 1}" type="model">
                <mesh>
                    <vertices>`;
            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];
                const y = positions[i + 1];
                const z = positions[i + 2];
                modelXml += `<vertex x="${x.toFixed(4)}" y="${y.toFixed(4)}" z="${z.toFixed(4)}" />`;
            }
            modelXml += `</vertices>
                    <triangles>`;
            for (let i = 0; i < indices.length; i += 3) {
                const v1 = indices[i];
                const v2 = indices[i + 1];
                const v3 = indices[i + 2];
                modelXml += `<triangle v1="${v1}" v2="${v2}" v3="${v3}" pid="1" p1="${colorIndexMap.get(colorHex)}" p2="${colorIndexMap.get(colorHex)}" p3="${colorIndexMap.get(colorHex)}"/>`;
            }
            modelXml += `</triangles>
                </mesh>
            </object>`;
            
            mergedGeometryForColor.dispose();
            objectIdCounter++;
        });
        tempBoxGeometry.dispose();

        modelXml += `</resources>
    <build>`;
        for(let i = 1; i < objectIdCounter; i++) {
            modelXml += `<item objectid="${i+1}"/>`;
        }
    modelXml += `</build>
</model>`;

        zip.file("3D/3DModel.model", modelXml);

        const content = await zip.generateAsync({ type: "blob", compression: "DEFLATE" });
        downloadBlob(content, 'voxel_model.3mf');

        showToast('Export erfolgreich', `3MF-Modell erfolgreich in ${exportScaleUnit} exportiert!`, 'success', 5000);

    } catch (error) {
        showToast('Export fehlgeschlagen', `Fehler beim Exportieren des 3MF-modells: ${error.message}`, 'error', 5000);
    }
}


async function exportGLBWithOptions(options) {
    if (voxels.size === 0) {
        showToast('Export fehlgeschlagen', 'Keine Voxel zum Exportieren vorhanden!', 'warning', 5000);
        return;
    }
    showToast('Exportiere GLB', 'Erzeuge GLB-Modell...', 'info', 5000);

    try {
        if (typeof THREE.GLTFExporter === 'undefined') {
            throw new Error('GLTFExporter-Bibliothek nicht geladen.');
        }

        const exporter = new THREE.GLTFExporter();
        const tempGroup = new THREE.Group();
        
        const materialCache = new Map();

        const effectiveVoxelSize = VS;
        const geometriesOrSingleGeometry = buildMergedGeometry(options.splitByColorAndMerge, effectiveVoxelSize);

        let geometriesToProcess = [];
        if (Array.isArray(geometriesOrSingleGeometry)) {
            geometriesToProcess = geometriesOrSingleGeometry;
        } else {
            geometriesToProcess = [geometriesOrSingleGeometry];
        }

        for (const { geometry: currentGeometry, colorHex } of geometriesToProcess) {
            if (!currentGeometry || currentGeometry.attributes.position.count === 0) {
                console.warn(`Skipping empty geometry for color ${colorHex || 'default'}`);
                if (currentGeometry) currentGeometry.dispose();
                continue;
            }

            const geometryClone = currentGeometry.clone();
                                                            
            if (options.floorPivot || options.gameReady) {
                geometryClone.computeBoundingBox();
                const boundingBox = geometryClone.boundingBox;
                const center = boundingBox.getCenter(new THREE.Vector3());
                const pivotShift = new THREE.Vector3(
                    -center.x,
                    options.floorPivot ? -boundingBox.min.y : -center.y,
                    -center.z
                );
                geometryClone.translate(pivotShift.x, pivotShift.y, pivotShift.z);
            }

            const scaleFactor = options.voxelSizeMM / 1000;
            geometryClone.scale(scaleFactor, scaleFactor, scaleFactor);

            let material;
            if (colorHex && options.splitByColorAndMerge) {
                material = materialCache.get(colorHex);
                if (!material) {
                    material = new THREE.MeshStandardMaterial({ color: new THREE.Color(colorHex), name: `mat_${colorHex.replace('#', '')}` });
                    materialCache.set(colorHex, material);
                }
            } else {
                material = materialCache.get('#FFFFFF');
                if (!material) {
                    material = new THREE.MeshStandardMaterial({ color: new THREE.Color(0xffffff), name: 'mat_default' });
                    materialCache.set('#FFFFFF', material);
                }
            }
            
            tempGroup.add(new THREE.Mesh(geometryClone, material));
        }
        
        exporter.parse(
            tempGroup,
            function (result) {
                downloadBlob(new Blob([result], { type: 'model/gltf-binary' }), 'voxel_model.glb');
                showToast('Export erfolgreich', `GLB-Modell erfolgreich in Metern (Voxelgröße ${options.voxelSizeMM}mm) exportiert!`, 'success', 5000);
            },
            function (error) {
                showToast('Export fehlgeschlagen', `Fehler beim Exportieren des GLB-Modells: ${error.message}`, 'error', 5000);
            },
            { binary: true }
        );

    } catch (error) {
        showToast('Export fehlgeschlagen', `Fehler beim Exportieren des GLB-Modells: ${error.message}`, 'error', 5000);
    } finally {
        if (Array.isArray(geometriesOrSingleGeometry)) {
            geometriesToProcess.forEach(({ geometry }) => {
                if (geometry) geometry.dispose();
            });
        } else if (geometriesOrSingleGeometry && geometriesOrSingleGeometry.geometry) {
            geometriesOrSingleGeometry.geometry.dispose();
        }

        materialCache.forEach(mat => mat.dispose());
        materialCache.clear();
        while(tempGroup.children.length > 0){
            const object = tempGroup.children[0];
            tempGroup.remove(object);
            if (object.geometry) object.geometry.dispose();
            if (object.material) object.material.dispose();
        }
    }
}


function showToast(title, message, type = 'info', duration = 5000) {
    const toast = document.createElement('div');
    toast.className = `alert shadow-lg ${type === 'info' ? 'alert-info' : type === 'success' ? 'alert-success' : type === 'error' ? 'alert-error' : type === 'warning' ? 'alert-warning' : ''}`;
    toast.innerHTML = `
        ${type === 'info' ? '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" class="stroke-current shrink-0 h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>' : ''}
        ${type === 'success' ? '<svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>' : ''}
        ${type === 'error' ? '<svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>' : ''}
        ${type === 'warning' ? '<svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>' : ''}
        <div><strong>${title}</strong><br><span>${message}</span></div><button class="close-btn btn btn-ghost btn-sm">&times;</button>`;
    toastContainer.appendChild(toast);
    void toast.offsetWidth;
    toast.classList.add('show');
    toast.querySelector('.close-btn').addEventListener('click', () => {
        toast.classList.remove('show');
        toast.addEventListener('transitionend', () => toast.remove(), { once: true });
    });
    setTimeout(() => {
        if (toast.parentNode) {
            toast.classList.remove('show');
            toast.addEventListener('transitionend', () => toast.remove(), { once: true });
        }
    }, duration);
}

function resetCameraPosition() {
    cam.position.set(GRID * 1.0, GRID * 1.2, GRID * 1.5);
    cam.lookAt(GRID / 2, GRID / 2, GRID / 2);
    if (euler) euler.setFromQuaternion(cam.quaternion, 'YXZ');
}

function loadImageTemplate() {
    document.getElementById('imageFileInput').click();
}

function handleImageFileSelect(event) {
    const file = event.target.files[0];
    if (!file) { return; }
    const reader = new FileReader();
    reader.onload = (e) => {
        const base64Image = e.target.result;
        const img = new Image();
        img.onload = () => {
            const aspectRatio = img.width / img.height;
            const planeWidth = GRID * VS;
            const planeHeight = planeWidth / aspectRatio;

            if (templateImageMesh) {
                scene.remove(templateImageMesh);
                templateImageMesh.geometry.dispose();
                templateImageMesh.material.dispose();
            }

            const texture = new THREE.TextureLoader().load(base64Image);
            const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true, depthWrite: false });
            const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
            templateImageMesh = new THREE.Mesh(geometry, material);

            templateImageMesh.position.set((GRID * VS) / 2, (GRID * VS) / 2, -0.001);
            templateImageMesh.rotation.set(0, 0, 0);

            templateImageMesh.renderOrder = -1;
            scene.add(templateImageMesh);

            templateImageData = {
                src: base64Image,
                position: templateImageMesh.position.toArray(),
                rotation: templateImageMesh.rotation.toArray(),
                scale: [1, 1, 1],
                scaledWidth: planeWidth,
                scaledHeight: planeHeight
            };
            document.getElementById('removeImageTemplateBtn').classList.remove('hidden');
            showToast('Bildvorlage geladen', 'Bild als Vorlage erfolgreich geladen.', 'success', 5000);
        };
        img.onerror = (err) => {
            showToast('Fehler', 'Bild konnte nicht geladen werden. Ungültiges Bildformat?', 'error', 5000);
            templateImageMesh = null;
            templateImageData = null;
            document.getElementById('removeImageTemplateBtn').classList.add('hidden');
        };
        img.src = base64Image;
    };
    reader.onerror = (err) => {
        showToast('Fehler', 'Fehler beim Lesen der Bilddatei.', 'error', 5000);
    };
    reader.readAsDataURL(file);

    event.target.value = '';
}
function removeImageTemplate(fromLoad = false) {
    if (templateImageMesh) {
        scene.remove(templateImageMesh);
        templateImageMesh.geometry.dispose();
        templateImageMesh.material.dispose();
        templateImageMesh = null;
        templateImageData = null;
        document.getElementById('removeImageTemplateBtn').classList.add('hidden');
        if (!fromLoad) showToast('Bildvorlage entfernt', 'Bildvorlage erfolgreich entfernt.', 'info', 5000);
    }
}

function getCurrentBlockDimensions() {
    return { dimX: 1, dimY: 1, dimZ: 1 };
}

async function loginLogout() {
    if (auth.currentUser) {
        try {
            await window.firebase.signOut(auth);
            showToast('Abgemeldet', 'Sie wurden erfolgreich abgemeldet.', 'info', 5000);
        } catch (e) {
            showToast('Fehler beim Abmelden', `Fehler: ${e.message}`, 'error', 5000);
        }
    } else {
        openAuthModal();
    }
}

function openUploadModal() {
    if (!currentUserId) {
        showToast('Anmeldung erforderlich', 'Bitte melden Sie sich an, um Projekte auf den Hub hochzuladen.', 'info', 3000);
        openAuthModal();
        return;
    }
    if (voxels.size === 0) {
        showToast('Upload fehlgeschritten', 'Die Szene ist leer. Bitte erstellen Sie zuerst ein Modell.', 'warning', 5000);
        return;
    }
    document.getElementById('uploadTitle').value = projectTitle;
    document.getElementById('uploadDescription').value = projectDescription;
    document.getElementById('uploadCategory').value = projectCategory;
    document.getElementById('uploadTags').value = projectTags.join(', ');
    document.querySelector(`input[name="uploadVisibility"][value="${projectVisibility}"]`).checked = true;

    const uploadCategorySelect = document.getElementById('uploadCategory');
    uploadCategorySelect.innerHTML = '<option value="" disabled selected>Kategorie auswählen</option>';
    predefinedCategories.forEach(cat => { const opt = document.createElement('option'); opt.value = cat; opt.textContent = cat; uploadCategorySelect.appendChild(opt); });
    uploadCategorySelect.value = projectCategory;

    document.getElementById('uploadProjectModal').showModal();
}

async function uploadProjectToHub() {
    if (!currentUserId) {
        showToast('Fehler', 'Nicht angemeldet. Bitte melden Sie sich an, um hochzuladen.', 'error', 5000);
        document.getElementById('uploadProjectModal').close();
        openAuthModal();
        return;
    }
    if (voxels.size === 0) {
        showToast('Upload fehlgeschlagen', 'Die Szene ist leer. Bitte erstellen Sie zuerst ein Modell.', 'warning', 5000);
        return;
    }
    const title = document.getElementById('uploadTitle').value.trim();
    const description = document.getElementById('uploadDescription').value.trim();
    const category = document.getElementById('uploadCategory').value;
    const tags = document.getElementById('uploadTags').value.split(',').map(tag => tag.trim()).filter(tag => tag !== '');
    const visibility = document.querySelector(`input[name="uploadVisibility"]:checked`).value;

    if (!title) { showToast('Fehler', 'Bitte geben Sie einen Titel für Ihr Projekt ein.', 'warning', 5000); return; }
    if (!category) { showToast('Fehler', 'Bitte wählen Sie eine Kategorie für Ihr Projekt aus.', 'warning', 5000); return; }

    showToast('Lade hoch...', 'Ihr Projekt wird hochgeladen. Bitte warten Sie...', 'info', 5000);
    try {
        const voxelMap = {};
        voxels.forEach((v, k) => { const p = parseKey(k); voxelMap[`${p[0]},${p[1]},${p[2]}`] = v.color; });

        const firestoreSafeSettings = {
            gridSize: GRID, cameraPosition: cam.position.toArray(), cameraQuaternion: cam.quaternion.toArray(),
            activeDrawingLevel: activeDrawingLevel, currentDrawingAxis: currentDrawingAxis, currentColor: currentColor,
            presetColors: presetColors, activePresetIndex: activePresetIndex, moveSpeed: moveSpeed,
            templateImageData: null
        };

        // Corrected collection path to match Firestore rules: /models
        const collectionPath = "models";
        
        const firestoreDocument = {
            title: title, description: description, category: category, tags: tags, visibility: visibility,
            remixOf: projectRemixOf || "", sourceJsonUrl: projectSourceJsonUrl || "",
            fileName: `${title.replace(/\s+/g, "_")}.json`, downloads: 0, rating: 0, ratingCount: 0, verified: false,
            userId: currentUserId, uploaderEmail: currentUser?.email || "", uploaderUid: currentUser?.uid || "",
            uploaderPhotoURL: currentUser?.photoURL || "", timestamp: window.firebase.serverTimestamp(),
            projectData: {
                description: description, remixOf: projectRemixOf || "", sourceJsonUrl: projectSourceJsonUrl || "",
                settings: firestoreSafeSettings,
                voxels: voxelMap
            }
        };
        
        const docRef = await window.firebase.addDoc(window.firebase.collection(db, collectionPath), firestoreDocument);
        
        projectTitle = title; projectDescription = description; projectCategory = category; projectTags = tags; projectVisibility = visibility;
        if (!projectSourceJsonUrl) projectSourceJsonUrl = `https://hub.voxelshaper.com?modelId=${docRef.id}`;
        
        showToast('Erfolgreich hochgeladen', `Ihr Projekt wurde erfolgreich hochgeladen! ID: ${docRef.id}`, 'success', 5000);
    } catch (e) {
        showToast('Fehler beim Hochladen', `Fehler: ${e.message}`, 'error', 5000);
    } finally {
        document.getElementById('uploadProjectModal').close();
    }
}

function openAuthModal() {
    document.getElementById('authModal').showModal();
    document.getElementById('emailLoginForm').classList.add('hidden');
}
function closeAuthModal() {
    document.getElementById('authModal').close();
    cvs.focus();
}

window.signInWithGoogle = async function() {
    try {
        await window.firebase.signInWithPopup(auth, new window.firebase.GoogleAuthProvider());
        showToast('Anmeldung erfolgreich', 'Mit Google angemeldet.', 'success', 5000);
        closeAuthModal();
    } catch (e) {
        showToast('Anmeldefehler', `Google: ${e.message}`, 'error', 5000);
    }
}
window.signInWithGithub = async function() {
    try {
        await window.firebase.signInWithPopup(auth, new window.firebase.GithubAuthProvider());
        showToast('Anmeldung erfolgreich', 'Mit GitHub angemeldet.', 'success', 5000);
        closeAuthModal();
    }
    catch (e) {
        showToast('Anmelmelfehler', `GitHub: ${e.message}`, 'error', 5000);
    }
}
window.signInEmailPassword = async function() {
    const email = document.getElementById('emailInput').value;
    const password = document.getElementById('passwordInput').value;
    try {
        await window.firebase.signInWithEmailAndPassword(auth, email, password);
        showToast('Anmeldung erfolgreich', 'Mit E-Mail angemeldet.', 'success', 5000);
        closeAuthModal();
    } catch (e) {
        showToast('Anmeldefehler', `E-Mail: ${e.message}`, 'error', 5000);
    }
}
window.signUpEmailPassword = async function() {
    const email = document.getElementById('emailInput').value;
    const password = document.getElementById('passwordInput').value;
    try {
        await window.firebase.createUserWithEmailAndPassword(auth, email, password);
        showToast('Registrierung erfolgreich', 'Konto erstellt und angemeldet.', 'success', 5000);
        closeAuthModal();
    }
    catch (e) {
        showToast('Registrierungsfehler', `E-Mail: ${e.message}`, 'error', 5000);
    }
}

function closeAllModals() {
    const modals = ['clearConfirmationModal', 'uploadProjectModal', 'authModal', 'exportOptionsModal'];
    modals.forEach(id => { const modal = document.getElementById(id); if (modal && modal.open) modal.close(); });
}
window.closeAllModals = closeAllModals;

function onPointerLockChange() {
    if (document.pointerLockElement === cvs) {
        isPointerLocked = true;
        firstMoveAfterLock = true; // Set to true here
        mouseMovementX = mouseMovementY = 0; // Reset accumulated movement
        updatePreviewVoxel(0,0,0,false);
        euler.setFromQuaternion(cam.quaternion, 'YXZ');
        cvs.focus(); // Explicitly set focus to canvas for keyboard input
        console.log("Pointer lock ACQUIRED. firstMoveAfterLock set to true. Canvas focused.");
    } else {
        isPointerLocked = false;
        console.log("Pointer lock RELEASED.");
    }
}

function onMouseWheel(e) {
    e.preventDefault();

    if (e.altKey) {
        if (!isMobile && (currentMode === Modes.ADD || currentMode === Modes.DRAW)) {
            if (e.shiftKey) {
                activeDrawingLevel.z = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.z - Math.sign(e.deltaY)));
                currentDrawingAxis = 'z';
            }
            else if (e.ctrlKey) {
                activeDrawingLevel.x = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.x - Math.sign(e.deltaY)));
                currentDrawingAxis = 'x';
            }
            else {
                activeDrawingLevel.y = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.y - Math.sign(e.deltaY)));
                currentDrawingAxis = 'y';
            }
            updateGridHelperPosition();
        } else {
            cam.position.addScaledVector(cam.getWorldDirection(new THREE.Vector3()), e.deltaY * 0.005 * moveSpeed * 5);
        }
    } else {
        moveSpeed = Math.max(0.01, Math.min(1.0, moveSpeed - Math.sign(e.deltaY) * 0.01));
        document.getElementById('fly-speed-slider').value = moveSpeed;
        document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
        localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
    }
}

const keyboard = {};
function onKeyDown(e) {
    console.log(`Key Down: ${e.key.toLowerCase()}, isPointerLocked: ${isPointerLocked}`);
    const activeModals = ['authModal', 'uploadProjectModal', 'clearConfirmationModal', 'exportOptionsModal'].some(id => document.getElementById(id).open);
    if (activeModals) { if (e.key === 'Escape') { closeAllModals(); e.preventDefault(); } return; }

    keyboard[e.key.toLowerCase()] = true;
    if (e.key === 'Shift') isShiftDragging = true;
    if (e.key === 'Control' || e.metaKey) isControlDragging = true;

    if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); }
    if (((e.ctrlKey || e.metaKey) && e.key === 'y') || ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'Z')) { e.preventDefault(); redo(); }
    
    if ((e.ctrlKey || e.metaKey) && e.key === 'd') e.preventDefault();
    
    if (e.key === 'Tab') { e.preventDefault(); cycleMode(); }

    switch (e.key) { case '1': setActivePreset(0); break; case '2': setActivePreset(1); break; case '3': setActivePreset(2); break; }
}

function onKeyUp(e) {
    console.log(`Key Up: ${e.key.toLowerCase()}, isPointerLocked: ${isPointerLocked}`);
    keyboard[e.key.toLowerCase()] = false;
    if (e.key === 'Shift') isShiftDragging = false;
    if (e.key === 'Control' || e.metaKey) isControlDragging = false;
}

let dragFixedLayerCoord = null;
let currentStrokeVoxelKeys = new Set();


function onPointerLeave(e) {
    console.log("onPointerLeave fired.");
    if (pointerIsDown && isDragging && currentStrokeVoxels.size > 0) {
        const oldState = [];
        const newState = [];
        for (const [gKey, change] of currentStrokeVoxels.entries()) {
            const p = parseKey(gKey); // p is [x,y,z]
            oldState.push({ x: p[0], y: p[1], z: p[2], color: change.originalColor });
            newState.push({ x: p[0], y: p[1], z: p[2], color: change.finalColor });
        }
        console.log(`onPointerLeave - Adding batch command. Old State Size: ${oldState.length}, New State Size: ${newState.length}`);
        if (oldState.length > 0) {
            addCommand('batch', oldState, newState);
        }
    }
    pointerIsDown = false;
    isDragging = false;
    doubleTapDragActive = false;
    lastActionVoxelCoords = null;
    initialClickPos = null;
    initialTargetVoxelCoords = null;
    voxelsAtDragStart = null;
    currentStrokeVoxels.clear();
    currentStrokeVoxelKeys.clear();
    updatePreviewVoxel(0, 0, 0, false);
    previewLineInstancedMesh.count = 0;
    previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
    previewLineVoxels = [];
    dragAxisLock = null;
    initialDragVoxelCoords = null;
    dragFixedLayerCoord = null; // Reset the fixed layer coordinate on pointer up
    console.log("onPointerLeave - All drag states reset.");
    
    // For touch, release the pointer from activePointers map
    if (e.pointerType === 'touch') {
        releasePointer(e.pointerId, e);
    }
}

let pointerIsDown = false; // Indicates if a voxel-modifying pointer is down
let rightMouseButtonDown = false;
let lastX, lastY;
let suppressNextTap = false; // Not strictly needed with the new logic, but kept for safety

function getVoxelsOnLine(start, end, fixedAxis = null, fixedCoord = null) {
    console.log(`getVoxelsOnLine called. Start: (${start.x}, ${start.y}, ${start.z}), End: (${end.x}, ${end.y}, ${end.z}), FixedAxis: ${fixedAxis}, FixedCoord: ${fixedCoord}`);
    const voxels = [];
    let x0 = start.x, y0 = start.y, z0 = start.z; // Use x,y,z
    let x1 = end.x, y1 = end.y, z1 = end.z; // Use x,y,z

    const dx = x1 - x0;
    const dy = y1 - y0;
    const dz = z1 - z0;

    const steps = Math.max(Math.abs(dx), Math.abs(dy), Math.abs(dz));

    if (steps === 0) {
        // Apply fixed layer constraint for single point case
        if (fixedAxis === 'x') x0 = fixedCoord;
        else if (fixedAxis === 'y') y0 = fixedCoord;
        else if (fixedAxis === 'z') z0 = fixedCoord;

        const clampedX = Math.max(0, Math.min(GRID - 1, x0));
        const clampedY = Math.max(0, Math.min(GRID - 1, y0));
        const clampedZ = Math.max(0, Math.min(GRID - 1, z0));
        voxels.push({ x: clampedX, y: clampedY, z: clampedZ }); // Use x,y,z
        console.log(`getVoxelsOnLine - single point. Result: (${clampedX}, ${clampedY}, ${clampedZ})`);
        return voxels;
    }

    const x_inc = dx / steps;
    const y_inc = dy / steps;
    const z_inc = dz / steps;

    for (let i = 0; i <= steps; i++) {
        let currentX_raw = x0 + x_inc * i;
        let currentY_raw = y0 + y_inc * i;
        let currentZ_raw = z0 + z_inc * i;

        // Force the coordinate on the fixed axis to be exactly fixedCoord
        if (fixedAxis === 'x') {
            currentX_raw = fixedCoord;
        } else if (fixedAxis === 'y') {
            currentY_raw = fixedCoord;
        } else if (fixedAxis === 'z') {
            currentZ_raw = fixedCoord;
        }

        // Round all coordinates to nearest integer voxel, knowing that the fixed axis is already exact.
        const finalX = Math.round(currentX_raw);
        const finalY = Math.round(currentY_raw);
        const finalZ = Math.round(currentZ_raw);

        // Clamp to grid boundaries and add to list
        voxels.push({
            x: Math.max(0, Math.min(GRID - 1, finalX)), // Use x,y,z
            y: Math.max(0, Math.min(GRID - 1, finalY)), // Use x,y,z
            z: Math.max(0, Math.min(GRID - 1, finalZ))  // Use x,y,z
        });
    }

    // Remove duplicates which can occur due to rounding or multiple segments hitting same voxel
    const uniqueVoxels = [];
    const seenKeys = new Set();
    for (const v of voxels) {
        const k = key(v.x, v.y, v.z); // Use v.x,v.y,v.z
        if (!seenKeys.has(k)) {
            seenKeys.add(k);
            uniqueVoxels.push(v);
        }
    }
    console.log(`getVoxelsOnLine - unique voxels generated (count: ${uniqueVoxels.length}):`, uniqueVoxels);
    return uniqueVoxels;
}

function onPointerUp(e) {
    console.log("onPointerUp fired.");
    e.preventDefault(); // Prevent default browser actions
    e.stopPropagation(); // Stop event bubbling

    if (e.button === 2) { // Right mouse button
        rightMouseButtonDown = false;
        document.exitPointerLock();
        return;
    }
    
    // If it was a double-tap initiated drag on mobile, or any drag on desktop, commit the stroke
    if (pointerIsDown && isDragging && currentStrokeVoxels.size > 0) {
        const oldState = [];
        const newState = [];
        for (const [gKey, change] of currentStrokeVoxels.entries()) {
            const p = parseKey(gKey);
            oldState.push({ x: p[0], y: p[1], z: p[2], color: change.originalColor });
            newState.push({ x: p[0], y: p[1], z: p[2], color: change.finalColor });
        }
        console.log(`onPointerUp - Adding batch command. Old State Size: ${oldState.length}, New State Size: ${newState.length}`);
        if (oldState.length > 0) {
            addCommand('batch', oldState, newState);
        }
    }

    // Reset all flags and states after pointer up
    pointerIsDown = false; // Reset voxel-modifying flag
    isDragging = false;
    doubleTapDragActive = false; // Always reset double tap flag on pointer up
    lastActionVoxelCoords = null;
    initialClickPos = null;
    initialTargetVoxelCoords = null;
    voxelsAtDragStart = null;
    currentStrokeVoxels.clear();
    currentStrokeVoxelKeys.clear();
    updatePreviewVoxel(0, 0, 0, false);
    previewLineInstancedMesh.count = 0;
    previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
    previewLineVoxels = [];
    dragAxisLock = null;
    initialDragVoxelCoords = null;
    dragFixedLayerCoord = null;
    console.log("onPointerUp - All drag states reset.");
    
    // For touch, release the pointer from activePointers map
    if (e.pointerType === 'touch') {
        releasePointer(e.pointerId, e);
    }
}

async function onPointerDown(e) {
    console.log("onPointerDown fired.");
    console.log(`Event: clientX=${e.clientX}, clientY=${e.clientY}, button=${e.button}, pointerType=${e.pointerType}`);

    e.preventDefault();
    e.stopPropagation();

    if (e.pointerType === 'mouse' && e.button === 2) {
        try {
            await cvs.requestPointerLock();
        } catch (error) {
            console.error("Failed to request pointer lock:", error);
            showToast('Fehler', 'Zeigerfixierung fehlgeschlagen.', 'error', 3000);
        }
        rightMouseButtonDown = true;
        return;
    }
    
    cvs.focus();
    console.log("onPointerDown - Canvas focused for interaction.");

    if (isPointerLocked) {
        console.log("onPointerDown - Pointer is locked, ignoring input for voxel interaction.");
        return;
    }

    if (e.button === 0 && e.altKey) {
        console.log("onPointerDown - Alt + Left click for color pick detected.");
        const hitResult = calculateRayTargetVoxelCoords(e.clientX, e.clientY);
        if (hitResult && hitResult.hitExistingVoxel) {
            const gKey = key(hitResult.x, hitResult.y, hitResult.z);
            if (voxels.has(gKey)) {
                const pickedColor = voxels.get(gKey).color;
                currentColor = pickedColor;
                document.getElementById('color-picker').value = pickedColor;
                const mobileColorInput = document.getElementById('mobile-color-input');
                if (mobileColorInput) mobileColorInput.value = pickedColor;
                localStorage.setItem('voxelEditorColor', pickedColor);
                presetBoxes.forEach(box => box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50')); activePresetIndex = -1;
                showToast('Farbe aufgenommen', `Farbe: ${pickedColor}`, 'info', 2000);
                console.log(`onPointerDown - Color picked: ${pickedColor}`);
            }
        } else {
            console.log("onPointerDown - Alt + Left click: No existing voxel hit for color pick.");
        }
        return;
    }

    if (e.pointerType === 'touch') {
        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY, pointerType: e.pointerType });
        
        if (activePointers.size === 1) { // Single touch
            const currentTime = performance.now();
            const dist = Math.hypot(e.clientX - lastTapCoords.x, e.clientY - lastTapCoords.y);

            if (currentTime - lastTapTime < DOUBLE_TAP_TIME_THRESHOLD && dist < DOUBLE_TAP_DIST_THRESHOLD) {
                // Double tap detected: Activate voxel modification.
                console.log("Double tap detected! Activating voxel modification.");
                doubleTapDragActive = true;
                pointerIsDown = true; // Set pointerIsDown for voxel operations
                
                voxelsAtDragStart = new Map(voxels);
                currentStrokeVoxels.clear();
                currentStrokeVoxelKeys.clear();
                dragAxisLock = null;
                isDragging = false;
                initialDragVoxelCoords = null;
                initialClickPos = { x: e.clientX, y: e.clientY };

                let rawInitialRayTarget = calculateRayTargetVoxelCoords(e.clientX, e.clientY);
                if (rawInitialRayTarget && Number.isFinite(rawInitialRayTarget.x) && Number.isFinite(rawInitialRayTarget.y) && Number.isFinite(rawInitialRayTarget.z)) {
                    initialTargetVoxelCoords = {
                        x: Math.max(0, Math.min(GRID - 1, rawInitialRayTarget.x)),
                        y: Math.max(0, Math.min(GRID - 1, rawInitialRayTarget.y)),
                        z: Math.max(0, Math.min(GRID - 1, rawInitialRayTarget.z)),
                        faceNormal: rawInitialRayTarget.faceNormal,
                        hitExistingVoxel: rawInitialRayTarget.hitExistingVoxel
                    };
                    if (currentMode === Modes.ADD) {
                        dragFixedLayerCoord = Number(initialTargetVoxelCoords[currentDrawingAxis]);
                        if (!Number.isFinite(dragFixedLayerCoord)) dragFixedLayerCoord = Number(activeDrawingLevel[currentDrawingAxis]);
                    } else { dragFixedLayerCoord = null; }
                    if (dragFixedLayerCoord !== null) initialTargetVoxelCoords[currentDrawingAxis] = dragFixedLayerCoord;

                    lastActionVoxelCoords = { ...initialTargetVoxelCoords };
                    const gKey = key(initialTargetVoxelCoords.x, initialTargetVoxelCoords.y, initialTargetVoxelCoords.z);
                    const initialColor = voxelsAtDragStart.has(gKey) ? voxelsAtDragStart.get(gKey).color : null;
                    performVoxelModification(initialTargetVoxelCoords.x, initialTargetVoxelCoords.y, initialTargetVoxelCoords.z, currentMode, currentColor);
                    const finalColor = voxels.has(gKey) ? voxels.get(gKey).color : null;
                    currentStrokeVoxels.set(gKey, { originalColor: initialColor, finalColor: finalColor });
                    currentStrokeVoxelKeys.add(gKey);
                    updatePreviewVoxel(initialTargetVoxelCoords.x, initialTargetVoxelCoords.y, initialTargetVoxelCoords.z, true);
                } else {
                    updatePreviewVoxel(0,0,0,false);
                }
                lastTapTime = 0; lastTapCoords = { x: 0, y: 0 };
            } else {
                // Single tap for camera movement: Initialize gesture state
                console.log("Single tap detected. Initializing camera gesture (mobile).");
                doubleTapDragActive = false;
                pointerIsDown = false; // Not a voxel operation
                lastTapTime = currentTime;
                lastTapCoords = { x: e.clientX, y: e.clientY };
                gestureState.type = 'none'; gestureState.startMid = gestureState.lastMid = { x: e.clientX, y: e.clientY };
                gestureState.startDist = gestureState.lastDist = 0;
                gestureState.initialPointerCount = 1;
                updatePreviewVoxel(0,0,0,false);
                previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
            }
        } else if (activePointers.size >= 2) { // Multi-touch: Camera control
            console.log("Multi-touch detected, switching to camera gesture.");
            doubleTapDragActive = false; // Disable voxel ops
            pointerIsDown = false; // Not a voxel operation
            initialTargetVoxelCoords = null;
            currentStrokeVoxels.clear(); currentStrokeVoxelKeys.clear();
            previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
            updatePreviewVoxel(0, 0, 0, false);
            isDragging = false; initialDragVoxelCoords = null; dragFixedLayerCoord = null;
            
            const pointersArr = [...activePointers.values()];
            const [p0, p1] = pointersArr;
            const midX = (p0.x + p1.x) * 0.5; const midY = (p0.y + p1.y) * 0.5; const dist = Math.hypot(p1.x - p0.x, p1.y - p0.y);
            gestureState.type = 'none'; gestureState.startMid = gestureState.lastMid = { x: midX, y: midY };
            gestureState.startDist = gestureState.lastDist = dist;
            gestureState.initialPointerCount = activePointers.size;
        }
        return; // Exit for all touch events, as they are handled above
    }

    // Desktop mouse left click: Always a voxel interaction
    pointerIsDown = true;
    voxelsAtDragStart = new Map(voxels);
    currentStrokeVoxels.clear();
    currentStrokeVoxelKeys.clear();
    dragAxisLock = null;
    isDragging = false;
    initialDragVoxelCoords = null;
    initialClickPos = { x: e.clientX, y: e.clientY };

    let rawInitialRayTarget = calculateRayTargetVoxelCoords(e.clientX, e.clientY);
    if (!rawInitialRayTarget || !Number.isFinite(rawInitialRayTarget.x) || !Number.isFinite(rawInitialRayTarget.y) || !Number.isFinite(rawInitialRayTarget.z)) {
        initialTargetVoxelCoords = null;
        dragFixedLayerCoord = null;
        updatePreviewVoxel(0,0,0,false);
        pointerIsDown = false; // No valid target, so no voxel operation
        return;
    } else {
        initialTargetVoxelCoords = {
            x: Math.max(0, Math.min(GRID - 1, rawInitialRayTarget.x)),
            y: Math.max(0, Math.min(GRID - 1, rawInitialRayTarget.y)),
            z: Math.max(0, Math.min(GRID - 1, rawInitialRayTarget.z)),
            faceNormal: rawInitialRayTarget.faceNormal,
            hitExistingVoxel: rawInitialRayTarget.hitExistingVoxel
        };
        if (currentMode === Modes.ADD) {
            dragFixedLayerCoord = Number(initialTargetVoxelCoords[currentDrawingAxis]);
            if (!Number.isFinite(dragFixedLayerCoord)) dragFixedLayerCoord = Number(activeDrawingLevel[currentDrawingAxis]);
        } else { dragFixedLayerCoord = null; }
        if (dragFixedLayerCoord !== null) initialTargetVoxelCoords[currentDrawingAxis] = dragFixedLayerCoord;
    }

    // Perform the first voxel modification immediately for desktop mouse clicks
    lastActionVoxelCoords = { ...initialTargetVoxelCoords };
    const gKey = key(initialTargetVoxelCoords.x, initialTargetVoxelCoords.y, initialTargetVoxelCoords.z);
    const initialColor = voxelsAtDragStart.has(gKey) ? voxelsAtDragStart.get(gKey).color : null;
    performVoxelModification(initialTargetVoxelCoords.x, initialTargetVoxelCoords.y, initialTargetVoxelCoords.z, currentMode, currentColor);
    const finalColor = voxels.has(gKey) ? voxels.get(gKey).color : null;
    currentStrokeVoxels.set(gKey, { originalColor: initialColor, finalColor: finalColor });
    currentStrokeVoxelKeys.add(gKey);
    updatePreviewVoxel(initialTargetVoxelCoords.x, initialTargetVoxelCoords.y, initialTargetVoxelCoords.z, true);
    console.log(`onPointerDown - First voxel modified (desktop): (${initialTargetVoxelCoords.x}, ${initialTargetVoxelCoords.y}, ${initialTargetVoxelCoords.z}). Key: ${gKey}`);
}

function onPointerMove(e) {
    e.preventDefault();
    e.stopPropagation();

    if (isPointerLocked) {
        mouseMovementX += e.movementX;
        mouseMovementY += e.movementY;
        return;
    }

    if (e.pointerType === 'touch') {
        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY, pointerType: e.pointerType });
        
        if (activePointers.size === 1 && !doubleTapDragActive) { // Single finger camera rotation
            handleGesture();
            updatePreviewVoxel(0, 0, 0, false); // No voxel preview during camera drag
            previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
            return;
        } else if (activePointers.size >= 2) { // Multi-finger camera pan/zoom
            handleGesture();
            updatePreviewVoxel(0, 0, 0, false); // No voxel preview during camera drag
            previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
            return;
        }
        // If we reach here for touch, it must be a doubleTapDragActive (voxel operation)
    }

    lastX = e.clientX;
    lastY = e.clientY;

    let currentRayHit = calculateRayTargetVoxelCoords(e.clientX, e.clientY);
    let currentTargetVoxelCoords = null;

    if (currentRayHit) {
        currentTargetVoxelCoords = { x: currentRayHit.x, y: currentRayHit.y, z: currentRayHit.z };
        currentTargetVoxelCoords.x = Math.max(0, Math.min(GRID - 1, currentTargetVoxelCoords.x));
        currentTargetVoxelCoords.y = Math.max(0, Math.min(GRID - 1, currentTargetVoxelCoords.y));
        currentTargetVoxelCoords.z = Math.max(0, Math.min(GRID - 1, currentTargetVoxelCoords.z));
    } else {
        currentTargetVoxelCoords = null;
    }

    // Logic for dragging (drawing a line of voxels) or hover preview
    if (pointerIsDown) { // A voxel-modifying pointer is down (desktop left click or mobile double tap drag)
        const currentMovedDist = initialClickPos ? Math.hypot(e.clientX - initialClickPos.x, e.clientY - initialClickPos.y) : 0;
        const shouldStartDrag = currentMovedDist > MOVE_PX;

        if (!isDragging && shouldStartDrag) {
            isDragging = true;
            console.log("onPointerMove - Drag initiated! isDragging set to true.");
        }

        if (isDragging) { // Voxel drag operation is active
            if (currentTargetVoxelCoords) {
                if (dragFixedLayerCoord !== null && Number.isFinite(dragFixedLayerCoord)) {
                    currentTargetVoxelCoords[currentDrawingAxis] = dragFixedLayerCoord;
                }

                const startPointForLine = { ...lastActionVoxelCoords };
                const endPointForLine = { ...currentTargetVoxelCoords };

                let pathVoxels;
                if (dragFixedLayerCoord !== null && Number.isFinite(dragFixedLayerCoord)) {
                    pathVoxels = getVoxelsOnLine(startPointForLine, endPointForLine, currentDrawingAxis, dragFixedLayerCoord);
                } else {
                    pathVoxels = getVoxelsOnLine(startPointForLine, endPointForLine);
                }

                if (currentMode === Modes.DELETE || currentMode === Modes.DRAW) {
                    pathVoxels = pathVoxels.filter(voxel => voxelsAtDragStart.has(key(voxel.x, voxel.y, voxel.z)));
                }
                
                for (const voxel of pathVoxels) {
                    const gKey = key(voxel.x, voxel.y, voxel.z);
                    const hasVoxelBeforeModification = voxels.has(gKey);
                    const originalColor = hasVoxelBeforeModification ? voxels.get(gKey).color : null;
                    
                    performVoxelModification(voxel.x, voxel.y, voxel.z, currentMode, currentColor);
                    
                    const hasVoxelAfterModification = voxels.has(gKey);
                    const finalColor = hasVoxelAfterModification ? voxels.get(gKey).color : null;

                    if (!currentStrokeVoxels.has(gKey)) {
                        if (originalColor !== finalColor || (originalColor === null && finalColor !== null)) {
                            currentStrokeVoxels.set(gKey, { originalColor: originalColor, finalColor: finalColor });
                        }
                    } else {
                        currentStrokeVoxels.get(gKey).finalColor = finalColor;
                    }
                    currentStrokeVoxelKeys.add(gKey);
                }
                if (pathVoxels.length > 0) {
                    lastActionVoxelCoords = { x: pathVoxels[pathVoxels.length - 1].x, y: pathVoxels[pathVoxels.length - 1].y, z: pathVoxels[pathVoxels.length - 1].z };
                } else {
                    lastActionVoxelCoords = { ...endPointForLine };
                }
                updatePreviewVoxel(currentTargetVoxelCoords.x, currentTargetVoxelCoords.y, currentTargetVoxelCoords.z, true);
                previewLineInstancedMesh.count = 0;
            } else { // No currentTargetVoxelCoords, so no voxel preview
                updatePreviewVoxel(0,0,0,false);
                previewLineInstancedMesh.count = 0;
                previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
                previewLineVoxels = [];
            }
        } else { // Pointer is down, but not yet dragging (or was a tap and finished)
            if (currentTargetVoxelCoords) {
                let showPreview = false;
                const gKeyAtPreview = key(currentTargetVoxelCoords.x, currentTargetVoxelCoords.y, currentTargetVoxelCoords.z);
                const hasVoxelAtPreview = voxels.has(gKeyAtPreview);

                if (currentMode === Modes.ADD) {
                    if (!hasVoxelAtPreview) { showPreview = true; }
                } else if (currentMode === Modes.DELETE || currentMode === Modes.DRAW) {
                    if (hasVoxelAtPreview) { showPreview = true; }
                }
                updatePreviewVoxel(currentTargetVoxelCoords.x, currentTargetVoxelCoords.y, currentTargetVoxelCoords.z, showPreview);
            } else {
                updatePreviewVoxel(0,0,0,false);
            }
            previewLineInstancedMesh.count = 0;
            previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
            previewLineVoxels = [];
        }
    } else { // Pointer not down, just show hover preview (no drag in progress)
        previewLineInstancedMesh.count = 0;
        previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
        previewLineVoxels = [];

        if (currentRayHit) {
            let hoverPreviewCoords = { x: currentRayHit.x, y: currentRayHit.y, z: currentRayHit.z };
            
            hoverPreviewCoords.x = Math.max(0, Math.min(GRID - 1, hoverPreviewCoords.x));
            hoverPreviewCoords.y = Math.max(0, Math.min(GRID - 1, hoverPreviewCoords.y));
            hoverPreviewCoords.z = Math.max(0, Math.min(GRID - 1, hoverPreviewCoords.z));

            let showPreview = false;
            const gKeyAtPreview = key(hoverPreviewCoords.x, hoverPreviewCoords.y, hoverPreviewCoords.z);
            const hasVoxelAtPreview = voxels.has(gKeyAtPreview);

            if (currentMode === Modes.ADD) {
                if (!hasVoxelAtPreview) { showPreview = true; }
                } else if (currentMode === Modes.DELETE || currentMode === Modes.DRAW) {
                if (hasVoxelAtPreview) { showPreview = true; }
            }
            updatePreviewVoxel(hoverPreviewCoords.x, hoverPreviewCoords.y, hoverPreviewCoords.z, showPreview);
        } else {
            updatePreviewVoxel(0, 0, 0, false);
        }
    }
}

function cycleDrawingAxis() {
    const axes = ['x', 'y', 'z'];
    const currentIndex = axes.indexOf(currentDrawingAxis);
    currentDrawingAxis = axes[(currentIndex + 1) % axes.length];
    updateGridHelperPosition();
    showToast('Zeichenachse', `Achse: ${currentDrawingAxis.toUpperCase()}`, 'info', 1500);
}

function moveDrawingLevel(direction) {
    if (currentMode !== Modes.ADD && currentMode !== Modes.DRAW) {
        showToast('Hinweis', 'Ebenensteuerung nur im Hinzufügen- oder Zeichenmodus verfügbar.', 'warning', 2000);
        return;
    }
    let level = activeDrawingLevel[currentDrawingAxis];

    if (!Number.isFinite(level)) {
        level = 0;
        activeDrawingLevel[currentDrawingAxis] = level;
    }

    level += direction;
    level = Math.max(0, Math.min(GRID - 1, level));
    activeDrawingLevel[currentDrawingAxis] = level;
    updateGridHelperPosition();
    showToast('Zeichenebene', `Ebene ${currentDrawingAxis.toUpperCase()}: ${level}`, 'info', 1500);
}


window.onload = async function() {
    closeAllModals();
    try {
        cvs = document.getElementById('voxelCanvas');
        containerDiv = document.getElementById('container');
        toastContainer = document.getElementById('toast-container');

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x282c34);
        cam = new THREE.PerspectiveCamera(75, containerDiv.clientWidth / containerDiv.clientHeight, 0.1, 1000);
        resetCameraPosition();
        euler = new THREE.Euler(0, 0, 0, 'YXZ');

        ren = new THREE.WebGLRenderer({ canvas: cvs, antialias: true });
        ren.setSize(containerDiv.clientWidth, containerDiv.clientHeight);
        isMobile = window.matchMedia('(max-width: 768px)').matches;
        ren.setPixelRatio(isMobile ? Math.min(1.5, window.devicePixelRatio) : window.devicePixelRatio);
        ren.shadowMap.enabled = true;
        ren.shadowMap.type = THREE.PCFSoftShadowMap;
      
        scene.add(new THREE.AmbientLight(0x606060));
        mainDirectionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        mainDirectionalLight.position.set(10, 20, 15);
        mainDirectionalLight.castShadow = true;
        mainDirectionalLight.shadow.mapSize.width = mainDirectionalLight.shadow.mapSize.height = 2048;
        mainDirectionalLight.shadow.camera.near = 0.5; mainDirectionalLight.shadow.camera.far = 50;
        mainDirectionalLight.shadow.camera.left = -30; mainDirectionalLight.shadow.camera.right = 30;
        mainDirectionalLight.shadow.camera.top = 30; mainDirectionalLight.shadow.camera.bottom = -30;
        mainDirectionalLight.shadow.bias = -0.0005; mainDirectionalLight.shadow.normalBias = 0.02;
        scene.add(mainDirectionalLight);

        const secondDirectionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
        secondDirectionalLight.position.set(-10, 10, -15);
        scene.add(secondDirectionalLight);
        scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.6));

        scene.add(previewVoxelMesh);
        updatePreviewVoxel(0,0,0,false);
        previewLineInstancedMesh = new THREE.InstancedMesh(new THREE.BoxGeometry(VS, VS, VS), new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.3, depthTest: false }));
        previewLineInstancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        previewLineInstancedMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(maxPreviewInstances * 3), 3);
        previewLineInstancedMesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
        scene.add(previewLineInstancedMesh);
        rebuildHelpers();

        window.addEventListener('resize', onResize);
        containerDiv.addEventListener('pointerdown', onPointerDown);
        containerDiv.addEventListener('pointermove', onPointerMove);
        containerDiv.addEventListener('pointerup', onPointerUp);
        containerDiv.addEventListener('pointercancel', onPointerUp);
        containerDiv.addEventListener('pointerleave', onPointerLeave);
        containerDiv.addEventListener('wheel', onMouseWheel, { passive: false });
        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);
        document.addEventListener('pointerlockchange', onPointerLockChange, false);
        containerDiv.addEventListener('mousemove', (e) => {
            if (isPointerLocked) {
                mouseMovementX += e.movementX;
                mouseMovementY += e.movementY;
                e.preventDefault();
            }
        });
        containerDiv.addEventListener('contextmenu', (e) => e.preventDefault());

        document.getElementById('grid-size-slider').addEventListener('input', (e) => {
            const oldGrid = GRID;
            const newGrid = parseInt(e.target.value);

            if (newGrid < oldGrid) {
                let voxelsWouldBeLost = false;
                for (const [id, data] of voxels.entries()) {
                    const p = parseKey(id); // p is [x,y,z]
                    if (p[0] >= newGrid || p[1] >= newGrid || p[2] >= newGrid) { // p[0], p[1], p[2] are x,y,z
                        voxelsWouldBeLost = true;
                        break;
                    }
                }

                if (voxelsWouldBeLost) {
                    showToast('Warnung', 'Gittergröße kann nicht reduziert werden, da sonst vorhandene Voxel außerhalb des Rasters verloren gehen würden.', 'warning', 5000);
                    e.target.value = oldGrid;
                    document.getElementById('grid-size-display').textContent = `${oldGrid}×${oldGrid}×${oldGrid}`;
                    return;
                }
            }
            
            const oldVoxelState = [...voxels.entries()].map(([id, data]) => { const p = parseKey(id); return { x: p[0], y: p[1], z: p[2], color: data.color }; }); // x,y,z
            for (const chunk of chunks.values()) chunk.dispose(); chunks.clear(); voxels.clear();
            oldVoxelState.filter(v => v.x < newGrid && v.y < newGrid && v.z < newGrid).forEach(v => _addSingleVoxel(v.x, v.y, v.z, v.color)); // x,y,z
            GRID = newGrid;
            document.getElementById('grid-size-slider').value = GRID;
            document.getElementById('grid-size-display').textContent = `${GRID}×${GRID}×${GRID}`;
            localStorage.setItem('voxelEditorGridSize', GRID);
            addCommand('resizeGrid', oldVoxelState, [...voxels.entries()].map(([id, data]) => { const p = parseKey(id); return { x: p[0], y: p[1], z: p[2], color: data.color }; }), { oldGrid: oldGrid, newGrid: GRID }); // x,y,z
            rebuildHelpers();
            resetCameraPosition();
        });

        document.getElementById('color-picker').addEventListener('input', (e) => {
            currentColor = e.target.value;
            localStorage.setItem('voxelEditorColor', currentColor);
            const mobileColorInput = document.getElementById('mobile-color-input');
            if (mobileColorInput) mobileColorInput.value = currentColor;
            presetBoxes.forEach(box => box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50')); activePresetIndex = -1;
            if (previewVoxelMesh.visible) {
                previewVoxelMaterial.color.set(currentColor);
            }
            showToast('Farbe ausgewählt', `Farbe: ${currentColor}`, 'info', 2000);
        });

        presetBoxes = [document.getElementById('color-preset-1'), document.getElementById('color-preset-2'), document.getElementById('color-preset-3')];
        presetColors.forEach((color, i) => { // Corrected: use presetColors[i] for box.value
            presetBoxes[i].value = color; // Assign value directly to the input element
            presetBoxes[i].addEventListener('click', (e) => setActivePreset(i));
            presetBoxes[i].addEventListener('input', (e) => savePresetColor(i, e.target.value));
        });
        if (activePresetIndex !== -1) setActivePreset(activePresetIndex);
        else document.getElementById('color-picker').value = currentColor;

        document.getElementById('modeToggle').addEventListener('click', cycleMode);
        document.getElementById('current-mode').textContent = `Modus: ${currentMode}`;

        document.getElementById('clearBtn').addEventListener('click', () => document.getElementById('clearConfirmationModal').showModal());
        document.getElementById('saveAndClearBtn').addEventListener('click', () => { saveJSON(); clearAll(); document.getElementById('clearConfirmationModal').close(); });
        document.getElementById('clearWithoutSaveBtn').addEventListener('click', () => { clearAll(); document.getElementById('clearConfirmationModal').close(); });
        document.getElementById('cancelClearBtn').addEventListener('click', () => document.getElementById('clearConfirmationModal').close());
        document.getElementById('clearConfirmationModal').addEventListener('cancel', () => document.getElementById('clearConfirmationModal').close());

        document.getElementById('fillLevelBtn').addEventListener('click', fillActiveLevel);
        document.getElementById('saveBtn').addEventListener('click', saveJSON);
        document.getElementById('loadBtn').addEventListener('click', () => document.getElementById('fileInput').click());
        document.getElementById('fileInput').addEventListener('change', loadJSON);
        
        document.getElementById('exportBtn').addEventListener('click', () => {
            const exportOptionsModal = document.getElementById('exportOptionsModal');
            // Set default format to OBJ and default axis to Z-Up for 3D printers (like Bambu Lab)
            document.querySelector(`input[name="exportFormat"][value="obj"]`).checked = true;
            document.querySelector(`input[name="exportScaleUnit"][value="mm"]`).checked = true;
            document.querySelector(`input[name="exportUpAxis"][value="Z"]`).checked = true; // Default for 3D printers
            
            document.getElementById('glbSpecificOptions').classList.add('hidden');
            scaleUnitOptionsDiv.classList.remove('hidden');
            exportAxisOptionsDiv.classList.remove('hidden'); // Ensure axis options are visible for non-GLB
            exportOptionsModal.showModal();
        });

        const exportFormatRadios = document.querySelectorAll('input[name="exportFormat"]');
        const glbSpecificOptionsDiv = document.getElementById('glbSpecificOptions');
        const scaleUnitOptionsDiv = document.getElementById('scaleUnitOptions');
        const exportAxisOptionsDiv = document.getElementById('exportAxisOptions'); // New element

        exportFormatRadios.forEach(radio => {
            radio.addEventListener('change', (event) => {
                if (event.target.value === 'glb') {
                    glbSpecificOptionsDiv.classList.remove('hidden');
                    scaleUnitOptionsDiv.classList.add('hidden');
                    exportAxisOptionsDiv.classList.add('hidden'); // Hide axis options for GLB
                } else {
                    glbSpecificOptionsDiv.classList.add('hidden');
                    scaleUnitOptionsDiv.classList.remove('hidden');
                    exportAxisOptionsDiv.classList.remove('hidden'); // Show axis options for non-GLB
                }
            });
        });

        document.getElementById('confirmExportBtn').addEventListener('click', () => {
            const selectedFormat = document.querySelector('input[name="exportFormat"]:checked').value;
            const selectedScaleUnit = document.querySelector('input[name="exportScaleUnit"]:checked').value;
            const selectedUpAxis = document.querySelector('input[name="exportUpAxis"]:checked')?.value || 'Y'; // Default to Y if not found

            if (selectedFormat === 'stl') {
                exportSTL(selectedScaleUnit, selectedUpAxis);
            } else if (selectedFormat === 'obj') {
                exportOBJ(selectedScaleUnit, selectedUpAxis);
            } else if (selectedFormat === '3mf') {
                export3MF(selectedScaleUnit, selectedUpAxis);
            } else if (selectedFormat === 'glb') {
                const gameReady = document.getElementById('glbGameReadyToggle').checked;
                const voxelSizeMM = parseFloat(document.getElementById('glbVoxelSizeInput').value);
                const floorPivot = document.getElementById('glbFloorPivotToggle')?.checked || false;
                const splitByColorAndMerge = document.getElementById('glbOptimizeToggle').checked;

                if (isNaN(voxelSizeMM) || voxelSizeMM <= 0) {
                    showToast('Fehler', 'Bitte geben Sie eine gültige Voxelgröße (mm) für GLB ein.', 'warning', 3000);
                    return;
                }
                exportGLBWithOptions({
                    gameReady,
                    voxelSizeMM,
                    floorPivot,
                    splitByColorAndMerge
                });
            }
            document.getElementById('exportOptionsModal').close();
        });

        document.getElementById('cancelExportOptionsBtn').addEventListener('click', () => document.getElementById('exportOptionsModal').close());
        document.getElementById('exportOptionsModal').addEventListener('click', (e) => {
            if (e.target === document.getElementById('exportOptionsModal')) {
                document.getElementById('exportOptionsModal').close();
                cvs.focus();
            }
        });


        document.getElementById('fly-speed-slider').addEventListener('input', (e) => {
            moveSpeed = parseFloat(e.target.value);
            document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
            localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
        });

        document.getElementById('resetCameraBtn').addEventListener('click', resetCameraPosition);
        
        document.getElementById('loadImageTemplateBtn').addEventListener('click', loadImageTemplate);
        document.getElementById('imageFileInput').addEventListener('change', handleImageFileSelect);
        document.getElementById('removeImageTemplateBtn').addEventListener('click', removeImageTemplate);

        // Mobile menu toggle
        document.getElementById('menuToggle').addEventListener('click', (e) => {
            e.preventDefault();
            const controlsPanel = document.getElementById('controls');
            controlsPanel.classList.toggle('hidden');
            if (!controlsPanel.classList.contains('hidden')) controlsPanel.classList.add('flex');
            else controlsPanel.classList.remove('flex');
            onResize(); // Recalculate canvas size after menu toggle
        });

        // Desktop menu toggle
        const desktopMenuToggleBtn = document.getElementById('desktopMenuToggle');
        desktopMenuToggleBtn.addEventListener('click', () => {
            const controlsPanel = document.getElementById('controls');
            const isHidden = controlsPanel.classList.toggle('hidden');
            if (!isHidden) controlsPanel.classList.add('flex');
            else controlsPanel.classList.remove('flex');
            desktopMenuToggleBtn.textContent = isHidden ? 'Menü einblenden' : 'Menü ausblenden';
            onResize(); // Recalculate canvas size after menu toggle
        });


        const mediaQuery = window.matchMedia('(max-width: 768px)');
        function handleMediaQueryChange(e) {
            isMobile = e.matches;
            const controlsPanel = document.getElementById('controls');
            const mobileControls = document.getElementById('mobile-controls');

            if (e.matches) {
                controlsPanel.classList.add('hidden'); // Hide desktop menu on mobile
                mobileControls.classList.remove('hidden');
                mobileControls.classList.add('flex');
                toastContainer.classList.remove('toast-end');
                toastContainer.classList.add('toast-top-center');
                desktopMenuToggleBtn.classList.add('hidden'); // Hide desktop toggle on mobile
            }
            else {
                controlsPanel.classList.remove('hidden'); // Show desktop menu on desktop
                controlsPanel.classList.add('flex');
                mobileControls.classList.add('hidden');
                mobileControls.classList.remove('flex');
                toastContainer.classList.remove('toast-top-center');
                toastContainer.classList.add('toast-end');
                desktopMenuToggleBtn.classList.remove('hidden'); // Show desktop toggle on desktop
                desktopMenuToggleBtn.textContent = controlsPanel.classList.contains('hidden') ? 'Menü einblenden' : 'Menü ausblenden';
            }
            onResize();
            rebuildHelpers();
            const mobileModeText = document.getElementById('mobile-mode-text');
            if (mobileModeText) {
                mobileModeText.textContent = currentMode;
            }
        }
        mediaQuery.addListener(handleMediaQueryChange); handleMediaQueryChange(mediaQuery);

        document.getElementById('mobile-undo').addEventListener('pointerdown', (e) => { e.stopPropagation(); e.preventDefault(); undo(); });
        document.getElementById('mobile-redo').addEventListener('pointerdown', (e) => { e.stopPropagation(); e.preventDefault(); redo(); });
        document.getElementById('mobile-save').addEventListener('pointerdown', (e) => { e.stopPropagation(); e.preventDefault(); saveJSON(); });
        document.getElementById('mobile-camera').addEventListener('pointerdown', (e) => { e.stopPropagation(); e.preventDefault(); resetCameraPosition(); });
        document.getElementById('mobile-mode-toggle').addEventListener('pointerdown', (e) => { e.stopPropagation(); e.preventDefault(); cycleMode(); });
        
        const mobileColorPickerBtn = document.getElementById('mobile-color-picker-btn');
        const mobileColorInput = document.getElementById('mobile-color-input');
        
        mobileColorPickerBtn.addEventListener('pointerdown', (e) => { e.stopPropagation(); e.preventDefault(); mobileColorInput.click(); });
        mobileColorInput.addEventListener('input', (e) => { // Fires continuously as color changes
            currentColor = e.target.value;
            localStorage.setItem('voxelEditorColor', currentColor);
            document.getElementById('color-picker').value = currentColor;
            presetBoxes.forEach(box => box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'));
            activePresetIndex = -1;
            if (previewVoxelMesh.visible) { previewVoxelMaterial.color.set(currentColor); }
        });
        mobileColorInput.addEventListener('change', (e) => { // Fires when picker is closed (e.g., "Done" button)
            currentColor = e.target.value;
            localStorage.setItem('voxelEditorColor', currentColor);
            document.getElementById('color-picker').value = currentColor;
            presetBoxes.forEach(box => box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'));
            activePresetIndex = -1;
            if (previewVoxelMesh.visible) { previewVoxelMaterial.color.set(currentColor); }
            showToast('Farbe ausgewählt', `Farbe: ${currentColor}`, 'info', 2000); // Show toast only when picker closes
        });
        mobileColorInput.value = currentColor;

        document.getElementById('mobile-login-logout').addEventListener('pointerdown', (e) => { e.stopPropagation(); e.preventDefault(); loginLogout(); });
        document.getElementById('mobile-upload-hub').addEventListener('pointerdown', (e) => { e.stopPropagation(); e.preventDefault(); openUploadModal(); });
        document.getElementById('mobile-go-hub').addEventListener('pointerdown', (e) => { e.stopPropagation(); e.preventDefault(); window.open('https://hub.voxelshaper.com', '_blank'); });


        document.getElementById('grid-size-slider').value = GRID;
        document.getElementById('grid-size-display').textContent = `${GRID}×${GRID}×${GRID}`;
        document.getElementById('color-picker').value = currentColor;
        document.getElementById('fly-speed-slider').value = moveSpeed;
        document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
        
        document.getElementById('mobile-mode-text').textContent = currentMode;

        // Firebase initialization using hardcoded config
        const app = window.firebase.initializeApp(firebaseConfig);
        auth = window.firebase.getAuth(app);
        db = window.firebase.getFirestore(app);

        const loginLogoutBtn = document.getElementById('loginLogoutBtn');
        const userIdDisplay = document.getElementById('userIdDisplay');
        let projectLoadedFromUrl = false;

        predefinedCategories.forEach(cat => { const opt = document.createElement('option'); opt.value = cat; opt.textContent = cat; document.getElementById('uploadCategory').appendChild(opt); });

        window.firebase.setPersistence(auth, window.firebase.browserLocalPersistence)
            .then(async () => {
                // No custom token sign-in here, as per user's prod file.
                // The Canvas environment might provide __initial_auth_token, but user explicitly asked to match their prod file.
                // If __initial_auth_token is present in Canvas, this part might need adjustment for Canvas-specific auth.
                // For now, assuming user's prod setup doesn't use custom tokens directly in client-side code.

                window.firebase.onAuthStateChanged(auth, async (user) => {
                    currentUserId = user ? user.uid : null;
                    currentUser = user;
                    loginLogoutBtn.textContent = user ? 'Abmelden' : 'Anmelden';
                    if (user) {
                        userIdDisplay.innerHTML = `<img src="${user.photoURL || 'https://placehold.co/24x24/cccccc/000000?text=U'}" alt="User Avatar" class="w-6 h-6 rounded-full align-middle mr-1"> ${user.displayName || user.email || 'Angemeldet'}`;
                        userIdDisplay.title = user.email || user.uid;
                        userIdDisplay.classList.remove('hidden');
                    } else {
                        userIdDisplay.classList.add('hidden');
                    }
                    document.getElementById('mobile-login-logout').textContent = user ? '🚪' : '🔑';
                    if (user) document.getElementById('authModal').close();

                    if (!projectLoadedFromUrl) {
                        const urlParams = new URLSearchParams(window.location.search);
                        const modelId = urlParams.get('modelId');
                        const encodedJson = urlParams.get('projectJson');
                        if (modelId) {
                            await loadProjectFromModelId(modelId);
                            projectLoadedFromUrl = true;
                        } else if (encodedJson) {
                            try {
                                const decodedJson = decodeURIComponent(encodedJson);
                                loadProjectData(JSON.parse(decodedJson));
                                showToast('Projekt geladen', 'Projekt erfolgreich aus URL-Parameter geladen.', 'success', 5000);
                                projectLoadedFromUrl = true;
                            } catch (e) { showToast('Fehler', 'Fehler beim Laden des Projekts aus der URL. Ungültige oder beschädigte Projektdaten. Fehler: ' + e.message, 'error', 5000); resetToDefaultProject(); }
                        } else {
                            projectRemixOf = ''; projectSourceJsonUrl = '';
                        }
                    }
                });
                animate();
            })
            .catch((e) => {
                showToast('Anmeldefehler', `Fehler bei der Anmeldungspersistenz: ${e.message}.`, 'error', 10000);
                animate();
            });

        document.getElementById('goToHubBtn').addEventListener('click', () => window.open('https://hub.voxelshaper.com', '_blank'));
        
        document.getElementById('uploadToHubBtn').addEventListener('click', () => {
            if (auth.currentUser) {
                openUploadModal();
            } else {
                openAuthModal();
            }
        });

        loginLogoutBtn.addEventListener('click', loginLogout);
        document.getElementById('authModal').addEventListener('click', (e) => { if (e.target === document.getElementById('authModal')) closeAuthModal(); });
        document.getElementById('authModalCloseBtn').addEventListener('click', closeAuthModal);
        document.getElementById('signInGoogleBtn').addEventListener('click', window.signInWithGoogle);
        document.getElementById('signInGithubBtn').addEventListener('click', window.signInGithub);
        document.getElementById('emailSignInBtn').addEventListener('click', window.signInEmailPassword);
        document.getElementById('emailSignUpBtn').addEventListener('click', window.signUpEmailPassword);
        document.getElementById('showEmailLoginFormBtn').addEventListener('click', () => document.getElementById('emailLoginForm').classList.remove('hidden'));
        
        document.getElementById('uploadProjectModal').addEventListener('click', (e) => { if (e.target === document.getElementById('uploadProjectModal')) { document.getElementById('uploadProjectModal').close(); cvs.focus(); } });
        document.getElementById('uploadConfirmBtn').addEventListener('click', uploadProjectToHub);
        document.getElementById('uploadCancelBtn').addEventListener('click', () => { document.getElementById('uploadProjectModal').close(); cvs.focus(); });

    } catch (e) {
        showToast('Schwerer Fehler', `Ein unerwarteter Fehler ist aufgetreten: ${e.message}.`, 'error', 10000);
    }
};

const frustum = new THREE.Frustum();
const tempCameraMatrix = new THREE.Matrix4();
function animate() {
    requestAnimationFrame(animate);

    if (isPointerLocked) {
        if (firstMoveAfterLock) {
            mouseMovementX = mouseMovementY = 0;
            firstMoveAfterLock = false;
        }
        
        if (mouseMovementX !== 0 || mouseMovementY !== 0) {
            euler.y -= mouseMovementX * rotSpeed;
            euler.x -= mouseMovementY * rotSpeed;
            euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
            cam.quaternion.setFromEuler(euler);
        }
        
        mouseMovementX = mouseMovementY = 0;

        const camDir = new THREE.Vector3(); cam.getWorldDirection(camDir);
        const rightDir = new THREE.Vector3().crossVectors(camDir, cam.up).normalize();
        const upVec = new THREE.Vector3(0, 1, 0);
        const currMoveSpeed = moveSpeed * 0.5;

        if (keyboard['w']) cam.position.addScaledVector(camDir, currMoveSpeed);
        if (keyboard['s']) cam.position.addScaledVector(camDir, -currMoveSpeed);
        if (keyboard['a']) cam.position.addScaledVector(rightDir, -currMoveSpeed);
        if (keyboard['d']) cam.position.addScaledVector(rightDir, currMoveSpeed);
        if (keyboard['e']) cam.position.addScaledVector(upVec, currMoveSpeed);
        if (keyboard['q']) cam.position.addScaledVector(upVec, -currMoveSpeed);
    }

    cam.updateMatrixWorld();
    tempCameraMatrix.multiplyMatrices(cam.projectionMatrix, cam.matrixWorldInverse);
    frustum.setFromProjectionMatrix(tempCameraMatrix);

    for (const chunk of chunks.values()) chunk.instancedMesh.visible = frustum.intersectsBox(chunk.boundingBox);

    ren.render(scene, cam);
}
</script></body></html>
