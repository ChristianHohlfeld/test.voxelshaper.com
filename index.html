<!DOCTYPE html>
<html lang="de" data-theme="dark">
<head>
<meta charset="UTF-8">
<meta property="og:title" content="VoxelShaper ‚Äì Create in 3D, Effortlessly" />
<meta property="og:description" content="A powerful, intuitive voxel-based 3D editor ‚Äì made for makers, artists, and coders." />
<meta property="og:image" content="https://voxelshaper.com/preview.png" />
<meta property="og:url" content="https://voxelshaper.com/" />
<meta property="og:type" content="website" />
<meta name="viewport"
      content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover">
<link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAAANl..."/>

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="VoxelShaper ‚Äì Create in 3D, Effortlessly">
<meta name="twitter:description" content="A powerful, intuitive voxel-based 3D editor ‚Äì made for makers, artists, and coders.">
<meta name="twitter:image" content="https://voxelshaper.com/preview.png">
<title>VoxelShaper ‚Äì Voxel Editor & 3D Print Exporter</title>

<link href="https://cdn.jsdelivr.net/npm/daisyui@4.7.2/dist/full.min.css" rel="stylesheet" type="text/css" />
<script src="https://cdn.tailwindcss.com"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

<style>
body {
    padding-top: env(safe-area-inset-top);
    padding-bottom: env(safe-area-inset-bottom);
    padding-left: env(safe-area-inset-left);
    padding-right: env(safe-area-inset-right);
    box-sizing: border-box;
    touch-action: auto; /* Allow default touch actions on body, but restrict on canvas */
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
    display: flex; /* Use flexbox for overall layout */
    flex-direction: column; /* Stack vertically */
    min-height: 100vh; /* Full viewport height */
    overflow: hidden; /* Prevent body scrollbar */
}
#container, #voxelCanvas {
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
    -webkit-touch-callout: none;
    touch-action: none; /* Crucial for preventing browser gestures on canvas */
}
input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
input[type="color"]::-webkit-color-swatch { border: none; border-radius: 50%; }
input[type="color"]::-moz-color-swatch-wrapper { padding: 0; }
input[type="color"]::-moz-color-swatch { border: none; border-radius: 50%; }
.color-preset-box::-webkit-color-swatch-wrapper { padding: 0; }
.color-preset-box::-webkit-color-swatch { border: none; border-radius: 0.375rem; }
.color-preset-box::-moz-color-swatch-wrapper { padding: 0; }
.color-preset-box::-moz-color-swatch { border: none; border-radius: 0.375rem; }

#toast-container {
    position: fixed;
    z-index: 50;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    padding: 1rem;
    pointer-events: none;
}

#toast-container.toast-end {
    bottom: 1rem;
    right: 1rem;
    align-items: flex-end;
}

@media (max-width: 768px) {
    #toast-container {
        top: 1rem;
        left: 50%;
        transform: translateX(-50%);
        width: calc(100% - 2rem);
        max-width: 300px;
        align-items: center;
    }
    #toast-container.toast-top-center { /* Added for mobile */
        bottom: auto;
        right: auto;
    }
}

.toast .alert {
    pointer-events: auto;
    opacity: 0;
    transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
    transform: translateY(20px);
}

.toast .alert.show {
    opacity: 1;
    transform: translateY(0);
}

@media (max-width: 768px) {
    .toast .alert {
        padding: 0.5rem 0.75rem;
        font-size: 0.875rem;
    }
    .toast .alert svg {
        width: 1.25rem;
        height: 1.25rem;
    }
    .toast .alert strong {
        font-size: 0.9rem;
    }
    .toast .alert span {
        font-size: 0.8rem;
    }
    .toast .alert .close-btn {
        font-size: 1rem;
        padding: 0.25rem;
    }
}
.mobile-btn {
    width: 56px; /* Slightly smaller */
    height: 56px; /* Slightly smaller */
    font-size: 1.5rem; /* Adjusted font size for icons */
    border-radius: 50%;
    background-color: var(--fallback-b3, oklch(var(--b3)/1));
    color: var(--fallback-bc, oklch(var(--bc)/1));
    border: 2px solid var(--fallback-bc, oklch(var(--bc)/1));
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
    transition: background-color 0.2s, transform 0.2s;
    text-align: center; /* Ensure text is centered */
    line-height: 1.2; /* Adjust line height for better text fit */
    padding: 0.2rem; /* Add padding for text */
}
/* Specific style for buttons with text content */
.mobile-btn.text-btn {
    font-size: 0.75rem; /* Smaller font size for text buttons */
}


.mobile-btn:hover {
    background-color: oklch(var(--bc)/0.2);
}

.mobile-btn:active {
    transform: scale(0.95);
}

#mobile-controls {
    gap: 0.75rem; /* Slightly reduced gap */
}

/* Mobile specific styles for the desktop controls panel when it's shown as an overlay */
@media (max-width: 768px) {
    #controls {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: var(--fallback-b1, oklch(var(--b1)/0.95)); /* Semi-transparent background */
        z-index: 1000; /* Above everything else */
        flex-direction: column; /* Stack items vertically */
        align-items: flex-start; /* Align items to the start */
        padding: 1rem;
        padding-top: 4rem; /* Add padding to account for the hamburger menu button */
        overflow-y: auto; /* Enable scrolling for controls */
        box-sizing: border-box;
        gap: 0.75rem; /* Adjust gap for mobile */
    }

    #controls .btn,
    #controls .input,
    #controls .select,
    #controls .range {
        width: 100%; /* Make controls full width */
        max-width: none; /* Remove max-width constraints */
        margin-bottom: 0.5rem; /* Add some vertical spacing */
    }

    #controls label {
        width: 100%; /* Ensure labels also take full width */
        text-align: left;
        margin-top: 0.5rem;
    }

    #controls .color-preset-box {
        width: 48px; /* Fixed size for color presets */
        height: 48px;
    }
    #controls .color-preset-container { /* If you group presets, make them flex-wrap */
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        width: 100%;
        justify-content: flex-start;
    }

    /* Add a close button for the mobile controls overlay */
    #controls::before {
        content: '‚úï';
        position: absolute;
        top: 1rem;
        right: 1rem;
        font-size: 1.5rem;
        cursor: pointer;
        color: var(--fallback-bc, oklch(var(--bc)/1));
        z-index: 1001; /* Ensure close button is clickable */
    }
}

#tutorial-panel-container {
    position: fixed; /* Changed to fixed for consistent positioning */
    bottom: 1rem;    /* Positioned at bottom right */
    right: 1rem;     /* Positioned at bottom right */
    z-index: 100;
    max-width: 350px; /* Reduced max-width */
    width: 90%; /* Still responsive for smaller screens */
    padding: 1rem; /* Reduced padding */
    background-color: var(--fallback-b2, oklch(var(--b2)/0.95)); /* Slightly more opaque */
    border-radius: 0.75rem; /* Slightly smaller border-radius */
    box-shadow: 0 5px 15px rgba(0,0,0,0.2); /* Reduced shadow */
    border: 1px solid oklch(var(--p)); /* Thinner border */
    display: flex;
    flex-direction: column;
    gap: 0.75rem; /* Reduced gap */
    pointer-events: auto;
    transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out; /* Added transition */
    transform: translateX(0) translateY(0); /* Reset transform */
    opacity: 1; /* Ensure visible when shown */
}

/* Added for responsive tutorial panel on mobile */
@media (max-width: 768px) {
    #tutorial-panel-container {
        top: 1rem; /* Move to top center on mobile */
        left: 50%;
        bottom: auto;
        right: auto;
        transform: translateX(-50%);
        max-width: 300px;
        padding: 0.75rem;
    }
}

#tutorial-panel-container.hidden {
    opacity: 0;
    pointer-events: none;
    transform: translateY(20px); /* Animate out downwards */
}

/* Wobble animation */
@keyframes wobble {
  0% { transform: translateX(0); }
  15% { transform: translateX(-5px) rotate(-1deg); }
  30% { transform: translateX(5px) rotate(1deg); }
  45% { transform: translateX(-5px) rotate(-1deg); }
  60% { transform: translateX(5px) rotate(1deg); }
  75% { transform: translateX(-2px) rotate(-0.5deg); }
  90% { transform: translateX(2px) rotate(0.5deg); }
  100% { transform: translateX(0); }
}

.wobble-success {
  animation: wobble 0.8s ease-in-out;
}

.reward-message {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    color: oklch(var(--su)); /* success color */
    font-weight: bold;
    margin-top: 0.5rem;
    opacity: 0;
    transform: translateY(5px);
    transition: opacity 0.3s ease-out, transform 0.3s ease-out;
}

.reward-message.show {
    opacity: 1;
    transform: translateY(0);
}

.reward-message .fas.fa-check-circle {
    color: oklch(var(--su));
}
</style>
</head>
<body class="bg-base-100 min-h-screen text-base-content flex flex-col">
<button id="menuToggle" aria-label="Men√º umschalten" class="fixed top-4 right-4 z-[1500] w-10 h-10 text-xl leading-10 text-center bg-base-300 text-base-content border-none rounded-lg cursor:pointer shadow-md hover:bg-base-content/20 lg:hidden">‚ò∞</button>

<!-- Main Controls (Desktop and Mobile Overlay) -->
<div id="controls" class="flex flex-wrap items-center justify-center gap-3 p-4 bg-base-200 border-b border-base-content/20 hidden md:flex">
    <label for="grid-size-slider" class="text-base-content">Gittergr√∂√üe:</label>
    <input type="range" id="grid-size-slider" min="5" max="180" value="10" aria-label="Gittergr√∂√üe anpassen" class="range range-xs w-36">
    <span id="grid-size-display" class="font-bold text-primary">10√ó10√ó10</span>
    
    <label for="color-picker-swatch" class="text-base-content">Farbe:</label>
    <div id="color-picker-swatch" class="w-10 h-10 p-0 rounded-full cursor-pointer border-2 border-base-content/20" style="background-color: #ffffff;"></div>
    <input type="color" id="color-picker-input-hidden" value="#ffffff" class="hidden">

    <div class="color-preset-container flex gap-2">
        <input type="color" id="color-preset-1" class="color-preset-box w-10 h-10 rounded-md border-2 border-base-content/20 cursor-pointer transition-all duration-200 hover:scale-110" value="#E4002B" aria-label="Voreingestellte Farbe 1">
        <input type="color" id="color-preset-2" class="color-preset-box w-10 h-10 rounded-md border-2 border-base-content/20 cursor-pointer transition-all duration-200 hover:scale-110" value="#00A040" aria-label="Voreingestellte Farbe 2">
        <input type="color" id="color-preset-3" class="color-preset-box w-10 h-10 rounded-md border-2 border-base-content/20 cursor-pointer flex items-center justify-center shadow-lg hover:bg-base-content/20" value="#0057B8" aria-label="Voreingestellte Farbe 3">
    </div>

    <button id="modeToggle" aria-label="Modus wechseln" class="btn btn-sm btn-neutral">Modus wechseln</button><span id="current-mode" class="font-bold text-success min-w-40 text-center">Modus: Hinzuf√ºgen</span>
    <button id="clearBtn" aria-label="Alles l√∂schen" class="btn btn-sm btn-neutral">Alles l√∂schen</button>
    <button id="fillLevelBtn" aria-label="Ebene f√ºllen" class="btn btn-sm btn-neutral">Ebene f√ºllen</button>
    
    <button id="saveBtn" aria-label="Projekt speichern" aria-describedby="save-description" class="btn btn-sm btn-neutral">Projekt speichern</button>
    <div id="save-description" class="sr-only">Speichert das aktuelle Projekt als JSON-Datei</div>
    <button id="loadBtn" aria-label="Projekt laden" class="btn btn-sm btn-neutral">Projekt laden</button>
    <button id="exportBtn" aria-label="Modell exportieren" class="btn btn-sm btn-neutral">Export</button>

    <label for="fly-speed-slider" class="text-base-content">Fluggeschwindigkeit:</label>
    <input type="range" id="fly-speed-slider" min="0.01" max="1.0" step="0.01" value="0.1" aria-label="Fluggeschwindigkeit anpassen" class="range range-xs w-36">
    <span id="fly-speed-display" class="font-bold text-primary">0.10</span>

    <label for="rot-speed-slider" class="text-base-content">Rotationsgeschwindigkeit:</label>
    <input type="range" id="rot-speed-slider" min="0.001" max="0.01" step="0.0005" value="0.003" aria-label="Rotationsgeschwindigkeit anpassen" class="range range-xs w-36">
    <span id="rot-speed-display" class="font-bold text-primary">0.0030</span>

    <!-- NEW: Camera/Strafe Controls moved here -->
    <button id="invert-look-x" class="btn btn-sm btn-neutral text-btn">‚ÜîÔ∏è Blick</button>
    <button id="invert-look-y" class="btn btn-sm btn-neutral text-btn">‚ÜïÔ∏è Blick</button>
    <button id="reverse-strafe-x" class="btn btn-sm btn-neutral text-btn">‚ÜîÔ∏è Strafe</button>
    <button id="reverse-strafe-y" class="btn btn-sm btn-neutral text-btn">‚ÜïÔ∏è Strafe</button>

    <button id="resetCameraBtn" aria-label="Kamera zur√ºcksetzen" class="btn btn-sm btn-neutral">Zur Szene zur√ºckkehen</button>

    <button id="loadImageTemplateBtn" aria-label="Bild als Vorlage laden" class="btn btn-sm btn-neutral">Bild als Vorlage laden</button>
    <button id="removeImageTemplateBtn" class="btn btn-sm btn-neutral hidden" aria-label="Bildvorlage entfernen">Bildvorlage entfernen</button>
    <input type="file" id="imageFileInput" accept="image/*" class="hidden">

    <button id="loginLogoutBtn" aria-label="Anmelden oder Abmelden" class="btn btn-sm btn-info">Anmelden</button>
    <span id="userIdDisplay" class="font-bold text-info ml-2 mr-2 whitespace-nowrap overflow-hidden text-ellipsis max-w-xs flex items-center gap-1"></span>
    <!-- Upload to Hub button will be hidden/shown by JS if tutorial is active, it's removed from tutorial steps -->
    <button id="uploadToHubBtn" aria-label="Auf Hub hochladen" class="btn btn-sm btn-warning hidden">Auf Hub hochladen</button>
    <button id="goToHubBtn" aria-label="Zum VoxelShaper Hub wechseln" class="btn btn-sm btn-secondary">Zum Hub</button>

    <!-- NEW: Tutorial Button -->
    <button id="startTutorialBtn" class="btn btn-sm btn-accent">Tutorial starten</button>
</div>

<div id="container" class="flex-1 relative border-2 border-transparent box-border overflow-hidden touch-none">
    <canvas id="voxelCanvas" class="w-full h-full block box-border"></canvas>
    <input type="file" id="fileInput" accept=".json" class="hidden">
</div>

<dialog id="clearConfirmationModal" class="modal">
    <div class="modal-box bg-base-200 text-base-content p-8 text-center shadow-xl max-w-md">
        <h3 class="font-bold text-lg text-primary mb-4">Projekt l√∂schen</h3>
        <p class="py-4">M√∂chten Sie das aktuelle Projekt speichern, bevor Sie alle Voxel l√∂schen?</p>
        <div class="modal-buttons flex justify-around gap-4 mt-6">
            <button id="saveAndClearBtn" class="confirm-save btn btn-success flex-1">Speichern & L√∂schen</button>
            <button id="clearWithoutSaveBtn" class="confirm-no-save btn btn-error flex-1">Ohne Speichern l√∂schen</button>
            <button id="cancelClearBtn" class="cancel btn btn-ghost flex-1">Abbrechen</button>
        </div>
    </div>
</dialog>

<dialog id="uploadProjectModal" class="modal">
    <div class="upload-modal-content modal-box bg-base-200 text-base-content p-8 shadow-xl max-w-xl w-11/12 text-left">
        <h3 class="font-bold text-lg text-primary text-center mb-6">Projekt auf Hub hochladen</h3>
        <label for="uploadTitle" class="label block mb-2 font-bold">Titel:</label>
        <input type="text" id="uploadTitle" placeholder="Ein aussagekr√§ftiger Titel f√ºr Ihr Projekt" maxlength="100" class="input input-bordered w-full bg-base-300 border-base-content/20 mb-4">

        <label for="uploadDescription" class="label block mb-2 font-bold">Beschreibung:</label>
        <textarea id="uploadDescription" placeholder="Beschreiben Sie Ihr Projekt kurz" maxlength="500" class="textarea textarea-bordered w-full bg-base-300 border-base-content/20 h-24 mb-4 resize-y"></textarea>

        <label for="uploadCategory" class="label block mb-2 font-bold">Kategorie:</label>
        <select id="uploadCategory" class="select select-bordered w-full bg-base-300 border-base-content/20 mb-4" required>
            <option value="" disabled selected>Kategorie ausw√§hlen</option>
        </select>

        <label for="uploadTags" class="label block mb-2 font-bold">Tags (Komma-getrennt):</label>
        <input type="text" id="uploadTags" placeholder="z.B. Haus, Baum, Auto, Geb√§ude" maxlength="100" class="input input-bordered w-full bg-base-300 border-base-content/20 mb-4">

        <label class="label block mb-2 font-bold">Sichtbarkeit:</label>
        <div class="radio-group flex gap-4 mb-4">
            <label class="flex items-center font-normal">
                <input type="radio" name="uploadVisibility" value="public" checked class="radio radio-primary mr-2"> √ñffentlich
            </label>
            <label class="flex items-center font-normal">
                <input type="radio" name="uploadVisibility" value="private" class="radio radio-primary mr-2"> Privat
            </label>
        </div>

        <div class="upload-modal-buttons flex justify-around gap-4 mt-6">
            <button id="uploadConfirmBtn" class="upload-confirm btn btn-success flex-1">Hochladen</button>
            <button id="uploadCancelBtn" class="upload-cancel btn btn-ghost flex-1">Abbrechen</button>
        </div>
    </div>
</dialog>

<dialog id="authModal" class="modal">
    <div class="auth-modal-content modal-box bg-base-200 text-base-content p-8 shadow-xl max-w-lg w-11/12 text-center">
        <h3 class="font-bold text-lg text-primary mb-6">Anmelden bei VoxelShaper Hub</h3>
        <div class="provider-buttons flex flex-col gap-3">
            <button id="signInGoogleBtn" class="google btn btn-error text-white">
                <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" alt="Google Icon" class="w-5 h-5">
                Mit Google anmelden
            </button>
            <button id="signInGithubBtn" class="github btn bg-neutral text-neutral-content hover:bg-neutral-focus">
                <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/github.svg" alt="GitHub Icon" class="w-5 h-5">
                Mit GitHub anmelden
            </button>
            <button id="showEmailLoginFormBtn" class="email btn btn-info">
                Mit E-Mail anmelden
            </button>
        </div>

        <div id="emailLoginForm" class="email-login-form mt-6 pt-6 border-t border-base-content/20 hidden">
            <form id="emailAuthForm">
                <input type="email" id="emailInput" placeholder="E-Mail" autocomplete="email" class="input input-bordered w-full bg-base-300 border-base-content/20 mb-3">
                <input type="password" id="passwordInput" placeholder="Passwort" autocomplete="current-password" class="input input-bordered w-full bg-base-300 border-base-content/20 mb-3">
                <button type="submit" id="emailSignInBtn" class="btn btn-primary w-full">Anmelden</button>
                <button type="button" id="emailSignUpBtn" class="btn btn-secondary w-full mt-2">Registrieren</button>
            </form>
        </div>

        <div class="close-button-container mt-6">
            <button id="authModalCloseBtn" class="btn btn-ghost">Schlie√üen</button>
        </div>
    </div>
</dialog>

<dialog id="exportOptionsModal" class="modal">
    <div class="modal-box bg-base-200 text-base-content p-8 shadow-xl max-w-md">
        <h3 class="font-bold text-lg text-primary mb-4">Export Optionen</h3>
        
        <div class="form-control mb-4">
            <label class="label"><span class="label-text">Format w√§hlen:</span></label>
            <div class="flex flex-wrap gap-3">
                <label class="flex items-center">
                    <input type="radio" name="exportFormat" value="stl" class="radio radio-primary" checked />
                    <span class="ml-2">STL</span>
                </label>
            </div>
        </div>

        <div class="form-control mb-4" id="scaleUnitOptions">
            <label class="label"><span class="label-text">Basiseinheit f√ºr Export:</span></label>
            <div class="flex gap-3">
                <label class="flex items-center">
                    <input type="radio" name="exportScaleUnit" value="mm" class="radio radio-primary" checked />
                    <span class="ml-2">Millimeter (mm)</span>
                </label>
                <label class="flex items-center">
                    <input type="radio" name="exportScaleUnit" value="cm" class="radio radio-primary" />
                    <span class="ml-2">Zentimeter (cm)</span>
                </label>
            </div>
        </div>

        <div class="form-control mb-4" id="exportAxisOptions">
            <label class="label"><span class="label-text">Up-Achse f√ºr Export:</span></label>
            <div class="flex gap-3">
                <label class="flex items-center">
                    <input type="radio" name="exportUpAxis" value="Y" class="radio radio-primary" />
                    <span class="ml-2">Y-Up (Standard)</span>
                </label>
                <label class="flex items-center">
                    <input type="radio" name="exportUpAxis" value="Z" class="radio radio-primary" checked />
                    <span class="ml-2">Z-Up (3D-Drucker)</span>
                </label>
            </div>
        </div>
        <!-- GLB specific options removed -->
        <div class="modal-buttons flex justify-around gap-4 mt-6">
            <button id="confirmExportBtn" class="btn btn-success flex-1">Exportieren</button>
            <button id="cancelExportOptionsBtn" class="btn btn-ghost flex-1">Abbrechen</button>
        </div>
    </div>
</dialog>

<!-- NEW: Tutorial Panel -->
<div id="tutorial-panel-container" class="hidden">
    <div class="card bg-base-100 shadow-xl">
        <div class="card-body">
            <h2 id="tutorial-title" class="card-title text-primary text-xl"></h2>
            <p id="tutorial-description" class="text-base"></p>
            <div id="tutorial-reward" class="reward-message hidden">
                <i class="fas fa-check-circle"></i> <span id="reward-text"></span>
            </div>
            <div class="card-actions justify-end mt-4">
                <button id="tutorial-next-btn" class="btn btn-primary btn-sm">N√§chster Schritt</button>
                <button id="tutorial-exit-btn" class="btn btn-ghost btn-sm">Tutorial beenden</button>
            </div>
        </div>
    </div>
</div>

<div id="toast-container" class="toast toast-end z-50"></div>

<!-- Mobile controls - now visible on mobile by default, hidden on desktop -->
<div id="mobile-controls" class="flex md:hidden flex-col gap-3 fixed bottom-4 right-4 z-[1000]">
    <button class="mobile-btn" id="mobile-undo" aria-label="R√ºckg√§ngig machen">‚Ü∫</button>
    <button class="mobile-btn" id="mobile-redo" aria-label="Wiederholen">‚Üª</button>
    <button class="mobile-btn" id="mobile-save" aria-label="Speichern">üíæ</button>
    <button class="mobile-btn" id="mobile-camera" aria-label="Kamera zur√ºcksetzen">üì∑</button>

    <button class="mobile-btn" id="mobile-mode-toggle" aria-label="Modus wechseln">
        <i id="mobile-mode-icon" class="fas fa-plus"></i>
    </button>

    <button class="mobile-btn" id="mobile-color-picker-btn" aria-label="Farbe ausw√§hlen">üé®</button>
    <input type="color" id="mobile-color-input-hidden" value="#008080" class="hidden w-0 h-0 opacity-0 absolute pointer-events-none">

    <button class="mobile-btn" id="mobile-axis-toggle" aria-label="Zeichenachse wechseln">
        <span id="mobile-axis-icon" class="fas fa-arrows-alt-v"></span>
    </button>
    <button class="mobile-btn" id="mobile-login-logout" aria-label="Anmelden oder Abmelden">üîë</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>
<!-- GLTFExporter and JSZip removed as not needed for STL only -->

<script type="module">
    // Remove window.firebase assignment and use direct imports
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import {
        getAuth,
        setPersistence,
        browserLocalPersistence,
        signInWithCustomToken,
        onAuthStateChanged,
        signOut,
        GoogleAuthProvider,
        GithubAuthProvider,
        signInWithPopup,
        createUserWithEmailAndPassword,
        signInWithEmailAndPassword,
        signInAnonymously // <--- ADDED signInAnonymously import
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import {
        getFirestore,
        doc,
        getDoc,
        collection,
        addDoc,
        serverTimestamp
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // Global references for Firebase (if needed by other functions, otherwise direct imports are fine)
    window.initializeApp = initializeApp;
    window.getAuth = getAuth;
    window.setPersistence = setPersistence;
    window.browserLocalPersistence = browserLocalPersistence;
    window.signInWithCustomToken = signInWithCustomToken;
    window.onAuthStateChanged = onAuthStateChanged;
    window.signOut = signOut;
    window.GoogleAuthProvider = GoogleAuthProvider;
    window.GithubAuthProvider = GithubAuthProvider;
    window.signInWithPopup = signInWithPopup;
    window.createUserWithEmailAndPassword = createUserWithEmailAndPassword;
    window.signInWithEmailAndPassword = signInWithEmailAndPassword;
    window.signInAnonymously = signInAnonymously; // <--- EXPOSED signInAnonymously globally
    window.getFirestore = getFirestore;
    window.doc = doc;
    window.getDoc = getDoc;
    window.collection = collection;
    window.addDoc = addDoc;
    window.serverTimestamp = serverTimestamp;


    // Remove hardcoded FIREBASE_API_KEY and direct firebaseConfig when running in Canvas
    const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {
        // Fallback for local development if not in Canvas environment
        apiKey: "YOUR_FIREBASE_API_KEY", // Replace with actual key for local dev
        authDomain: "your-project-id.firebaseapp.com",
        projectId: "your-project-id",
        storageBucket: "your-project-id.appspot.com",
        messagingSenderId: "your-messaging-sender-id",
        appId: "your-app-id",
        measurementId: "your-measurement-id"
    };
    window.firebaseConfig = firebaseConfig; // Keep for window.firebase.initializeApp
</script>

<script>
const VS = 1, HALF = VS * 0.5;
const CHUNK_SIZE = 16;
const VOX_BITS = 10;
const VOX_MASK = (1 << VOX_BITS) - 1;
const SHIFT_X  = VOX_BITS * 2;
const SHIFT_Y  = VOX_BITS;

function key(x, y, z) { return ((x << SHIFT_X) | (y << SHIFT_Y) | z) >>> 0; }
function parseKey(k) { return [(k >>> SHIFT_X) & VOX_MASK, (k >>> SHIFT_Y) & VOX_MASK, k & VOX_MASK]; }

const VOXEL_DRAG_THRESHOLD = 1;
// Adjusted thresholds for better gesture differentiation
const PINCH_REL_TH = 0.08; // Increased from 0.05
const MOVE_PX = 15; // Increased from 10
const DT_MS = 250;

const ROTATE_SPEED_TOUCH_MOBILE = 0.008;
const PAN_SPEED_TOUCH_MOBILE = 0.15;
const PINCH_ZOOM_MULT_MOBILE = 80;

const ROTATE_SPEED_TOUCH_DESKTOP = 0.004;
const PAN_SPEED_TOUCH_DESKTOP = 0.1;


let activePointers = new Map();
let gestureState = { type: 'none', startDist: 0, startMid: { x: 0, y: 0 }, lastMid: { x: 0, y: 0 }, lastDist: 0, startTime: 0, initialPointerCount: 0 };
let tapCandidate = null;
let doubleTapDragActive = false; // Flag for double tap to enable drawing/editing

let scene, cam, ren, gridHelper, boxHelper;
let rotSpeed = parseFloat(localStorage.getItem('voxelEditorRotSpeed') || '0.003'); // Initialized from localStorage, default 0.003
let euler;
const voxels = new Map();
const chunks = new Map();

let cvs, containerDiv;
let activeDrawingLevel = { x: 0, y: 0, z: 0 };
let currentDrawingAxis = 'y';

let currentColor = localStorage.getItem('voxelEditorColor') || '#008080'; // Default to a good color
let moveSpeed = parseFloat(localStorage.getItem('voxelEditorFlySpeed') || '0.1');
let GRID = parseInt(localStorage.getItem('voxelEditorGridSize') || '10');

// New settings for camera inversion and strafe reversal
let invertLookX = localStorage.getItem('voxelEditorInvertLookX') === 'true';
let invertLookY = localStorage.getItem('voxelEditorInvertLookY') === 'true';
let reverseStrafeX = localStorage.getItem('voxelEditorReverseStrafeX') === 'true';
let reverseStrafeY = localStorage.getItem('voxelEditorReverseStrafeY') === 'true';


activeDrawingLevel.x = Number(localStorage.getItem('voxelEditorActiveDrawingLevelX') || '0');
if (!Number.isFinite(activeDrawingLevel.x)) activeDrawingLevel.x = 0;
activeDrawingLevel.x = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.x)));

activeDrawingLevel.y = Number(localStorage.getItem('voxelEditorActiveDrawingLevelY') || '0');
if (!Number.isFinite(activeDrawingLevel.y)) activeDrawingLevel.y = 0;
activeDrawingLevel.y = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.y)));

activeDrawingLevel.z = Number(localStorage.getItem('voxelEditorActiveDrawingLevelZ') || '0');
if (!Number.isFinite(activeDrawingLevel.z)) activeDrawingLevel.z = 0;
activeDrawingLevel.z = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.z)));

currentDrawingAxis = localStorage.getItem('voxelEditorCurrentDrawingAxis') || 'y';

const presetColors = [
    localStorage.getItem('voxelPresetColor1') || '#E4002B',
    localStorage.getItem('voxelPresetColor2') || '#00A040',
    localStorage.getItem('voxelPresetColor3') || '#0057B8'
];
let activePresetIndex = -1;
let presetBoxes = [];

let mainDirectionalLight, fillDirectionalLight, hemisphereLight;
let isShiftDragging = false;
let isControlDragging = false;
let isPointerLocked = false;
let lastActionVoxelCoords = null;
let initialClickPos = null;
let initialTargetVoxelCoords = null;
let isDragging = false;
let firstMoveAfterLock = true;
let mouseMovementX = 0;
let mouseMovementY = 0;

const dummy = new THREE.Object3D();
const previewVoxelGeometry = new THREE.BoxGeometry(VS, VS, VS);
const previewVoxelMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5, depthTest: false });
previewVoxelMaterial.polygonOffset = true;
previewVoxelMaterial.polygonOffsetFactor = -1;
let previewVoxelMesh = new THREE.Mesh(previewVoxelGeometry, previewVoxelMaterial);

const Modes = {
    ADD: 'Hinzuf√ºgen',
    DELETE: 'L√∂schen',
    DRAW: 'Zeichnen',
};

const ModeIcons = {
    ADD: 'fas fa-plus',
    DELETE: 'fas fa-trash',
    DRAW: 'fas fa-paint-brush'
};

const AxisIcons = {
    x: 'fas fa-arrows-alt-h',
    y: 'fas fa-arrows-alt-v',
    z: 'fas fa-arrows-alt'
};

let currentMode = Modes.ADD;

let history = [];
let historyPointer = -1;
const MAX_HISTORY_SIZE = 100;

let currentStrokeVoxels = new Map();
let voxelsAtDragStart = null;
let currentStrokeVoxelKeys = new Set(); // To track keys of voxels in current stroke

let previewLineInstancedMesh;
const maxPreviewInstances = 180 * 3;
let previewLineVoxels = [];

let templateImageMesh = null;
let templateImageData = null;

let isMobile = window.matchMedia('(max-width: 768px)').matches;

let initialDragVoxelWorldPos = null;
let dragAxisLock = null;
let initialDragVoxelCoords = null;
let dragFixedLayerCoord = null; // For layer lock during adding

let projectTitle = '';
let projectDescription = '';
let projectCategory = 'Allgemein';
let projectTags = [];
let projectRemixOf = '';
let projectSourceJsonUrl = '';
let projectVisibility = 'public';

const predefinedCategories = ["Spielzeug", "Dekoration", "Funktional", "Kunst", "Allgemein", "Charaktere", "Fahrzeuge", "Natur", "Architektur", "Abstrakt"];

const VoxelShaperIO = {
    saveBlob: function(data, filename) {
        const url = URL.createObjectURL(new Blob([data], { type: 'application/octet-stream' }));
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    },
};


function getChunkCoords(gx, gy, gz) { return { cx: Math.floor(gx / CHUNK_SIZE), cy: Math.floor(gy / CHUNK_SIZE), cz: Math.floor(gz / CHUNK_SIZE) }; }
function getChunkKey(cx, cy, cz) { return `${cx},${cy},${cz}`; }

class VoxelChunk {
    constructor(chunkX, chunkY, chunkZ, chunkSize, scene) {
        this.chunkX = chunkX; this.chunkY = chunkY; this.chunkZ = chunkZ; this.scene = scene; this.chunkSize = chunkSize;
        this.offsetX = chunkX * chunkSize * VS; this.offsetY = chunkY * chunkSize * VS; this.offsetZ = chunkZ * chunkSize * VS;
        this.voxels = new Map(); this.globalToLocalInstanceIdMap = new Map();
        const maxInstancesInChunk = chunkSize * chunkSize * chunkSize;
        const voxelBaseGeometry = new THREE.BoxGeometry(VS, VS, VS);
        const meshMaterial = new THREE.MeshLambertMaterial();
        this.instancedMesh = new THREE.InstancedMesh(voxelBaseGeometry, meshMaterial, maxInstancesInChunk);
        this.instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(maxInstancesInChunk * 3), 3);
        this.instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        this.instancedMesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
        this.instancedMesh.castShadow = true; this.instancedMesh.receiveShadow = true; this.instancedMesh.count = 0;
        this.instancedMesh.position.set(this.offsetX, this.offsetY, this.offsetZ);
        this.scene.add(this.instancedMesh);
        this.boundingBox = new THREE.Box3(
            new THREE.Vector3(this.offsetX, this.offsetY, this.offsetZ),
            new THREE.Vector3(this.offsetX + chunkSize * VS, this.offsetY + chunkSize * VS, this.offsetZ + chunkSize * VS)
        );
    }
    getLocalKey(gx, gy, gz) { return key(gx % this.chunkSize, gy % this.chunkSize, gz % this.chunkSize); }
    
    // Method to update the color of a specific instance
    updateInstanceColor(instanceId, colorHex) {
        const color = new THREE.Color(colorHex);
        this.instancedMesh.instanceColor.setXYZ(instanceId, color.r, color.g, color.b);
        this.instancedMesh.instanceColor.needsUpdate = true;
    }

    addVoxel(gx, gy, gz, colorHex) {
        const lKey = this.getLocalKey(gx, gy, gz); const gKey = key(gx, gy, gz);
        if (this.voxels.has(lKey)) {
            const instanceId = this.voxels.get(lKey).instanceId;
            this.voxels.set(lKey, { color: colorHex, instanceId }); this.updateInstanceColor(instanceId, colorHex);
        } else {
            const instanceId = this.instancedMesh.count++;
            this.voxels.set(lKey, { color: colorHex, instanceId }); this.globalToLocalInstanceIdMap.set(gKey, instanceId);
            dummy.position.set((gx % this.chunkSize) * VS + HALF, (gy % this.chunkSize) * VS + HALF, (gz % this.chunkSize) * VS + HALF);
            dummy.updateMatrix(); this.instancedMesh.setMatrixAt(instanceId, dummy.matrix);
            this.updateInstanceColor(instanceId, colorHex);
            this.instancedMesh.instanceMatrix.needsUpdate = true; this.instancedMesh.instanceColor.needsUpdate = true;
        }
    }
    removeVoxel(gx, gy, gz) {
        const lKey = this.getLocalKey(gx, gy, gz); const gKey = key(gx, gy, gz);
        if (!this.voxels.has(lKey)) return;
        const { instanceId: removedId } = this.voxels.get(lKey);
        this.voxels.delete(lKey); this.globalToLocalInstanceIdMap.delete(gKey);
        const lastId = this.instancedMesh.count - 1;
        if (removedId !== lastId) {
            let lastVoxelLKey = null;
            for (const [lk, data] of this.voxels.entries()) { if (data.instanceId === lastId) { lastVoxelLKey = lk; break; } }
            if (lastVoxelLKey !== null) {
                const tempMatrix = new THREE.Matrix4(); this.instancedMesh.getMatrixAt(lastId, tempMatrix);
                this.instancedMesh.setMatrixAt(removedId, tempMatrix);
                this.updateInstanceColor(removedId, this.voxels.get(lastVoxelLKey).color);
                this.voxels.get(lastVoxelLKey).instanceId = removedId;
                const [lx, ly, lz] = parseKey(lastVoxelLKey);
                this.globalToLocalInstanceIdMap.set(key(this.chunkX * this.chunkSize + lx, this.chunkY * this.chunkSize + ly, this.chunkZ * this.chunkSize + lz), removedId);
            }
        }
        this.instancedMesh.count--;
        this.instancedMesh.instanceMatrix.needsUpdate = true; this.instancedMesh.instanceColor.needsUpdate = true;
    }
    recolorVoxel(gx, gy, gz, newColorHex) {
        const lKey = this.getLocalKey(gx, gy, gz);
        if (!this.voxels.has(lKey)) return;
        const { instanceId } = this.voxels.get(lKey);
        this.voxels.set(lKey, { color: newColorHex, instanceId: instanceId });
        this.updateInstanceColor(instanceId, newColorHex);
    }
    dispose() {
        this.scene.remove(this.instancedMesh);
        this.instancedMesh.geometry.dispose(); this.instancedMesh.material.dispose();
        this.instancedMesh = null; this.voxels.clear(); this.globalToLocalInstanceIdMap.clear();
    }
}

function onResize() {
    cam.aspect = containerDiv.clientWidth / containerDiv.clientHeight; cam.updateProjectionMatrix();
    ren.setSize(containerDiv.clientWidth, containerDiv.clientHeight);
    ren.setPixelRatio(isMobile ? Math.min(1.5, window.devicePixelRatio) : window.devicePixelRatio);
}

function handleGesture() {
    const pointers = [...activePointers.values()];
    if (pointers.length === 0) return;

    if (pointers.length === 1) {
        const p = pointers[0];
        const rotateSpeed = isMobile ? ROTATE_SPEED_TOUCH_MOBILE : ROTATE_SPEED_TOUCH_DESKTOP;
        
        let deltaX = (p.x - gestureState.lastMid.x) * rotateSpeed;
        let deltaY = (p.y - gestureState.lastMid.y) * rotateSpeed;

        if (invertLookX) deltaX *= -1;
        if (invertLookY) deltaY *= -1;

        euler.y += deltaX;
        euler.x -= deltaY;
        
        euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
        cam.quaternion.setFromEuler(euler);
        gestureState.lastMid = { x: p.x, y: p.y };

        // NEW: Check tutorial progress for camera rotation
        if (tutorial.active && tutorial.stepIndex === tutorial.getStepIndex('freelook') && (Math.abs(deltaX) > 0.0001 || Math.abs(deltaY) > 0.0001)) {
            tutorial.cameraMoved = true;
            tutorial.checkCondition();
        }
        return;
    }

    if (pointers.length >= 2) {
        const [p0, p1] = pointers;
        const midX = (p0.x + p1.x) * 0.5;
        const midY = (p0.y + p1.y) * 0.5;
        const dist = Math.hypot(p1.x - p0.x, p1.y - p0.y);

        if (gestureState.type === 'none') {
            const dMid = Math.hypot(midX - gestureState.startMid.x, midY - gestureState.startMid.y);
            const relDelta = Math.abs(dist / gestureState.startDist - 1);

            // Prioritize pinch if significant distance change, otherwise pan if significant movement
            if (relDelta > PINCH_REL_TH) {
                gestureState.type = 'pinch';
            } else if (dMid > MOVE_PX) {
                gestureState.type = 'pan';
            }
            return;
        } else if (gestureState.type === 'pinch') {
            const pinchZoomMult = isMobile ? PINCH_ZOOM_MULT_MOBILE : PINCH_ZOOM_MULT_DESKTOP;
            const zoomDelta = (dist / gestureState.lastDist - 1) * pinchZoomMult * moveSpeed;
            cam.position.addScaledVector(cam.getWorldDirection(new THREE.Vector3()), zoomDelta);
            gestureState.lastDist = dist;
        } else if (gestureState.type === 'pan') {
            const panSpeed = isMobile ? PAN_SPEED_TOUCH_MOBILE : PAN_SPEED_TOUCH_DESKTOP;
            let dx = (midX - gestureState.lastMid.x) * panSpeed;
            let dy = (midY - gestureState.lastMid.y) * panSpeed;
            
            if (reverseStrafeX) dx *= -1;
            if (reverseStrafeY) dy *= -1;

            const right = new THREE.Vector3().crossVectors(cam.getWorldDirection(new THREE.Vector3()), cam.up).normalize();
            cam.position.addScaledVector(right, dx);
            cam.position.addScaledVector(new THREE.Vector3(0, 1, 0), dy);
            
            gestureState.lastMid = { x: midX, y: midY };
        }
    }
}

function releasePointer(id, eventType) {
    activePointers.delete(id);
    if (activePointers.size < 2) {
        gestureState.type = 'none';
        if (activePointers.size === 1) { const last = [...activePointers.values()][0]; gestureState.lastMid = { x: last.x, y: last.y }; }
    }
    if (activePointers.size === 0) {
        doubleTapDragActive = false; lastActionVoxelCoords = null;
        initialDragVoxelWorldPos = null; dragAxisLock = null; initialDragVoxelCoords = null;
        previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
    }
}

function onPointerLeave(e) {
    // This function is now defined to handle the pointerleave event.
    // It will clear the preview voxel and reset drag-related states.
    if (pointerIsDown && isDragging && currentStrokeVoxels.size > 0) {
        const oldState = [];
        const newState = [];
        for (const [gKey, change] of currentStrokeVoxels.entries()) {
            const p = parseKey(gKey);
            oldState.push({ x: p[0], y: p[1], z: p[2], color: change.originalColor });
            newState.push({ x: p[0], y: p[1], z: p[2], color: change.finalColor });
        }
        if (oldState.length > 0) {
            addCommand('batch', oldState, newState);
        }
    }
    updatePreviewVoxel(0, 0, 0, false);
    previewLineInstancedMesh.count = 0;
    previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
    previewLineVoxels = [];
    pointerIsDown = false;
    isDragging = false;
    doubleTapDragActive = false;
    lastActionVoxelCoords = null;
    initialClickPos = null;
    initialTargetVoxelCoords = null;
    voxelsAtDragStart = null;
    currentStrokeVoxels.clear();
    currentStrokeVoxelKeys.clear();
    dragAxisLock = null;
    dragFixedLayerCoord = null; // Ensure this is reset

    if (e.pointerType === 'touch') {
        releasePointer(e.pointerId, e);
    }
}

function rebuildHelpers() {
    if (gridHelper) scene.remove(gridHelper); if (boxHelper) scene.remove(boxHelper);
    const size = GRID * VS;
    if (isMobile) {
        gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444 ); gridHelper.position.set(size / 2, activeDrawingLevel.y * VS, size / 2);
    } else {
        if (currentDrawingAxis === 'y') {
            gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444 ); gridHelper.position.set(size / 2, activeDrawingLevel.y * VS, size / 2);
        } else if (currentDrawingAxis === 'x') {
            gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444); gridHelper.rotation.z = Math.PI / 2; gridHelper.position.set(activeDrawingLevel.x * VS, size / 2, size / 2);
        } else if (currentDrawingAxis === 'z') {
            gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444); gridHelper.rotation.x = Math.PI / 2; gridHelper.position.set(size / 2, size / 2, activeDrawingLevel.z * VS);
        }
    }
    scene.add(gridHelper);
    const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(size, size, size));
    boxHelper = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x00ffff }));
    boxHelper.position.set(size / 2, size / 2, size / 2); scene.add(boxHelper);

    const mobileAxisIcon = document.getElementById('mobile-axis-icon');
    if (mobileAxisIcon) {
        mobileAxisIcon.className = AxisIcons[currentDrawingAxis];
    }
}

function updateGridHelperPosition() {
    rebuildHelpers();
    localStorage.setItem('voxelEditorActiveDrawingLevelX', activeDrawingLevel.x);
    localStorage.setItem('voxelEditorActiveDrawingLevelY', activeDrawingLevel.y);
    localStorage.setItem('voxelEditorActiveDrawingLevelZ', activeDrawingLevel.z);
    localStorage.setItem('voxelEditorCurrentDrawingAxis', currentDrawingAxis);
}

function cycleMode() {
    const activeElement = document.activeElement;
    if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'SELECT' || activeElement.tagName === 'TEXTAREA')) {
        cvs.focus(); return;
    }
    const oldMode = currentMode;
    switch (currentMode) {
        case Modes.ADD: currentMode = Modes.DELETE; break;
        case Modes.DELETE: currentMode = Modes.DRAW; break;
        case Modes.DRAW: currentMode = Modes.ADD; break;
    }
    document.getElementById('current-mode').textContent = `Modus: ${currentMode}`;
    const mobileModeIcon = document.getElementById('mobile-mode-icon');
    if (mobileModeIcon) {
        mobileModeIcon.className = ModeIcons[Object.keys(Modes).find(key => Modes[key] === currentMode)];
    }
    lastActionVoxelCoords = null; updatePreviewVoxel(0, 0, 0, false);
    previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];

    // NEW: Check tutorial progress
    if (tutorial.active) {
        const modeToggleBtn = document.getElementById('modeToggle');
        // The tutorial step for changing to ADD mode is removed, so no check for it here.
        if (oldMode === Modes.ADD && currentMode === Modes.DELETE && tutorial.stepIndex === tutorial.getStepIndex('changeModeToDelete')) {
            tutorial.checkCondition(modeToggleBtn);
        } else if (oldMode === Modes.DELETE && currentMode === Modes.DRAW && tutorial.stepIndex === tutorial.getStepIndex('changeModeToDraw')) {
            tutorial.checkCondition(modeToggleBtn);
        }
    }
}

function setActivePreset(index) {
    if (index >= 0 && index < presetColors.length) {
        currentColor = presetColors[index];
        document.getElementById('color-picker-input-hidden').value = currentColor; // Update hidden input
        document.getElementById('color-picker-swatch').style.backgroundColor = currentColor; // Update swatch
        const mobileColorInput = document.getElementById('mobile-color-input-hidden');
        if (mobileColorInput) mobileColorInput.value = currentColor;
        localStorage.setItem('voxelEditorColor', currentColor);
        presetBoxes.forEach((box, i) => {
            if (i === index) { box.classList.add('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'); }
            else { box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'); }
        });
        activePresetIndex = index;
        if (previewVoxelMesh.visible) {
            previewVoxelMaterial.color.set(currentColor);
        }

        // NEW: Check tutorial progress
        if (tutorial.active && tutorial.stepIndex === tutorial.getStepIndex('changeColor')) {
            tutorial.checkCondition(document.getElementById('color-picker-swatch'));
        }
    }
}

function savePresetColor(index, colorValue) {
    if (index >= 0 && index < presetColors.length) {
        presetColors[index] = colorValue;
        localStorage.setItem(`voxelPresetColor${index + 1}`, colorValue);
        if (activePresetIndex === index) {
            currentColor = colorValue;
            document.getElementById('color-picker-input-hidden').value = currentColor; // Update hidden input
            document.getElementById('color-picker-swatch').style.backgroundColor = currentColor; // Update swatch
            const mobileColorInput = document.getElementById('mobile-color-input-hidden');
            if (mobileColorInput) mobileColorInput.value = currentColor;
            localStorage.setItem('voxelEditorColor', currentColor);
        }
    }
}

function applyVoxelState(state) {
    for (const chunk of chunks.values()) chunk.dispose();
    chunks.clear(); voxels.clear();
    state.forEach(v => _addSingleVoxel(v.x, v.y, v.z, v.color));
}

function addCommand(type, oldState = null, newState = null, commandData = null) {
    if (historyPointer < history.length - 1) history.splice(historyPointer + 1);
    history.push({ type, oldState, newState, commandData }); historyPointer++;
    if (history.length > MAX_HISTORY_SIZE) { history.shift(); historyPointer--; }
}

function executeCommand(command, reverse = false) {
    const { type, oldState, newState, commandData } = command;
    switch (type) {
        case 'batch': applyVoxelState(reverse ? oldState : newState); break;
        case 'clearAll': clearAllInternal(true); if (reverse) applyVoxelState(oldState); break;
        case 'fillLevel': applyVoxelState(reverse ? oldState : newState); break;
        case 'resizeGrid':
            GRID = reverse ? commandData.oldGrid : commandData.newGrid;
            document.getElementById('grid-size-slider').value = GRID;
            document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`;
            localStorage.setItem('voxelEditorGridSize', GRID);
            applyVoxelState(reverse ? oldState : newState); break;
    }
    rebuildHelpers();
}

function undo() { if (historyPointer >= 0) { executeCommand(history[historyPointer], true); historyPointer--; } }
function redo() { if (historyPointer < history.length - 1) { historyPointer++; executeCommand(history[historyPointer], false); } }

function _addSingleVoxel(x, y, z, colorHex) {
    const gKey = key(x, y, z); voxels.set(gKey, { color: colorHex });
    const { cx, cy, cz } = getChunkCoords(x, y, z); const cKey = getChunkKey(cx, cy, cz);
    let chunk = chunks.get(cKey);
    if (!chunk) { chunk = new VoxelChunk(cx, cy, cz, CHUNK_SIZE, scene); chunks.set(cKey, chunk); }
    chunk.addVoxel(x, y, z, colorHex);
}

function _removeSingleVoxel(x, y, z) {
    const gKey = key(x, y, z); if (!voxels.has(gKey)) return;
    voxels.delete(gKey);
    const { cx, cy, cz } = getChunkCoords(x, y, z); const cKey = getChunkKey(cx, cy, cz);
    if (chunks.has(cKey)) {
        const chunk = chunks.get(cKey); chunk.removeVoxel(x, y, z);
        if (chunk.instancedMesh.count === 0) { chunk.dispose(); chunks.delete(cKey); }
    }
}

function _recolorSingleVoxel(x, y, z, newColorHex) {
    const gKey = key(x, y, z); if (!voxels.has(gKey)) return;
    voxels.set(gKey, { color: newColorHex });
    const { cx, cy, cz } = getChunkCoords(x, y, z); const cKey = getChunkKey(cx, cy, cz);
    if (chunks.has(cKey)) chunks.get(cKey).recolorVoxel(x, y, z, newColorHex);
}

function performVoxelModification(x, y, z, mode, newColor) {
    const gKey = key(x, y, z);
    const hasVoxel = voxels.has(gKey);

    x = Math.max(0, Math.min(GRID - 1, x));
    y = Math.max(0, Math.min(GRID - 1, y));
    z = Math.max(0, Math.min(GRID - 1, z));

    let modified = false;
    let initialColor = hasVoxel ? voxels.get(gKey).color : null;

    switch (mode) {
        case Modes.ADD:
            if (!hasVoxel) {
                _addSingleVoxel(x, y, z, newColor);
                modified = true;
                if (tutorial.active && tutorial.stepIndex === tutorial.getStepIndex('addVoxel')) {
                    tutorial.voxelAddedThisStep = true;
                }
            }
            break;
        case Modes.DELETE:
            if (hasVoxel) {
                _removeSingleVoxel(x, y, z);
                modified = true;
                if (tutorial.active && tutorial.stepIndex === tutorial.getStepIndex('deleteVoxel')) {
                    tutorial.voxelDeletedThisStep = true;
                }
            }
            break;
        case Modes.DRAW:
            if (hasVoxel) { // Only recolor if voxel exists
                if (initialColor !== newColor) {
                    _recolorSingleVoxel(x, y, z, newColor);
                    modified = true;
                    if (tutorial.active && tutorial.stepIndex === tutorial.getStepIndex('paintVoxel')) {
                        tutorial.voxelPaintedThisStep = true;
                    }
                }
            }
            // Do NOT add new voxels in DRAW mode
            break;
    }

    if (modified && tutorial.active) {
        // Ensure that the tutorial can track voxel changes
        if (mode === Modes.ADD && tutorial.stepIndex === tutorial.getStepIndex('addVoxel')) {
             tutorial.checkCondition(previewVoxelMesh);
        } else if (mode === Modes.DELETE && tutorial.stepIndex === tutorial.getStepIndex('deleteVoxel')) {
            tutorial.checkCondition(previewVoxelMesh);
        } else if (mode === Modes.DRAW && tutorial.stepIndex === tutorial.getStepIndex('paintVoxel')) {
            tutorial.checkCondition(previewVoxelMesh);
        }
    }
}

function updatePreviewVoxel(x, y, z, visible) {
    if (previewVoxelMesh) {
        if (visible) {
            if (previewVoxelMesh.geometry.parameters.width !== VS ||
                previewVoxelMesh.geometry.parameters.height !== VS ||
                previewVoxelMesh.geometry.parameters.depth !== VS) {
                previewVoxelMesh.geometry.dispose();
                previewVoxelMesh.geometry = new THREE.BoxGeometry(VS, VS, VS);
            }
            previewVoxelMesh.position.set(x * VS + HALF, y * VS + HALF, z * VS + HALF);
            previewVoxelMesh.visible = true;
            previewVoxelMaterial.color.set(currentColor);
            previewVoxelMaterial.opacity = (currentMode === Modes.DELETE) ? 0.2 : 0.5;
        } else {
            previewVoxelMesh.visible = false;
        }
    }
}

function calculateRayTargetVoxelCoords(clientX, clientY) {
    if (isPointerLocked) return null;

    const rect = cvs.getBoundingClientRect();
    const mouse = new THREE.Vector2(
        ((clientX - rect.left) / rect.width) * 2 - 1,
        -((clientY - rect.top) / rect.height) * 2 + 1
    );

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, cam);

    const objectsToIntersect = Array.from(chunks.values()).map(chunk => chunk.instancedMesh);
    if (templateImageMesh) {
        templateImageMesh.raycast = function() {}; // Prevent template image from being intersected
    }

    const intersects = raycaster.intersectObjects(objectsToIntersect);

    let hitResult = null;
    if (intersects.length > 0) {
        const hit = intersects[0];
        const hitNormal = hit.face.normal.clone();
        const intersectionPoint = hit.point;

        if (!Number.isFinite(intersectionPoint.x) || !Number.isFinite(intersectionPoint.y) || !Number.isFinite(intersectionPoint.z)) {
            return null;
        }

        const epsilon = 0.001;
        let adjustedPoint = intersectionPoint.clone().addScaledVector(hitNormal, -epsilon);

        let hitVoxelX = Math.floor(adjustedPoint.x / VS);
        let hitVoxelY = Math.floor(adjustedPoint.y / VS);
        let hitVoxelZ = Math.floor(adjustedPoint.z / VS);

        if (currentMode === Modes.ADD) {
             hitVoxelX += hitNormal.x;
             hitVoxelY += hitNormal.y;
             hitVoxelZ += hitNormal.z;
        }
        
        // Note: Clamping is done AFTER potential adjustment by normal for ADD mode,
        // but BEFORE returning, so the coordinates are always within grid bounds.
        hitVoxelX = Math.max(0, Math.min(GRID - 1, hitVoxelX));
        hitVoxelY = Math.max(0, Math.min(GRID - 1, hitVoxelY));
        hitVoxelZ = Math.max(0, Math.min(GRID - 1, hitVoxelZ));

        hitResult = { x: Number(hitVoxelX), y: Number(hitVoxelY), z: Number(hitVoxelZ), faceNormal: hitNormal, hitExistingVoxel: true };
        if (!Number.isFinite(hitResult.x) || !Number.isFinite(hitResult.y) || !Number.isFinite(hitResult.z)) {
            hitResult = null;
        }
    }

    if (hitResult === null) {
        if (currentMode === Modes.ADD) { // Only allow ADD mode to draw on plane
            let planeNormal = new THREE.Vector3();
            let planeConstant = 0;

            if (currentDrawingAxis === 'y') {
                planeNormal.set(0, 1, 0);
                planeConstant = -(activeDrawingLevel.y * VS);
            } else if (currentDrawingAxis === 'x') {
                planeNormal.set(1, 0, 0);
                planeConstant = -(activeDrawingLevel.x * VS);
            } else if (currentDrawingAxis === 'z') {
                planeNormal.set(0, 0, 1);
                planeConstant = -(activeDrawingLevel.z * VS);
            }

            const drawingPlane = new THREE.Plane(planeNormal, planeConstant);
            const intersectionPoint = new THREE.Vector3();

            if (raycaster.ray.intersectPlane(drawingPlane, intersectionPoint)) {
                if (!Number.isFinite(intersectionPoint.x) || !Number.isFinite(intersectionPoint.y) || !Number.isFinite(intersectionPoint.z)) {
                    return null;
                }

                let x = Math.floor(intersectionPoint.x / VS);
                let y = Math.floor(intersectionPoint.y / VS);
                let z = Math.floor(intersectionPoint.z / VS);

                // Crucially, snap to the activeDrawingLevel for the current axis.
                if (currentDrawingAxis === 'y') y = activeDrawingLevel.y;
                else if (currentDrawingAxis === 'x') x = activeDrawingLevel.x;
                else if (currentDrawingAxis === 'z') z = activeDrawingLevel.z;

                x = Number(x);
                y = Number(y);
                z = Number(z);

                if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(z)) {
                    return null;
                }
                
                hitResult = { x, y, z, faceNormal: null, hitExistingVoxel: false };
            }
        }
    }
    return hitResult;
}

function clearAllInternal(fromHistory = false) {
    if (!fromHistory) {
        const oldState = [...voxels.entries()].map(([id, data]) => { const p = parseKey(id); return { x: p[0], y: p[1], z: p[2], color: data.color }; });
        addCommand('clearAll', oldState, []);
    }
    for (const chunk of chunks.values()) chunk.dispose();
    chunks.clear(); voxels.clear(); rebuildHelpers();

    // NEW: Check tutorial progress
    if (tutorial.active && tutorial.stepIndex === tutorial.getStepIndex('clearAll')) {
        tutorial.checkCondition(document.getElementById('clearBtn'));
    }
}
function clearAll() { clearAllInternal(false); }

function fillActiveLevel() {
    const oldState = [...voxels.entries()].map(([id, data]) => { const p = parseKey(id); return { x: p[0], y: p[1], z: p[2], color: data.color }; });
    const voxelsToRemove = [];
    for (let x = 0; x < GRID; x++) { for (let z = 0; z < GRID; z++) {
        let gx, gy, gz;
        if (currentDrawingAxis === 'y') { gx = x; gy = activeDrawingLevel.y; gz = z; }
        else if (currentDrawingAxis === 'x') { gx = activeDrawingLevel.x; gy = x; gz = z; }
        else if (currentDrawingAxis === 'z') { gx = x; gy = z; gz = activeDrawingLevel.z; }
        const k = key(gx, gy, gz); if (voxels.has(k)) voxelsToRemove.push(k);
    }}
    voxelsToRemove.forEach(k => { const [gx, gy, gz] = parseKey(k); _removeSingleVoxel(gx, gy, gz); });
    const newState = [];
    for (let x = 0; x < GRID; x++) { for (let z = 0; z < GRID; z++) {
        let gx, gy, gz;
        if (currentDrawingAxis === 'y') { gx = x; gy = activeDrawingLevel.y; gz = z; }
        else if (currentDrawingAxis === 'x') { gx = activeDrawingLevel.x; gy = x; gz = z; }
        else if (currentDrawingAxis === 'z') { gx = x; gy = z; gz = activeDrawingLevel.z; }
        _addSingleVoxel(gx, gy, gz, currentColor); newState.push({ x: gx, y: gy, z: gz, color: currentColor, dimX: 1, dimY: 1, dimZ: 1 });
    }}
    addCommand('fillLevel', oldState, newState);

    // NEW: Check tutorial progress
    if (tutorial.active && tutorial.stepIndex === tutorial.getStepIndex('fillLevel')) {
        tutorial.checkCondition(document.getElementById('fillLevelBtn'));
    }
}

function downloadBlob(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

function saveJSON() {
    // MODIFIED: Check if there's at least one voxel
    if (voxels.size === 0) {
        showToast('Speichern fehlgeschlagen', 'Keine Voxel zum Speichern vorhanden! Bitte erstellen Sie zuerst ein Modell.', 'warning', 5000);
        return;
    }

    const data = {};
    voxels.forEach((value, k) => {
        const [x, y, z] = parseKey(k);
        data[`${x},${y},${z}`] = value.color;
    });

    const settings = {
        gridSize: GRID,
        cameraPosition: cam.position.toArray(),
        cameraQuaternion: cam.quaternion.toArray(),
        activeDrawingLevel: activeDrawingLevel,
        currentDrawingAxis: currentDrawingAxis,
        currentColor: currentColor,
        presetColors: presetColors,
        activePresetIndex: activePresetIndex,
        moveSpeed: moveSpeed,
        rotSpeed: rotSpeed, // Save rotation speed
        invertLookX: invertLookX, // Save invert look X
        invertLookY: invertLookY, // Save invert look Y
        reverseStrafeX: reverseStrafeX, // Save reverse strafe X
        reverseStrafeY: reverseStrafeY, // Save reverse strafe Y
        templateImageData: templateImageData,
        // NEW: Save tutorial state
        tutorial: {
            active: tutorial.active,
            stepIndex: tutorial.stepIndex
        }
    };

    const fileContent = {
        title: projectTitle,
        description: projectDescription,
        category: projectCategory,
        tags: projectTags,
        remixOf: projectRemixOf,
        sourceJsonUrl: projectSourceJsonUrl,
        visibility: projectVisibility,
        fileName: `${projectTitle.replace(/\s+/g, "_") || "voxel_project"}.json`,
        timestamp: new Date().toISOString(),

        projectData: {
            settings: settings,
            voxels: data
        }
    };

    downloadBlob(new Blob([JSON.stringify(fileContent, null, 2)], { type: 'application/json' }), fileContent.fileName);
    showToast('Speichern erfolgreich', 'Projekt als JSON-Datei gespeichert.', 'success', 5000);

    // NEW: Set tutorial flag for saving
    if (tutorial.active) {
        tutorial.savedProject = true;
        tutorial.checkCondition(document.getElementById('saveBtn'));
    }
}

function resetToDefaultProject() {
    clearAllInternal(true); GRID = 10;
    document.getElementById('grid-size-slider').value = GRID; document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`; localStorage.setItem('voxelEditorGridSize', GRID);
    currentColor = '#008080'; // Set default color to turquoise
    document.getElementById('color-picker-input-hidden').value = currentColor; // Update hidden input
    document.getElementById('color-picker-swatch').style.backgroundColor = currentColor; // Update swatch
    const mobileColorInput = document.getElementById('mobile-color-input-hidden');
    if (mobileColorInput) mobileColorInput.value = currentColor;
    localStorage.setItem('voxelEditorColor', currentColor);

    activeDrawingLevel = { x: 0, y: 0, z: 0 }; currentDrawingAxis = 'y';
    localStorage.setItem('voxelEditorActiveDrawingLevelX', activeDrawingLevel.x);
    localStorage.setItem('voxelEditorActiveDrawingLevelY', activeDrawingLevel.y);
    localStorage.setItem('voxelEditorActiveDrawingLevelZ', activeDrawingLevel.z);
    localStorage.setItem('voxelEditorCurrentDrawingAxis', currentDrawingAxis);
    moveSpeed = 0.1; document.getElementById('fly-speed-slider').value = moveSpeed; document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2); localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
    rotSpeed = 0.003; document.getElementById('rot-speed-slider').value = rotSpeed; document.getElementById('rot-speed-display').textContent = rotSpeed.toFixed(4); localStorage.setItem('voxelEditorRotSpeed', rotSpeed); // Reset rotation speed
    
    // Reset new settings
    invertLookX = false; localStorage.setItem('voxelEditorInvertLookX', 'false');
    invertLookY = false; localStorage.setItem('voxelEditorInvertLookY', 'false');
    reverseStrafeX = false; localStorage.setItem('voxelEditorReverseStrafeX', 'false');
    reverseStrafeY = false; localStorage.setItem('voxelEditorReverseStrafeY', 'false');
    updateMobileCameraControlButtons(); // Update button states

    presetColors[0] = '#E4002B'; presetColors[1] = '#00A040'; presetColors[2] = '#0057B8';
    localStorage.setItem('voxelPresetColor1', presetColors[0]); localStorage.setItem('voxelPresetColor2', presetColors[1]); localStorage.setItem('voxelPresetColor3', presetColors[2]);
    presetBoxes.forEach((box, i) => { box.value = presetColors[i]; box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'); });
    activePresetIndex = -1; removeImageTemplate(true); history.length = 0; historyPointer = -1;
    previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
    projectTitle = ''; projectDescription = ''; projectCategory = 'Allgemein'; projectTags = []; projectRemixOf = ''; projectSourceJsonUrl = ''; projectVisibility = 'public';
    rebuildHelpers(); resetCameraPosition(); showToast('Projekt zur√ºckgesetzt', 'Das Projekt wurde auf den Standardzustand zur√ºckgesetzt.', 'info', 5000);
}

function loadProjectData(projectData) {
    try {
        const loadedVoxels = projectData.projectData ? projectData.projectData.voxels : projectData.voxels;
        const loadedSettings = projectData.projectData ? projectData.projectData.settings : projectData.settings;
        clearAllInternal(true); removeImageTemplate(true);
        projectTitle = projectData.title || ''; projectDescription = projectData.description || '';
        projectCategory = projectData.category || 'Allgemein';
        projectTags = Array.isArray(projectData.tags) ? projectData.tags : (typeof projectData.tags === 'string' ? projectData.tags.split(',').map(tag => tag.trim()).filter(tag => tag !== '') : []);
        projectRemixOf = projectData.remixOf || ''; projectSourceJsonUrl = projectData.sourceJsonUrl || ''; projectVisibility = projectData.visibility || 'public';

        if (loadedSettings) {
            GRID = loadedSettings.gridSize !== undefined ? loadedSettings.gridSize : 10;
            document.getElementById('grid-size-slider').value = GRID; document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`; localStorage.setItem('voxelEditorGridSize', GRID);
        }
        for (const k in loadedVoxels) {
            const colorValue = loadedVoxels[k]; const parts = k.split(',').map(Number);
            if (parts.length === 3 && !isNaN(parts[0]) && !isNaN(parts[1]) && !isNaN(parts[2])) {
                const x = parts[0]; const y = parts[1]; const z = parts[2];
                if (x >= 0 && x < GRID && y >= 0 && y < GRID && z >= 0 && z < GRID) _addSingleVoxel(x, y, z, colorValue);
            }
        }
        if (loadedSettings) {
            if (loadedSettings.cameraPosition) cam.position.fromArray(loadedSettings.cameraPosition);
            if (loadedSettings.cameraQuaternion) { cam.quaternion.fromArray(loadedSettings.cameraQuaternion); euler.setFromQuaternion(cam.quaternion, 'YXZ'); }
            if (loadedSettings.activeDrawingLevel) {
                activeDrawingLevel = {
                    x: Number(loadedSettings.activeDrawingLevel.x || 0),
                    y: Number(loadedSettings.activeDrawingLevel.y || 0),
                    z: Number(loadedSettings.activeDrawingLevel.z || 0)
                };
                if (!Number.isFinite(activeDrawingLevel.x)) activeDrawingLevel.x = 0;
                if (!Number.isFinite(activeDrawingLevel.y)) activeDrawingLevel.y = 0;
                if (!Number.isFinite(activeDrawingLevel.z)) activeDrawingLevel.z = 0;

                activeDrawingLevel.x = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.x)));
                activeDrawingLevel.y = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.y)));
                activeDrawingLevel.z = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.z)));

                localStorage.setItem('voxelEditorActiveDrawingLevelX', activeDrawingLevel.x);
                localStorage.setItem('voxelEditorActiveDrawingLevelY', activeDrawingLevel.y);
                localStorage.setItem('voxelEditorActiveDrawingLevelZ', activeDrawingLevel.z);
            }
            if (loadedSettings.currentDrawingAxis) { currentDrawingAxis = loadedSettings.currentDrawingAxis; localStorage.setItem('voxelEditorCurrentDrawingAxis', currentDrawingAxis); }
            updateGridHelperPosition();
            currentColor = loadedSettings.currentColor || '#008080'; // Set default color to turquoise
            document.getElementById('color-picker-input-hidden').value = currentColor; // Update hidden input
            document.getElementById('color-picker-swatch').style.backgroundColor = currentColor; // Update swatch
            const mobileColorInput = document.getElementById('mobile-color-input-hidden');
            if (mobileColorInput) mobileColorInput.value = currentColor;

            if (loadedSettings.presetColors) {
                for(let i = 0; i < loadedSettings.presetColors.length && i < presetColors.length; i++) {
                    presetColors[i] = loadedSettings.presetColors[i]; document.getElementById(`color-preset-${i + 1}`).value = presetColors[i]; localStorage.setItem(`voxelPresetColor${i + 1}`, presetColors[i]);
                }
            }
            setActivePreset(loadedSettings.activePresetIndex !== undefined ? loadedSettings.activePresetIndex : -1);
            if (loadedSettings.moveSpeed !== undefined) {
                moveSpeed = loadedSettings.moveSpeed; document.getElementById('fly-speed-slider').value = moveSpeed; document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2); localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
            }
            if (loadedSettings.rotSpeed !== undefined) { // Load rotation speed
                rotSpeed = loadedSettings.rotSpeed; document.getElementById('rot-speed-slider').value = rotSpeed; document.getElementById('rot-speed-display').textContent = rotSpeed.toFixed(4); localStorage.setItem('voxelEditorRotSpeed', rotSpeed);
            }
            // Load new settings
            invertLookX = loadedSettings.invertLookX === true; localStorage.setItem('voxelEditorInvertLookX', invertLookX);
            invertLookY = loadedSettings.invertLookY === true; localStorage.setItem('voxelEditorInvertLookY', invertLookY);
            reverseStrafeX = loadedSettings.reverseStrafeX === true; localStorage.setItem('voxelEditorReverseStrafeX', reverseStrafeX);
            reverseStrafeY = loadedSettings.reverseStrafeY === true; localStorage.setItem('voxelEditorReverseStrafeY', reverseStrafeY);
            updateMobileCameraControlButtons(); // Update button states

            if (loadedSettings.templateImageData) {
                templateImageData = loadedSettings.templateImageData;
                new THREE.TextureLoader().load(templateImageData.src, (texture) => {
                    const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true, depthWrite: false });
                    const geometry = new THREE.PlaneGeometry(templateImageData.scaledWidth, templateImageData.scaledHeight);
                    if (templateImageMesh) { scene.remove(templateImageMesh); templateImageMesh.geometry.dispose(); templateImageMesh.material.dispose(); }
                    templateImageMesh = new THREE.Mesh(geometry, material);
                    templateImageMesh.position.fromArray(templateImageData.position); templateImageMesh.rotation.fromArray(templateImageData.rotation); templateImageMesh.scale.fromArray(templateImageData.scale);
                    templateImageMesh.renderOrder = -1; scene.add(templateImageMesh);
                    document.getElementById('removeImageTemplateBtn').classList.remove('hidden');
                }, undefined, (err) => { templateImageMesh = null; templateImageData = null; document.getElementById('removeImageTemplateBtn').classList.add('hidden'); });
            }
        }
        history.length = 0; historyPointer = -1;
        previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
        resetCameraPosition();
    } catch (error) {
        showToast('Fehler', 'Fehler beim Laden der Datei. Stellen Sie sicher, dass es sich um eine g√ºltige JSON-Datei handelt. Fehler: ' + error.message, 'error', 5000);
        resetToDefaultProject();
    }
}

async function loadProjectFromModelId(modelId) {
    showToast('Lade Projekt', `Lade Projekt mit ID: ${modelId}...`, 'info', 5000);
    try {
        const docSnap = await window.getDoc(window.doc(db, "models", modelId));
        if (docSnap.exists()) {
            const pData = docSnap.data();
            const isPublic = pData.visibility === 'public';
            const isOwner = auth.currentUser && auth.currentUser.uid === pData.uploaderUid;
            if (isPublic || isOwner) {
                if (pData && pData.projectData) {
                    projectRemixOf = modelId; projectSourceJsonUrl = window.location.href;
                    loadProjectData(pData);
                    showToast('Projekt geladen', `Projekt "${docSnap.data().title}" erfolgreich geladen.`, 'success', 5000);
                } else { showToast('Fehler', 'Projektdaten im Dokument nicht gefunden.', 'error', 5000); resetToDefaultProject(); }
            } else { showToast('Zugriff verweigert', 'Sie haben keine Berechtigung, dieses private Projekt zu laden.', 'error', 5000); resetToDefaultProject(); }
        } else { showToast('Projekt nicht gefunden', `Kein Projekt mit ID "${modelId}" gefunden.`, 'warning', 5000); resetToDefaultProject(); }
    } catch (error) {
        if (error.code === 'permission-denied') showToast('Zugriff verweigert', `Berechtigungsfehler beim Laden des Projekts. Stellen Sie sicher, dass das Modell √∂ffentlich ist oder Sie der Eigent√ºmer sind.`, 'error', 5000);
        else showToast('Fehler', `Fehler beim Laden des Projekts: ${error.message}`, 'error', 5000);
        resetToDefaultProject();
    }
}

function loadJSON(event) {
    const file = event.target.files[0]; if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const projectData = JSON.parse(e.target.result);
            projectRemixOf = ''; projectSourceJsonUrl = ''; loadProjectData(projectData);
        } catch (error) {
            showToast('Fehler', 'Fehler beim Parsen der Datei. Stellen Sie sicher, dass es sich um eine g√ºltige JSON-Datei handelt. Fehler: ' + error.message, 'error', 5000);
            resetToDefaultProject();
        }
    };
    reader.readAsText(file);
}

function buildMergedGeometry(effectiveVoxelSize = VS) {
    const tempBoxGeometry = new THREE.BoxGeometry(effectiveVoxelSize, effectiveVoxelSize, effectiveVoxelSize);
    
    const allGeometries = [];
    voxels.forEach((data, k) => {
        const p = parseKey(k);
        dummy.position.set(p[0] * effectiveVoxelSize + effectiveVoxelSize * 0.5,
                            p[1] * effectiveVoxelSize + effectiveVoxelSize * 0.5,
                            p[2] * effectiveVoxelSize + effectiveVoxelSize * 0.5);
        dummy.updateMatrix();
        const instanceGeometry = tempBoxGeometry.clone();
        instanceGeometry.applyMatrix4(dummy.matrix);
        allGeometries.push(instanceGeometry);
    });

    const mergedGeometry = allGeometries.length > 0 ? THREE.BufferGeometryUtils.mergeBufferGeometries(allGeometries, true) : new THREE.BufferGeometry();
    allGeometries.forEach(g => g.dispose());
    tempBoxGeometry.dispose();
    return mergedGeometry;
}

function applyAxisTransform(geometry, upAxis) {
    if (upAxis === 'Z') {
        geometry.rotateX(-Math.PI / 2);
    }
}

async function exportSTL(exportScaleUnit, exportUpAxis) {
    // MODIFIED: Check if there's at least one voxel
    if (voxels.size === 0) { showToast('Export fehlgeschlagen', 'Keine Voxel zum Exportieren vorhanden! Bitte erstellen Sie zuerst ein Modell.', 'warning', 5000); return false; }
    showToast('Exportiere STL', 'Erzeuge STL-Modell...', 'info', 5000);

    try {
        const effectiveVoxelSize = exportScaleUnit === 'mm' ? VS : VS / 10;
        const mergedGeometry = buildMergedGeometry(effectiveVoxelSize); 
        
        applyAxisTransform(mergedGeometry, exportUpAxis);

        const tempMesh = new THREE.Mesh(mergedGeometry);

        if (typeof THREE.STLExporter === 'undefined') { throw new Error('STLExporter-Bibliothek nicht geladen.'); }
        const exporter = new THREE.STLExporter();
        const result = exporter.parse(tempMesh);

        VoxelShaperIO.saveBlob(result, 'voxel_model.stl');
        
        if (mergedGeometry) mergedGeometry.dispose();
        tempMesh.geometry.dispose();
        if (tempMesh.material) tempMesh.material.dispose();

        showToast('Export erfolgreich', `STL-Modell erfolgreich in ${exportScaleUnit} exportiert!`, 'success', 5000);
        return true;
    } catch (error) {
        showToast('Export fehlgeschlagen', `Fehler beim Exportieren des STL-Modells: ${error.message}`, 'error', 5000);
        return false;
    } finally {
        // NEW: Check tutorial progress
        if (tutorial.active && tutorial.stepIndex === tutorial.getStepIndex('exportSTL')) {
            // This is called AFTER the export is attempted. If it was successful, tutorial.exportedSTL will be set true
            tutorial.exportedSTL = true; // Set exportedSTL to true regardless of direct success/failure here for tutorial purposes
            tutorial.checkCondition(document.getElementById('exportBtn'));
        }
    }
}

// All other export functions (OBJ, 3MF, GLB) removed as not needed for STL only.

// Declare toastContainer at a broader scope
let toastContainer;

function showToast(title, message, type = 'info', duration = 5000) {
    if (!toastContainer) {
        console.error("Toast container not initialized. Call init for tutorial or check onload function.");
        return;
    }
    const toast = document.createElement('div');
    toast.className = `alert shadow-lg ${type === 'info' ? 'alert-info' : type === 'success' ? 'alert-success' : type === 'error' ? 'alert-error' : type === 'warning' ? 'alert-warning' : ''}`;
    toast.innerHTML = `
        ${type === 'info' ? '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" class="stroke-current shrink-0 h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>' : ''}
        ${type === 'success' ? '<svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>' : ''}
        ${type === 'error' ? '<svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>' : ''}
        ${type === 'warning' ? '<svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>' : ''}
        <div><strong>${title}</strong><br><span>${message}</span></div><button class="close-btn btn btn-ghost btn-sm">&times;</button>`;
    toastContainer.appendChild(toast);
    void toast.offsetWidth; toast.classList.add('show');
    toast.querySelector('.close-btn').addEventListener('click', () => { toast.classList.remove('show'); toast.addEventListener('transitionend', () => toast.remove(), { once: true }); });
    setTimeout(() => { if (toast.parentNode) { toast.classList.remove('show'); toast.addEventListener('transitionend', () => toast.remove(), { once: true }); } }, duration);
}

function resetCameraPosition() {
    cam.position.set(GRID * 1.0, GRID * 1.2, GRID * 1.5); cam.lookAt(GRID / 2, GRID / 2, GRID / 2);
    if (euler) euler.setFromQuaternion(cam.quaternion, 'YXZ');
}

function loadImageTemplate() {
    document.getElementById('imageFileInput').click();
}

function handleImageFileSelect(event) {
    const file = event.target.files[0];
    if (!file) {
        return;
    }
    const reader = new FileReader();
    reader.onload = (e) => {
        const base64Image = e.target.result;
        const img = new Image();
        img.onload = () => {
            const aspectRatio = img.width / img.height;
            const planeWidth = GRID * VS;
            const planeHeight = planeWidth / aspectRatio;

            if (templateImageMesh) {
                scene.remove(templateImageMesh);
                templateImageMesh.geometry.dispose();
                templateImageMesh.material.dispose();
            }

            const texture = new THREE.TextureLoader().load(base64Image);
            const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true, depthWrite: false });
            const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
            templateImageMesh = new THREE.Mesh(geometry, material);

            templateImageMesh.position.set((GRID * VS) / 2, (GRID * VS) / 2, -0.001);
            templateImageMesh.rotation.set(0, 0, 0);

            templateImageMesh.renderOrder = -1; scene.add(templateImageMesh);
            templateImageData = {
                src: base64Image,
                position: templateImageMesh.position.toArray(),
                rotation: templateImageMesh.rotation.toArray(),
                scale: [1, 1, 1],
                scaledWidth: planeWidth,
                scaledHeight: planeHeight
            };
            document.getElementById('removeImageTemplateBtn').classList.remove('hidden');
            showToast('Bildvorlage geladen', 'Bild als Vorlage erfolgreich geladen.', 'success', 5000);
        };
        img.onerror = (err) => {
            showToast('Fehler', 'Bild konnte nicht geladen werden. Ung√ºltiges Bildformat?', 'error', 5000);
            templateImageMesh = null;
            templateImageData = null;
            document.getElementById('removeImageTemplateBtn').classList.add('hidden');
        };
        img.src = base64Image;
    };
    reader.onerror = (err) => {
        showToast('Fehler', 'Fehler beim Lesen der Bilddatei.', 'error', 5000);
    };
    reader.readAsDataURL(file);

    event.target.value = '';
}
function removeImageTemplate(fromLoad = false) {
    if (templateImageMesh) {
        scene.remove(templateImageMesh); templateImageMesh.geometry.dispose(); templateImageMesh.material.dispose();
        templateImageMesh = null; templateImageData = null; document.getElementById('removeImageTemplateBtn').classList.add('hidden');
        if (!fromLoad) showToast('Bildvorlage entfernt', 'Bildvorlage erfolgreich entfernt.', 'info', 5000);
    }
}

function getCurrentBlockDimensions() {
    return { dimX: 1, dimY: 1, dimZ: 1 };
}

async function loginLogout() {
    if (auth.currentUser) { try { await window.signOut(auth); showToast('Abgemeldet', 'Sie wurden erfolgreich abgemeldet.', 'info', 5000); } catch (e) { showToast('Abmeldefehler', `Fehler: ${e.message}`, 'error', 5000); } }
    else openAuthModal();
}

function openUploadModal() {
    if (!currentUserId) { openAuthModal(); return; }
    if (voxels.size === 0) { showToast('Upload fehlgeschuldert', 'Die Szene ist leer. Bitte erstellen Sie zuerst ein Modell.', 'warning', 5000); return; }
    document.getElementById('uploadTitle').value = projectTitle; document.getElementById('uploadDescription').value = projectDescription;
    document.getElementById('uploadCategory').value = projectCategory; document.getElementById('uploadTags').value = projectTags.join(', ');
    document.querySelector(`input[name="uploadVisibility"][value="${projectVisibility}"]`).checked = true;
    const uploadCategorySelect = document.getElementById('uploadCategory');
    uploadCategorySelect.innerHTML = '<option value="" disabled selected>Kategorie ausw√§hlen</option>';
    predefinedCategories.forEach(cat => { const opt = document.createElement('option'); opt.value = cat; opt.textContent = cat; uploadCategorySelect.appendChild(opt); });
    uploadCategorySelect.value = projectCategory;
    document.getElementById('uploadProjectModal').showModal();
}

async function uploadProjectToHub() {
    if (!currentUserId) { showToast('Fehler', 'Nicht angemeldet. Bitte melden Sie sich an, um hochzuladen.', 'error', 5000); return; }
    if (voxels.size === 0) { showToast('Upload fehlgeschuldert', 'Die Szene ist leer. Bitte erstellen Sie zuerst ein Modell.', 'warning', 5000); return; }
    const title = document.getElementById('uploadTitle').value.trim();
    const description = document.getElementById('uploadDescription').value.trim();
    const category = document.getElementById('uploadCategory').value;
    const tags = document.getElementById('uploadTags').value.split(',').map(tag => tag.trim()).filter(tag => tag !== '');
    const visibility = document.querySelector('input[name="uploadVisibility"]:checked').value;
    if (!title) { showToast('Fehler', 'Bitte geben Sie einen Titel f√ºr Ihr Projekt ein.', 'warning', 5000); return; }
    if (!category) { showToast('Fehler', 'Bitte w√§hlen Sie eine Kategorie f√ºr Ihr Projekt aus.', 'warning', 5000); 'warning'; return; }
    showToast('Lade hoch...', 'Ihr Projekt wird hochgeladen. Bitte warten Sie...', 'info', 5000);
    try {
        const voxelMap = {}; voxels.forEach((v, k) => { const [x, y, z] = parseKey(k); voxelMap[`${x},${y},${z}`] = v.color; });
        const firestoreSafeSettings = {
            gridSize: GRID, cameraPosition: cam.position.toArray(), cameraQuaternion: cam.quaternion.toArray(),
            activeDrawingLevel: activeDrawingLevel, currentDrawingAxis: currentDrawingAxis, currentColor: currentColor,
            presetColors: presetColors, activePresetIndex: activePresetIndex, moveSpeed: moveSpeed,
            rotSpeed: rotSpeed, // Save rotation speed
            invertLookX: invertLookX, invertLookY: invertLookY,
            reverseStrafeX: reverseStrafeX, reverseStrafeY: reverseStrafeY,
            templateImageData: null
        };
        const firestoreDocument = {
            title: title, description: description, category: category, tags: tags, visibility: visibility,
            remixOf: projectRemixOf || "", sourceJsonUrl: projectSourceJsonUrl || "",
            fileName: `${title.replace(/\s+/g, "_")}.json`, downloads: 0, rating: 0, ratingCount: 0, verified: false,
            userId: currentUserId, uploaderEmail: currentUser?.email || "", uploaderUid: currentUser?.uid || "",
            uploaderPhotoURL: currentUser?.photoURL || "", timestamp: window.serverTimestamp(),
            projectData: {
                description: description, remixOf: projectRemixOf || "", sourceJsonUrl: projectSourceJsonUrl || "",
                settings: firestoreSafeSettings, activeDrawingLevel: firestoreSafeSettings.activeDrawingLevel, activePresetIndex: firestoreSafeSettings.activePresetIndex,
                cameraPosition: firestoreSafeSettings.cameraPosition, cameraQuaternion: firestoreSafeSettings.cameraQuaternion,
                currentColor: firestoreSafeSettings.currentColor, currentDrawingAxis: firestoreSafeSettings.currentDrawingAxis,
                gridSize: firestoreSafeSettings.gridSize, moveSpeed: firestoreSafeSettings.moveSpeed, rotSpeed: firestoreSafeSettings.rotSpeed, presetColors: firestoreSafeSettings.presetColors,
                invertLookX: firestoreSafeSettings.invertLookX, invertLookY: firestoreSafeSettings.invertLookY,
                reverseStrafeX: firestoreSafeSettings.reverseStrafeX, reverseStrafeY: firestoreSafeSettings.reverseStrafeY,
                templateImageData: null, voxels: voxelMap
            }
        };
        const docRef = await window.addDoc(window.collection(db, "models"), firestoreDocument);
        projectTitle = title; projectDescription = description; projectCategory = category; projectTags = tags; projectVisibility = visibility;
        if (!projectSourceJsonUrl) projectSourceJsonUrl = `https://hub.voxelshaper.com?modelId=${docRef.id}`;
        showToast('Erfolgreich hochgeladen', `Ihr Projekt wurde erfolgreich hochgeladen! ID: ${docRef.id}`, 'success', 5000);

        // This check for tutorial will be removed as the step is removed.
        // if (tutorial.active) {
        //     tutorial.uploadedProject = true;
        //     tutorial.checkCondition(document.getElementById('uploadToHubBtn'));
        // }
    } catch (e) { showToast('Fehler beim Hochladen', `Fehler: ${e.message}`, 'error', 5000); }
    finally { document.getElementById('uploadProjectModal').close(); }
}

function openAuthModal() { document.getElementById('authModal').showModal(); document.getElementById('emailLoginForm').classList.add('hidden'); }
function closeAuthModal() { document.getElementById('authModal').close(); cvs.focus(); }

window.signInWithGoogle = async function() { try { await window.signInWithPopup(auth, new window.GoogleAuthProvider()); showToast('Anmeldung erfolgreich', 'Mit Google angemeldet.', 'success', 5000); closeAuthModal(); } catch (e) { showToast('Anmeldefehler', `Google: ${e.message}`, 'error', 5000); } }
window.signInWithGithub = async function() { try { await window.signInWithPopup(auth, new window.GithubAuthProvider()); showToast('Anmeldung erfolgreich', 'Mit GitHub angemeldet.', 'success', 5000); closeAuthModal(); } catch (e) { showToast('Anmelmelfehler', `GitHub: ${e.message}`, 'error', 5000); } }
window.signInEmailPassword = async function() { const email = document.getElementById('emailInput').value; const password = document.getElementById('passwordInput').value; try { await window.signInWithEmailAndPassword(auth, email, password); showToast('Anmeldung erfolgreich', 'Mit E-Mail angemeldet.', 'success', 5000); closeAuthModal(); } catch (e) { showToast('Anmeldefehler', `E-Mail: ${e.message}`, 'error', 5000); } }
window.signUpEmailPassword = async function() { const email = document.getElementById('emailInput').value; const password = document.getElementById('passwordInput').value; try { await window.createUserWithEmailAndPassword(auth, email, password); showToast('Registrierung erfolgreich', 'Konto erstellt und angemeldet.', 'success', 5000); closeAuthModal(); } catch (e) { showToast('Registrierungsfehler', `E-Mail: ${e.message}`, 'error', 5000); } }

function closeAllModals() {
    const modals = ['clearConfirmationModal', 'uploadProjectModal', 'authModal', 'exportOptionsModal']; // Removed ideaGeneratorModal
    modals.forEach(id => { const modal = document.getElementById(id); if (modal && modal.open) modal.close(); });
}
window.closeAllModals = closeAllModals;

function onPointerLockChange() {
    if (document.pointerLockElement === cvs) { 
        isPointerLocked = true; 
        firstMoveAfterLock = true; 
        mouseMovementX = mouseMovementY = 0; 
        updatePreviewVoxel(0,0,0,false); 
        euler.setFromQuaternion(cam.quaternion, 'YXZ'); 
    } else { 
        isPointerLocked = false; 
    }
    // No direct checkCondition here, it's checked by mousemove.
}

function onMouseWheel(e) {
    e.preventDefault();
    if (e.altKey) {
        if (!isMobile && (currentMode === Modes.ADD || currentMode === Modes.DRAW)) {
            if (e.shiftKey) { activeDrawingLevel.z = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.z - Math.sign(e.deltaY))); currentDrawingAxis = 'z'; }
            else if (e.ctrlKey) { activeDrawingLevel.x = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.x - Math.sign(e.deltaY))); currentDrawingAxis = 'x'; }
            else { activeDrawingLevel.y = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.y - Math.sign(e.deltaY))); currentDrawingAxis = 'y'; }
            updateGridHelperPosition();
        } else {
            cam.position.addScaledVector(cam.getWorldDirection(new THREE.Vector3()), e.deltaY * 0.005 * moveSpeed * 5);
        }
    } else {
        moveSpeed = Math.max(0.01, Math.min(1.0, moveSpeed - Math.sign(e.deltaY) * 0.01));
        document.getElementById('fly-speed-slider').value = moveSpeed; document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2); localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
    }
}

const keyboard = {};
function onKeyDown(e) {
    const activeModals = ['authModal', 'uploadProjectModal', 'clearConfirmationModal', 'exportOptionsModal'].some(id => document.getElementById(id).open); // Removed ideaGeneratorModal
    if (activeModals) { if (e.key === 'Escape') { closeAllModals(); e.preventDefault(); } return; }
    keyboard[e.key.toLowerCase()] = true;
    if (e.key === 'Shift') isShiftDragging = true;
    if (e.key === 'Control' || e.metaKey) isControlDragging = true;
    if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); }
    if (((e.ctrlKey || e.metaKey) && e.key === 'y') || ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'Z')) { e.preventDefault(); redo(); }
    if ((e.ctrlKey || e.metaKey) && e.key === 'd') e.preventDefault();
    if (e.key === 'Tab') { e.preventDefault(); cycleMode(); } // Tab for mode toggle
    if (e.key === ' ') { e.preventDefault(); cycleMode(); } // Space for mode toggle

    switch (e.key) { case '1': setActivePreset(0); break; case '2': setActivePreset(1); break; case '3': setActivePreset(2); break; }

    // NEW: Check tutorial progress for movement keys
    if (tutorial.active && isPointerLocked) {
        if (e.key.toLowerCase() === 'w' && tutorial.stepIndex === tutorial.getStepIndex('moveForward')) tutorial.checkCondition(cvs);
        if (e.key.toLowerCase() === 's' && tutorial.stepIndex === tutorial.getStepIndex('moveBackward')) tutorial.checkCondition(cvs);
        if (e.key.toLowerCase() === 'a' && tutorial.stepIndex === tutorial.getStepIndex('moveLeft')) tutorial.checkCondition(cvs);
        if (e.key.toLowerCase() === 'd' && tutorial.stepIndex === tutorial.getStepIndex('moveRight')) tutorial.checkCondition(cvs);
        if (e.key.toLowerCase() === 'e' && tutorial.stepIndex === tutorial.getStepIndex('moveUp')) tutorial.checkCondition(cvs);
        if (e.key.toLowerCase() === 'q' && tutorial.stepIndex === tutorial.getStepIndex('moveDown')) tutorial.checkCondition(cvs);
    }
}

function onKeyUp(e) {
    keyboard[e.key.toLowerCase()] = false;
    if (e.key === 'Shift') isShiftDragging = false;
    if (e.key === 'Control' || e.metaKey) isControlDragging = false;
}

let pointerIsDown = false;
let rightMouseButtonDown = false;
let lastX, lastY;
let suppressNextTap = false;
let lastTapTime = 0; // Added for touch double tap
let lastTapCoords = { x: 0, y: 0 }; // Added for touch double tap
const DOUBLE_TAP_TIME_THRESHOLD = 300; // ms
const DOUBLE_TAP_DIST_THRESHOLD = 20; // pixels

function getVoxelsOnLine(start, end, fixedAxis = null, fixedCoord = null) {
    const voxels = [];
    let x0 = start.x, y0 = start.y, z0 = start.z;
    let x1 = end.x, y1 = end.y, z1 = end.z;

    const dx = x1 - x0;
    const dy = y1 - y0;
    const dz = z1 - z0;

    const steps = Math.max(Math.abs(dx), Math.abs(dy), Math.abs(dz));

    if (steps === 0) {
        // Apply fixed layer constraint for single point case
        if (fixedAxis === 'x' && fixedCoord !== null) x0 = fixedCoord;
        else if (fixedAxis === 'y' && fixedCoord !== null) y0 = fixedCoord;
        else if (fixedAxis === 'z' && fixedCoord !== null) z0 = fixedCoord;

        const clampedX = Math.max(0, Math.min(GRID - 1, Math.round(x0)));
        const clampedY = Math.max(0, Math.min(GRID - 1, Math.round(y0)));
        const clampedZ = Math.max(0, Math.min(GRID - 1, Math.round(z0)));
        voxels.push({ x: clampedX, y: clampedY, z: clampedZ });
        return voxels;
    }

    const x_inc = dx / steps;
    const y_inc = dy / steps;
    const z_inc = dz / steps;

    for (let i = 0; i <= steps; i++) {
        let currentX_raw = x0 + x_inc * i;
        let currentY_raw = y0 + y_inc * i;
        let currentZ_raw = z0 + z_inc * i;

        // Force the coordinate on the fixed axis to be exactly fixedCoord
        if (fixedAxis === 'x' && fixedCoord !== null) {
            currentX_raw = fixedCoord;
        } else if (fixedAxis === 'y' && fixedCoord !== null) {
            currentY_raw = fixedCoord;
        } else if (fixedAxis === 'z' && fixedCoord !== null) {
            currentZ_raw = fixedCoord;
        }

        // Round all coordinates to nearest integer voxel, knowing that the fixed axis is already exact.
        const finalX = Math.round(currentX_raw);
        const finalY = Math.round(currentY_raw);
        const finalZ = Math.round(currentZ_raw);

        // Clamp to grid boundaries and add to list
        voxels.push({
            x: Math.max(0, Math.min(GRID - 1, finalX)),
            y: Math.max(0, Math.min(GRID - 1, finalY)),
            z: Math.max(0, Math.min(GRID - 1, finalZ))
        });
    }

    // Remove duplicates which can occur due to rounding or multiple segments hitting same voxel
    const uniqueVoxels = [];
    const seenKeys = new Set();
    for (const v of voxels) {
        const k = key(v.x, v.y, v.z);
        if (!seenKeys.has(k)) {
            seenKeys.add(k);
            uniqueVoxels.push(v);
        }
    }
    return uniqueVoxels;
}

function onPointerUp(e) {
    e.preventDefault();
    e.stopPropagation();

    if (e.button === 2) {
        rightMouseButtonDown = false;
        document.exitPointerLock();
        return;
    }
    
    if (pointerIsDown && isDragging && currentStrokeVoxels.size > 0) {
        const oldState = [];
        const newState = [];
        for (const [gKey, change] of currentStrokeVoxels.entries()) {
            const p = parseKey(gKey);
            oldState.push({ x: p[0], y: p[1], z: p[2], color: change.originalColor });
            newState.push({ x: p[0], y: p[1], z: p[2], color: change.finalColor });
        }
        if (oldState.length > 0) {
            addCommand('batch', oldState, newState);
        }
    }

    pointerIsDown = false;
    isDragging = false;
    doubleTapDragActive = false; // Reset double tap active state
    lastActionVoxelCoords = null;
    initialClickPos = null;
    initialTargetVoxelCoords = null;
    voxelsAtDragStart = null;
    currentStrokeVoxels.clear();
    currentStrokeVoxelKeys.clear();
    updatePreviewVoxel(0, 0, 0, false);
    previewLineInstancedMesh.count = 0;
    previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
    previewLineVoxels = [];
    dragAxisLock = null;
    dragFixedLayerCoord = null; // Ensure this is reset
    
    if (e.pointerType === 'touch') {
        releasePointer(e.pointerId, e);
    }
}

async function onPointerDown(e) {
    e.preventDefault();
    e.stopPropagation();

    if (e.pointerType === 'mouse' && e.button === 2) {
        try {
            await cvs.requestPointerLock();
        } catch (error) {
            showToast('Fehler', 'Zeigerfixierung fehlgeschlagen.', 'error', 3000);
        }
        rightMouseButtonDown = true;
        
        // No direct checkCondition here, it's checked by mousemove (when cameraMoved is set).
        return;
    }
    
    cvs.focus();

    if (isPointerLocked) {
        return;
    }

    if (e.button === 0 && e.altKey) {
        const hitResult = calculateRayTargetVoxelCoords(e.clientX, e.clientY);
        if (hitResult && hitResult.hitExistingVoxel) {
            const gKey = key(hitResult.x, hitResult.y, hitResult.z);
            if (voxels.has(gKey)) {
                const pickedColor = voxels.get(gKey).color;
                currentColor = pickedColor;
                document.getElementById('color-picker-input-hidden').value = pickedColor; // Update hidden input
                document.getElementById('color-picker-swatch').style.backgroundColor = pickedColor; // Update swatch
                const mobileColorInput = document.getElementById('mobile-color-input-hidden');
                if (mobileColorInput) mobileColorInput.value = pickedColor;
                localStorage.setItem('voxelEditorColor', pickedColor);
                presetBoxes.forEach(box => box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50')); activePresetIndex = -1;
                showToast('Farbe aufgenommen', `Farbe: ${pickedColor}`, 'info', 2000);

                // NEW: Check tutorial progress
                if (tutorial.active && tutorial.stepIndex === tutorial.getStepIndex('pickColor')) {
                    tutorial.checkCondition(cvs); // Wobble canvas for now, maybe specific voxel later
                }
            }
        }
        return;
    }

    if (e.pointerType === 'touch') {
        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY, pointerType: e.pointerType });
        
        if (activePointers.size === 1) {
            const currentTime = performance.now();
            const dist = Math.hypot(e.clientX - (lastTapCoords.x || 0), e.clientY - (lastTapCoords.y || 0));

            if (currentTime - (lastTapTime || 0) < DOUBLE_TAP_TIME_THRESHOLD && dist < DOUBLE_TAP_DIST_THRESHOLD) { 
                // Double tap detected: activate drawing/editing mode
                doubleTapDragActive = true;
                pointerIsDown = true; // Indicate that a modification gesture is starting
                
                voxelsAtDragStart = new Map(voxels);
                currentStrokeVoxels.clear();
                currentStrokeVoxelKeys.clear();
                dragAxisLock = null;
                isDragging = false;
                initialDragVoxelCoords = null;
                initialClickPos = { x: e.clientX, y: e.clientY };

                let rawInitialRayTarget = calculateRayTargetVoxelCoords(e.clientX, e.clientY);

                if (rawInitialRayTarget && Number.isFinite(rawInitialRayTarget.x) && Number.isFinite(rawInitialRayTarget.y) && Number.isFinite(rawInitialRayTarget.z)) {
                    initialTargetVoxelCoords = {
                        x: rawInitialRayTarget.x,
                        y: rawInitialRayTarget.y,
                        z: rawInitialRayTarget.z,
                        faceNormal: rawInitialRayTarget.faceNormal,
                        hitExistingVoxel: rawInitialRayTarget.hitExistingVoxel
                    };
                    
                    if (currentMode === Modes.ADD) {
                        dragFixedLayerCoord = Number(initialTargetVoxelCoords[currentDrawingAxis]); 
                        if (!Number.isFinite(dragFixedLayerCoord)) { 
                            dragFixedLayerCoord = Number(activeDrawingLevel[currentDrawingAxis]);
                        }
                    } else { // DELETE or DRAW mode: no layer lock
                        dragFixedLayerCoord = null; 
                    }

                    if (dragFixedLayerCoord !== null && Number.isFinite(dragFixedLayerCoord)) {
                        initialTargetVoxelCoords[currentDrawingAxis] = dragFixedLayerCoord;
                    }
                    
                    // Clamp after applying fixed layer
                    initialTargetVoxelCoords.x = Math.max(0, Math.min(GRID - 1, initialTargetVoxelCoords.x));
                    initialTargetVoxelCoords.y = Math.max(0, Math.min(GRID - 1, initialTargetVoxelCoords.y));
                    initialTargetVoxelCoords.z = Math.max(0, Math.min(GRID - 1, initialTargetVoxelCoords.z));

                    // Only perform modification if allowed by mode
                    let shouldPerformModification = true;
                    if (currentMode === Modes.DRAW && !initialTargetVoxelCoords.hitExistingVoxel) {
                        shouldPerformModification = false; // Do not add new voxels in DRAW mode
                    }

                    if (shouldPerformModification) {
                        lastActionVoxelCoords = { ...initialTargetVoxelCoords };
                        const gKey = key(initialTargetVoxelCoords.x, initialTargetVoxelCoords.y, initialTargetVoxelCoords.z);
                        const initialColor = voxelsAtDragStart.has(gKey) ? voxelsAtDragStart.get(gKey).color : null;
                        performVoxelModification(initialTargetVoxelCoords.x, initialTargetVoxelCoords.y, initialTargetVoxelCoords.z, currentMode, currentColor);
                        const finalColor = voxels.has(gKey) ? voxels.get(gKey).color : null;
                        currentStrokeVoxels.set(gKey, { originalColor: initialColor, finalColor: finalColor });
                        currentStrokeVoxelKeys.add(gKey);
                        updatePreviewVoxel(initialTargetVoxelCoords.x, initialTargetVoxelCoords.y, initialTargetVoxelCoords.z, true);
                    } else {
                        updatePreviewVoxel(0,0,0,false); // Hide preview if no modification
                    }
                } else {
                    updatePreviewVoxel(0,0,0,false);
                }
                lastTapTime = 0; lastTapCoords = { x: 0, y: 0 }; // Reset for next double tap
            } else {
                // Single tap, not double tap: prepare for camera movement
                doubleTapDragActive = false;
                pointerIsDown = false; // Not a voxel modification gesture
                lastTapTime = currentTime;
                lastTapCoords = { x: e.clientX, y: e.clientY };
                gestureState.type = 'none'; gestureState.startMid = gestureState.lastMid = { x: e.clientX, y: e.clientY };
                gestureState.startDist = gestureState.lastDist = 0;
                gestureState.initialPointerCount = 1;
                updatePreviewVoxel(0,0,0,false);
                previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
            }
        } else if (activePointers.size >= 2) {
            // Multi-finger: always for camera pan/zoom
            doubleTapDragActive = false;
            pointerIsDown = false;
            initialTargetVoxelCoords = null;
            currentStrokeVoxels.clear(); currentStrokeVoxelKeys.clear();
            previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
            updatePreviewVoxel(0, 0, 0, false);
            isDragging = false; dragFixedLayerCoord = null;
            
            const pointersArr = [...activePointers.values()];
            const [p0, p1] = pointersArr;
            const midX = (p0.x + p1.x) * 0.5; const midY = (p0.y + p1.y) * 0.5; const dist = Math.hypot(p1.x - p0.x, p1.y - p0.y);
            gestureState.type = 'none'; gestureState.startMid = gestureState.lastMid = { x: midX, y: midY };
            gestureState.startDist = gestureState.lastDist = dist;
            gestureState.initialPointerCount = activePointers.size;
        }
        return;
    }

    // Mouse Left Click (always for voxel modification)
    pointerIsDown = true;
    doubleTapDragActive = false; // Ensure double tap mode is off for mouse
    voxelsAtDragStart = new Map(voxels);
    currentStrokeVoxels.clear();
    currentStrokeVoxelKeys.clear();
    dragAxisLock = null;
    isDragging = false;
    initialDragVoxelCoords = null;
    initialClickPos = { x: e.clientX, y: e.clientY };

    let rawInitialRayTarget = calculateRayTargetVoxelCoords(e.clientX, e.clientY);

    if (!rawInitialRayTarget || !Number.isFinite(rawInitialRayTarget.x) || !Number.isFinite(rawInitialRayTarget.y) || !Number.isFinite(rawInitialRayTarget.z)) {
        initialTargetVoxelCoords = null;
        dragFixedLayerCoord = null;
        updatePreviewVoxel(0,0,0,false);
        pointerIsDown = false;
        return;
    } else {
        initialTargetVoxelCoords = {
            x: rawInitialRayTarget.x,
            y: rawInitialRayTarget.y,
            z: rawInitialRayTarget.z,
            faceNormal: rawInitialRayTarget.faceNormal,
            hitExistingVoxel: rawInitialRayTarget.hitExistingVoxel
        };

        if (currentMode === Modes.ADD) {
            dragFixedLayerCoord = Number(initialTargetVoxelCoords[currentDrawingAxis]);
            if (!Number.isFinite(dragFixedLayerCoord)) {
                dragFixedLayerCoord = Number(activeDrawingLevel[currentDrawingAxis]);
            }
        } else { // DELETE or DRAW mode: no layer lock
            dragFixedLayerCoord = null;
        }

        if (dragFixedLayerCoord !== null && Number.isFinite(dragFixedLayerCoord)) {
            initialTargetVoxelCoords[currentDrawingAxis] = dragFixedLayerCoord;
        }

        // Clamp after applying fixed layer
        initialTargetVoxelCoords.x = Math.max(0, Math.min(GRID - 1, initialTargetVoxelCoords.x));
        initialTargetVoxelCoords.y = Math.max(0, Math.min(GRID - 1, initialTargetVoxelCoords.y));
        initialTargetVoxelCoords.z = Math.max(0, Math.min(GRID - 1, initialTargetVoxelCoords.z));
    }

    // Only perform modification if allowed by mode
    let shouldPerformModification = true;
    if (currentMode === Modes.DRAW && !initialTargetVoxelCoords.hitExistingVoxel) {
        shouldPerformModification = false; // Do not add new voxels in DRAW mode
    }

    if (shouldPerformModification) {
        lastActionVoxelCoords = { ...initialTargetVoxelCoords };
        const gKey = key(initialTargetVoxelCoords.x, initialTargetVoxelCoords.y, initialTargetVoxelCoords.z);
        const initialColor = voxelsAtDragStart.has(gKey) ? voxelsAtDragStart.get(gKey).color : null;
        performVoxelModification(initialTargetVoxelCoords.x, initialTargetVoxelCoords.y, initialTargetVoxelCoords.z, currentMode, currentColor);
        const finalColor = voxels.has(gKey) ? voxels.get(gKey).color : null;
        currentStrokeVoxels.set(gKey, { originalColor: initialColor, finalColor: finalColor });
        currentStrokeVoxelKeys.add(gKey);
        updatePreviewVoxel(initialTargetVoxelCoords.x, initialTargetVoxelCoords.y, initialTargetVoxelCoords.z, true);
    } else {
        updatePreviewVoxel(0,0,0,false); // Hide preview if no modification
    }
}

function onPointerMove(e) {
    e.preventDefault();
    e.stopPropagation();

    // If pointer is locked, movement is handled by the dedicated 'mousemove' listener.
    // This function should not process movement events when pointer is locked.
    if (isPointerLocked) {
        // No direct voxel preview/modification when locked, as the user is flying around
        // Mouse movement for camera rotation is handled in animate() based on mouseMovementX/Y
        // Camera movement conditions for tutorial are checked in animate() with keyboard input
        return; 
    }

    if (e.pointerType === 'touch') {
        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY, pointerType: e.pointerType });
        
        if (doubleTapDragActive) {
            // In double tap mode, only handle voxel modification, no camera movement
            let currentRayHit = calculateRayTargetVoxelCoords(e.clientX, e.clientY);
            let currentTargetVoxelCoords = null;

            if (currentRayHit) {
                currentTargetVoxelCoords = { x: currentRayHit.x, y: currentRayHit.y, z: currentRayHit.z };
                if (dragFixedLayerCoord !== null && Number.isFinite(dragFixedLayerCoord)) {
                    currentTargetVoxelCoords[currentDrawingAxis] = dragFixedLayerCoord;
                }
                currentTargetVoxelCoords.x = Math.max(0, Math.min(GRID - 1, currentTargetVoxelCoords.x));
                currentTargetVoxelCoords.y = Math.max(0, Math.min(GRID - 1, currentTargetVoxelCoords.y));
                currentTargetVoxelCoords.z = Math.max(0, Math.min(GRID - 1, currentTargetVoxelCoords.z));
            } else {
                currentTargetVoxelCoords = null;
            }

            const currentMovedDist = initialClickPos ? Math.hypot(e.clientX - initialClickPos.x, e.clientY - initialClickPos.y) : 0;
            const shouldStartDrag = currentMovedDist > MOVE_PX;

            if (!isDragging && shouldStartDrag) {
                isDragging = true;
            }

            if (isDragging) {
                if (currentTargetVoxelCoords) {
                    const startPointForLine = { ...lastActionVoxelCoords };
                    const endPointForLine = { ...currentTargetVoxelCoords };

                    let pathVoxels;
                    if (dragFixedLayerCoord !== null && Number.isFinite(dragFixedLayerCoord)) {
                        pathVoxels = getVoxelsOnLine(startPointForLine, endPointForLine, currentDrawingAxis, dragFixedLayerCoord);
                    } else {
                        pathVoxels = getVoxelsOnLine(startPointForLine, endPointForLine);
                    }

                    // Only filter if we're dealing with existing voxels (DELETE or DRAW)
                    // and also if in DRAW mode, only consider existing voxels
                    if (currentMode === Modes.DELETE || currentMode === Modes.DRAW) {
                        pathVoxels = pathVoxels.filter(voxel => voxelsAtDragStart.has(key(voxel.x, voxel.y, voxel.z)));
                    }
                    
                    for (const voxel of pathVoxels) {
                        const gKey = key(voxel.x, voxel.y, voxel.z);
                        const hasVoxelBeforeModification = voxels.has(gKey);
                        const originalColor = hasVoxelBeforeModification ? voxels.get(gKey).color : null;
                        
                        performVoxelModification(voxel.x, voxel.y, voxel.z, currentMode, currentColor);
                        
                        const hasVoxelAfterModification = voxels.has(gKey);
                        const finalColor = hasVoxelAfterModification ? voxels.get(gKey).color : null;

                        if (!currentStrokeVoxels.has(gKey)) {
                            if (originalColor !== finalColor || (originalColor === null && finalColor !== null)) {
                                currentStrokeVoxels.set(gKey, { originalColor: originalColor, finalColor: finalColor });
                            }
                        } else {
                            currentStrokeVoxels.get(gKey).finalColor = finalColor;
                        }
                        currentStrokeVoxelKeys.add(gKey);
                    }
                    if (pathVoxels.length > 0) {
                        lastActionVoxelCoords = { x: pathVoxels[pathVoxels.length - 1].x, y: pathVoxels[pathVoxels.length - 1].y, z: pathVoxels[pathVoxels.length - 1].z };
                    } else {
                        lastActionVoxelCoords = { ...endPointForLine };
                    }
                    // Only show preview if a modification occurred or is possible
                    const potentialPreview = currentMode === Modes.ADD ? !voxels.has(key(currentTargetVoxelCoords.x, currentTargetVoxelCoords.y, currentTargetVoxelCoords.z)) : voxels.has(key(currentTargetVoxelCoords.x, currentTargetVoxelCoords.y, currentTargetVoxelCoords.z));
                    updatePreviewVoxel(currentTargetVoxelCoords.x, currentTargetVoxelCoords.y, currentTargetVoxelCoords.z, potentialPreview);
                    previewLineInstancedMesh.count = 0;
                } else {
                    updatePreviewVoxel(0,0,0,false);
                    previewLineInstancedMesh.count = 0;
                    previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
                    previewLineVoxels = [];
                }
            } else {
                if (currentTargetVoxelCoords) {
                    let showPreview = false;
                    const gKeyAtPreview = key(currentTargetVoxelCoords.x, currentTargetVoxelCoords.y, currentTargetVoxelCoords.z);
                    const hasVoxelAtPreview = voxels.has(gKeyAtPreview);

                    if (currentMode === Modes.ADD) {
                        if (!hasVoxelAtPreview) { showPreview = true; }
                    } else if (currentMode === Modes.DELETE || currentMode === Modes.DRAW) {
                        if (hasVoxelAtPreview) { showPreview = true; }
                    }
                    updatePreviewVoxel(currentTargetVoxelCoords.x, currentTargetVoxelCoords.y, currentTargetVoxelCoords.z, showPreview);
                } else {
                    updatePreviewVoxel(0,0,0,false);
                }
                previewLineInstancedMesh.count = 0;
                previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
                previewLineVoxels = [];
            }
            return; // Exit touch logic if doubleTapDragActive
        } else {
            // Normal touch gestures (camera movement)
            if (activePointers.size === 1) {
                handleGesture(); // Only camera rotation
                updatePreviewVoxel(0, 0, 0, false); // No voxel preview during camera movement
                previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
                return;
            } else if (activePointers.size >= 2) {
                handleGesture(); // Camera pan/zoom
                updatePreviewVoxel(0, 0, 0, false); // No voxel preview during camera movement
                previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
                return;
            }
        }
    }

    // Mouse Logic (always for voxel modification if pointerIsDown, otherwise preview)
    lastX = e.clientX;
    lastY = e.clientY;

    let currentRayHit = calculateRayTargetVoxelCoords(e.clientX, e.clientY);
    let currentTargetVoxelCoords = null;

    if (currentRayHit) {
        currentTargetVoxelCoords = { x: currentRayHit.x, y: currentRayHit.y, z: currentRayHit.z };
        if (dragFixedLayerCoord !== null && Number.isFinite(dragFixedLayerCoord)) {
            currentTargetVoxelCoords[currentDrawingAxis] = dragFixedLayerCoord;
        }
        currentTargetVoxelCoords.x = Math.max(0, Math.min(GRID - 1, currentTargetVoxelCoords.x));
        currentTargetVoxelCoords.y = Math.max(0, Math.min(GRID - 1, currentTargetVoxelCoords.y));
        currentTargetVoxelCoords.z = Math.max(0, Math.min(GRID - 1, currentTargetVoxelCoords.z));
    } else {
        currentTargetVoxelCoords = null;
    }

    if (pointerIsDown) {
        const currentMovedDist = initialClickPos ? Math.hypot(e.clientX - initialClickPos.x, e.clientY - initialClickPos.y) : 0;
        const shouldStartDrag = currentMovedDist > MOVE_PX;

        if (!isDragging && shouldStartDrag) {
            isDragging = true;
        }

        if (isDragging) {
            if (currentTargetVoxelCoords) {
                const startPointForLine = { ...lastActionVoxelCoords };
                const endPointForLine = { ...currentTargetVoxelCoords };

                let pathVoxels;
                if (dragFixedLayerCoord !== null && Number.isFinite(dragFixedLayerCoord)) {
                    pathVoxels = getVoxelsOnLine(startPointForLine, endPointForLine, currentDrawingAxis, dragFixedLayerCoord);
                } else {
                    pathVoxels = getVoxelsOnLine(startPointForLine, endPointForLine);
                }

                // Only filter if we're dealing with existing voxels (DELETE or DRAW)
                // and also if in DRAW mode, only consider existing voxels
                if (currentMode === Modes.DELETE || currentMode === Modes.DRAW) {
                    pathVoxels = pathVoxels.filter(voxel => voxelsAtDragStart.has(key(voxel.x, voxel.y, voxel.z)));
                }
                
                for (const voxel of pathVoxels) {
                    const gKey = key(voxel.x, voxel.y, voxel.z);
                    const hasVoxelBeforeModification = voxels.has(gKey);
                    const originalColor = hasVoxelBeforeModification ? voxels.get(gKey).color : null;
                    
                    performVoxelModification(voxel.x, voxel.y, voxel.z, currentMode, currentColor);
                    
                    const hasVoxelAfterModification = voxels.has(gKey);
                    const finalColor = hasVoxelAfterModification ? voxels.get(gKey).color : null;

                    if (!currentStrokeVoxels.has(gKey)) {
                        if (originalColor !== finalColor || (originalColor === null && finalColor !== null)) {
                            currentStrokeVoxels.set(gKey, { originalColor: originalColor, finalColor: finalColor });
                        }
                    } else {
                        currentStrokeVoxels.get(gKey).finalColor = finalColor;
                    }
                    currentStrokeVoxelKeys.add(gKey);
                }
                if (pathVoxels.length > 0) {
                    lastActionVoxelCoords = { x: pathVoxels[pathVoxels.length - 1].x, y: pathVoxels[pathVoxels.length - 1].y, z: pathVoxels[pathVoxels.length - 1].z };
                } else {
                    lastActionVoxelCoords = { ...endPointForLine };
                }
                // Only show preview if a modification occurred or is possible
                const potentialPreview = currentMode === Modes.ADD ? !voxels.has(key(currentTargetVoxelCoords.x, currentTargetVoxelCoords.y, currentTargetVoxelCoords.z)) : voxels.has(key(currentTargetVoxelCoords.x, currentTargetVoxelCoords.y, currentTargetVoxelCoords.z));
                updatePreviewVoxel(currentTargetVoxelCoords.x, currentTargetVoxelCoords.y, currentTargetVoxelCoords.z, potentialPreview);
                previewLineInstancedMesh.count = 0;
            } else {
                updatePreviewVoxel(0,0,0,false);
                previewLineInstancedMesh.count = 0;
                previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
                previewLineVoxels = [];
            }
        } else {
            if (currentTargetVoxelCoords) {
                let showPreview = false;
                const gKeyAtPreview = key(currentTargetVoxelCoords.x, currentTargetVoxelCoords.y, currentTargetVoxelCoords.z);
                const hasVoxelAtPreview = voxels.has(gKeyAtPreview);

                if (currentMode === Modes.ADD) {
                    if (!hasVoxelAtPreview) { showPreview = true; }
                } else if (currentMode === Modes.DELETE || currentMode === Modes.DRAW) {
                    if (hasVoxelAtPreview) { showPreview = true; }
                }
                updatePreviewVoxel(currentTargetVoxelCoords.x, currentTargetVoxelCoords.y, currentTargetVoxelCoords.z, showPreview);
            } else {
                updatePreviewVoxel(0,0,0,false);
            }
            previewLineInstancedMesh.count = 0;
            previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
            previewLineVoxels = [];
        }
    }
}


function cycleDrawingAxis() {
    const axes = ['x', 'y', 'z'];
    const currentIndex = axes.indexOf(currentDrawingAxis);
    currentDrawingAxis = axes[(currentIndex + 1) % axes.length];
    updateGridHelperPosition();
    showToast('Zeichenachse', `Achse: ${currentDrawingAxis.toUpperCase()}`, 'info', 1500);

    // NEW: Check tutorial progress
    if (tutorial.active && tutorial.stepIndex === tutorial.getStepIndex('changeAxis')) {
        tutorial.checkCondition(document.getElementById('mobile-axis-toggle'));
    }
}

function moveDrawingLevel(direction) {
    if (currentMode !== Modes.ADD && currentMode !== Modes.DRAW) {
        showToast('Hinweis', 'Ebenensteuerung nur im Hinzuf√ºgen- oder Zeichenmodus verf√ºgbar.', 'warning', 2000);
        return;
    }
    let level = activeDrawingLevel[currentDrawingAxis];

    if (!Number.isFinite(level)) {
        level = 0;
        activeDrawingLevel[currentDrawingAxis] = level;
    }

    level += direction;
    level = Math.max(0, Math.min(GRID - 1, level));
    activeDrawingLevel[currentDrawingAxis] = level;
    updateGridHelperPosition();
    showToast('Zeichenebene', `Ebene ${currentDrawingAxis.toUpperCase()}: ${level}`, 'info', 1500);
}

// Function to update the visual state of the new mobile camera control buttons
function updateMobileCameraControlButtons() {
    // These buttons are now in the main #controls div
    const invertLookXBtn = document.getElementById('invert-look-x');
    const invertLookYBtn = document.getElementById('invert-look-y');
    const reverseStrafeXBtn = document.getElementById('reverse-strafe-x');
    const reverseStrafeYBtn = document.getElementById('reverse-strafe-y');

    if (invertLookXBtn) invertLookXBtn.classList.toggle('btn-primary', invertLookX);
    if (invertLookYBtn) invertLookYBtn.classList.toggle('btn-primary', invertLookY);
    if (reverseStrafeXBtn) reverseStrafeXBtn.classList.toggle('btn-primary', reverseStrafeX);
    if (reverseStrafeYBtn) reverseStrafeYBtn.classList.toggle('btn-primary', reverseStrafeY);
}


// =========================================================
// NEW: TUTORIAL SYSTEM IMPLEMENTATION
// =========================================================
const tutorial = {
    active: false,
    stepIndex: parseInt(localStorage.getItem('tutorialStepIndex') || '0', 10),
    tutorialPanel: null,
    tutorialTitle: null,
    tutorialDescription: null,
    nextButton: null,
    exitButton: null,
    rewardContainer: null,
    rewardText: null,
    // Flags for tracking successful modification actions in tutorial steps
    voxelAddedThisStep: false,
    voxelDeletedThisStep: false,
    voxelPaintedThisStep: false,
    initialVoxelCountForDeleteTutorial: 0,
    cameraMoved: false, // New flag for camera movement detection
    isMobileDevice: window.matchMedia('(max-width: 768px)').matches, // Detect mobile
    savedProject: false,
    exportedSTL: false,

    steps: [], // Will be populated based on device type in init

    getStepIndex: function(id) {
        return this.steps.findIndex(step => step.id === id);
    },

    getDesktopSteps: function() {
        return [
            {
                id: "freelook",
                title: "Willkommen!",
                description: "Drehen Sie die Kamera: **rechte Maustaste gedr√ºckt halten + Maus ziehen**.",
                condition: () => this.cameraMoved,
                reward: "Kamera-Steuerung aktiv!",
                nextText: "Weiter",
                onStepEnter: () => { this.cameraMoved = false; },
                targetElement: () => cvs
            },
            {
                id: "moveForward",
                title: "Fliegen: Vorw√§rts (W)",
                description: "Halten Sie die **rechte Maustaste gedr√ºckt** und dr√ºcken Sie **'W'** zum Vorw√§rtsfliegen.",
                condition: () => keyboard['w'] && isPointerLocked,
                reward: "Super! Vorw√§rts.",
                nextText: "Weiter",
                targetElement: () => cvs
            },
            {
                id: "moveBackward",
                title: "Fliegen: R√ºckw√§rts (S)",
                description: "Halten Sie die **rechte Maustaste gedr√ºckt** und dr√ºcken Sie **'S'** zum R√ºckw√§rtsfliegen.",
                condition: () => keyboard['s'] && isPointerLocked,
                reward: "Zur√ºck!",
                nextText: "Weiter",
                targetElement: () => cvs
            },
            {
                id: "moveLeft",
                title: "Fliegen: Links (A)",
                description: "Halten Sie die **rechte Maustaste gedr√ºckt** und dr√ºcken Sie **'A'** zum Linksfliegen.",
                condition: () => keyboard['a'] && isPointerLocked,
                reward: "Nach links!",
                nextText: "Weiter",
                targetElement: () => cvs
            },
            {
                id: "moveRight",
                title: "Fliegen: Rechts (D)",
                description: "Halten Sie die **rechte Maustaste gedr√ºckt** und dr√ºcken Sie **'D'** zum Rechtsfliegen.",
                condition: () => keyboard['d'] && isPointerLocked,
                reward: "Nach rechts!",
                nextText: "Weiter",
                targetElement: () => cvs
            },
            {
                id: "moveUp",
                title: "Fliegen: Hoch (E)",
                description: "Halten Sie die **rechte Maustaste gedr√ºckt** und dr√ºcken Sie **'E'** zum Hochfliegen.",
                condition: () => keyboard['e'] && isPointerLocked,
                reward: "Aufw√§rts!",
                nextText: "Weiter",
                targetElement: () => cvs
            },
            {
                id: "moveDown",
                title: "Fliegen: Runter (Q)",
                description: "Halten Sie die **rechte Maustaste gedr√ºckt** und dr√ºcken Sie **'Q'** zum Runterfliegen.",
                condition: () => keyboard['q'] && isPointerLocked,
                reward: "Abw√§rts!",
                nextText: "Weiter",
                targetElement: () => cvs
            },
            {
                id: "flyIntoDrawingArea",
                title: "In den Zeichenbereich fliegen",
                description: "Fliegen Sie in den gr√ºn-blauen Kasten, den **Zeichenbereich**.",
                condition: () => {
                    const center = new THREE.Vector3(GRID * VS / 2, GRID * VS / 2, GRID * VS / 2);
                    const distance = cam.position.distanceTo(center);
                    const maxDistance = Math.sqrt(3 * (GRID * VS / 2) ** 2) * 1.5;
                    return distance < maxDistance;
                },
                reward: "Im Zeichenbereich!",
                nextText: "Weiter",
                targetElement: () => boxHelper
            },
            // Removed 'changeModeToAdd' as it's default and handled by 'addVoxel'
            {
                id: "addVoxel",
                title: "Voxel hinzuf√ºgen",
                description: "Im 'Hinzuf√ºgen'-Modus: **Linksklick** in den Zeichenbereich, um Voxel zu platzieren.",
                condition: () => this.voxelAddedThisStep, // Now checks for any voxel added
                reward: "Voxel hinzugef√ºgt!",
                nextText: "Weiter",
                onStepEnter: () => { this.voxelAddedThisStep = false; }, // Reset flag on step entry
                targetElement: () => previewVoxelMesh
            },
            {
                id: "changeColor",
                title: "Farbe ausw√§hlen",
                description: "Klicken Sie auf den **Farbw√§hler** und w√§hlen Sie eine neue Farbe.",
                condition: () => currentColor !== '#008080',
                reward: "Farbe ausgew√§hlt!",
                nextText: "Weiter",
                targetElement: () => document.getElementById('color-picker-swatch')
            },
            {
                id: "changeModeToDraw",
                title: "Modus: Zeichnen",
                description: "Wechseln Sie in den Modus **'Zeichnen'** (TAB/LEERTASTE).",
                condition: () => currentMode === Modes.DRAW,
                reward: "Modus ge√§ndert!",
                nextText: "Weiter",
                targetElement: () => document.getElementById('modeToggle')
            },
            {
                id: "paintVoxel",
                title: "Voxel bemalen",
                description: "Im 'Zeichnen'-Modus: Klicken Sie auf einen Voxel, um ihn mit der gew√§hlten Farbe zu bemalen.",
                condition: () => this.voxelPaintedThisStep, // Now checks for any voxel painted
                reward: "Voxel bemalt!",
                nextText: "Weiter",
                onStepEnter: () => {
                    this.voxelPaintedThisStep = false; // Reset flag
                    // Ensure there's a voxel to paint if the scene is empty
                    if (voxels.size === 0) {
                        const paintX = Math.floor(GRID / 2), paintY = Math.floor(GRID / 2), paintZ = Math.floor(GRID / 2);
                        _addSingleVoxel(paintX, paintY, paintZ, '#FF0000');
                        showToast('Voxel hinzugef√ºgt', 'Ein Voxel wurde f√ºr dieses Tutorial hinzugef√ºgt.', 'info', 3000);
                    }
                },
                targetElement: () => previewVoxelMesh // Generic target for painting
            },
            {
                id: "changeModeToDelete",
                title: "Modus: L√∂schen",
                description: "Wechseln Sie in den Modus **'L√∂schen'** (TAB/LEERTASTE).",
                condition: () => currentMode === Modes.DELETE,
                reward: "Modus ge√§ndert!",
                nextText: "Weiter",
                targetElement: () => document.getElementById('modeToggle')
            },
            {
                id: "deleteVoxel",
                title: "Voxel l√∂schen",
                description: "Im 'L√∂schen'-Modus: **Linksklick** auf einen Voxel, um ihn zu entfernen.",
                condition: () => this.voxelDeletedThisStep, // Now checks for any voxel deleted
                reward: "Voxel gel√∂scht!",
                nextText: "Weiter",
                onStepEnter: () => {
                    this.voxelDeletedThisStep = false; // Reset flag
                    // Ensure there's a voxel to delete if the scene is empty
                    if (voxels.size === 0) {
                        const deleteX = Math.floor(GRID / 2), deleteY = Math.floor(GRID / 2), deleteZ = Math.floor(GRID / 2);
                        _addSingleVoxel(deleteX, deleteY, deleteZ, '#00FFFF');
                        showToast('Voxel hinzugef√ºgt', 'Ein Voxel wurde f√ºr dieses Tutorial hinzugef√ºgt.', 'info', 3000);
                    }
                    this.initialVoxelCountForDeleteTutorial = voxels.size; // This will now track the count before deletion attempt
                },
                targetElement: () => previewVoxelMesh
            },
            {
                id: "saveProject",
                title: "Projekt speichern",
                description: "Klicken Sie auf **'Projekt speichern'**, um Ihr Voxel-Projekt als JSON-Datei zu sichern. Achten Sie darauf, dass sich mindestens ein W√ºrfel in der Szene befindet.",
                condition: () => this.savedProject === true,
                reward: "Projekt gespeichert!",
                nextText: "Weiter",
                onStepEnter: () => {
                    this.savedProject = false;
                    // Ensure a voxel exists for saving tutorial step if the scene is empty
                    if (voxels.size === 0) {
                        const saveX = Math.floor(GRID / 2), saveY = Math.floor(GRID / 2), saveZ = Math.floor(GRID / 2);
                        _addSingleVoxel(saveX, saveY, saveZ, '#FFFF00');
                        showToast('Voxel hinzugef√ºgt', 'Ein Voxel wurde f√ºr dieses Tutorial hinzugef√ºgt.', 'info', 3000);
                    }
                },
                targetElement: () => document.getElementById('saveBtn')
            },
            {
                id: "exportSTL",
                title: "STL-Export",
                description: "Klicken Sie auf **'Export'** und dann auf **'Exportieren'** f√ºr das STL-Format. Achten Sie darauf, dass sich mindestens ein W√ºrfel in der Szene befindet.",
                condition: () => this.exportedSTL === true,
                reward: "Modell exportiert!",
                nextText: "Tutorial beenden", // Last step, so text is "Tutorial beenden"
                onStepEnter: () => {
                    this.exportedSTL = false;
                     // Ensure a voxel exists for export tutorial step if the scene is empty
                    if (voxels.size === 0) {
                        const exportX = Math.floor(GRID / 2), exportY = Math.floor(GRID / 2), exportZ = Math.floor(GRID / 2);
                        _addSingleVoxel(exportX, exportY, exportZ, '#00FFFF');
                        showToast('Voxel hinzugef√ºgt', 'Ein Voxel wurde f√ºr dieses Tutorial hinzugef√ºgt.', 'info', 3000);
                    }
                },
                targetElement: () => document.getElementById('exportBtn')
            },
            {
                id: "endTutorial",
                title: "Tutorial beendet!",
                description: "Sie haben die Grundlagen von VoxelShaper gelernt! Viel Spa√ü beim Gestalten!",
                condition: () => false, // This is always false, the button will simply close the tutorial
                reward: null,
                nextText: "Schlie√üen",
                targetElement: () => document.getElementById('tutorial-panel-container')
            }
        ];
    },

    getMobileSteps: function() {
        return [
            {
                id: "freelook",
                title: "Willkommen!",
                description: "Drehen Sie die Kamera: **Mit einem Finger ziehen** auf dem Canvas. Bewegen Sie die Kamera etwas, dann k√∂nnen Sie auf 'Weiter' klicken.",
                condition: () => this.cameraMoved,
                reward: "Kamera-Steuerung aktiv!",
                nextText: "Weiter",
                onStepEnter: () => { this.cameraMoved = false; },
                targetElement: () => cvs
            },
            {
                id: "zoomPan",
                title: "Zoomen & Schwenken",
                description: "Zoomen: **Zwei Finger spreizen oder zusammenziehen**. Schwenken: **Zwei Finger zusammen √ºber den Bildschirm ziehen**.",
                condition: () => {
                    // This condition is tricky to make reliable without complex gesture detection.
                    // For simplicity, we'll assume the user attempts it if they tap 'Next'
                    // However, we can improve by checking camera position/zoom changes from start of step.
                    // For now, allow progression after a short delay or explicit next click.
                    // A more robust solution would involve tracking `cam.position` and `cam.quaternion` changes.
                    return true; // Always allow progression after showing instructions
                },
                reward: "Zoomen & Schwenken gelernt!",
                nextText: "Weiter",
                targetElement: () => cvs
            },
            {
                id: "flyIntoDrawingArea",
                title: "In den Zeichenbereich fliegen",
                description: "Benutzen Sie Ihre Finger, um die Kamera in den gr√ºn-blauen Kasten, den **Zeichenbereich**, zu bewegen.",
                condition: () => {
                    const center = new THREE.Vector3(GRID * VS / 2, GRID * VS / 2, GRID * VS / 2);
                    const distance = cam.position.distanceTo(center);
                    const maxDistance = Math.sqrt(3 * (GRID * VS / 2) ** 2) * 1.5;
                    return distance < maxDistance;
                },
                reward: "Im Zeichenbereich!",
                nextText: "Weiter",
                targetElement: () => boxHelper
            },
            // Removed 'changeModeToAdd' as it's default and handled by 'addVoxel'
            {
                id: "addVoxel",
                title: "Voxel hinzuf√ºgen",
                description: "Im 'Hinzuf√ºgen'-Modus: **Doppeltippen und Ziehen** auf den Zeichenbereich, um Voxel zu platzieren.",
                condition: () => this.voxelAddedThisStep, // Now checks for any voxel added
                reward: "Voxel hinzugef√ºgt!",
                nextText: "Weiter",
                onStepEnter: () => { this.voxelAddedThisStep = false; }, // Reset flag on step entry
                targetElement: () => previewVoxelMesh
            },
            {
                id: "changeColor",
                title: "Farbe ausw√§hlen",
                description: "Tippen Sie auf den **Farbw√§hler-Button** (<i class='fas fa-palette'></i>) unten rechts und w√§hlen Sie eine neue Farbe.",
                condition: () => currentColor !== '#008080',
                reward: "Farbe ausgew√§hlt!",
                nextText: "Weiter",
                targetElement: () => document.getElementById('mobile-color-picker-btn')
            },
            {
                id: "changeModeToDraw",
                title: "Modus: Zeichnen",
                description: "Tippen Sie auf den **Modus-Button** unten rechts, bis der Modus **'Zeichnen'** angezeigt wird.",
                condition: () => currentMode === Modes.DRAW,
                reward: "Modus ge√§ndert!",
                nextText: "Weiter",
                targetElement: () => document.getElementById('mobile-mode-toggle')
            },
            {
                id: "paintVoxel",
                title: "Voxel bemalen",
                description: "Im 'Zeichnen'-Modus: **Doppeltippen und Ziehen** auf einen Voxel, um ihn mit der gew√§hlten Farbe zu bemalen.",
                condition: () => this.voxelPaintedThisStep, // Now checks for any voxel painted
                reward: "Voxel bemalt!",
                nextText: "Weiter",
                onStepEnter: () => {
                    this.voxelPaintedThisStep = false; // Reset flag
                    // Ensure there's a voxel to paint if the scene is empty
                    if (voxels.size === 0) {
                        const paintX = Math.floor(GRID / 2), paintY = Math.floor(GRID / 2), paintZ = Math.floor(GRID / 2);
                        _addSingleVoxel(paintX, paintY, paintZ, '#FF0000');
                        showToast('Voxel hinzugef√ºgt', 'Ein Voxel wurde f√ºr dieses Tutorial hinzugef√ºgt.', 'info', 3000);
                    }
                },
                targetElement: () => previewVoxelMesh // Generic target for painting
            },
            {
                id: "changeModeToDelete",
                title: "Modus: L√∂schen",
                description: "Tippen Sie auf den **Modus-Button** unten rechts, bis der Modus **'L√∂schen'** angezeigt wird.",
                condition: () => currentMode === Modes.DELETE,
                reward: "Modus ge√§ndert!",
                nextText: "Weiter",
                targetElement: () => document.getElementById('mobile-mode-toggle')
            },
            {
                id: "deleteVoxel",
                title: "Voxel l√∂schen",
                description: "Im 'L√∂schen'-Modus: **Doppeltippen und Ziehen** auf einen Voxel, um ihn zu entfernen.",
                condition: () => this.voxelDeletedThisStep, // Now checks for any voxel deleted
                reward: "Voxel gel√∂scht!",
                nextText: "Weiter",
                onStepEnter: () => {
                    this.voxelDeletedThisStep = false; // Reset flag
                    // Ensure there's a voxel to delete if the scene is empty
                    if (voxels.size === 0) {
                        const deleteX = Math.floor(GRID / 2), deleteY = Math.floor(GRID / 2), deleteZ = Math.floor(GRID / 2);
                        _addSingleVoxel(deleteX, deleteY, deleteZ, '#00FFFF');
                        showToast('Voxel hinzugef√ºgt', 'Ein Voxel wurde f√ºr dieses Tutorial hinzugef√ºgt.', 'info', 3000);
                    }
                    this.initialVoxelCountForDeleteTutorial = voxels.size; // This will now track the count before deletion attempt
                },
                targetElement: () => previewVoxelMesh
            },
            {
                id: "saveProject",
                title: "Projekt speichern",
                description: "Tippen Sie auf den **Speicher-Button** (<i class='fas fa-save'></i>) unten rechts, um Ihr Voxel-Projekt zu speichern. Achten Sie darauf, dass sich mindestens ein W√ºrfel in der Szene befindet.",
                condition: () => this.savedProject === true,
                reward: "Projekt gespeichert!",
                nextText: "Weiter",
                onStepEnter: () => {
                    this.savedProject = false;
                    // Ensure a voxel exists for saving tutorial step if the scene is empty
                    if (voxels.size === 0) {
                        const saveX = Math.floor(GRID / 2), saveY = Math.floor(GRID / 2), saveZ = Math.floor(GRID / 2);
                        _addSingleVoxel(saveX, saveY, saveZ, '#FFFF00');
                        showToast('Voxel hinzugef√ºgt', 'Ein Voxel wurde f√ºr dieses Tutorial hinzugef√ºgt.', 'info', 3000);
                    }
                },
                targetElement: () => document.getElementById('mobile-save')
            },
            {
                id: "exportSTL",
                title: "STL-Export",
                description: "√ñffnen Sie das Men√º (‚ò∞ oben rechts), tippen Sie auf **'Export'** und dann auf **'Exportieren'** f√ºr das STL-Format. Achten Sie darauf, dass sich mindestens ein W√ºrfel in der Szene befindet.",
                condition: () => this.exportedSTL === true,
                reward: "Modell exportiert!",
                nextText: "Tutorial beenden", // Last step, so text is "Tutorial beenden"
                onStepEnter: () => {
                    this.exportedSTL = false;
                     // Ensure a voxel exists for export tutorial step if the scene is empty
                    if (voxels.size === 0) {
                        const exportX = Math.floor(GRID / 2), exportY = Math.floor(GRID / 2), exportZ = Math.floor(GRID / 2);
                        _addSingleVoxel(exportX, exportY, exportZ, '#00FFFF');
                        showToast('Voxel hinzugef√ºgt', 'Ein Voxel wurde f√ºr dieses Tutorial hinzugef√ºgt.', 'info', 3000);
                    }
                },
                targetElement: () => document.getElementById('exportBtn')
            },
            {
                id: "endTutorial",
                title: "Tutorial beendet!",
                description: "Sie haben die Grundlagen von VoxelShaper gelernt! Viel Spa√ü beim Gestalten!",
                condition: () => false,
                reward: null,
                nextText: "Schlie√üen",
                targetElement: () => document.getElementById('tutorial-panel-container')
            }
        ];
    },

    start: function() {
        this.active = true;
        this.stepIndex = 0;
        localStorage.setItem('tutorialStepIndex', this.stepIndex);
        this.savedProject = false;
        this.exportedSTL = false;
        this.voxelAddedThisStep = false;
        this.voxelDeletedThisStep = false;
        this.voxelPaintedThisStep = false;
        this.cameraMoved = false;
        
        // Populate steps based on device
        this.steps = this.isMobileDevice ? this.getMobileSteps() : this.getDesktopSteps();

        this.showCurrentStep();
        document.getElementById('tutorial-panel-container').classList.remove('hidden');
        resetToDefaultProject();
        // Hide mobile controls if on mobile and tutorial starts
        if (this.isMobileDevice) {
            document.getElementById('mobile-controls').classList.add('hidden');
        }
    },

    next: function() {
        this.hideReward();
        this.stepIndex++;
        localStorage.setItem('tutorialStepIndex', this.stepIndex);
        if (this.stepIndex < this.steps.length) {
            this.showCurrentStep();
        } else {
            this.end();
        }
    },

    showCurrentStep: function() {
        const step = this.steps[this.stepIndex];
        this.tutorialTitle.textContent = step.title;
        this.tutorialDescription.innerHTML = step.description;
        this.nextButton.textContent = step.nextText;
        this.nextButton.disabled = !step.condition(); 

        // Handle the last step specific styling
        const isLastStep = (this.stepIndex === this.steps.length - 1);
        if (isLastStep) {
            this.nextButton.textContent = "Tutorial beenden";
            if (!this.nextButton.disabled) {
                this.nextButton.classList.add('btn-success');
                this.nextButton.classList.remove('btn-primary'); // Ensure primary is removed if it was there
            } else {
                this.nextButton.classList.remove('btn-success');
                this.nextButton.classList.add('btn-primary');
            }
        } else {
            this.nextButton.classList.remove('btn-success');
            this.nextButton.classList.add('btn-primary'); // Default primary color for other steps
        }
        
        // The uploadToHub button is no longer part of the tutorial logic for conditional display.
        // It remains permanently outside of the tutorial's conditional hide/show logic.
        // Thus, the following block is removed as the 'uploadToHub' step no longer exists:
        // if (step.id === "uploadToHub" && !auth.currentUser) {
        //     document.getElementById('uploadToHubBtn').classList.add('hidden');
        //     this.tutorialDescription.innerHTML = this.isMobileDevice ? 
        //         "Melden Sie sich an, um Ihr Projekt auf den Hub hochzuladen. Tippen Sie auf den **Anmelde-Button** (<i class='fas fa-key'></i>) unten rechts." :
        //         "Melden Sie sich an, um Ihr Projekt auf den Hub hochzuladen. Klicken Sie auf **'Anmelden'**.";
        // } else if (step.id === "uploadToHub" && auth.currentUser) {
        //     document.getElementById('uploadToHubBtn').classList.remove('hidden');
        // }


        if (step.onStepEnter) {
            step.onStepEnter();
        }
    },

    checkCondition: function(wobbleElement = null) {
        if (!this.active) return;
        const step = this.steps[this.stepIndex];
        if (step.condition()) {
            this.nextButton.disabled = false;
            if (step.reward) {
                this.showReward(step.reward);
                if (wobbleElement) {
                    this.wobbleTarget(wobbleElement);
                } else if (step.targetElement && step.targetElement()) {
                    this.wobbleTarget(step.targetElement());
                }
            } else {
                this.hideReward();
            }
            // Update button color for the very last step if it becomes enabled
            const isLastStep = (this.stepIndex === this.steps.length - 1);
            if (isLastStep) {
                 this.nextButton.classList.add('btn-success');
                 this.nextButton.classList.remove('btn-primary');
            }
        } else {
            this.nextButton.disabled = true;
            this.hideReward();
            // Revert button color for the very last step if it becomes disabled
            const isLastStep = (this.stepIndex === this.steps.length - 1);
            if (isLastStep) {
                this.nextButton.classList.remove('btn-success');
                this.nextButton.classList.add('btn-primary');
            }
        }
    },

    showReward: function(message) {
        this.rewardText.textContent = message;
        this.rewardContainer.classList.remove('hidden');
        void this.rewardContainer.offsetWidth;
        this.rewardContainer.classList.add('show');
    },

    hideReward: function() {
        this.rewardContainer.classList.remove('show');
        this.rewardContainer.addEventListener('transitionend', () => {
            if (!this.rewardContainer.classList.contains('show')) {
                this.rewardContainer.classList.add('hidden');
            }
        }, { once: true });
    },

    wobbleTarget: function(element) {
        if (!element) return;
        if (typeof element.getBoundingClientRect === 'function') {
            element.classList.add('wobble-success');
            element.addEventListener('animationend', () => {
                element.classList.remove('wobble-success');
            }, { once: true });
        }
    },

    end: function() {
        this.active = false;
        this.stepIndex = 0;
        localStorage.removeItem('tutorialStepIndex');
        document.getElementById('tutorial-panel-container').classList.add('hidden');
        showToast('Tutorial beendet', 'Viel Spa√ü beim Erstellen von Voxeln!', 'info', 5000);
        // Show mobile controls again if on mobile
        if (this.isMobileDevice) {
            document.getElementById('mobile-controls').classList.remove('hidden');
        }
    },

    init: function() {
        this.tutorialPanel = document.getElementById('tutorial-panel-container');
        this.tutorialTitle = document.getElementById('tutorial-title');
        this.tutorialDescription = document.getElementById('tutorial-description');
        this.nextButton = document.getElementById('tutorial-next-btn');
        this.exitButton = document.getElementById('tutorial-exit-btn');
        this.rewardContainer = document.getElementById('tutorial-reward');
        this.rewardText = document.getElementById('reward-text');

        this.nextButton.addEventListener('click', () => this.next());
        this.exitButton.addEventListener('click', () => this.end());
        document.getElementById('startTutorialBtn').addEventListener('click', () => this.start());

        // Populate steps array based on device on init
        this.steps = this.isMobileDevice ? this.getMobileSteps() : this.getDesktopSteps();

        if (this.stepIndex > 0) {
            this.active = true;
            this.showCurrentStep();
            this.tutorialPanel.classList.remove('hidden');
            showToast('Tutorial fortgesetzt', 'Sie setzen das Tutorial fort.', 'info', 3000);
            // Hide mobile controls if on mobile and tutorial resumes
            if (this.isMobileDevice) {
                document.getElementById('mobile-controls').classList.add('hidden');
            }
        }
    }
};

window.onload = function() {
    containerDiv = document.getElementById('container');
    cvs = document.getElementById('voxelCanvas');
    const gridSizeSlider = document.getElementById('grid-size-slider');
    const gridSizeDisplay = document.getElementById('grid-size-display');
    const colorPickerSwatch = document.getElementById('color-picker-swatch');
    const colorPickerInputHidden = document.getElementById('color-picker-input-hidden');
    const modeToggle = document.getElementById('modeToggle');
    const currentModeSpan = document.getElementById('current-mode');
    const clearBtn = document.getElementById('clearBtn');
    const fillLevelBtn = document.getElementById('fillLevelBtn');
    const saveBtn = document.getElementById('saveBtn');
    const loadBtn = document.getElementById('loadBtn');
    const exportBtn = document.getElementById('exportBtn');
    const fileInput = document.getElementById('fileInput');
    const flySpeedSlider = document.getElementById('fly-speed-slider');
    const flySpeedDisplay = document.getElementById('fly-speed-display');
    const rotSpeedSlider = document.getElementById('rot-speed-slider');
    const rotSpeedDisplay = document.getElementById('rot-speed-display');
    toastContainer = document.getElementById('toast-container'); // Initialize toastContainer here
    const clearConfirmationModal = document.getElementById('clearConfirmationModal');
    const saveAndClearBtn = document.getElementById('saveAndClearBtn');
    const clearWithoutSaveBtn = document.getElementById('clearWithoutSaveBtn');
    const cancelClearBtn = document.getElementById('cancelClearBtn');
    const resetCameraBtn = document.getElementById('resetCameraBtn');
    const loadImageTemplateBtn = document.getElementById('loadImageTemplateBtn');
    const removeImageTemplateBtn = document.getElementById('removeImageTemplateBtn');
    const imageFileInput = document.getElementById('imageFileInput');
    const loginLogoutBtn = document.getElementById('loginLogoutBtn');
    const userIdDisplay = document.getElementById('userIdDisplay');
    const uploadToHubBtn = document.getElementById('uploadToHubBtn');
    const goToHubBtn = document.getElementById('goToHubBtn');
    const uploadProjectModal = document.getElementById('uploadProjectModal');
    const uploadConfirmBtn = document.getElementById('uploadConfirmBtn');
    const uploadCancelBtn = document.getElementById('uploadCancelBtn');
    const authModal = document.getElementById('authModal');
    const authModalCloseBtn = document.getElementById('authModalCloseBtn');
    const signInGoogleBtn = document.getElementById('signInGoogleBtn');
    const signInGithubBtn = document.getElementById('signInGithubBtn');
    const showEmailLoginFormBtn = document.getElementById('showEmailLoginFormBtn');
    const emailAuthForm = document.getElementById('emailAuthForm');
    const emailSignInBtn = document.getElementById('emailSignInBtn');
    const emailSignUpBtn = document.getElementById('emailSignUpBtn');
    const exportOptionsModal = document.getElementById('exportOptionsModal');
    const confirmExportBtn = document.getElementById('confirmExportBtn');
    const cancelExportOptionsBtn = document.getElementById('cancelExportOptionsBtn');
    const exportFormatRadios = document.querySelectorAll('input[name="exportFormat"]');
    const scaleUnitOptions = document.getElementById('scaleUnitOptions');
    const exportAxisOptions = document.getElementById('exportAxisOptions');
    
    // GLB specific options removed from HTML
    // const glbSpecificOptions = document.getElementById('glbSpecificOptions');
    // const glbGameReadyToggle = document.getElementById('glbGameReadyToggle');
    // const glbVoxelSizeInput = document.getElementById('glbVoxelSizeInput');
    // const glbOptimizeToggle = document.getElementById('glbOptimizeToggle');

    const mobileMenuToggle = document.getElementById('menuToggle');
    const mobileControls = document.getElementById('mobile-controls');
    const mobileUndoBtn = document.getElementById('mobile-undo');
    const mobileRedoBtn = document.getElementById('mobile-redo');
    const mobileSaveBtn = document.getElementById('mobile-save');
    const mobileCameraBtn = document.getElementById('mobile-camera');
    const mobileModeToggle = document.getElementById('mobile-mode-toggle');
    const mobileColorPickerBtn = document.getElementById('mobile-color-picker-btn');
    const mobileColorInputHidden = document.getElementById('mobile-color-input-hidden');
    const mobileAxisToggle = document.getElementById('mobile-axis-toggle');
    const mobileLoginLogout = document.getElementById('mobile-login-logout');
    
    // Camera Control Buttons
    const invertLookXBtn = document.getElementById('invert-look-x');
    const invertLookYBtn = document.getElementById('invert-look-y');
    const reverseStrafeXBtn = document.getElementById('reverse-strafe-x');
    const reverseStrafeYBtn = document.getElementById('reverse-strafe-y');


    // Firebase Init
    const app = window.initializeApp(window.firebaseConfig);
    const db = window.getFirestore(app);
    const auth = window.getAuth(app);
    window.db = db;
    window.auth = auth;
    let currentUserId = null;
    let currentUser = null;

    // Persist authentication state
    window.setPersistence(auth, window.browserLocalPersistence)
        .catch((error) => {
            console.error("Error setting persistence:", error);
        });

    window.onAuthStateChanged(auth, async (user) => {
        currentUser = user;
        if (user) {
            currentUserId = user.uid;
            loginLogoutBtn.textContent = 'Abmelden';
            userIdDisplay.textContent = `Angemeldet: ${user.email || user.displayName || user.uid}`;
            uploadToHubBtn.classList.remove('hidden');
        } else {
            currentUserId = null;
            loginLogoutBtn.textContent = 'Anmelden';
            userIdDisplay.textContent = '';
            uploadToHubBtn.classList.add('hidden');
            // Try to sign in anonymously if no user is signed in
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token !== '') {
                try {
                    await window.signInWithCustomToken(auth, __initial_auth_token);
                    console.log("Signed in with custom token.");
                } catch (error) {
                    console.error("Error signing in with custom token:", error);
                    try {
                        await window.signInAnonymously(auth); // Corrected: Using window.signInAnonymously
                        console.log("Signed in anonymously.");
                    } catch (anonError) {
                        console.error("Error signing in anonymously:", anonError);
                    }
                }
            } else {
                try {
                    await window.signInAnonymously(auth); // Corrected: Using window.signInAnonymously
                    console.log("Signed in anonymously (no initial token).");
                } catch (anonError) {
                    console.error("Error signing in anonymously:", anonError);
                }
            }
        }
        // No longer checking tutorial for uploadToHub step as it's removed.
    });

    // Handle URL parameters for loading models from hub
    const urlParams = new URLSearchParams(window.location.search);
    const modelIdFromUrl = urlParams.get('modelId');
    if (modelIdFromUrl) {
        // Wait for auth to be ready before trying to load model
        const unsubscribe = window.onAuthStateChanged(auth, (user) => {
            if (user) { // Only attempt to load once user is authenticated (even anonymously)
                loadProjectFromModelId(modelIdFromUrl);
                unsubscribe(); // Stop listening after first auth state change
            }
        });
    }

    // Scene setup
    scene = new THREE.Scene();
    cam = new THREE.PerspectiveCamera(75, containerDiv.clientWidth / containerDiv.clientHeight, 0.1, 1000);
    ren = new THREE.WebGLRenderer({ canvas: cvs, antialias: true });
    ren.shadowMap.enabled = true;
    ren.shadowMap.type = THREE.PCFSoftShadowMap;

    euler = new THREE.Euler(0, 0, 0, 'YXZ');
    
    // Lights
    mainDirectionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
    mainDirectionalLight.position.set(50, 80, 60);
    mainDirectionalLight.castShadow = true;
    mainDirectionalLight.shadow.mapSize.width = 2048;
    mainDirectionalLight.shadow.mapSize.height = 2048;
    mainDirectionalLight.shadow.camera.left = -100;
    mainDirectionalLight.shadow.camera.right = 100;
    mainDirectionalLight.shadow.camera.top = 100;
    mainDirectionalLight.shadow.camera.bottom = -100;
    mainDirectionalLight.shadow.camera.near = 0.5;
    mainDirectionalLight.shadow.camera.far = 150;
    scene.add(mainDirectionalLight);

    fillDirectionalLight = new THREE.DirectionalLight(0xabcdef, 0.5); // Softer fill light
    fillDirectionalLight.position.set(-50, 30, -40);
    scene.add(fillDirectionalLight);

    hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.7); // Sky, Ground, Intensity
    scene.add(hemisphereLight);

    scene.add(previewVoxelMesh);

    const previewLineMaterial = new THREE.LineBasicMaterial({ color: 0xff00ff, transparent: true, opacity: 0.7 });
    previewLineInstancedMesh = new THREE.InstancedMesh(new THREE.BufferGeometry(), previewLineMaterial, maxPreviewInstances);
    previewLineInstancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    previewLineInstancedMesh.count = 0;
    scene.add(previewLineInstancedMesh);

    function animate() {
        requestAnimationFrame(animate);
        if (isPointerLocked) {
            if (firstMoveAfterLock) {
                firstMoveAfterLock = false;
                mouseMovementX = mouseMovementY = 0;
                return;
            }
            let deltaY = mouseMovementX * rotSpeed;
            let deltaX = mouseMovementY * rotSpeed;

            if (invertLookX) deltaY *= -1;
            if (invertLookY) deltaX *= -1;

            euler.y -= deltaY;
            euler.x -= deltaX;
            euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
            cam.quaternion.setFromEuler(euler);
            
            // NEW: Set cameraMoved flag if significant rotation detected
            if (tutorial.active && tutorial.stepIndex === tutorial.getStepIndex('freelook') && (Math.abs(mouseMovementX) > 5 || Math.abs(mouseMovementY) > 5)) { // Small threshold for movement
                tutorial.cameraMoved = true;
                tutorial.checkCondition(cvs);
            }
            
            mouseMovementX = mouseMovementY = 0;
            const camDir = new THREE.Vector3(); cam.getWorldDirection(camDir);
            const rightDir = new THREE.Vector3().crossVectors(camDir, cam.up).normalize();
            const upVec = new THREE.Vector3(0, 1, 0); const currMoveSpeed = moveSpeed * 0.5;
            
            let actualMoveSpeed = currMoveSpeed;
            if (isShiftDragging) actualMoveSpeed *= 3; // Sprint speed

            let moveVector = new THREE.Vector3(0, 0, 0);

            if (keyboard['w']) moveVector.addScaledVector(camDir, actualMoveSpeed);
            if (keyboard['s']) moveVector.addScaledVector(camDir, -actualMoveSpeed);
            if (keyboard['a']) moveVector.addScaledVector(rightDir, reverseStrafeX ? actualMoveSpeed : -actualMoveSpeed);
            if (keyboard['d']) moveVector.addScaledVector(rightDir, reverseStrafeX ? -actualMoveSpeed : actualMoveSpeed);
            if (keyboard['e']) moveVector.addScaledVector(upVec, reverseStrafeY ? -actualMoveSpeed : actualMoveSpeed);
            if (keyboard['q']) moveVector.addScaledVector(upVec, reverseStrafeY ? actualMoveSpeed : -actualMoveSpeed);

            cam.position.add(moveVector);
        }
        cam.updateMatrixWorld();

        ren.render(scene, cam);
    }
    
    // Initial setup
    rebuildHelpers();
    resetCameraPosition();
    onResize();

    // Event Listeners
    window.addEventListener('resize', onResize);
    cvs.addEventListener('contextmenu', (e) => e.preventDefault()); // Prevent right-click context menu
    cvs.addEventListener('pointerdown', onPointerDown);
    cvs.addEventListener('pointermove', onPointerMove);
    cvs.addEventListener('pointerup', onPointerUp);
    cvs.addEventListener('pointerleave', onPointerLeave); // NEW: Handle pointerleave

    // NEW: mousemove for pointerlock only
    cvs.addEventListener('mousemove', (e) => {
        if (isPointerLocked) {
            mouseMovementX += e.movementX;
            mouseMovementY += e.movementY;
        }
    });

    document.addEventListener('pointerlockchange', onPointerLockChange);
    cvs.addEventListener('wheel', onMouseWheel, { passive: false });
    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);

    gridSizeSlider.value = GRID;
    gridSizeDisplay.textContent = `${GRID}√ó${GRID}√óGRID`;
    gridSizeSlider.addEventListener('input', () => {
        const newGrid = parseInt(gridSizeSlider.value);
        if (newGrid !== GRID) {
            const oldState = [...voxels.entries()].map(([id, data]) => { const p = parseKey(id); return { x: p[0], y: p[1], z: p[2], color: data.color }; });
            const oldGridSize = GRID; // Store old GRID value before updating
            GRID = newGrid;
            localStorage.setItem('voxelEditorGridSize', GRID);
            gridSizeDisplay.textContent = `${GRID}√ó${GRID}√ó${GRID}`;
            for (const chunk of chunks.values()) chunk.dispose();
            chunks.clear(); voxels.clear();
            applyVoxelState(oldState); // Re-add existing voxels to new grid size
            addCommand('resizeGrid', oldState, [...voxels.entries()].map(([id, data]) => { const p = parseKey(id); return { x: p[0], y: p[1], z: p[2], color: data.color }; }), { oldGrid: oldGridSize, newGrid: newGrid });
            rebuildHelpers();
        }
    });

    colorPickerInputHidden.value = currentColor;
    colorPickerSwatch.style.backgroundColor = currentColor;
    colorPickerSwatch.addEventListener('click', () => colorPickerInputHidden.click());
    colorPickerInputHidden.addEventListener('input', (e) => {
        currentColor = e.target.value;
        colorPickerSwatch.style.backgroundColor = currentColor;
        localStorage.setItem('voxelEditorColor', currentColor);
        if (previewVoxelMesh.visible) {
            previewVoxelMaterial.color.set(currentColor);
        }
        if (tutorial.active && tutorial.stepIndex === tutorial.getStepIndex('changeColor')) {
             tutorial.checkCondition(colorPickerSwatch);
        }
    });

    presetBoxes = [document.getElementById('color-preset-1'), document.getElementById('color-preset-2'), document.getElementById('color-preset-3')];
    presetBoxes.forEach((box, index) => {
        box.value = presetColors[index];
        box.addEventListener('click', () => setActivePreset(index));
        box.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            const chosenColor = prompt('Neue Farbe f√ºr Preset (Hex oder Name):', box.value);
            if (chosenColor) {
                try {
                    const tempColor = new THREE.Color(chosenColor);
                    savePresetColor(index, '#' + tempColor.getHexString());
                    box.value = '#' + tempColor.getHexString();
                    if (activePresetIndex === index) {
                        currentColor = '#' + tempColor.getHexString();
                        colorPickerInputHidden.value = currentColor;
                        colorPickerSwatch.style.backgroundColor = currentColor;
                        if (previewVoxelMesh.visible) {
                            previewVoxelMaterial.color.set(currentColor);
                        }
                    }
                } catch (err) {
                    showToast('Fehler', 'Ung√ºltiges Farbformat. Verwenden Sie Hex (#RRGGBB) oder einen CSS-Farbnamen.', 'error', 5000);
                }
            }
        });
    });
    setActivePreset(activePresetIndex);

    modeToggle.addEventListener('click', cycleMode);
    currentModeSpan.textContent = `Modus: ${currentMode}`;

    clearBtn.addEventListener('click', () => clearConfirmationModal.showModal());
    saveAndClearBtn.addEventListener('click', () => { saveJSON(); clearAll(); clearConfirmationModal.close(); });
    clearWithoutSaveBtn.addEventListener('click', () => { clearAll(); clearConfirmationModal.close(); });
    cancelClearBtn.addEventListener('click', () => clearConfirmationModal.close());

    fillLevelBtn.addEventListener('click', fillActiveLevel);

    saveBtn.addEventListener('click', saveJSON);
    
    loadBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', loadJSON);

    exportBtn.addEventListener('click', () => exportOptionsModal.showModal());
    cancelExportOptionsBtn.addEventListener('click', () => exportOptionsModal.close());
    confirmExportBtn.addEventListener('click', async () => {
        const format = document.querySelector('input[name="exportFormat"]:checked').value;
        const scaleUnit = document.querySelector('input[name="exportScaleUnit"]:checked').value;
        const upAxis = document.querySelector('input[name="exportUpAxis"]:checked').value;
        
        let success = false;
        if (format === 'stl') {
            success = await exportSTL(scaleUnit, upAxis);
        }
        // OBJ, 3MF, GLB removed here

        if (success) {
            exportOptionsModal.close();
        }
    });

    // Event listener for export format change (simplified for STL only)
    exportFormatRadios.forEach(radio => {
        radio.addEventListener('change', () => {
            // All options related to other formats and GLB specific settings are now removed from HTML
            // so this listener largely becomes moot or can be removed if only STL is left.
            // For now, keep it for robustness, even if only 'stl' option exists.
            if (radio.value === 'stl') {
                scaleUnitOptions.classList.remove('hidden');
                exportAxisOptions.classList.remove('hidden');
            } else {
                scaleUnitOptions.classList.add('hidden');
                exportAxisOptions.classList.add('hidden');
            }
        });
    });
    // Trigger initial check on load
    document.querySelector('input[name="exportFormat"]:checked').dispatchEvent(new Event('change'));


    flySpeedSlider.value = moveSpeed;
    flySpeedDisplay.textContent = moveSpeed.toFixed(2);
    flySpeedSlider.addEventListener('input', (e) => {
        moveSpeed = parseFloat(e.target.value);
        flySpeedDisplay.textContent = moveSpeed.toFixed(2);
        localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
    });

    rotSpeedSlider.value = rotSpeed;
    rotSpeedDisplay.textContent = rotSpeed.toFixed(4);
    rotSpeedSlider.addEventListener('input', (e) => {
        rotSpeed = parseFloat(e.target.value);
        rotSpeedDisplay.textContent = rotSpeed.toFixed(4);
        localStorage.setItem('voxelEditorRotSpeed', rotSpeed);
    });

    invertLookXBtn.addEventListener('click', () => {
        invertLookX = !invertLookX; localStorage.setItem('voxelEditorInvertLookX', invertLookX); updateMobileCameraControlButtons();
        showToast('Blickachse X', invertLookX ? 'X-Achse invertiert' : 'X-Achse normal', 'info', 1000);
    });
    invertLookYBtn.addEventListener('click', () => {
        invertLookY = !invertLookY; localStorage.setItem('voxelEditorInvertLookY', invertLookY); updateMobileCameraControlButtons();
        showToast('Blickachse Y', invertLookY ? 'Y-Achse invertiert' : 'Y-Achse normal', 'info', 1000);
    });
    reverseStrafeXBtn.addEventListener('click', () => {
        reverseStrafeX = !reverseStrafeX; localStorage.setItem('voxelEditorReverseStrafeX', reverseStrafeX); updateMobileCameraControlButtons();
        showToast('Strafe X', reverseStrafeX ? 'X-Strafe invertiert' : 'X-Strafe normal', 'info', 1000);
    });
    reverseStrafeYBtn.addEventListener('click', () => {
        reverseStrafeY = !reverseStrafeY; localStorage.setItem('voxelEditorReverseStrafeY', reverseStrafeY); updateMobileCameraControlButtons();
        showToast('Strafe Y', reverseStrafeY ? 'Y-Strafe invertiert' : 'Y-Strafe normal', 'info', 1000);
    });
    updateMobileCameraControlButtons(); // Set initial button states

    resetCameraBtn.addEventListener('click', resetCameraPosition);
    
    loadImageTemplateBtn.addEventListener('click', loadImageTemplate);
    imageFileInput.addEventListener('change', handleImageFileSelect);
    removeImageTemplateBtn.addEventListener('click', removeImageTemplate);

    loginLogoutBtn.addEventListener('click', loginLogout);
    uploadToHubBtn.addEventListener('click', openUploadModal);
    uploadConfirmBtn.addEventListener('click', uploadProjectToHub);
    uploadCancelBtn.addEventListener('click', () => uploadProjectModal.close());
    goToHubBtn.addEventListener('click', () => window.open('https://hub.voxelshaper.com/', '_blank'));

    authModalCloseBtn.addEventListener('click', closeAuthModal);
    signInGoogleBtn.addEventListener('click', window.signInWithGoogle);
    signInGithubBtn.addEventListener('click', window.signInWithGithub);
    showEmailLoginFormBtn.addEventListener('click', () => document.getElementById('emailLoginForm').classList.toggle('hidden'));
    emailSignInBtn.addEventListener('click', (e) => { e.preventDefault(); window.signInEmailPassword(); });
    emailSignUpBtn.addEventListener('click', (e) => { e.preventDefault(); window.signUpEmailPassword(); });

    // Mobile controls logic
    mobileMenuToggle.addEventListener('click', () => {
        const controlsPanel = document.getElementById('controls');
        controlsPanel.classList.toggle('hidden');
        controlsPanel.classList.toggle('flex');
    });
    // Close desktop controls when clicking outside in mobile view
    document.getElementById('controls').addEventListener('click', (event) => {
        const controlsPanel = document.getElementById('controls');
        // Check if the click was directly on the overlay background or the close button
        if (event.target === controlsPanel || event.target.textContent === '‚úï') {
            controlsPanel.classList.add('hidden');
            controlsPanel.classList.remove('flex');
        }
    });

    // Mobile control buttons
    mobileUndoBtn.addEventListener('click', undo);
    mobileRedoBtn.addEventListener('click', redo);
    mobileSaveBtn.addEventListener('click', saveJSON);
    mobileCameraBtn.addEventListener('click', resetCameraPosition);
    mobileModeToggle.addEventListener('click', cycleMode);
    mobileColorPickerBtn.addEventListener('click', () => mobileColorInputHidden.click());
    mobileColorInputHidden.addEventListener('input', (e) => {
        currentColor = e.target.value;
        document.getElementById('color-picker-input-hidden').value = currentColor;
        colorPickerSwatch.style.backgroundColor = currentColor;
        localStorage.setItem('voxelEditorColor', currentColor);
        if (previewVoxelMesh.visible) {
            previewVoxelMaterial.color.set(currentColor);
        }
        if (tutorial.active && tutorial.stepIndex === tutorial.getStepIndex('changeColor')) {
             tutorial.checkCondition(mobileColorPickerBtn); // Pass the mobile button as wobble target
        }
    });
    mobileAxisToggle.addEventListener('click', cycleDrawingAxis);
    mobileLoginLogout.addEventListener('click', loginLogout);

    // Start the animation loop
    animate();

    // Initialize tutorial system
    tutorial.init();
};
</script>
</body>
</html>
