<!DOCTYPE html>
<html lang="de" data-theme="dark">
<head>
<meta charset="UTF-8">
<meta property="og:title" content="VoxelShaper – Create in 3D, Effortlessly" />
<meta property="og:description" content="A powerful, intuitive voxel-based 3D editor – made for makers, artists, and coders." />
<meta property="og:image" content="https://voxelshaper.com/preview.png" />
<meta property="og:url" content="https://voxelshaper.com/" />
<meta property="og:type" content="website" />
<meta name="viewport"
      content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover">
<link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAAANl..."/>

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="VoxelShaper – Create in 3D, Effortlessly">
<meta name="twitter:description" content="A powerful, intuitive voxel-based 3D editor – made for makers, artists, and coders.">
<meta name="twitter:image" content="https://voxelshaper.com/preview.png">
<title>VoxelShaper – Voxel Editor & 3D Print Exporter</title>

<link href="https://cdn.jsdelivr.net/npm/daisyui@4.7.2/dist/full.min.css" rel="stylesheet" type="text/css" />
<script src="https://cdn.tailwindcss.com"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

<style>
body {
    padding-top: env(safe-area-inset-top);
    padding-bottom: env(safe-area-inset-bottom);
    padding-left: env(safe-area-inset-left);
    padding-right: env(safe-area-inset-right);
    box-sizing: border-box;
    touch-action: auto;
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
}
#container, #voxelCanvas {
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
    -webkit-touch-callout: none;
    touch-action: none;
}
.touch-indicator { animation: pulse 0.5s; }
@keyframes pulse {
    0% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
    50% { transform: translate(-50%, -50%) scale(1.5); opacity: 0.2; }
    100% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
}
input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
input[type="color"]::-webkit-color-swatch { border: none; border-radius: 50%; }
input[type="color"]::-moz-color-swatch-wrapper { padding: 0; }
input[type="color"]::-moz-color-swatch { border: none; border-radius: 50%; }
.color-preset-box::-webkit-color-swatch-wrapper { padding: 0; }
input[type="color"]::-webkit-color-swatch { border: none; border-radius: 50%; }
input[type="color"]::-moz-color-swatch-wrapper { padding: 0; }
input[type="color"]::-moz-color-swatch { border: none; border-radius: 50%; }
.color-preset-box::-webkit-color-swatch-wrapper { padding: 0; }
.color-preset-box::-webkit-color-swatch { border: none; border-radius: 0.375rem; }
.color-preset-box::-moz-color-swatch-wrapper { padding: 0; }
.color-preset-box::-moz-color-swatch { border: none; border-radius: 0.375rem; }

#toast-container {
    position: fixed;
    z-index: 50;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    padding: 1rem;
    pointer-events: none;
}

#toast-container.toast-end {
    bottom: 1rem;
    right: 1rem;
    align-items: flex-end;
}

@media (max-width: 768px) {
    #toast-container {
        top: 1rem;
        left: 50%;
        transform: translateX(-50%);
        width: calc(100% - 2rem);
        max-width: 300px;
        align-items: center;
    }
    #toast-container.toast-end {
        bottom: auto;
        right: auto;
    }
}

.toast .alert {
    pointer-events: auto;
    opacity: 0;
    transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
    transform: translateY(20px);
}

.toast .alert.show {
    opacity: 1;
    transform: translateY(0);
}

@media (max-width: 768px) {
    .toast .alert {
        padding: 0.5rem 0.75rem;
        font-size: 0.875rem;
    }
    .toast .alert svg {
        width: 1.25rem;
        height: 1.25rem;
    }
    .toast .alert strong {
        font-size: 0.9rem;
    }
    .toast .alert span {
        font-size: 0.8rem;
    }
    .toast .alert .close-btn {
        font-size: 1rem;
        padding: 0.25rem;
    }
}
.mobile-btn {
    width: 64px;
    height: 64px;
    font-size: 2rem;
    border-radius: 50%;
    background-color: var(--fallback-b3, oklch(var(--b3)/1));
    color: var(--fallback-bc, oklch(var(--bc)/1));
    border: 2px solid var(--fallback-bc, oklch(var(--bc)/1));
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
    transition: background-color 0.2s, transform 0.2s;
}

.mobile-btn:hover {
    background-color: oklch(var(--bc)/0.2);
}

.mobile-btn:active {
    transform: scale(0.95);
}

#mobile-controls {
    gap: 1rem;
}
</style>
</head>
<body class="bg-base-100 min-h-screen text-base-content flex flex-col">
<button id="menuToggle" aria-label="Menü umschalten" class="fixed top-4 right-4 z-[1500] w-10 h-10 text-xl leading-10 text-center bg-base-300 text-base-content border-none rounded-lg cursor-pointer shadow-md hover:bg-base-content/20 lg:hidden">☰</button>

<div id="controls" class="flex flex-wrap items-center justify-center gap-3 p-4 bg-base-200 border-b border-base-content/20 hidden md:flex">
    <label for="grid-size-slider" class="text-base-content">Gittergröße:</label>
    <input type="range" id="grid-size-slider" min="5" max="180" value="10" aria-label="Gittergröße anpassen" class="range range-xs w-36">
    <span id="grid-size-display" class="font-bold text-primary">10×10×10</span>
    
    <label for="color-picker" class="text-base-content">Farbe:</label>
    <input type="color" id="color-picker" value="#ffffff" aria-label="Aktuelle Farbe wählen" class="input input-bordered w-10 h-10 p-0 rounded-full cursor-pointer border-base-content/20">
    <input type="color" id="color-preset-1" class="color-preset-box w-10 h-10 rounded-md border-2 border-base-content/20 cursor-pointer transition-all duration-200 hover:scale-110" value="#E4002B" aria-label="Voreingestellte Farbe 1">
    <input type="color" id="color-preset-2" class="color-preset-box w-10 h-10 rounded-md border-2 border-base-content/20 cursor-pointer transition-all duration-200 hover:scale-110" value="#00A040" aria-label="Voreingestellte Farbe 2">
    <input type="color" id="color-preset-3" class="color-preset-box w-10 h-10 rounded-md border-2 border-base-content/20 cursor-pointer flex items-center justify-center shadow-lg hover:bg-base-content/20" value="#0057B8" aria-label="Voreingestellte Farbe 3">

    <button id="modeToggle" aria-label="Modus wechseln" class="btn btn-sm btn-neutral">Modus wechseln</button><span id="current-mode" class="font-bold text-success min-w-40 text-center">Modus: Hinzufügen</span>
    <button id="clearBtn" aria-label="Alles löschen" class="btn btn-sm btn-neutral">Alles löschen</button>
    <button id="fillLevelBtn" aria-label="Ebene füllen" class="btn btn-sm btn-neutral">Ebene füllen</button>
    <button id="saveBtn" aria-label="Projekt speichern" aria-describedby="save-description" class="btn btn-sm btn-neutral">Projekt speichern</button>
    <div id="save-description" class="sr-only">Speichert das aktuelle Projekt als JSON-Datei</div>
    <button id="loadBtn" aria-label="Projekt laden" class="btn btn-sm btn-neutral">Projekt laden</button>
    <button id="exportStlBtn" aria-label="STL Export" class="btn btn-sm btn-neutral">STL Export</button>
    <button id="exportObjBtn" aria-label="OBJ Export" class="btn btn-sm btn-neutral">OBJ Export</button>
    <button id="exportGlbBtn" aria-label="GLB Export" class="btn btn-sm btn-neutral">GLB Export</button>

    <label for="fly-speed-slider" class="text-base-content">Fluggeschwindigkeit:</label>
    <input type="range" id="fly-speed-slider" min="0.01" max="1.0" step="0.01" value="0.1" aria-label="Fluggeschwindigkeit anpassen" class="range range-xs w-36">
    <span id="fly-speed-display" class="font-bold text-primary">0.10</span>

    <button id="resetCameraBtn" aria-label="Kamera zurücksetzen" class="btn btn-sm btn-neutral">Zur Szene zurückkehen</button>
    <button id="generateVoxelIdeaBtn" aria-label="Voxel-Idee generieren" class="btn btn-sm btn-primary">✨ Voxel-Idee generieren ✨</button>

    <button id="loadImageTemplateBtn" aria-label="Bild als Vorlage laden" class="btn btn-sm btn-neutral">Bild als Vorlage laden</button>
    <button id="removeImageTemplateBtn" class="btn btn-sm btn-neutral hidden" aria-label="Bildvorlage entfernen">Bildvorlage entfernen</button>
    <input type="file" id="imageFileInput" accept="image/*" class="hidden">

    <button id="loadTemplateBtn" aria-label="Vorlage laden" class="btn btn-sm btn-neutral">Vorlage laden</button>
    <button id="removeTemplateBtn" class="btn btn-sm btn-neutral hidden" aria-label="Vorlage entfernen">Vorlage entfernen</button>

    <button id="loginLogoutBtn" aria-label="Anmelden oder Abmelden" class="btn btn-sm btn-info">Anmelden</button>
    <span id="userIdDisplay" class="font-bold text-info ml-2 mr-2 whitespace-nowrap overflow-hidden text-ellipsis max-w-xs flex items-center gap-1"></span>
    <button id="uploadToHubBtn" aria-label="Auf Hub hochladen" class="btn btn-sm btn-warning hidden">Auf Hub hochladen</button>
    <button id="goToHubBtn" aria-label="Zum VoxelShaper Hub wechseln" class="btn btn-sm btn-secondary">Zum Hub</button>
</div>

<div id="container" class="flex-1 relative border-2 border-transparent box-border overflow-hidden touch-none">
    <canvas id="voxelCanvas" class="w-full h-full block box-border" tabindex="0"></canvas>
    <div id="touch-indicator" class="touch-indicator absolute w-10 h-10 rounded-full bg-blue-500/30 transform -translate-x-1/2 -translate-y-1/2 pointer-events-none hidden z-[2000]"></div>
    <input type="file" id="fileInput" accept=".json" class="hidden">
</div>

<dialog id="clearConfirmationModal" class="modal">
    <div class="modal-box bg-base-200 text-base-content p-8 text-center shadow-xl max-w-md">
        <h3 class="font-bold text-lg text-primary mb-4">Projekt löschen</h3>
        <p class="py-4">Möchten Sie das aktuelle Projekt speichern, bevor Sie alle Voxel löschen?</p>
        <div class="modal-buttons flex justify-around gap-4 mt-6">
            <button id="saveAndClearBtn" class="confirm-save btn btn-success flex-1">Speichern & Löschen</button>
            <button id="clearWithoutSaveBtn" class="confirm-no-save btn btn-error flex-1">Ohne Speichern löschen</button>
            <button id="cancelClearBtn" class="cancel btn btn-ghost flex-1">Abbrechen</button>
        </div>
    </div>
</dialog>

<dialog id="uploadProjectModal" class="modal">
    <div class="upload-modal-content modal-box bg-base-200 text-base-content p-8 shadow-xl max-w-xl w-11/12 text-left">
        <h3 class="font-bold text-lg text-primary text-center mb-6">Projekt auf Hub hochladen</h3>
        <label for="uploadTitle" class="label block mb-2 font-bold">Titel:</label>
        <input type="text" id="uploadTitle" placeholder="Ein aussagekräftiger Titel für Ihr Projekt" maxlength="100" class="input input-bordered w-full bg-base-300 border-base-content/20 mb-4">

        <label for="uploadDescription" class="label block mb-2 font-bold">Beschreibung:</label>
        <textarea id="uploadDescription" placeholder="Beschreiben Sie Ihr Projekt kurz" maxlength="500" class="textarea textarea-bordered w-full bg-base-300 border-base-content/20 h-24 mb-4 resize-y"></textarea>

        <label for="uploadCategory" class="label block mb-2 font-bold">Kategorie:</label>
        <select id="uploadCategory" class="select select-bordered w-full bg-base-300 border-base-content/20 mb-4" required>
            <option value="" disabled selected>Kategorie auswählen</option>
        </select>

        <label for="uploadTags" class="label block mb-2 font-bold">Tags (Komma-getrennt):</label>
        <input type="text" id="uploadTags" placeholder="z.B. Haus, Baum, Auto, Gebäude" maxlength="100" class="input input-bordered w-full bg-base-300 border-base-content/20 mb-4">

        <label class="label block mb-2 font-bold">Sichtbarkeit:</label>
        <div class="radio-group flex gap-4 mb-4">
            <label class="flex items-center font-normal">
                <input type="radio" name="uploadVisibility" value="public" checked class="radio radio-primary mr-2"> Öffentlich
            </label>
            <label class="flex items-center font-normal">
                <input type="radio" name="uploadVisibility" value="private" class="radio radio-primary mr-2"> Privat
            </label>
        </div>

        <div class="upload-modal-buttons flex justify-around gap-4 mt-6">
            <button id="uploadConfirmBtn" class="upload-confirm btn btn-success flex-1">Hochladen</button>
            <button id="uploadCancelBtn" class="upload-cancel btn btn-ghost flex-1">Abbrechen</button>
        </div>
    </div>
</dialog>

<dialog id="authModal" class="modal">
    <div class="auth-modal-content modal-box bg-base-200 text-base-content p-8 shadow-xl max-w-lg w-11/12 text-center">
        <h3 class="font-bold text-lg text-primary mb-6">Anmelden bei VoxelShaper Hub</h3>
        <div class="provider-buttons flex flex-col gap-3">
            <button id="signInGoogleBtn" class="google btn btn-error text-white">
                <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" alt="Google Icon" class="w-5 h-5">
                Mit Google anmelden
            </button>
            <button id="signInGithubBtn" class="github btn bg-neutral text-neutral-content hover:bg-neutral-focus">
                <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/github.svg" alt="GitHub Icon" class="w-5 h-5">
                Mit GitHub anmelden
            </button>
            <button id="showEmailLoginFormBtn" class="email btn btn-info">
                Mit E-Mail anmelden
            </button>
        </div>

        <div id="emailLoginForm" class="email-login-form mt-6 pt-6 border-t border-base-content/20 hidden">
            <form id="emailAuthForm">
                <input type="email" id="emailInput" placeholder="E-Mail" autocomplete="email" class="input input-bordered w-full bg-base-300 border-base-content/20 mb-3">
                <input type="password" id="passwordInput" placeholder="Passwort" autocomplete="current-password" class="input input-bordered w-full bg-base-300 border-base-content/20 mb-3">
                <button type="submit" id="emailSignInBtn" class="btn btn-primary w-full">Anmelden</button>
                <button type="button" id="emailSignUpBtn" class="btn btn-secondary w-full mt-2">Registrieren</button>
            </form>
        </div>

        <div class="close-button-container mt-6">
            <button id="authModalCloseBtn" class="btn btn-ghost">Schließen</button>
        </div>
    </div>
</dialog>

<dialog id="ideaGeneratorModal" class="modal">
    <div class="modal-box bg-base-200 text-base-content p-8 shadow-xl max-w-md">
        <h3 class="font-bold text-lg text-primary mb-4">✨ Voxel-Idee generieren ✨</h3>
        <p class="py-2">Geben Sie ein Thema oder Konzept ein, um eine Voxel-Modell-Idee zu generieren:</p>
        <textarea id="ideaPromptInput" placeholder="Z.B. 'Ein gemütliches Baumhaus', 'Ein futuristisches Raumschiff'" class="textarea textarea-bordered w-full bg-base-300 border-base-content/20 h-24 mb-4 resize-y"></textarea>
        <div id="ideaResultDisplay" class="bg-base-300 p-4 rounded-md mb-4 hidden overflow-auto max-h-40"></div>
        <div id="ideaLoadingIndicator" class="text-center py-4 hidden">
            <span class="loading loading-spinner loading-lg text-primary"></span>
            <p>Generiere Idee...</p>
        </div>
        <div class="modal-buttons flex justify-around gap-4 mt-6">
            <button id="generateIdeaConfirmBtn" class="btn btn-primary flex-1">Generieren</button>
            <button id="ideaGeneratorCloseBtn" class="btn btn-ghost flex-1">Schließen</button>
        </div>
    </div>
</dialog>

<dialog id="templateChooserModal" class="modal">
    <div class="modal-box bg-base-200 text-base-content p-8 shadow-xl max-w-md">
        <h3 class="font-bold text-lg text-primary mb-4">Vorlage auswählen</h3>
        <div id="templateList" class="flex flex-col gap-2">
            <!-- Templates will be injected here by JS -->
        </div>
        <div class="modal-buttons flex justify-end gap-4 mt-6">
            <button id="templateChooserCloseBtn" class="btn btn-ghost">Schließen</button>
        </div>
    </div>
</dialog>

<div id="toast-container" class="toast toast-end z-50"></div>

<div id="mobile-controls" class="hidden md:hidden flex-col gap-3 fixed bottom-4 right-4 z-[1000]">
    <button class="mobile-btn" id="mobile-undo" aria-label="Rückgängig machen">↺</button>
    <button class="mobile-btn" id="mobile-redo" aria-label="Wiederholen">↻</button>
    <button class="mobile-btn" id="mobile-save" aria-label="Speichern">💾</button>
    <button class="mobile-btn" id="mobile-camera" aria-label="Kamera zurücksetzen">📷</button>

    <button class="mobile-btn" id="mobile-mode-toggle" aria-label="Modus wechseln">
        <span id="mobile-mode-icon" class="fas fa-plus"></span>
    </button>

    <button class="mobile-btn" id="mobile-color-picker-btn" aria-label="Farbe auswählen">🎨</button>
    <input type="color" id="mobile-color-input" value="#ffffff" class="hidden w-0 h-0 opacity-0 absolute pointer-events-none">

    <button class="mobile-btn" id="mobile-axis-toggle" aria-label="Zeichenachse wechseln">
        <span id="mobile-axis-icon" class="fas fa-arrows-alt-v"></span>
    </button>
    <button class="mobile-btn" id="mobile-level-up" aria-label="Ebene erhöhen">⬆️</button>
    <button class="mobile-btn" id="mobile-level-down" aria-label="Ebene verringern">⬇️</button>

    <button class="mobile-btn" id="mobile-generate-idea" aria-label="Voxel-Idee generieren">✨</button>
    <button class="mobile-btn" id="mobile-template" aria-label="Vorlage laden">📐</button>
    <button class="mobile-btn" id="mobile-login-logout" aria-label="Anmelden oder Abmelden">🔑</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/GLTFExporter.js"></script>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import {
        getAuth,
        setPersistence,
        browserLocalPersistence,
        signInWithCustomToken,
        onAuthStateChanged,
        signOut,
        GoogleAuthProvider,
        GithubAuthProvider,
        signInWithPopup,
        createUserWithEmailAndPassword,
        signInWithEmailAndPassword
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import {
        getFirestore,
        doc,
        getDoc,
        collection,
        addDoc,
        serverTimestamp
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    window.firebase = {
        initializeApp,
        getAuth,
        signInWithCustomToken,
        onAuthStateChanged,
        setPersistence,
        browserLocalPersistence,
        signOut,
        GoogleAuthProvider,
        GithubAuthProvider,
        signInWithPopup,
        createUserWithEmailAndPassword,
        signInWithEmailAndPassword,
        getFirestore,
        doc,
        getDoc,
        collection,
        addDoc,
        serverTimestamp
    };

    const FIREBASE_API_KEY = "AIzaSyB9-mpyAu9W6oiVtB0fYG8E6YFvTAsjtAA"; 

    const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {
        apiKey: FIREBASE_API_KEY,
        authDomain: "voxelshaper.firebaseapp.com",
        projectId: "voxelshaper",
        storageBucket: "voxelshaper.firebasestorage.app", 
        messagingSenderId: "1053689247573",
        appId: "1:1053689247573:web:f7960c7f8c2e8849e8e1dc",
        measurementId: "G-QJCNKZ5DR"
    };
    window.firebaseConfig = firebaseConfig;
</script>

<script>
// Konstanten für Voxelgröße und Bitmaskierung
const VS = 1, HALF = VS * 0.5; // Voxelgröße und halbe Voxelgröße
const CHUNK_SIZE = 16; // Größe der Chunks für die Optimierung der Voxel-Speicherung
const VOX_BITS = 10; // Bits pro Voxelkoordinate für die Key-Generierung
const VOX_MASK = (1 << VOX_BITS) - 1; // Maske für Voxelkoordinaten
const SHIFT_X  = VOX_BITS * 2; // Shift-Wert für X-Koordinate
const SHIFT_Y  = VOX_BITS; // Shift-Wert für Y-Koordinate

const AI_API_KEY = "AIzaSyD3uQ6BnGsliYAtR9r0jdBUq03KEfFO0"; // API-Schlüssel für KI-Dienste

// Funktion zur Generierung eines eindeutigen Keys für Voxel
function key(x, y, z) { return ((x << SHIFT_X) | (y << SHIFT_Y) | z) >>> 0; }
// Funktion zum Parsen eines Voxel-Keys zurück in Koordinaten
function parseKey(k) { return [(k >>> SHIFT_X) & VOX_MASK, (k >>> SHIFT_Y) & VOX_MASK, k & VOX_MASK]; }

// Konstanten für Maus-/Touch-Interaktion
const VOXEL_DRAG_THRESHOLD = 1;
const PINCH_ZOOM_MULT = 40;
const TAP_DIST_TH = 10;
const MOVE_PX = 10;
const DT_MS = 250;

// Geschwindigkeiten für Touch-Steuerung auf Mobilgeräten und Desktop
const ROTATE_SPEED_TOUCH_MOBILE = 0.008;
const PAN_SPEED_TOUCH_MOBILE = 0.2;
const PINCH_ZOOM_MULT_MOBILE = 80;

const ROTATE_SPEED_TOUCH_DESKTOP = 0.004;
const PAN_SPEED_TOUCH_DESKTOP = 0.1;
const PINCH_ZOOM_MULT_DESKTOP = 40;

// Globale Variablen für Touch-Interaktion
let activePointers = new Map(); // Speichert aktive Touch-Punkte
let gestureState = { type: 'none', startDist: 0, startMid: { x: 0, y: 0 }, lastMid: { x: 0, y: 0 }, lastDist: 0, startTime: 0, initialPointerCount: 0 };
let tapCandidate = null; // Kandidat für Tap-Geste
let doubleTapDragActive = false; // Status für Doppeltipp-Drag
let touchIndicator; // Visueller Indikator für Touch-Eingaben

// Three.js Szenen-Variablen
let scene, cam, ren, gridHelper, boxHelper; // Szene, Kamera, Renderer, Gitterhelfer, Boxhelfer
let rotSpeed = 0.004; // Rotationsgeschwindigkeit der Kamera
let euler; // Euler-Winkel für die Kamera-Rotation
const voxels = new Map(); // Map zur Speicherung aller vorhandenen Voxel
const chunks = new Map(); // Map zur Speicherung der Voxel-Chunks für Performance

let cvs, containerDiv; // Canvas-Element und sein Container-Div
let activeDrawingLevel = { x: 0, y: 0, z: 0 }; // Aktuelle Zeichenebene
let currentDrawingAxis = 'y'; // Aktuelle Zeichenachse

// Aktuelle Farbe und Bewegungsgeschwindigkeit (aus LocalStorage geladen)
let currentColor = localStorage.getItem('voxelEditorColor') || '#ffffff';
let moveSpeed = parseFloat(localStorage.getItem('voxelEditorFlySpeed') || '0.1');
let GRID = parseInt(localStorage.getItem('voxelEditorGridSize') || '10'); // Größe des Voxel-Gitters

// Initialisierung der aktiven Zeichenebene basierend auf LocalStorage oder Standardwerten
activeDrawingLevel.x = Number(localStorage.getItem('voxelEditorActiveDrawingLevelX') || '0');
if (!Number.isFinite(activeDrawingLevel.x)) activeDrawingLevel.x = 0;
activeDrawingLevel.x = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.x)));

activeDrawingLevel.y = Number(localStorage.getItem('voxelEditorActiveDrawingLevelY') || '0');
if (!Number.isFinite(activeDrawingLevel.y)) activeDrawingLevel.y = 0;
activeDrawingLevel.y = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.y)));

activeDrawingLevel.z = Number(localStorage.getItem('voxelEditorActiveDrawingLevelZ') || '0');
if (!Number.isFinite(activeDrawingLevel.z)) activeDrawingLevel.z = 0;
activeDrawingLevel.z = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.z)));

currentDrawingAxis = localStorage.getItem('voxelEditorCurrentDrawingAxis') || 'y';

// Voreingestellte Farben (aus LocalStorage geladen)
const presetColors = [
    localStorage.getItem('voxelPresetColor1') || '#E4002B',
    localStorage.getItem('voxelPresetColor2') || '#00A040',
    localStorage.getItem('voxelPresetColor3') || '#0057B8'
];
let activePresetIndex = -1; // Index der aktiven voreingestellten Farbe
let presetBoxes = []; // HTML-Elemente für die voreingestellten Farben

let mainDirectionalLight, fillDirectionalLight, hemisphereLight; // Beleuchtung der Szene
let isShiftDragging = false; // Status für Shift-Drag (falls benötigt)
let isControlDragging = false; // Status für Control-Drag (falls benötigt)
let isPointerLocked = false; // Status für Pointer-Lock (Maussteuerung)
let lastActionVoxelCoords = null; // Letzte Voxelkoordinaten bei Aktionen
let initialClickPos = null; // Startposition des Klicks
let initialRayHitCoords = null; // Rohe Voxelkoordinaten des ersten Raycast-Treffers beim Klick/Touch
let isDragging = false; // Status für Dragging
let firstMoveAfterLock = true; // Erster Maus-Move nach Pointer-Lock
let mouseMovementX = 0; // Mausbewegung in X-Richtung (für Pointer-Lock)
let mouseMovementY = 0; // Mausbewegung in Y-Richtung (für Pointer-Lock)

const dummy = new THREE.Object3D(); // Dummy-Objekt für InstancedMesh-Transformationen
const previewVoxelGeometry = new THREE.BoxGeometry(VS, VS, VS); // Geometrie für den Vorschau-Voxel
const previewVoxelMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5, depthTest: false }); // Material für den Vorschau-Voxel
previewVoxelMaterial.polygonOffset = true;
previewVoxelMaterial.polygonOffsetFactor = -1; // Versatz für korrekte Darstellung
let previewVoxelMesh = new THREE.Mesh(previewVoxelGeometry, previewVoxelMaterial); // Vorschau-Voxel-Mesh

// Definitions of Modes (ADD, DELETE, DRAW)
const Modes = {
    ADD: 'Hinzufügen',
    DELETE: 'Löschen',
    DRAW: 'Zeichnen',
};

// Icons corresponding to each Mode
const ModeIcons = {
    ADD: 'fas fa-plus',
    DELETE: 'fas fa-eraser',
    DRAW: 'fas fa-paint-brush'
};

// Icons corresponding to each Axis
const AxisIcons = {
    x: 'fas fa-arrows-alt-h',
    y: 'fas fa-arrows-alt-v',
    z: 'fas fa-arrows-alt'
};

let currentMode = Modes.ADD; // Aktueller Bearbeitungsmodus

let history = []; // Historie der Aktionen für Undo/Redo
let historyPointer = -1; // Aktueller Zeiger in der Historie
const MAX_HISTORY_SIZE = 100; // Maximale Größe der Historie

let currentStrokeVoxels = new Map(); // Voxel im aktuellen Zeichenstrich
let voxelsAtDragStart = null; // Voxel-Zustand zu Beginn eines Drags

let previewLineInstancedMesh; // Instanziiertes Mesh für Vorschau-Linien (z.B. beim Zeichnen)
const maxPreviewInstances = 180 * 3; // Maximale Instanzen für Vorschau-Linien
let previewLineVoxels = []; // Voxel in der Vorschau-Linie

let templateImageMesh = null; // Mesh für Bildvorlagen
let templateImageData = null; // Daten der Bildvorlage

let isMobile = window.matchMedia('(max-width: 768px)').matches; // Erkennung, ob es sich um ein Mobilgerät handelt

let initialDragVoxelWorldPos = null; // Weltposition des Voxels zu Beginn des Drags
let dragAxisLock = null; // Achsen-Sperre für Drag-Operationen
let initialDragVoxelCoords = null; // Voxelkoordinaten zu Beginn des Drags (der erste tatsächlich geänderte Voxel)
let initialDragYLevel = null; // Speichert die Y-Ebene zu Beginn eines Drag-Vorgangs im DRAW-Modus

// Projektmetadaten
let projectTitle = '';
let projectDescription = '';
let projectCategory = 'Allgemein';
let projectTags = [];
let projectRemixOf = '';
let projectSourceJsonUrl = '';
let projectVisibility = 'public';

// Vordefinierte Kategorien für Uploads
const predefinedCategories = ["Spielzeug", "Dekoration", "Funktional", "Kunst", "Allgemein", "Charaktere", "Fahrzeuge", "Natur", "Architektur", "Abstrakt"];

// THREE.js Voxel-Exporter Utility Funktionen (OBJ, MTL)
const VoxelShaperIO = {
    voxToOBJ: function(voxModel, voxelSize) {
        let obj = '# VoxelShaper OBJ Export\n';
        let mtls = '# VoxelShaper MTL Export\n';
        let vertexCount = 0;
        const materials = new Map();

        voxModel.voxels.forEach(v => {
            if (!materials.has(v.color)) {
                const matName = `material_${materials.size + 1}`;
                materials.set(v.color, matName);
                const c = new THREE.Color(v.color);
                mtls += `newmtl ${matName}\n`;
                mtls += `Kd ${c.r.toFixed(4)} ${c.g.toFixed(4)} ${c.b.toFixed(4)}\n`;
                mtls += `Ka ${c.r.toFixed(4)} ${c.g.toFixed(4)} ${c.b.toFixed(4)}\n`;
                mtls += `Ks 0.0 0.0 0.0\n`;
                mtls += `Ns 0.0\n`;
                mtls += `d 1.0\n`;
                mtls += `illum 1\n\n`;
            }
        });

        obj += `mtllib voxel_model.mtl\n`;

        obj += '# Vertex Normals\n';
        const normals = [
            new THREE.Vector3(0, 0, 1),
            new THREE.Vector3(0, 0, -1),
            new THREE.Vector3(1, 0, 0),
            new THREE.Vector3(-1, 0, 0),
            new THREE.Vector3(0, 1, 0),
            new THREE.Vector3(0, -1, 0)
        ];
        normals.forEach(n => {
            obj += `vn ${n.x.toFixed(4)} ${n.y.toFixed(4)} ${n.z.toFixed(4)}\n`;
        });
        obj += '\n';


        voxModel.voxels.forEach(v => {
            const x = v.x * voxelSize;
            const y = v.y * voxelSize;
            const z = v.z * voxelSize;

            const verts = [
                [x, y, z],
                [x + voxelSize, y, z],
                [x, y + voxelSize, z],
                [x + voxelSize, y + voxelSize, z],
                [x, y, z + voxelSize],
                [x + voxelSize, y, z + voxelSize],
                [x, y + voxelSize, z + voxelSize],
                [x + voxelSize, y + voxelSize, z + voxelSize]
            ];

            verts.forEach(vert => {
                obj += `v ${vert[0].toFixed(4)} ${vert[1].toFixed(4)} ${vert[2].toFixed(4)}\n`;
            });

            const matName = materials.get(v.color);
            obj += `usemtl ${matName}\n`;

            const baseIdx = vertexCount;

            obj += `f ${baseIdx + 5}//1 ${baseIdx + 6}//1 ${baseIdx + 8}//1 ${baseIdx + 7}//1\n`;
            obj += `f ${baseIdx + 1}//2 ${baseIdx + 3}//2 ${baseIdx + 4}//2 ${baseIdx + 2}//2\n`;
            obj += `f ${baseIdx + 2}//3 ${baseIdx + 6}//3 ${baseIdx + 8}//3 ${baseIdx + 4}//3\n`;
            obj += `f ${baseIdx + 1}//4 ${baseIdx + 3}//4 ${baseIdx + 7}//4 ${baseIdx + 5}//4\n`;
            obj += `f ${baseIdx + 3}//5 ${baseIdx + 4}//5 ${baseIdx + 8}//5 ${baseIdx + 7}//5\n`;
            obj += `f ${baseIdx + 1}//6 ${baseIdx + 5}//6 ${baseIdx + 6}//6 ${baseIdx + 2}//6\n`;

            vertexCount += 8;
        });

        return { obj: obj, mtl: mtls };
    },
    saveBlob: function(data, filename) {
        const objBlob = new Blob([data.obj], { type: 'text/plain' });
        const mtlBlob = new Blob([data.mtl], { type: 'text/plain' });

        const objUrl = URL.createObjectURL(objBlob);
        const mtlUrl = URL.createObjectURL(mtlBlob);

        const aObj = document.createElement('a');
        aObj.href = objUrl;
        aObj.download = filename;
        document.body.appendChild(aObj);
        aObj.click();
        document.body.removeChild(aObj);
        URL.revokeObjectURL(objUrl);

        const aMtl = document.createElement('a');
        aMtl.href = mtlUrl;
        aMtl.download = filename.replace('.obj', '.mtl');
        document.body.appendChild(aMtl);
        aMtl.click();
        document.body.removeChild(aMtl);
        URL.revokeObjectURL(mtlUrl);
    },
    VoxModel: function(width, height, depth, voxels) {
        this.width = width;
        this.height = height;
        this.depth = depth;
        this.voxels = voxels;
    }
};

// Hilfsfunktionen für Chunk-Koordinaten
function getChunkCoords(gx, gy, gz) { return { cx: Math.floor(gx / CHUNK_SIZE), cy: Math.floor(gy / CHUNK_SIZE), cz: Math.floor(gz / CHUNK_SIZE) }; }
function getChunkKey(cx, cy, cz) { return `${cx},${cy},${cz}`; }

// Klasse für Voxel-Chunks zur effizienten Verwaltung großer Modelle
class VoxelChunk {
    constructor(chunkX, chunkY, chunkZ, chunkSize, scene) {
        this.chunkX = chunkX; this.chunkY = chunkY; this.chunkZ = chunkZ; this.scene = scene; this.chunkSize = chunkSize;
        this.offsetX = chunkX * chunkSize * VS; this.offsetY = chunkY * chunkSize * VS; this.offsetZ = chunkZ * chunkSize * VS;
        this.voxels = new Map(); this.globalToLocalInstanceIdMap = new Map();
        const maxInstancesInChunk = chunkSize * chunkSize * chunkSize;
        const voxelBaseGeometry = new THREE.BoxGeometry(VS, VS, VS);
        const meshMaterial = new THREE.MeshLambertMaterial(); // Material für Voxel
        this.instancedMesh = new THREE.InstancedMesh(voxelBaseGeometry, meshMaterial, maxInstancesInChunk);
        this.instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(maxInstancesInChunk * 3), 3);
        this.instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        this.instancedMesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
        this.instancedMesh.castShadow = true; this.instancedMesh.receiveShadow = true; this.instancedMesh.count = 0;
        this.instancedMesh.position.set(this.offsetX, this.offsetY, this.offsetZ);
        this.scene.add(this.instancedMesh);
        this.boundingBox = new THREE.Box3(
            new THREE.Vector3(this.offsetX, this.offsetY, this.offsetZ),
            new THREE.Vector3(this.offsetX + chunkSize * VS, this.offsetY + chunkSize * VS, this.offsetZ + chunkSize * VS)
        );
    }
    getLocalKey(gx, gy, gz) { return key(gx % this.chunkSize, gy % this.chunkSize, gz % this.chunkSize); }
    addVoxel(gx, gy, gz, colorHex) {
        const lKey = this.getLocalKey(gx, gy, gz); const gKey = key(gx, gy, gz);
        if (this.voxels.has(lKey)) {
            const instanceId = this.voxels.get(lKey).instanceId;
            this.voxels.set(lKey, { color: colorHex, instanceId }); this.updateInstanceColor(instanceId, colorHex);
        } else {
            const instanceId = this.instancedMesh.count++;
            this.voxels.set(lKey, { color: colorHex, instanceId }); this.globalToLocalInstanceIdMap.set(gKey, instanceId);
            dummy.position.set((gx % this.chunkSize) * VS + HALF, (gy % this.chunkSize) * VS + HALF, (gz % this.chunkSize) * VS + HALF);
            dummy.updateMatrix(); this.instancedMesh.setMatrixAt(instanceId, dummy.matrix);
            this.updateInstanceColor(instanceId, colorHex);
            this.instancedMesh.instanceMatrix.needsUpdate = true; this.instancedMesh.instanceColor.needsUpdate = true;
        }
    }
    removeVoxel(gx, gy, gz) {
        const lKey = this.getLocalKey(gx, gy, gz); const gKey = key(gx, gy, gz);
        if (!this.voxels.has(lKey)) return;
        const { instanceId: removedId } = this.voxels.get(lKey);
        this.voxels.delete(lKey); this.globalToLocalInstanceIdMap.delete(gKey);
        const lastId = this.instancedMesh.count - 1;
        if (removedId !== lastId) {
            let lastVoxelLKey = null;
            for (const [lk, data] of this.voxels.entries()) { if (data.instanceId === lastId) { lastVoxelLKey = lk; break; } }
            if (lastVoxelLKey !== null) {
                const tempMatrix = new THREE.Matrix4(); this.instancedMesh.getMatrixAt(lastId, tempMatrix);
                this.instancedMesh.setMatrixAt(removedId, tempMatrix);
                this.updateInstanceColor(removedId, this.voxels.get(lastVoxelLKey).color);
                this.voxels.get(lastVoxelLKey).instanceId = removedId;
                const [lx, ly, lz] = parseKey(lastVoxelLKey);
                this.globalToLocalInstanceIdMap.set(key(this.chunkX * this.chunkSize + lx, this.chunkY * this.chunkSize + ly, this.chunkZ * this.chunkSize + lz), removedId);
            }
        }
        this.instancedMesh.count--;
        this.instancedMesh.instanceMatrix.needsUpdate = true; this.instancedMesh.instanceColor.needsUpdate = true;
    }
    recolorVoxel(gx, gy, gz, newColorHex) {
        const lKey = this.getLocalKey(gx, gy, gz);
        if (!this.voxels.has(lKey)) return;
        const { instanceId } = this.voxels.get(lKey);
        this.voxels.set(lKey, { color: newColorHex, instanceId: instanceId });
        this.updateInstanceColor(instanceId, newColorHex);
    }
    updateInstanceColor(instanceId, hex) {
        const c = new THREE.Color(hex); this.instancedMesh.instanceColor.setXYZ(instanceId, c.r, c.g, c.b);
        this.instancedMesh.instanceColor.needsUpdate = true;
    }
    dispose() {
        this.scene.remove(this.instancedMesh);
        this.instancedMesh.geometry.dispose(); this.instancedMesh.material.dispose();
        this.instancedMesh = null; this.voxels.clear(); this.globalToLocalInstanceIdMap.clear();
    }
}

// Handler für Größenänderungen des Fensters
function onResize() {
    cam.aspect = containerDiv.clientWidth / containerDiv.clientHeight; cam.updateProjectionMatrix();
    ren.setSize(containerDiv.clientWidth, containerDiv.clientHeight);
    ren.setPixelRatio(isMobile ? Math.min(1.5, window.devicePixelRatio) : window.devicePixelRatio);
}

// Funktion zur Handhabung von Touch-Gesten (Rotieren, Zoomen, Schwenken)
function handleGesture() {
    const pointers = [...activePointers.values()];
    if (pointers.length === 0) return;

    if (pointers.length === 1) {
        const p = pointers[0];
        const rotateSpeed = isMobile ? ROTATE_SPEED_TOUCH_MOBILE : ROTATE_SPEED_TOUCH_DESKTOP;
        
        euler.y += (p.x - gestureState.lastMid.x) * rotateSpeed;
        euler.x -= (p.y - gestureState.lastMid.y) * rotateSpeed;
        
        euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
        cam.quaternion.setFromEuler(euler);
        gestureState.lastMid = { x: p.x, y: p.y };
        return;
    }

    if (pointers.length >= 2) {
        const [p0, p1] = pointers;
        const midX = (p0.x + p1.x) * 0.5;
        const midY = (p0.y + p1.y) * 0.5;
        const dist = Math.hypot(p1.x - p0.x, p1.y - p0.y);

        if (gestureState.type === 'none') {
            const dMid = Math.hypot(midX - gestureState.startMid.x, midY - gestureState.startMid.y);
            const PINCH_REL_TH = 0.05;
            const relDelta = Math.abs(dist - gestureState.startDist) / gestureState.startDist;
            if (relDelta > PINCH_REL_TH) {
                gestureState.type = 'pinch';
            } else if (dMid > MOVE_PX) {
                gestureState.type = 'pan';
            }
            return;
        } else if (gestureState.type === 'pinch') {
            const pinchZoomMult = isMobile ? PINCH_ZOOM_MULT_MOBILE : PINCH_ZOOM_MULT_DESKTOP;
            const zoomDelta = (dist / gestureState.lastDist - 1) * pinchZoomMult * moveSpeed;
            cam.position.addScaledVector(cam.getWorldDirection(new THREE.Vector3()), zoomDelta);
            gestureState.lastDist = dist;
        } else if (gestureState.type === 'pan') {
            const panSpeed = isMobile ? PAN_SPEED_TOUCH_MOBILE : PAN_SPEED_TOUCH_DESKTOP;
            const dx = (midX - gestureState.lastMid.x) * panSpeed;
            const dy = (midY - gestureState.lastMid.y) * panSpeed;
            
            const right = new THREE.Vector3().crossVectors(cam.getWorldDirection(new THREE.Vector3()), cam.up).normalize();
            cam.position.addScaledVector(right, dx);
            cam.position.addScaledVector(new THREE.Vector3(0, 1, 0), dy);
            
            gestureState.lastMid = { x: midX, y: midY };
        }
    }
}

// Funktion zum Freigeben eines Pointers (Touch-Punkt)
function releasePointer(id, eventType) {
    activePointers.delete(id);
    if (activePointers.size < 2) {
        gestureState.type = 'none';
        if (activePointers.size === 1) { const last = [...activePointers.values()][0]; gestureState.lastMid = { x: last.x, y: last.y }; }
    }
    if (activePointers.size === 0) {
        doubleTapDragActive = false; lastActionVoxelCoords = null; touchIndicator.style.display = 'none';
        initialDragVoxelWorldPos = null; dragAxisLock = null; initialDragVoxelCoords = null;
        initialDragYLevel = null; // Reset Y-level lock
        previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
    }
}

// Funktion zum Neuaufbau von Gitter- und Box-Helfern (visuelle Hilfslinien)
function rebuildHelpers() {
    if (gridHelper) scene.remove(gridHelper); if (boxHelper) scene.remove(boxHelper);
    const size = GRID * VS;
    if (isMobile) {
        gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444 ); gridHelper.position.set(size / 2, activeDrawingLevel.y * VS, size / 2);
    } else {
        if (currentDrawingAxis === 'y') {
            gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444 ); gridHelper.position.set(size / 2, activeDrawingLevel.y * VS, size / 2);
        } else if (currentDrawingAxis === 'x') {
            gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444); gridHelper.rotation.z = Math.PI / 2; gridHelper.position.set(activeDrawingLevel.x * VS, size / 2, size / 2);
        } else if (currentDrawingAxis === 'z') {
            gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444); gridHelper.rotation.x = Math.PI / 2; gridHelper.position.set(size / 2, size / 2, activeDrawingLevel.z * VS);
        }
    }
    scene.add(gridHelper);
    const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(size, size, size));
    boxHelper = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x00ffff }));
    boxHelper.position.set(size / 2, size / 2, size / 2); scene.add(boxHelper);

    const mobileAxisIcon = document.getElementById('mobile-axis-icon');
    if (mobileAxisIcon) {
        mobileAxisIcon.className = AxisIcons[currentDrawingAxis];
    }
}

// Aktualisiert die Position des Gitterhelfers und speichert sie im LocalStorage
function updateGridHelperPosition() {
    rebuildHelpers();
    localStorage.setItem('voxelEditorActiveDrawingLevelX', activeDrawingLevel.x);
    localStorage.setItem('voxelEditorActiveDrawingLevelY', activeDrawingLevel.y);
    localStorage.setItem('voxelEditorActiveDrawingLevelZ', activeDrawingLevel.z);
    localStorage.setItem('voxelEditorCurrentDrawingAxis', currentDrawingAxis);
}

// Wechselt den Bearbeitungsmodus (Hinzufügen, Löschen, Zeichnen)
function cycleMode() {
    const activeElement = document.activeElement;
    if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'SELECT' || activeElement.tagName === 'TEXTAREA')) {
        cvs.focus(); return;
    }
    switch (currentMode) {
        case Modes.ADD: currentMode = Modes.DELETE; break;
        case Modes.DELETE: currentMode = Modes.DRAW; break;
        case Modes.DRAW: currentMode = Modes.ADD; break;
    }
    document.getElementById('current-mode').textContent = `Modus: ${currentMode}`;
    const mobileModeIcon = document.getElementById('mobile-mode-icon');
    if (mobileModeIcon) {
        mobileModeIcon.className = ModeIcons[currentMode];
    }
    lastActionVoxelCoords = null; updatePreviewVoxel(0, 0, 0, false);
    previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
}

// Setzt eine voreingestellte Farbe als aktuelle Farbe
function setActivePreset(index) {
    if (index >= 0 && index < presetColors.length) {
        currentColor = presetColors[index];
        document.getElementById('color-picker').value = currentColor;
        const mobileColorInput = document.getElementById('mobile-color-input');
        if (mobileColorInput) mobileColorInput.value = currentColor;
        localStorage.setItem('voxelEditorColor', currentColor);
        presetBoxes.forEach((box, i) => {
            if (i === index) { box.classList.add('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'); }
            else { box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'); }
        });
        activePresetIndex = index;
        if (previewVoxelMesh.visible) {
            previewVoxelMaterial.color.set(currentColor);
        }
    }
}

// Speichert eine Farbe als Voreinstellung
function savePresetColor(index, colorValue) {
    if (index >= 0 && index < presetColors.length) {
        presetColors[index] = colorValue;
        localStorage.setItem(`voxelPresetColor${index + 1}`, colorValue);
        if (activePresetIndex === index) {
            currentColor = colorValue;
            document.getElementById('color-picker').value = currentColor;
            const mobileColorInput = document.getElementById('mobile-color-input');
            if (mobileColorInput) mobileColorInput.value = currentColor;
            localStorage.setItem('voxelEditorColor', currentColor);
        }
    }
}

// Wendet einen Voxel-Zustand an (für Undo/Redo)
function applyVoxelState(state) {
    for (const chunk of chunks.values()) chunk.dispose();
    chunks.clear(); voxels.clear();
    state.forEach(v => _addSingleVoxel(v.gx, v.gy, v.gz, v.color));
}

// Fügt einen Befehl zur Historie hinzu
function addCommand(type, oldState = null, newState = null, commandData = null) {
    if (historyPointer < history.length - 1) history.splice(historyPointer + 1);
    history.push({ type, oldState, newState, commandData }); historyPointer++;
    if (history.length > MAX_HISTORY_SIZE) { history.shift(); historyPointer--; }
}

// Führt einen Befehl aus (für Undo/Redo)
function executeCommand(command, reverse = false) {
    const { type, oldState, newState, commandData } = command;
    switch (type) {
        case 'batch': applyVoxelState(reverse ? oldState : newState); break;
        case 'clearAll': clearAllInternal(true); if (reverse) applyVoxelState(oldState); break;
        case 'fillLevel': applyVoxelState(reverse ? oldState : newState); break;
        case 'resizeGrid':
            GRID = reverse ? commandData.oldGrid : commandData.newGrid;
            document.getElementById('grid-size-slider').value = GRID;
            document.getElementById('grid-size-display').textContent = `${GRID}×${GRID}×${GRID}`;
            localStorage.setItem('voxelEditorGridSize', GRID);
            applyVoxelState(reverse ? oldState : newState); break;
    }
    rebuildHelpers();
}

// Undo-Funktion
function undo() { if (historyPointer >= 0) { executeCommand(history[historyPointer], true); historyPointer--; } }
// Redo-Funktion
function redo() { if (historyPointer < history.length - 1) { historyPointer++; executeCommand(history[historyPointer], false); } }

// Fügt einen einzelnen Voxel hinzu
function _addSingleVoxel(gx, gy, gz, colorHex) {
    const gKey = key(gx, gy, gz); voxels.set(gKey, { color: colorHex });
    const { cx, cy, cz } = getChunkCoords(gx, gy, gz); const cKey = getChunkKey(cx, cy, cz);
    let chunk = chunks.get(cKey);
    if (!chunk) { chunk = new VoxelChunk(cx, cy, cz, CHUNK_SIZE, scene); chunks.set(cKey, chunk); }
    chunk.addVoxel(gx, gy, gz, colorHex);
}

// Entfernt einen einzelnen Voxel
function _removeSingleVoxel(gx, gy, gz) {
    const gKey = key(gx, gy, gz); if (!voxels.has(gKey)) return;
    voxels.delete(gKey);
    const { cx, cy, cz } = getChunkCoords(gx, gy, gz); const cKey = getChunkKey(cx, cy, cz);
    if (chunks.has(cKey)) {
        const chunk = chunks.get(cKey); chunk.removeVoxel(gx, gy, gz);
        if (chunk.instancedMesh.count === 0) { chunk.dispose(); chunks.delete(cKey); }
    }
}

// Färbt einen einzelnen Voxel neu
function _recolorSingleVoxel(gx, gy, gz, newColorHex) {
    const gKey = key(gx, gy, gz); if (!voxels.has(gKey)) return;
    voxels.set(gKey, { color: newColorHex });
    const { cx, cy, cz } = getChunkCoords(gx, gy, gz); const cKey = getChunkKey(cx, cy, cz);
    if (chunks.has(cKey)) chunks.get(cKey).recolorVoxel(gx, gy, gz, newColorHex);
}

// Führt eine Voxel-Modifikation durch (Hinzufügen, Löschen, Zeichnen)
function performVoxelModification(gx, gy, gz, mode, newColor) {
    const gKey = key(gx, gy, gz);
    const hasVoxel = voxels.has(gKey);

    gx = Math.max(0, Math.min(GRID - 1, gx));
    gy = Math.max(0, Math.min(GRID - 1, gy));
    gz = Math.max(0, Math.min(GRID - 1, gz));

    switch (mode) {
        case Modes.ADD:
            if (!hasVoxel) {
                _addSingleVoxel(gx, gy, gz, newColor);
            }
            break;
        case Modes.DELETE:
            if (hasVoxel) {
                _removeSingleVoxel(gx, gy, gz);
            }
            break;
        case Modes.DRAW:
            if (hasVoxel) {
                if (voxels.get(gKey).color !== newColor) {
                    _recolorSingleVoxel(gx, gy, gz, newColor);
                }
            }
            break;
    }
}

// Aktualisiert den Vorschau-Voxel
function updatePreviewVoxel(x, y, z, visible) {
    if (previewVoxelMesh) {
        if (visible) {
            if (previewVoxelMesh.geometry.parameters.width !== VS ||
                previewVoxelMesh.geometry.parameters.height !== VS ||
                previewVoxelMesh.geometry.parameters.depth !== VS) {
                previewVoxelMesh.geometry.dispose();
                previewVoxelMesh.geometry = new THREE.BoxGeometry(VS, VS, VS);
            }
            previewVoxelMesh.position.set(x * VS + HALF, y * VS + HALF, z * VS + HALF);
            previewVoxelMesh.visible = true;
            previewVoxelMaterial.color.set(currentColor);
            previewVoxelMaterial.opacity = (currentMode === Modes.DELETE) ? 0.2 : 0.5;
        } else {
            previewVoxelMesh.visible = false;
        }
    }
}

// Globale Variablen für Vorlagen
let templateInstancedMesh = null;
const templateVoxelGeometry = new THREE.BoxGeometry(VS, VS, VS); // Geometrie für Vorlagen-Voxel
// Material für Vorlagen-Voxel (halbtransparent, kein Depth-Test, um immer sichtbar zu sein)
const templateVoxelMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.2, depthTest: false });
templateVoxelMaterial.polygonOffset = true;
templateVoxelMaterial.polygonOffsetFactor = -2; // Render behind real voxels, but in front of grid

let templateVoxelMap = new Map(); // Map zur schnellen Überprüfung, ob ein Voxel Teil der geladenen Vorlage ist

// Vordefinierte Vorlagen für die App im Projekt-JSON-Format
const predefinedTemplates = [
    {
        name: "Kleines Haus",
        description: "Ein einfaches Haus zum Nachbauen.",
        voxels: {
            "4,0,4": "#8B4513", "5,0,4": "#8B4513", "6,0,4": "#8B4513",
            "4,0,5": "#8B4513", "5,0,5": "#8B4513", "6,0,5": "#8B4513",
            "4,0,6": "#8B4513", "5,0,6": "#8B4513", "6,0,6": "#8B4513",

            "4,1,4": "#8B4513", "5,1,4": "#8B4513", "6,1,4": "#8B4513",
            "4,1,5": "#8B4513", "5,1,5": "#8B4513", "6,1,5": "#8B4513",
            "4,1,6": "#8B4513", "5,1,6": "#8B4513", "6,1,6": "#8B4513",

            "4,2,4": "#8B4513", "5,2,4": "#8B4513", "6,2,4": "#8B4513",
            "4,2,5": "#8B4513", "5,2,5": "#8B4513", "6,2,5": "#8B4513",
            "4,2,6": "#8B4513", "5,2,6": "#8B4513", "6,2,6": "#8B4513",

            "5,3,5": "#A52A2A",
            "4,3,4": "#A52A2A", "5,3,4": "#A52A2A", "6,3,4": "#A52A2A",
            "4,3,5": "#A52A2A", "6,3,5": "#A52A2A",
            "4,3,6": "#A52A2A", "5,3,6": "#A52A2A", "6,3,6": "#A52A2A",

            "5,0,3": "#7B3F00",
            "5,1,3": "#7B3F00"
        }
    },
    {
        name: "Einfacher Baum",
        description: "Ein Baum mit Stamm und Blättern.",
        voxels: {
            "5,0,5": "#5F4F30",
            "5,1,5": "#5F4F30",
            "5,2,5": "#5F4F30",
            
            "5,3,5": "#228B22",
            "4,3,5": "#228B22", "6,3,5": "#228B22",
            "5,3,4": "#228B22", "5,3,6": "#228B22",

            "5,4,5": "#228B22",
            "4,4,5": "#228B22", "6,4,5": "#228B22",
            "5,4,4": "#228B22", "5,4,6": "#228B22",

            "4,3,4": "#228B22", "6,3,6": "#228B22",
            "4,3,6": "#228B22", "6,3,4": "#228B22",

            "4,4,4": "#228B22", "6,4,6": "#228B22",
            "4,4,6": "#228B22", "6,4,4": "#228B22"
        }
    },
    {
        name: "Auto-Umriss",
        description: "Ein einfacher Auto-Umriss zum Ausfüllen.",
        voxels: {
            "3,0,5": "#C0C0C0", "4,0,5": "#C0C0C0", "5,0,5": "#C0C0C0", "6,0,5": "#C0C0C0",
            "3,0,6": "#C0C0C0", "4,0,6": "#C0C0C0", "5,0,6": "#C0C0C0", "6,0,6": "#C0C0C0",

            "3,1,5": "#C0C0C0", "6,1,5": "#C0C0C0",
            "3,1,6": "#C0C0C0", "6,1,6": "#C0C0C0",

            "3,2,5": "#C0C0C0", "6,2,5": "#C0C0C0",
            "3,2,6": "#C0C0C0", "6,2,6": "#C0C0C0",

            "4,2,5": "#A9A9A9", "5,2,5": "#A9A9A9",
            "4,2,6": "#A9A9A9", "5,2,6": "#A9A9A9",

            "4,3,5": "#A9A9A9", "5,3,5": "#A9A9A9",
            "4,3,6": "#A9A9A9", "5,3,6": "#A9A9A9"
        }
    }
];

/**
 * Berechnet die rohen Voxelkoordinaten, die von einem Raycast getroffen wurden.
 * @param {number} clientX - X-Koordinate des Maus-/Touch-Ereignisses relativ zum Viewport.
 * @param {number} clientY - Y-Koordinate des Maus-/Touch-Ereignisses relativ zum Viewport.
 * @param {Map<number, boolean>} [excludeVoxelsMap] - Optional: Eine Map von Voxel-Keys, die ignoriert werden sollen (z.B. Voxel im aktuellen Zeichenstrich).
 * @returns {object|null} Voxelkoordinaten (gx, gy, gz), Normalenvektor (faceNormal, falls Voxel getroffen),
 * ob ein existierender Voxel (hitExistingVoxel) oder eine Vorlage (hitTemplate) getroffen wurde.
 */
function calculateRayTargetVoxelCoords(clientX, clientY, excludeVoxelsMap = null) {
    if (isPointerLocked) return null; // Keine Interaktion, wenn der Pointer gesperrt ist

    const rect = cvs.getBoundingClientRect(); // Position und Größe des Canvas
    const mouse = new THREE.Vector2(
        ((clientX - rect.left) / rect.width) * 2 - 1,
        -((clientY - rect.top) / rect.height) * 2 + 1
    );

    const raycaster = new THREE.Raycaster(); // Raycaster für Kollisionserkennung
    raycaster.setFromCamera(mouse, cam); // Raycast von der Kamera durch die Mausposition

    // 1. Priorität: Treffen der Vorlage, wenn eine geladen ist
    if (templateInstancedMesh && templateInstancedMesh.count > 0) {
        const templateIntersects = raycaster.intersectObject(templateInstancedMesh);
        for (const hit of templateIntersects) { // Iterate to find a valid hit
            const instanceMatrix = new THREE.Matrix4();
            templateInstancedMesh.getMatrixAt(hit.instanceId, instanceMatrix);
            const instancePosition = new THREE.Vector3().setFromMatrixPosition(instanceMatrix);

            const hitVoxelX = Math.round((instancePosition.x - HALF) / VS);
            const hitVoxelY = Math.round((instancePosition.y - HALF) / VS);
            const hitVoxelZ = Math.round((instancePosition.z - HALF) / VS);

            const hitKey = key(hitVoxelX, hitVoxelY, hitVoxelZ);
            if (excludeVoxelsMap && excludeVoxelsMap.has(hitKey)) {
                continue; // Skip this template voxel if it's in the exclude list
            }

            return { gx: hitVoxelX, gy: hitVoxelY, gz: hitVoxelZ, faceNormal: null, hitExistingVoxel: false, hitTemplate: true };
        }
    }

    // 2. Priorität: Treffen von existierenden Voxeln
    const objectsToIntersect = Array.from(chunks.values()).map(chunk => chunk.instancedMesh);
    // Prevents the image template from being hit by the raycaster
    if (templateImageMesh) {
        templateImageMesh.raycast = function() {}; 
    }

    const intersects = raycaster.intersectObjects(objectsToIntersect);

    for (const hit of intersects) { // Iterate to find a valid hit
        const hitNormal = hit.face.normal.clone();
        const intersectionPoint = hit.point;

        if (!Number.isFinite(intersectionPoint.x) || !Number.isFinite(intersectionPoint.y) || !Number.isFinite(intersectionPoint.z)) {
            continue; // Skip invalid intersection points
        }

        const epsilon = 0.001; // Kleiner Versatz, um die korrekte Seite des Voxels zu treffen
        const adjustedPoint = intersectionPoint.clone().addScaledVector(hitNormal, -epsilon);

        const hitVoxelX = Math.floor(adjustedPoint.x / VS);
        const hitVoxelY = Math.floor(adjustedPoint.y / VS);
        const hitVoxelZ = Math.floor(adjustedPoint.z / VS);
        
        const hitKey = key(hitVoxelX, hitVoxelY, hitVoxelZ);
        if (excludeVoxelsMap && excludeVoxelsMap.has(hitKey)) {
            continue; // Skip this voxel if it's in the exclude list
        }

        const result = { gx: Number(hitVoxelX), gy: Number(hitVoxelY), gz: Number(hitVoxelZ), faceNormal: hitNormal, hitExistingVoxel: true, hitTemplate: false };
        if (!Number.isFinite(result.gx) || !Number.isFinite(result.gy) || !Number.isFinite(result.gz)) {
            continue; // Skip if coordinates are not finite
        }
        return result;
    }

    // 3. Priorität: Treffen der Zeichenebene, wenn keine Voxel getroffen wurden
    let planeNormal = new THREE.Vector3();
    let planeConstant = 0;

    if (currentDrawingAxis === 'y') {
        planeNormal.set(0, 1, 0);
        planeConstant = -(activeDrawingLevel.y * VS);
    } else if (currentDrawingAxis === 'x') {
        planeNormal.set(1, 0, 0);
        planeConstant = -(activeDrawingLevel.x * VS);
    } else if (currentDrawingAxis === 'z') {
        planeNormal.set(0, 0, 1);
        planeConstant = -(activeDrawingLevel.z * VS);
    }

    const drawingPlane = new THREE.Plane(planeNormal, planeConstant);
    const intersectionPoint = new THREE.Vector3();

    if (raycaster.ray.intersectPlane(drawingPlane, intersectionPoint)) {
        if (!Number.isFinite(intersectionPoint.x) || !Number.isFinite(intersectionPoint.y) || !Number.isFinite(intersectionPoint.z)) {
            return null;
        }

        let gx = Math.floor(intersectionPoint.x / VS);
        let gy = Math.floor(intersectionPoint.y / VS);
        let gz = Math.floor(intersectionPoint.z / VS);

        if (currentDrawingAxis === 'y') gy = activeDrawingLevel.y;
        else if (currentDrawingAxis === 'x') gx = activeDrawingLevel.x;
        else if (currentDrawingAxis === 'z') gz = activeDrawingLevel.z;

        gx = Number(gx);
        gy = Number(gy);
        gz = Number(gz);

        if (!Number.isFinite(gx) || !Number.isFinite(gy) || !Number.isFinite(gz)) {
            return null;
        }

        const result = { gx, gy, gz, faceNormal: null, hitExistingVoxel: false, hitTemplate: false };
        return result;
    }
    return null;
}

// Interne Funktion zum vollständigen Löschen aller Voxel (mit optionaler Historien-Speicherung)
function clearAllInternal(fromHistory = false) {
    if (!fromHistory) {
        // Speichert den aktuellen Zustand für Undo
        const oldState = [...voxels.entries()].map(([id, data]) => { const p = parseKey(id); return { gx: p[0], gy: p[1], gz: p[2], color: data.color }; });
        addCommand('clearAll', oldState, []);
    }
    // Entsorgt alle Chunks und löscht Maps
    for (const chunk of chunks.values()) chunk.dispose();
    chunks.clear(); voxels.clear(); rebuildHelpers(); // Setzt Helfer und Gitter zurück
}
// Öffentliche Funktion zum Löschen aller Voxel
function clearAll() { clearAllInternal(false); }

// Füllt die aktive Zeichenebene mit Voxeln
function fillActiveLevel() {
    // Speichert den alten Zustand für Undo
    const oldState = [...voxels.entries()].map(([id, data]) => { const p = parseKey(id); return { gx: p[0], gy: p[1], gz: p[2], color: data.color }; });
    const voxelsToRemove = [];
    // Sammelt Voxel, die gelöscht werden müssen, wenn die Ebene gefüllt wird
    for (let x = 0; x < GRID; x++) { for (let z = 0; z < GRID; z++) {
        let gx, gy, gz;
        if (currentDrawingAxis === 'y') { gx = x; gy = activeDrawingLevel.y; gz = z; }
        else if (currentDrawingAxis === 'x') { gx = activeDrawingLevel.x; gy = x; gz = z; }
        else if (currentDrawingAxis === 'z') { gx = x; gy = z; gz = activeDrawingLevel.z; }
        const k = key(gx, gy, gz); if (voxels.has(k)) voxelsToRemove.push(k);
    }}
    // Entfernt die gesammelten Voxel
    voxelsToRemove.forEach(k => { const [gx, gy, gz] = parseKey(k); _removeSingleVoxel(gx, gy, gz); });
    const newState = [];
    // Fügt neue Voxel hinzu, um die Ebene zu füllen
    for (let x = 0; x < GRID; x++) { for (let z = 0; z < GRID; z++) {
        let gx, gy, gz;
        if (currentDrawingAxis === 'y') { gx = x; gy = activeDrawingLevel.y; gz = z; }
        else if (currentDrawingAxis === 'x') { gx = activeDrawingLevel.x; gy = x; gz = z; }
        else if (currentDrawingAxis === 'z') { gx = x; gy = z; gz = activeDrawingLevel.z; }
        _addSingleVoxel(gx, gy, gz, currentColor); newState.push({ gx, gy, gz, color: currentColor, dimX: 1, dimY: 1, dimZ: 1 });
    }}
    addCommand('fillLevel', oldState, newState); // Fügt den Befehl zur Historie hinzu
}

// Speichert das aktuelle Projekt als JSON-Datei
function saveJSON() {
    const data = {};
    voxels.forEach((value, k) => {
        const [gx, gy, gz] = parseKey(k);
        data[`${gx},${gy},${gz}`] = value.color;
    });

    const settings = {
        gridSize: GRID,
        cameraPosition: cam.position.toArray(),
        cameraQuaternion: cam.quaternion.toArray(),
        activeDrawingLevel: activeDrawingLevel,
        currentDrawingAxis: currentDrawingAxis,
        currentColor: currentColor,
        presetColors: presetColors,
        activePresetIndex: activePresetIndex,
        moveSpeed: moveSpeed,
        templateImageData: templateImageData
    };

    const fileContent = {
        title: projectTitle,
        description: projectDescription,
        category: projectCategory,
        tags: projectTags,
        remixOf: projectRemixOf,
        sourceJsonUrl: projectSourceJsonUrl,
        visibility: projectVisibility,
        fileName: `${projectTitle.replace(/\s+/g, "_") || "voxel_project"}.json`,
        timestamp: new Date().toISOString(),

        projectData: {
            settings: settings,
            voxels: data
        }
    };

    const blob = new Blob([JSON.stringify(fileContent, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = fileContent.fileName;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    showToast('Speichern erfolgreich', 'Projekt als JSON-Datei gespeichert.', 'success', 5000);
}

// Setzt das Projekt auf den Standardzustand zurück
function resetToDefaultProject() {
    clearAllInternal(true); GRID = 10;
    document.getElementById('grid-size-slider').value = GRID; document.getElementById('grid-size-display').textContent = `${GRID}×${GRID}×${GRID}`; localStorage.setItem('voxelEditorGridSize', GRID);
    currentColor = '#ffffff'; document.getElementById('color-picker').value = currentColor; localStorage.setItem('voxelEditorColor', currentColor);
    const mobileColorInput = document.getElementById('mobile-color-input');
    if (mobileColorInput) mobileColorInput.value = currentColor;

    activeDrawingLevel = { x: 0, y: 0, z: 0 }; currentDrawingAxis = 'y';
    localStorage.setItem('voxelEditorActiveDrawingLevelX', activeDrawingLevel.x);
    localStorage.setItem('voxelEditorActiveDrawingLevelY', activeDrawingLevel.y);
    localStorage.setItem('voxelEditorActiveDrawingLevelZ', activeDrawingLevel.z);
    localStorage.setItem('voxelEditorCurrentDrawingAxis', currentDrawingAxis);
    moveSpeed = 0.1; document.getElementById('fly-speed-slider').value = moveSpeed; document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2); localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
    presetColors[0] = '#E4002B'; presetColors[1] = '#00A040'; presetColors[2] = '#0057B8';
    localStorage.setItem('voxelPresetColor1', presetColors[0]); localStorage.setItem('voxelPresetColor2', presetColors[1]); localStorage.setItem('voxelPresetColor3', presetColors[2]);
    presetBoxes.forEach((box, i) => { box.value = presetColors[i]; box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'); });
    activePresetIndex = -1; removeImageTemplate(true); removeTemplate(); history.length = 0; historyPointer = -1;
    previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
    projectTitle = ''; projectDescription = ''; projectCategory = 'Allgemein'; projectTags = []; projectRemixOf = ''; projectSourceJsonUrl = ''; projectVisibility = 'public';
    rebuildHelpers(); resetCameraPosition(); showToast('Projekt zurückgesetzt', 'Das Projekt wurde auf den Standardzustand zurückgesetzt.', 'info', 5000);
}

// Lädt Projektdaten aus einem übergebenen Objekt
function loadProjectData(projectData) {
    try {
        const loadedVoxels = projectData.projectData ? projectData.projectData.voxels : projectData.voxels;
        const loadedSettings = projectData.projectData ? projectData.projectData.settings : projectData.settings;
        clearAllInternal(true); removeImageTemplate(true); removeTemplate(); // Löscht vorhandene Daten und Vorlagen

        // Setzt Projektmetadaten
        projectTitle = projectData.title || ''; projectDescription = projectData.description || '';
        projectCategory = projectData.category || 'Allgemein';
        projectTags = Array.isArray(projectData.tags) ? projectData.tags : (typeof projectData.tags === 'string' ? projectData.tags.split(',').map(tag => tag.trim()).filter(tag => tag !== '') : []);
        projectRemixOf = projectData.remixOf || ''; projectSourceJsonUrl = projectData.sourceJsonUrl || ''; projectVisibility = projectData.visibility || 'public';

        if (loadedSettings) {
            GRID = loadedSettings.gridSize !== undefined ? loadedSettings.gridSize : 10;
            document.getElementById('grid-size-slider').value = GRID; document.getElementById('grid-size-display').textContent = `${GRID}×${GRID}×${GRID}`; localStorage.setItem('voxelEditorGridSize', GRID);
        }
        // Lädt Voxel
        for (const k in loadedVoxels) {
            const colorValue = loadedVoxels[k]; const parts = k.split(',').map(Number);
            if (parts.length === 3 && !isNaN(parts[0]) && !isNaN(parts[1]) && !isNaN(parts[2])) {
                const gx = parts[0]; const gy = parts[1]; const gz = parts[2];
                if (gx >= 0 && gx < GRID && gy >= 0 && gy < GRID && gz >= 0 && gz < GRID) _addSingleVoxel(gx, gy, gz, colorValue);
            }
        }
        if (loadedSettings) {
            // Lädt Kamera-Position und -Rotation
            if (loadedSettings.cameraPosition) cam.position.fromArray(loadedSettings.cameraPosition);
            if (loadedSettings.cameraQuaternion) { cam.quaternion.fromArray(loadedSettings.cameraQuaternion); euler.setFromQuaternion(cam.quaternion, 'YXZ'); }
            if (loadedSettings.activeDrawingLevel) {
                activeDrawingLevel = {
                    x: Number(loadedSettings.activeDrawingLevel.x || 0),
                    y: Number(loadedSettings.activeDrawingLevel.y || 0),
                    z: Number(loadedSettings.activeDrawingLevel.z || 0)
                };
                if (!Number.isFinite(activeDrawingLevel.x)) activeDrawingLevel.x = 0;
                if (!Number.isFinite(activeDrawingLevel.y)) activeDrawingLevel.y = 0;
                if (!Number.isFinite(activeDrawingLevel.z)) activeDrawingLevel.z = 0;

                activeDrawingLevel.x = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.x)));
                activeDrawingLevel.y = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.y)));
                activeDrawingLevel.z = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.z)));

                localStorage.setItem('voxelEditorActiveDrawingLevelX', activeDrawingLevel.x);
                localStorage.setItem('voxelEditorActiveDrawingLevelY', activeDrawingLevel.y);
                localStorage.setItem('voxelEditorActiveDrawingLevelZ', activeDrawingLevel.z);
            }
            if (loadedSettings.currentDrawingAxis) { currentDrawingAxis = loadedSettings.currentDrawingAxis; localStorage.setItem('voxelEditorCurrentDrawingAxis', currentDrawingAxis); }
            updateGridHelperPosition();
            currentColor = loadedSettings.currentColor || '#ffffff'; document.getElementById('color-picker').value = currentColor;
            const mobileColorInput = document.getElementById('mobile-color-input');
            if (mobileColorInput) mobileColorInput.value = currentColor;

            if (loadedSettings.presetColors) {
                for(let i = 0; i < loadedSettings.presetColors.length && i < presetColors.length; i++) {
                    presetColors[i] = loadedSettings.presetColors[i]; document.getElementById(`color-preset-${i + 1}`).value = presetColors[i]; localStorage.setItem(`voxelPresetColor${i + 1}`, presetColors[i]);
                }
            }
            setActivePreset(loadedSettings.activePresetIndex !== undefined ? loadedSettings.activePresetIndex : -1);
            if (loadedSettings.moveSpeed !== undefined) {
                moveSpeed = loadedSettings.moveSpeed; document.getElementById('fly-speed-slider').value = moveSpeed; document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2); localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
            }
            if (loadedSettings.templateImageData) {
                templateImageData = loadedSettings.templateImageData;
                new THREE.TextureLoader().load(templateImageData.src, (texture) => {
                    const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true, depthWrite: false });
                    const geometry = new THREE.PlaneGeometry(templateImageData.scaledWidth, templateImageData.scaledHeight);
                    if (templateImageMesh) { scene.remove(templateImageMesh); templateImageMesh.geometry.dispose(); templateImageMesh.material.dispose(); }
                    templateImageMesh = new THREE.Mesh(geometry, material);
                    templateImageMesh.position.fromArray(templateImageData.position); templateImageMesh.rotation.fromArray(templateImageData.rotation); templateImageMesh.scale.fromArray(templateImageData.scale);
                    templateImageMesh.renderOrder = -1; scene.add(templateImageMesh);
                    document.getElementById('removeImageTemplateBtn').classList.remove('hidden');
                }, undefined, (err) => { templateImageMesh = null; templateImageData = null; document.getElementById('removeImageTemplateBtn').classList.add('hidden'); });
            }
        }
        history.length = 0; historyPointer = -1;
        previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
        resetCameraPosition();
    } catch (error) {
        showToast('Fehler', 'Fehler beim Laden der Datei. Stellen Sie sicher, dass es sich um eine gültige JSON-Datei handelt. Fehler: ' + error.message, 'error', 5000);
        resetToDefaultProject();
    }
}

// Lädt ein Projekt aus dem VoxelShaper Hub über eine Model-ID
async function loadProjectFromModelId(modelId) {
    showToast('Lade Projekt', `Lade Projekt mit ID: ${modelId}...`, 'info', 5000);
    try {
        const docSnap = await window.firebase.getDoc(window.firebase.doc(db, "models", modelId));
        if (docSnap.exists()) {
            const pData = docSnap.data();
            const isPublic = pData.visibility === 'public';
            const isOwner = auth.currentUser && auth.currentUser.uid === pData.uploaderUid;
            if (isPublic || isOwner) {
                if (pData && pData.projectData) {
                    projectRemixOf = modelId; projectSourceJsonUrl = window.location.href;
                    loadProjectData(pData);
                    showToast('Projekt geladen', `Projekt "${docSnap.data().title}" erfolgreich geladen.`, 'success', 5000);
                } else { showToast('Fehler', 'Projektdaten im Dokument nicht gefunden.', 'error', 5000); resetToDefaultProject(); }
            } else { showToast('Zugriff verweigert', 'Sie haben keine Berechtigung, dieses private Projekt zu laden.', 'error', 5000); resetToDefaultProject(); }
        } else { showToast('Projekt nicht gefunden', `Kein Projekt mit ID "${modelId}" gefunden.`, 'warning', 5000); resetToDefaultProject(); }
    } catch (error) {
        if (error.code === 'permission-denied') showToast('Zugriff verweigert', `Berechtigungsfehler beim Laden des Projekts. Stellen Sie sicher, dass das Modell öffentlich ist oder Sie der Eigentümer sind.`, 'error', 5000);
        else showToast('Fehler', `Fehler beim Laden des Projekts: ${error.message}`, 'error', 5000);
        resetToDefaultProject();
    }
}

// Lädt ein Projekt aus einer lokalen JSON-Datei
function loadJSON(event) {
    const file = event.target.files[0]; if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const projectData = JSON.parse(e.target.result);
            projectRemixOf = ''; projectSourceJsonUrl = ''; loadProjectData(projectData);
        } catch (error) {
            showToast('Fehler', 'Fehler beim Parsen der Datei. Stellen Sie sicher, dass es sich um eine gültige JSON-Datei handelt. Fehler: ' + error.message, 'error', 5000);
            resetToDefaultProject();
        }
    };
    reader.readAsText(file);
}

// Exportiert das Modell als STL-Datei
async function exportSTL() {
    if (voxels.size === 0) { showToast('Export fehlgeschlagen', 'Keine Voxel zum Exportieren vorhanden!', 'warning', 5000); return; }
    showToast('Exportiere STL', 'Erzeuge STL-Modell...', 'info', 5000);
    const geometriesToMerge = []; const tempBoxGeometry = new THREE.BoxGeometry(VS, VS, VS);
    voxels.forEach((data, k) => {
        const [x, y, z] = parseKey(k);
        dummy.position.set(x * VS + HALF, y * VS + HALF, z * VS + HALF); dummy.updateMatrix();
        const instanceGeometry = tempBoxGeometry.clone(); instanceGeometry.applyMatrix4(dummy.matrix);
        const c = new THREE.Color(data.color);
        const vtxColorArr = []; for (let j = 0; j < instanceGeometry.attributes.position.count; j++) vtxColorArr.push(c.r, c.g, c.b);
        instanceGeometry.setAttribute('color', new THREE.Float32BufferAttribute(vtxColorArr, 3));
        geometriesToMerge.push(instanceGeometry);
    });
    const mergedGeometry = geometriesToMerge.length > 0 ? THREE.BufferGeometryUtils.mergeBufferGeometries(geometriesToMerge, true) : new THREE.BufferGeometry();
    const tempMesh = new THREE.Mesh(mergedGeometry);
    if (typeof THREE.STLExporter === 'undefined') { showToast('Export fehlgeschlagen', 'STLExporter-Bibliothek nicht geladen.', 'error', 5000); return; }
    const exporter = new THREE.STLExporter(); const result = exporter.parse(tempMesh);
    const blob = new Blob([result], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'voxel_model.stl';
    document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
    tempBoxGeometry.dispose(); if (mergedGeometry) mergedGeometry.dispose();
    showToast('Export erfolgreich', 'STL-Modell erfolgreich exportiert!', 'success', 5000);
}

// Exportiert das Modell als OBJ-Datei (mit MTL für Farben)
async function exportOBJ() {
    if (voxels.size === 0) { showToast('Export fehlgeschlagen', 'Keine Voxel zum Exportieren vorhanden!', 'warning', 5000); return; }
    showToast('Exportiere OBJ', 'Erzeuge OBJ-Modell...', 'info', 5000);
    const voxelsToExport = []; let maxX = 0, maxY = 0, maxZ = 0;
    voxels.forEach((data, k) => {
        const [x, y, z] = parseKey(k); voxelsToExport.push({ x, y, z, color: data.color });
        maxX = Math.max(maxX, x); maxY = Math.max(maxY, y); maxZ = Math.max(maxZ, z);
    });
    const voxModel = new VoxelShaperIO.VoxModel(maxX + 1, maxY + 1, maxZ + 1, voxelsToExport);
    VoxelShaperIO.saveBlob(VoxelShaperIO.voxToOBJ(voxModel, VS), 'voxel_model.obj');
    showToast('Export erfolgreich', 'OBJ-Modell erfolgreich mit Farben exportiert!', 'success', 5000);
}

// Exportiert das Modell als GLB-Datei
async function exportGLB() {
    if (voxels.size === 0) {
        showToast('Export fehlgeschlagen', 'Keine Voxel zum Exportieren vorhanden!', 'warning', 5000);
        return;
    }
    showToast('Exportiere GLB', 'Erzeuge GLB-Modell...', 'info', 5000);

    if (typeof THREE.GLTFExporter === 'undefined') {
        showToast('Export fehlgeschlagen', 'GLTFExporter-Bibliothek nicht geladen. Bitte versuchen Sie es erneut.', 'error', 5000);
        return;
    }

    const exporter = new THREE.GLTFExporter();
    const tempGroup = new THREE.Group();
    const tempGeometry = new THREE.BoxGeometry(VS, VS, VS);

    const materialCache = new Map();

    voxels.forEach((data, k) => {
        const [x, y, z] = parseKey(k);
        const colorHex = data.color;

        let material = materialCache.get(colorHex);
        if (!material) {
            material = new THREE.MeshStandardMaterial({ color: new THREE.Color(colorHex) });
            materialCache.set(colorHex, material);
        }

        const mesh = new THREE.Mesh(tempGeometry, material);
        mesh.position.set(x * VS + HALF, y * VS + HALF, z * VS + HALF);
        tempGroup.add(mesh);
    });

    exporter.parse(
        tempGroup,
        function (result) {
            const blob = new Blob([result], { type: 'model/gltf-binary' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'voxel_model.glb';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showToast('Export erfolgreich', 'GLB-Modell erfolgreich exportiert!', 'success', 5000);
        },
        function (error) {
            showToast('Export fehlgeschlagen', `Fehler beim Exportieren des GLB-Modells: ${error.message}`, 'error', 5000);
        },
        { binary: true }
    );

    tempGeometry.dispose();
    materialCache.forEach(mat => mat.dispose());
    while(tempGroup.children.length > 0){
        const object = tempGroup.children[0];
        tempGroup.remove(object);
    }
}

// Zeigt eine Toast-Benachrichtigung an
function showToast(title, message, type = 'info', duration = 5000) {
    const toast = document.createElement('div');
    toast.className = `alert shadow-lg ${type === 'info' ? 'alert-info' : type === 'success' ? 'alert-success' : type === 'error' ? 'alert-error' : type === 'warning' ? 'alert-warning' : ''}`;
    toast.innerHTML = `
        ${type === 'info' ? '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" class="stroke-current shrink-0 h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>' : ''}
        ${type === 'success' ? '<svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>' : ''}
        ${type === 'error' ? '<svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>' : ''}
        ${type === 'warning' ? '<svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>' : ''}
        <div><strong>${title}</strong><br><span>${message}</span></div><button class="close-btn btn btn-ghost btn-sm">&times;</button>`;
    toastContainer.appendChild(toast);
    void toast.offsetWidth; toast.classList.add('show');
    toast.querySelector('.close-btn').addEventListener('click', () => { toast.classList.remove('show'); toast.addEventListener('transitionend', () => toast.remove(), { once: true }); });
    setTimeout(() => { if (toast.parentNode) { toast.classList.remove('show'); toast.addEventListener('transitionend', () => toast.remove(), { once: true }); } }, duration);
}

// Setzt die Kamera auf die Standardposition zurück
function resetCameraPosition() {
    cam.position.set(GRID * 1.0, GRID * 1.2, GRID * 1.5); cam.lookAt(GRID / 2, GRID / 2, GRID / 2);
    if (euler) euler.setFromQuaternion(cam.quaternion, 'YXZ');
}

// Lädt eine Bildvorlage
function loadImageTemplate() {
    document.getElementById('imageFileInput').click();
}

// Handler für die Auswahl einer Bilddatei als Vorlage
function handleImageFileSelect(event) {
    const file = event.target.files[0];
    if (!file) {
        return;
    }
    const reader = new FileReader();
    reader.onload = (e) => {
        const base64Image = e.target.result;
        const img = new Image();
        img.onload = () => {
            const aspectRatio = img.width / img.height;
            const planeWidth = GRID * VS;
            const planeHeight = planeWidth / aspectRatio;

            if (templateImageMesh) {
                scene.remove(templateImageMesh);
                templateImageMesh.geometry.dispose();
                templateImageMesh.material.dispose();
            }

            const texture = new THREE.TextureLoader().load(base64Image);
            const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true, depthWrite: false });
            const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
            templateImageMesh = new THREE.Mesh(geometry, material);

            templateImageMesh.position.set((GRID * VS) / 2, (GRID * VS) / 2, -0.001);
            templateImageMesh.rotation.set(0, 0, 0);

            templateImageMesh.renderOrder = -1; scene.add(templateImageMesh);
            templateImageData = {
                src: base64Image,
                position: templateImageMesh.position.toArray(),
                rotation: templateImageMesh.rotation.toArray(),
                scale: [1, 1, 1],
                scaledWidth: planeWidth,
                scaledHeight: planeHeight
            };
            document.getElementById('removeImageTemplateBtn').classList.remove('hidden');
            showToast('Bildvorlage geladen', 'Bild als Vorlage erfolgreich geladen.', 'success', 5000);
        };
        img.onerror = (err) => {
            showToast('Fehler', 'Bild konnte nicht geladen werden. Ungültiges Bildformat?', 'error', 5000);
            templateImageMesh = null;
            templateImageData = null;
            document.getElementById('removeImageTemplateBtn').classList.add('hidden');
        };
        img.src = base64Image;
    };
    reader.onerror = (err) => {
        showToast('Fehler', 'Fehler beim Lesen der Bilddatei.', 'error', 5000);
    };
    reader.readAsDataURL(file);

    event.target.value = '';
}
// Entfernt die aktuelle Bildvorlage
function removeImageTemplate(fromLoad = false) {
    if (templateImageMesh) {
        scene.remove(templateImageMesh); templateImageMesh.geometry.dispose(); templateImageMesh.material.dispose();
        templateImageMesh = null; templateImageData = null; document.getElementById('removeImageTemplateBtn').classList.add('hidden');
        if (!fromLoad) showToast('Bildvorlage entfernt', 'Bildvorlage erfolgreich entfernt.', 'info', 5000);
    }
}

// Lädt eine vordefinierte Voxel-Vorlage in die Szene
function loadTemplate(templateData) {
    // Entfernt bestehendes Vorlagen-Mesh, falls vorhanden
    if (templateInstancedMesh) {
        scene.remove(templateInstancedMesh);
        templateInstancedMesh.geometry.dispose();
        templateInstancedMesh.material.dispose();
        templateInstancedMesh = null;
    }

    templateVoxelMap.clear(); // Löscht die Map der Vorlagen-Voxel

    if (!templateData || !templateData.voxels || Object.keys(templateData.voxels).length === 0) {
        showToast('Vorlage entfernt', 'Keine Vorlage geladen oder Vorlage entfernt.', 'info', 3000);
        document.getElementById('removeTemplateBtn').classList.add('hidden');
        return;
    }

    // Bestimmt die maximale Anzahl von Instanzen basierend auf der Vorlage
    const maxTemplateInstances = Object.keys(templateData.voxels).length;
    // Erstellt ein neues InstancedMesh für die Vorlage
    templateInstancedMesh = new THREE.InstancedMesh(templateVoxelGeometry, templateVoxelMaterial, maxTemplateInstances);
    templateInstancedMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(maxTemplateInstances * 3), 3);
    templateInstancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    templateInstancedMesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
    templateInstancedMesh.castShadow = false; // Vorlagen werfen keine Schatten
    templateInstancedMesh.receiveShadow = false;
    templateInstancedMesh.count = 0;
    templateInstancedMesh.renderOrder = -2; // Soll hinter echten Voxeln und dem Gitter gerendert werden

    // Befüllt das InstancedMesh mit den Voxeldaten der Vorlage
    for (const keyString in templateData.voxels) {
        const [x, y, z] = keyString.split(',').map(Number);
        const color = templateData.voxels[keyString];

        const gKey = key(x, y, z);
        templateVoxelMap.set(gKey, true); // Speichert den Key in der Map für schnelle Überprüfung

        const instanceId = templateInstancedMesh.count++;
        dummy.position.set(x * VS + HALF, y * VS + HALF, z * VS + HALF);
        dummy.updateMatrix();
        templateInstancedMesh.setMatrixAt(instanceId, dummy.matrix);

        const c = new THREE.Color(color);
        templateInstancedMesh.instanceColor.setXYZ(instanceId, c.r, c.g, c.b);
    }

    templateInstancedMesh.instanceMatrix.needsUpdate = true;
    templateInstancedMesh.instanceColor.needsUpdate = true;
    scene.add(templateInstancedMesh); // Fügt die Vorlage zur Szene hinzu
    document.getElementById('removeTemplateBtn').classList.remove('hidden'); // Zeigt den "Vorlage entfernen" Button
    showToast('Vorlage geladen', `Vorlage "${templateData.name}" geladen. Füllen Sie die transparenten Voxel aus!`, 'success', 5000);
}

// Entfernt die aktuell geladene Vorlage
function removeTemplate() {
    if (templateInstancedMesh) {
        scene.remove(templateInstancedMesh);
        templateInstancedMesh.geometry.dispose();
        templateInstancedMesh.material.dispose();
        templateInstancedMesh = null;
        templateVoxelMap.clear(); // Löscht die Map der Vorlagen-Voxel
        document.getElementById('removeTemplateBtn').classList.add('hidden');
        showToast('Vorlage entfernt', 'Transparente Vorlage wurde entfernt.', 'info', 3000);
    }
}

function getCurrentBlockDimensions() {
    return { dimX: 1, dimY: 1, dimZ: 1 };
}

// Funktion für Login/Logout
async function loginLogout() {
    if (auth.currentUser) { try { await window.firebase.signOut(auth); showToast('Abgemeldet', 'Sie wurden erfolgreich abgemeldet.', 'info', 5000); } catch (e) { showToast('Fehler beim Abmelden', `Fehler: ${e.message}`, 'error', 5000); } }
    else openAuthModal();
}

// Öffnet das Upload-Modal
function openUploadModal() {
    if (!currentUserId) { openAuthModal(); return; }
    if (voxels.size === 0) { showToast('Upload fehlgeschuldert', 'Die Szene ist leer. Bitte erstellen Sie zuerst ein Modell.', 'warning', 5000); return; }
    document.getElementById('uploadTitle').value = projectTitle; document.getElementById('uploadDescription').value = projectDescription;
    document.getElementById('uploadCategory').value = projectCategory; document.getElementById('uploadTags').value = projectTags.join(', ');
    document.querySelector(`input[name="uploadVisibility"][value="${projectVisibility}"]`).checked = true;
    const uploadCategorySelect = document.getElementById('uploadCategory');
    uploadCategorySelect.innerHTML = '<option value="" disabled selected>Kategorie auswählen</option>';
    predefinedCategories.forEach(cat => { const opt = document.createElement('option'); opt.value = cat; opt.textContent = cat; uploadCategorySelect.appendChild(opt); });
    uploadCategorySelect.value = projectCategory;
    document.getElementById('uploadProjectModal').showModal();
}

// Lädt das Projekt in den Hub hoch (Firestore)
async function uploadProjectToHub() {
    if (!currentUserId) { showToast('Fehler', 'Nicht angemeldet. Bitte melden Sie sich an, um hochzuladen.', 'error', 5000); return; }
    if (voxels.size === 0) { showToast('Upload fehlgeschuldert', 'Die Szene ist leer. Bitte erstellen Sie zuerst ein Modell.', 'warning', 5000); return; }
    const title = document.getElementById('uploadTitle').value.trim();
    const description = document.getElementById('uploadDescription').value.trim();
    const category = document.getElementById('uploadCategory').value;
    const tags = document.getElementById('uploadTags').value.split(',').map(tag => tag.trim()).filter(tag => tag !== '');
    const visibility = document.querySelector('input[name="uploadVisibility"]:checked').value;
    if (!title) { showToast('Fehler', 'Bitte geben Sie einen Titel für Ihr Projekt ein.', 'warning', 5000); return; }
    if (!category) { showToast('Fehler', 'Bitte wählen Sie eine Kategorie für Ihr Projekt aus.', 'warning', 5000); 'warning'; return; }
    showToast('Lade hoch...', 'Ihr Projekt wird hochgeladen. Bitte warten Sie...', 'info', 5000);
    try {
        const voxelMap = {}; voxels.forEach((v, k) => { const [gx, gy, gz] = parseKey(k); voxelMap[`${gx},${gy},${gz}`] = v.color; });
        const firestoreSafeSettings = {
            gridSize: GRID, cameraPosition: cam.position.toArray(), cameraQuaternion: cam.quaternion.toArray(),
            activeDrawingLevel: activeDrawingLevel, currentDrawingAxis: currentDrawingAxis, currentColor: currentColor,
            presetColors: presetColors, activePresetIndex: activePresetIndex, moveSpeed: moveSpeed,
            templateImageData: null
        };
        const firestoreDocument = {
            title: title, description: description, category: category, tags: tags, visibility: visibility,
            remixOf: projectRemixOf || "", sourceJsonUrl: projectSourceJsonUrl || "",
            fileName: `${title.replace(/\s+/g, "_")}.json`, downloads: 0, rating: 0, ratingCount: 0, verified: false,
            userId: currentUserId, uploaderEmail: currentUser?.email || "", uploaderUid: currentUser?.uid || "",
            uploaderPhotoURL: currentUser?.photoURL || "", timestamp: window.firebase.serverTimestamp(),
            projectData: {
                description: description, remixOf: projectRemixOf || "", sourceJsonUrl: projectSourceJsonUrl || "",
                settings: firestoreSafeSettings, activeDrawingLevel: firestoreSafeSettings.activeDrawingLevel, activePresetIndex: firestoreSafeSettings.activePresetIndex,
                cameraPosition: firestoreSafeSettings.cameraPosition, cameraQuaternion: firestoreSafeSettings.cameraQuaternion,
                currentColor: firestoreSafeSettings.currentColor, currentDrawingAxis: firestoreSafeSettings.currentDrawingAxis,
                gridSize: firestoreSafeSettings.gridSize, moveSpeed: firestoreSafeSettings.moveSpeed, presetColors: firestoreSafeSettings.presetColors, templateImageData: null, voxels: voxelMap
            }
        };
        const docRef = await window.firebase.addDoc(window.firebase.collection(db, "models"), firestoreDocument);
        projectTitle = title; projectDescription = description; projectCategory = category; projectTags = tags; projectVisibility = visibility;
        if (!projectSourceJsonUrl) projectSourceJsonUrl = `https://hub.voxelshaper.com?modelId=${docRef.id}`;
        showToast('Erfolgreich hochgeladen', `Ihr Projekt wurde erfolgreich hochgeladen! ID: ${docRef.id}`, 'success', 5000);
    } catch (e) { showToast('Fehler beim Hochladen', `Fehler: ${e.message}`, 'error', 5000); }
    finally { document.getElementById('uploadProjectModal').close(); }
}

// Öffnet das Authentifizierungs-Modal
function openAuthModal() { document.getElementById('authModal').showModal(); document.getElementById('emailLoginForm').classList.add('hidden'); }
// Schließt das Authentifizierungs-Modal
function closeAuthModal() { document.getElementById('authModal').close(); cvs.focus(); }

// Funktionen für Firebase-Authentifizierung (Google, GitHub, E-Mail/Passwort)
window.signInWithGoogle = async function() { try { await window.firebase.signInWithPopup(auth, new window.firebase.GoogleAuthProvider()); showToast('Anmeldung erfolgreich', 'Mit Google angemeldet.', 'success', 5000); closeAuthModal(); } catch (e) { showToast('Anmeldefehler', `Google: ${e.message}`, 'error', 5000); } }
window.signInWithGithub = async function() { try { await window.firebase.signInWithPopup(auth, new window.firebase.GithubAuthProvider()); showToast('Anmeldung erfolgreich', 'Mit GitHub angemeldet.', 'success', 5000); closeAuthModal(); } catch (e) { showToast('Anmelmelfehler', `GitHub: ${e.message}`, 'error', 5000); } }
window.signInEmailPassword = async function() { const email = document.getElementById('emailInput').value; const password = document.getElementById('passwordInput').value; try { await window.firebase.signInWithEmailAndPassword(auth, email, password); showToast('Anmeldung erfolgreich', 'Mit E-Mail angemeldet.', 'success', 5000); closeAuthModal(); } catch (e) { showToast('Anmeldefehler', `E-Mail: ${e.message}`, 'error', 5000); } }
window.signUpEmailPassword = async function() { const email = document.getElementById('emailInput').value; const password = document.getElementById('passwordInput').value; try { await window.firebase.createUserWithEmailAndPassword(auth, email, password); showToast('Registrierung erfolgreich', 'Konto erstellt und angemeldet.', 'success', 5000); closeAuthModal(); } catch (e) { showToast('Registrierungsfehler', `E-Mail: ${e.message}`, 'error', 5000); } }

// Schließt alle Modals
function closeAllModals() {
    const modals = ['clearConfirmationModal', 'uploadProjectModal', 'authModal', 'ideaGeneratorModal', 'templateChooserModal'];
    modals.forEach(id => { const modal = document.getElementById(id); if (modal && modal.open) modal.close(); });
}
window.closeAllModals = closeAllModals;

// Handler für Pointer-Lock-Änderungen
function onPointerLockChange() {
    if (document.pointerLockElement === cvs) { isPointerLocked = true; firstMoveAfterLock = true; mouseMovementX = mouseMovementY = 0; updatePreviewVoxel(0,0,0,false); euler.setFromQuaternion(cam.quaternion, 'YXZ'); }
    else { isPointerLocked = false; }
}

// Handler für Mausrad-Ereignisse
function onMouseWheel(e) {
    e.preventDefault();
    if (e.altKey) { // Wenn ALT-Taste gedrückt ist, steuert das Mausrad die Zeichenebene
        if (!isMobile && (currentMode === Modes.ADD || currentMode === Modes.DRAW)) {
            if (e.shiftKey) { activeDrawingLevel.z = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.z - Math.sign(e.deltaY))); currentDrawingAxis = 'z'; }
            else if (e.ctrlKey) { activeDrawingLevel.x = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.x - Math.sign(e.deltaY))); currentDrawingAxis = 'x'; }
            else { activeDrawingLevel.y = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.y - Math.sign(e.deltaY))); currentDrawingAxis = 'y'; }
            updateGridHelperPosition();
        } else { // Ansonsten, wenn kein Zeichenmodus oder Mobilgerät, zoomt die Kamera
            cam.position.addScaledVector(cam.getWorldDirection(new THREE.Vector3()), e.deltaY * 0.005 * moveSpeed * 5);
        }
    } else { // Wenn ALT-Taste nicht gedrückt ist, steuert das Mausrad die Fluggeschwindigkeit
        moveSpeed = Math.max(0.01, Math.min(1.0, moveSpeed - Math.sign(e.deltaY) * 0.01));
        document.getElementById('fly-speed-slider').value = moveSpeed; document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2); localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
    }
}

const keyboard = {}; // Speichert den Zustand der Tastaturtasten
// Handler für Tastendruck (Key Down)
function onKeyDown(e) {
    // Wenn ein Modal geöffnet ist, nur Escape-Taste zur Schließung erlauben
    const activeModals = ['authModal', 'uploadProjectModal', 'clearConfirmationModal', 'ideaGeneratorModal', 'templateChooserModal'].some(id => document.getElementById(id).open);
    if (activeModals) { if (e.key === 'Escape') { closeAllModals(); e.preventDefault(); } return; }
    keyboard[e.key.toLowerCase()] = true; // Setzt die Taste auf gedrückt
    if (e.key === 'Shift') isShiftDragging = true;
    if (e.key === 'Control' || e.metaKey) isControlDragging = true;
    if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); } // Undo mit Ctrl/Cmd + Z
    if (((e.ctrlKey || e.metaKey) && e.key === 'y') || ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'Z')) { e.preventDefault(); redo(); } // Redo mit Ctrl/Cmd + Y oder Ctrl/Cmd + Shift + Z
    if ((e.ctrlKey || e.metaKey) && e.key === 'd') e.preventDefault(); // Verhindert das Duplizieren von Tabs/Fenstern mit Ctrl/Cmd + D
    if (e.key === 'Tab') { e.preventDefault(); cycleMode(); } // Wechselt den Modus mit Tab
    // Aktiviert voreingestellte Farben mit den Tasten 1, 2, 3
    switch (e.key) { case '1': setActivePreset(0); break; case '2': setActivePreset(1); break; case '3': setActivePreset(2); break; }
}

// Handler für Tastenfreigabe (Key Up)
function onKeyUp(e) {
    keyboard[e.key.toLowerCase()] = false; // Setzt die Taste auf nicht gedrückt
    if (e.key === 'Shift') isShiftDragging = false;
    if (e.key === 'Control' || e.metaKey) isControlDragging = false;
}

// Handler, wenn der Pointer das Canvas verlässt
function onPointerLeave(e) {
    // Wenn ein Dragging aktiv ist und Voxel im aktuellen Strich sind, füge einen Batch-Befehl zur Historie hinzu
    if (pointerIsDown && isDragging && currentStrokeVoxels.size > 0) {
        const oldState = [];
        const newState = [];
        for (const [gKey, change] of currentStrokeVoxels.entries()) {
            const [gx, gy, gz] = parseKey(gKey);
            oldState.push({ gx, gy, gz, color: change.originalColor });
            newState.push({ gx, gy, gz, color: change.finalColor });
        }
        if (oldState.length > 0) {
            addCommand('batch', oldState, newState);
        }
    }
    // Setzt alle Dragging- und Pointer-bezogenen Zustände zurück
    pointerIsDown = false;
    isDragging = false;
    doubleTapDragActive = false;
    lastActionVoxelCoords = null;
    initialClickPos = null;
    initialRayHitCoords = null;
    voxelsAtDragStart = null;
    currentStrokeVoxels.clear();
    updatePreviewVoxel(0, 0, 0, false); // Vorschau-Voxel ausblenden
    previewLineInstancedMesh.count = 0; // Vorschau-Linie ausblenden
    previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
    previewLineVoxels = [];
    dragAxisLock = null;
    initialDragVoxelCoords = null;
    initialDragYLevel = null; // Reset Y-level lock on leave
}

let pointerIsDown = false; // Ob ein Pointer gedrückt ist (Maus oder Touch)
let rightMouseButtonDown = false; // Ob die rechte Maustaste gedrückt ist
let lastX, lastY; // Letzte X/Y-Koordinaten des Pointers
let suppressNextTap = false; // Flag, um das nächste Tap-Ereignis zu unterdrücken (z.B. nach einem Drag)

// Berechnet alle Voxel, die auf einer Linie zwischen zwei Punkten liegen (Bresenham-ähnlich)
function getVoxelsOnLine(start, end) {
    if (!start || !Number.isFinite(start.gx) || !Number.isFinite(start.gy) || !Number.isFinite(start.gz) ||
        !end || !Number.isFinite(end.gx) || !Number.isFinite(end.gy) || !Number.isFinite(end.gz)) {
        return [];
    }
    const voxelsOnLine = [];
    let x1 = start.gx, y1 = start.gy, z1 = start.gz;
    let x2 = end.gx, y2 = end.gy, z2 = end.gz;
    let dx = Math.abs(x2 - x1), dy = Math.abs(y2 - y1), dz = Math.abs(z2 - z1);
    let sx = (x1 < x2) ? 1 : -1, sy = (y1 < y2) ? 1 : -1, sz = (z1 < z2) ? 1 : -1;
    let dm = Math.max(dx, dy, dz); // Längste Achse
    let x = x1, y = y1, z = z1;
    let p1 = 2 * dy - dm, p2 = 2 * dz - dm;

    for (let i = 0; i <= dm; i++) {
        // Stellt sicher, dass die Voxel innerhalb des Rasters bleiben
        const clampedX = Math.max(0, Math.min(GRID - 1, x));
        const clampedY = Math.max(0, Math.min(GRID - 1, y));
        const clampedZ = Math.max(0, Math.min(GRID - 1, z));
        voxelsOnLine.push({ gx: clampedX, gy: clampedY, gz: clampedZ });
        
        // Schritt-Logik für 3D-Bresenham
        if (dm === dx) { y += sy * (p1 > 0); p1 += 2 * dy; z += sz * (p2 > 0); p2 += 2 * dz; }
        else if (dm === dy) { x += sx * (p1 > 0); p1 += 2 * dx; z += sz * (p2 > 0); p2 += 2 * dz; }
        else { x += sx * (p1 > 0); p1 += 2 * dy; y += sy * (p2 > 0); p2 += 2 * dx; }
        if (dm === dx) x += sx; else if (dm === dy) y += sy; else z += sz;
    }
    return voxelsOnLine;
}

// Handler für Pointer Up (Maustaste oder Touch freigegeben)
function onPointerUp(e) {
    if (e.button === 2) { // Rechte Maustaste
        rightMouseButtonDown = false;
        document.exitPointerLock(); // Pointer-Lock beenden
        return;
    }
    
    // Berechnet die insgesamt zurückgelegte Distanz
    const totalMovedDist = initialClickPos ? Math.hypot(e.clientX - initialClickPos.x, e.clientY - initialClickPos.y) : 0;
    const wasDrag = (totalMovedDist > MOVE_PX) || isDragging; // War es ein Drag?

    if (wasDrag) {
        // Wenn es ein Drag war und Voxel im aktuellen Strich sind, füge einen Batch-Befehl zur Historie hinzu
        if (currentStrokeVoxels.size > 0) {
            const oldState = [];
            const newState = [];
            for (const [gKey, change] of currentStrokeVoxels.entries()) {
                const [gx, gy, gz] = parseKey(gKey);
                oldState.push({ gx, gy, gz, color: change.originalColor });
                newState.push({ gx, gy, gz, color: change.finalColor });
            }
            if (oldState.length > 0) {
                addCommand('batch', oldState, newState);
            }
        }
    } else { // Wenn es kein Drag war (also ein Klick/Tap)
        if (initialRayHitCoords) { // initialRayHitCoords kommt aus onPointerDown und enthält alle Trefferinfos
            let finalVoxelCoords = { ...initialRayHitCoords };

            // Spezifische Behandlung für ADD-Modus bei Klick (nicht Drag)
            if (currentMode === Modes.ADD) {
                if (initialRayHitCoords.hitTemplate) {
                    // Wenn eine Vorlage getroffen wurde, Aktion auf der Vorlage durchführen
                    // finalVoxelCoords bleiben wie initialRayHitCoords (die Voxel-Position der Vorlage)
                } else if (initialRayHitCoords.faceNormal) {
                    // Wenn ein existierender Voxel getroffen wurde (nicht Vorlage), Voxel an der Seite des getroffenen Voxels hinzufügen
                    finalVoxelCoords.gx += initialRayHitCoords.faceNormal.x;
                    finalVoxelCoords.gy += initialRayHitCoords.faceNormal.y;
                    finalVoxelCoords.gz += initialRayHitCoords.faceNormal.z;
                } else {
                    // Wenn nichts getroffen wurde (nur Zeichenebene), bleibt finalVoxelCoords der Ebenentreffer
                }
            }
            // Für DELETE/DRAW bleibt finalVoxelCoords immer die Position des getroffenen Voxels (initialRayHitCoords)


            // Stellt sicher, dass die Koordinaten innerhalb des Rasters liegen
            finalVoxelCoords.gx = Math.max(0, Math.min(GRID - 1, finalVoxelCoords.gx));
            finalVoxelCoords.gy = Math.max(0, Math.min(GRID - 1, finalVoxelCoords.gy));
            finalVoxelCoords.gz = Math.max(0, Math.min(GRID - 1, finalVoxelCoords.gz));

            const gKey = key(finalVoxelCoords.gx, finalVoxelCoords.gy, finalVoxelCoords.gz);
            // Speichert den ursprünglichen und den neuen Zustand des Voxels für Undo/Redo
            const initialColor = voxelsAtDragStart.has(gKey) ? voxelsAtDragStart.get(gKey).color : null;
            
            performVoxelModification(finalVoxelCoords.gx, finalVoxelCoords.gy, finalVoxelCoords.gz, currentMode, currentColor);
            
            const newColor = voxels.has(gKey) ? voxels.get(gKey).color : null;
            if (initialColor !== newColor || (currentMode === Modes.ADD && initialColor === null && newColor !== null)) {
                addCommand('batch', [{ gx: finalVoxelCoords.gx, gy: finalVoxelCoords.gy, gz: finalVoxelCoords.gz, color: initialColor }], [{ gx: finalVoxelCoords.gx, gy: finalVoxelCoords.gy, gz: finalVoxelCoords.gz, color: newColor }]);
            }
        }
    }

    // Setzt alle Dragging- und Pointer-bezogenen Zustände zurück
    pointerIsDown = false;
    isDragging = false;
    doubleTapDragActive = false;
    lastActionVoxelCoords = null;
    initialClickPos = null;
    initialRayHitCoords = null;
    voxelsAtDragStart = null;
    currentStrokeVoxels.clear();
    updatePreviewVoxel(0, 0, 0, false); // Vorschau-Voxel ausblenden
    previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
    dragAxisLock = null;
    initialDragVoxelCoords = null;
    initialDragYLevel = null; // Reset Y-level lock on up
    
    if (e.pointerType === 'touch') {
        releasePointer(e.pointerId, e); // Pointer für Touch-Ereignisse freigeben
    }
}

// Handler für Pointer Down (Maustaste oder Touch gedrückt)
function onPointerDown(e) {
    if (e.button === 2) { // Rechte Maustaste
        e.preventDefault();
        rightMouseButtonDown = true;
        cvs.focus();
        cvs.requestPointerLock(); // Pointer-Lock anfordern
        return;
    }
    if (isPointerLocked) return; // Keine Interaktion, wenn der Pointer gesperrt ist

    // Farbauswahl mit ALT-Taste
    if (e.button === 0 && e.altKey) { 
        const hitResult = calculateRayTargetVoxelCoords(e.clientX, e.clientY);
        if (hitResult && hitResult.hitExistingVoxel) { // Wenn ein existierender Voxel getroffen wird
            const gKey = key(hitResult.gx, hitResult.gy, hitResult.gz);
            if (voxels.has(gKey)) {
                const pickedColor = voxels.get(gKey).color; // Farbe des Voxels aufnehmen
                currentColor = pickedColor;
                document.getElementById('color-picker').value = pickedColor;
                const mobileColorInput = document.getElementById('mobile-color-input');
                if (mobileColorInput) mobileColorInput.value = pickedColor;
                localStorage.setItem('voxelEditorColor', pickedColor);
                presetBoxes.forEach(box => box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50')); activePresetIndex = -1;
                showToast('Farbe aufgenommen', `Farbe: ${pickedColor}`, 'info', 2000);
            }
        }
        return; 
    }

    voxelsAtDragStart = new Map(voxels); // Speichert den Voxel-Zustand zu Beginn des Drags
    currentStrokeVoxels.clear(); // Leert den aktuellen Zeichenstrich
    dragAxisLock = null;
    isDragging = false;
    initialDragVoxelCoords = null; // Wird erst gesetzt, wenn Drag beginnt
    initialDragYLevel = null; // Initialisiert Y-Level Lock für Drag

    initialClickPos = { x: e.clientX, y: e.clientY }; // Speichert die Startposition des Klicks
    pointerIsDown = true;

    // Berechnet die Voxelkoordinaten am Start des Klicks (roher Treffer)
    initialRayHitCoords = calculateRayTargetVoxelCoords(e.clientX, e.clientY);
    if (!initialRayHitCoords || (!Number.isFinite(initialRayHitCoords.gx) || !Number.isFinite(initialRayHitCoords.gy) || !Number.isFinite(initialRayHitCoords.gz))) {
        pointerIsDown = false; initialClickPos = null; initialRayHitCoords = null;
        return;
    }

    // Für Touch-Ereignisse
    if (e.pointerType === 'touch') {
        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY, pointerType: e.pointerType }); // Speichert den aktiven Touch-Punkt
        touchIndicator.style.display = 'block'; touchIndicator.style.left = `${e.clientX}px`; touchIndicator.style.top = `${e.clientY}px`; // Zeigt Touch-Indikator

        if (activePointers.size > 1) { // Multi-Touch (Geste)
            initialRayHitCoords = null; // Kein Einzel-Voxel-Ziel bei Multi-Touch
            currentStrokeVoxels.clear();
            previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
            updatePreviewVoxel(0, 0, 0, false);
            doubleTapDragActive = false;
            isDragging = false;
            initialDragVoxelCoords = null; // Auch hier zurücksetzen
            initialDragYLevel = null; // Reset Y-level lock
            
            const pointersArr = [...activePointers.values()];
            const [p0, p1] = pointersArr;
            const midX = (p0.x + p1.x) * 0.5; const midY = (p0.y + p1.y) * 0.5; const dist = Math.hypot(p1.x - p0.x, p1.y - p0.y);
            gestureState.type = 'none'; gestureState.startMid = gestureState.lastMid = { x: midX, y: midY };
            gestureState.startDist = gestureState.lastDist = dist;
            gestureState.initialPointerCount = activePointers.size;
            return;
        }

        // Behandlung des initialen Klicks/Taps für Einzel-Touch (kann auch Drag-Start sein)
        if (initialRayHitCoords) {
            isDragging = true; // Bei Touch gilt der erste Tap oft als Start eines Drags

            let firstActionCoords = { ...initialRayHitCoords };
            // Passt die Koordinaten für den ADD-Modus an, wenn kein Template getroffen wurde
            if (currentMode === Modes.ADD && initialRayHitCoords.faceNormal && !initialRayHitCoords.hitTemplate) {
                firstActionCoords.gx += initialRayHitCoords.faceNormal.x;
                firstActionCoords.gy += initialRayHitCoords.faceNormal.y;
                firstActionCoords.gz += initialRayHitCoords.faceNormal.z;
            }
            // Klemmen nach potenzieller Anpassung
            firstActionCoords.gx = Math.max(0, Math.min(GRID - 1, firstActionCoords.gx));
            firstActionCoords.gy = Math.max(0, Math.min(GRID - 1, firstActionCoords.gy));
            firstActionCoords.gz = Math.max(0, Math.min(GRID - 1, firstActionCoords.gz));

            initialDragVoxelCoords = { ...firstActionCoords }; // Dies ist der erste Voxel, der vom Strich betroffen ist
            lastActionVoxelCoords = { ...firstActionCoords }; // Initialisiert lastActionCoords
            initialDragYLevel = firstActionCoords.gy; // Speichert die initiale Y-Ebene für den Drag

            // Führt die erste Voxel-Modifikation für den Startpunkt des Drags aus
            const gKey = key(firstActionCoords.gx, firstActionCoords.gy, firstActionCoords.gz);
            const initialColor = voxelsAtDragStart.has(gKey) ? voxelsAtDragStart.get(gKey).color : null;
            performVoxelModification(firstActionCoords.gx, firstActionCoords.gy, firstActionCoords.gz, currentMode, currentColor);
            const finalColor = voxels.has(gKey) ? voxels.get(gKey).color : null;
            currentStrokeVoxels.set(gKey, { originalColor: initialColor, finalColor: finalColor });
        }
        return;
    }

    // Für Maus-Ereignisse (Linke Maustaste)
    if (e.pointerType === 'mouse' && e.button === 0) {
        lastX = e.clientX; lastY = e.clientY;
        updatePreviewVoxel(0, 0, 0, false); // Vorschau-Voxel ausblenden
        previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
    }
}

// Handler für Pointer Move (Maus oder Touch bewegt)
function onPointerMove(e) {
    e.preventDefault();
    if (isPointerLocked) return; // Keine Interaktion, wenn Pointer gesperrt ist

    // Für Touch-Ereignisse: Aktualisiert Pointer-Position und handhabt Gesten
    if (e.pointerType === 'touch' && activePointers.has(e.pointerId)) {
        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY, pointerType: e.pointerType });
        if (activePointers.size > 1) { // Bei Multi-Touch: Geste handhaben
            handleGesture();
            updatePreviewVoxel(0, 0, 0, false); // Vorschau-Voxel ausblenden
            previewLineInstancedMesh.count = 0; // Vorschau-Linie ausblenden
            previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
            previewLineVoxels = [];
            return;
        }
    }

    lastX = e.clientX;
    lastY = e.clientY;

    // Überprüft, ob ein Drag begonnen hat (Bewegung über einen Schwellenwert hinaus)
    const currentMovedDist = initialClickPos ? Math.hypot(e.clientX - initialClickPos.x, e.clientY - initialClickPos.y) : 0;
    const shouldStartDrag = pointerIsDown && (currentMovedDist > MOVE_PX);

    // Wichtig: currentStrokeVoxels als excludeVoxelsMap übergeben, wenn ein Drag aktiv ist
    let currentRayHit = calculateRayTargetVoxelCoords(e.clientX, e.clientY, isDragging ? currentStrokeVoxels : null); 
    let targetForVoxelAction = null; // Die Koordinaten, wo die Voxel-Aktion (hinzufügen/löschen/zeichnen) stattfinden soll
    let voxelForPreview = null;     // Die Koordinaten, wo der transparente Vorschau-Voxel angezeigt werden soll

    if (currentRayHit) {
        // --- Bestimme targetForVoxelAction ---
        let gx_action = currentRayHit.gx;
        let gy_action = currentRayHit.gy;
        let gz_action = currentRayHit.gz;

        // Anpassung für ADD-Modus, wenn kein Template getroffen wird
        if (currentMode === Modes.ADD && currentRayHit.faceNormal && !currentRayHit.hitTemplate) {
            gx_action += currentRayHit.faceNormal.x;
            gy_action += currentRayHit.faceNormal.y;
            gz_action += currentRayHit.faceNormal.z;
        }

        // Y-Ebene-Sperre speziell für DRAW-Modus während des Ziehens
        if (isDragging && currentMode === Modes.DRAW && initialDragYLevel !== null) {
            gy_action = initialDragYLevel;
        }
        // Klemmen der Action-Koordinaten innerhalb des Rasters
        gx_action = Math.max(0, Math.min(GRID - 1, gx_action));
        gy_action = Math.max(0, Math.min(GRID - 1, gy_action));
        gz_action = Math.max(0, Math.min(GRID - 1, gz_action));
        if (Number.isFinite(gx_action) && Number.isFinite(gy_action) && Number.isFinite(gz_action)) {
            targetForVoxelAction = { gx: gx_action, gy: gy_action, gz: gz_action };
        }


        // --- Bestimme voxelForPreview ---
        let gx_preview = currentRayHit.gx;
        let gy_preview = currentRayHit.gy;
        let gz_preview = currentRayHit.gz;

        // Vorschau für ADD-Modus (wo er platziert würde)
        if (currentMode === Modes.ADD && currentRayHit.faceNormal && !currentRayHit.hitTemplate) {
            gx_preview += currentRayHit.faceNormal.x;
            gy_preview += currentRayHit.faceNormal.y;
            gz_preview += currentRayHit.faceNormal.z;
        }
        // Vorschau, wenn ein Template-Voxel im ADD-Modus getroffen wird
        else if (currentMode === Modes.ADD && currentRayHit.hitTemplate) {
            // Keine Anpassung, Vorschau an der Position des Template-Voxels
        }
        // Vorschau für DELETE/DRAW (an der Position des getroffenen Voxels)
        else if (currentMode === Modes.DELETE || currentMode === Modes.DRAW) {
             // Keine Anpassung, Vorschau an der Position des getroffenen Voxels
        }
        // Klemmen der Preview-Koordinaten innerhalb des Rasters
        gx_preview = Math.max(0, Math.min(GRID - 1, gx_preview));
        gy_preview = Math.max(0, Math.min(GRID - 1, gy_preview));
        gz_preview = Math.max(0, Math.min(GRID - 1, gz_preview));
        if (Number.isFinite(gx_preview) && Number.isFinite(gy_preview) && Number.isFinite(gz_preview)) {
            voxelForPreview = { gx: gx_preview, gy: gy_preview, gz: gz_preview };
        }
    }
    
    // Führe Aktionen aus, wenn der Pointer gedrückt ist und ein Ziel gefunden wurde
    if (pointerIsDown && targetForVoxelAction) {
        if (!isDragging && shouldStartDrag) { // Start des Drags erkennen
            isDragging = true;
            // Der erste Voxel, der vom Strich betroffen ist, und die erste Modifikation
            // werden bereits in onPointerDown gehandhabt. Hier nur lastActionVoxelCoords aktualisieren.
            lastActionVoxelCoords = { ...targetForVoxelAction };
        }

        if (isDragging) {
            const startPointForLine = lastActionVoxelCoords;
            const endPointForLine = { ...targetForVoxelAction }; // Aktuelles Ziel für das Linienende

            let pathVoxels = getVoxelsOnLine(startPointForLine, endPointForLine);

            // Filterung der Voxel im Strich basierend auf dem Modus und der Vorlage
            if (currentMode === Modes.ADD) {
                pathVoxels = pathVoxels.filter(voxel => {
                    const gKey = key(voxel.gx, voxel.gy, voxel.gz);
                    const isTemplateVoxel = templateVoxelMap.has(gKey); // Prüft, ob es ein Template-Voxel ist
                    const hasExistingVoxel = voxels.has(gKey); // Prüft, ob bereits ein Voxel existiert
                    // Füge hinzu, wenn es leer ist UND (ein Template-Voxel ODER keine Template geladen)
                    return !hasExistingVoxel && (isTemplateVoxel || !templateInstancedMesh);
                });
            } else if (currentMode === Modes.DELETE || currentMode === Modes.DRAW) {
                // Nur Voxel im Strich berücksichtigen, die zu Beginn des Drags existierten
                pathVoxels = pathVoxels.filter(voxel => voxelsAtDragStart.has(key(voxel.gx, voxel.gy, voxel.gz)));
            }

            for (let i = 0; i < pathVoxels.length; i++) {
                const voxel = pathVoxels[i];
                const gKey = key(voxel.gx, voxel.gy, voxel.gz);
                const initialColorOfStroke = voxelsAtDragStart.has(gKey) ? voxelsAtDragStart.get(gKey).color : null;
                
                performVoxelModification(voxel.gx, voxel.gy, voxel.gz, currentMode, currentColor);
                
                const finalColorAfterModification = voxels.has(gKey) ? voxels.get(gKey).color : null;

                if (!currentStrokeVoxels.has(gKey)) {
                     currentStrokeVoxels.set(gKey, { originalColor: initialColorOfStroke, finalColor: finalColorAfterModification });
                } else {
                    currentStrokeVoxels.get(gKey).finalColor = finalColorAfterModification;
                }
            }
            lastActionVoxelCoords = { ...endPointForLine }; // Letzte Aktionskoordinaten für den nächsten Segment aktualisieren
            updatePreviewVoxel(voxelForPreview.gx, voxelForPreview.gy, voxelForPreview.gz, true); // Vorschau-Voxel anzeigen
            previewLineInstancedMesh.count = 0; // Vorschau-Linie während des Drags ausblenden

        } else { // Pointer ist gedrückt, aber noch kein Drag (Hover-Zustand, bevor Drag-Schwelle überschritten)
            if (voxelForPreview) { // Nutze das dedizierte Preview-Ziel
                let showPreview = false;
                const gKeyAtPreview = key(voxelForPreview.gx, voxelForPreview.gy, voxelForPreview.gz);
                const hasVoxelAtPreview = voxels.has(gKeyAtPreview);
                const isTemplateVoxel = templateVoxelMap.has(gKeyAtPreview); // Nutze die Map für Effizienz

                if (currentMode === Modes.ADD) {
                    showPreview = !hasVoxelAtPreview || isTemplateVoxel; // Vorschau anzeigen, wenn leer oder Template-Voxel
                } else if (currentMode === Modes.DELETE || currentMode === Modes.DRAW) {
                    showPreview = hasVoxelAtPreview; // Vorschau anzeigen, wenn existierender Voxel
                }
                updatePreviewVoxel(voxelForPreview.gx, voxelForPreview.gy, voxelForPreview.gz, showPreview);
            } else {
                updatePreviewVoxel(0, 0, 0, false);
            }
            previewLineInstancedMesh.count = 0;
        }
    } else { // Pointer ist nicht gedrückt (nur Maus/Finger bewegen, ohne zu klicken)
        previewLineInstancedMesh.count = 0;
        previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
        previewLineVoxels = [];

        if (currentRayHit) {
            let hoverPreviewCoords = { ...currentRayHit };
            // Wenn ADD-Modus und kein Template hit (sondern Raycast auf Leere oder existierendes Voxel), Preview an Face-Normal-Position
            if (currentMode === Modes.ADD && currentRayHit.faceNormal && !currentRayHit.hitTemplate) {
                hoverPreviewCoords.gx += currentRayHit.faceNormal.x;
                hoverPreviewCoords.gy += currentRayHit.faceNormal.y;
                hoverPreviewCoords.gz += currentRayHit.faceNormal.z;
            }
            // Klemmen der Koordinaten innerhalb des Rasters
            hoverPreviewCoords.gx = Math.max(0, Math.min(GRID - 1, hoverPreviewCoords.gx));
            hoverPreviewCoords.gy = Math.max(0, Math.min(GRID - 1, hoverPreviewCoords.gy));
            hoverPreviewCoords.gz = Math.max(0, Math.min(GRID - 1, hoverPreviewCoords.gz));

            let showPreview = false;
            const gKeyAtPreview = key(hoverPreviewCoords.gx, hoverPreviewCoords.gy, hoverPreviewCoords.gz);
            const hasVoxelAtPreview = voxels.has(gKeyAtPreview);
            const isTemplateVoxel = templateVoxelMap.has(gKeyAtPreview); // Nutze die Map für Effizienz

            if (currentMode === Modes.ADD) {
                showPreview = !hasVoxelAtPreview || isTemplateVoxel; // Vorschau anzeigen, wenn leer oder Template-Voxel
            } else if (currentMode === Modes.DELETE || currentMode === Modes.DRAW) {
                showPreview = hasVoxelAtPreview; // Vorschau anzeigen, wenn existierender Voxel
            }
            updatePreviewVoxel(hoverPreviewCoords.gx, hoverPreviewCoords.gy, hoverPreviewCoords.gz, showPreview);
        } else {
            updatePreviewVoxel(0, 0, 0, false);
        }
    }
    
    // Wenn nur ein Finger auf dem Touchscreen und kein Drag, handhabt Geste (Rotation)
    if (e.pointerType === 'touch' && activePointers.size === 1 && !isDragging) {
        handleGesture();
    }
}

// Öffnet das Modal zur Generierung von KI-Ideen
function openIdeaGeneratorModal() {
    document.getElementById('ideaPromptInput').value = '';
    document.getElementById('ideaResultDisplay').innerHTML = '';
    document.getElementById('ideaResultDisplay').classList.add('hidden');
    document.getElementById('ideaLoadingIndicator').classList.add('hidden');
    document.getElementById('ideaGeneratorModal').showModal();
}

// Generiert eine Voxel-Idee mithilfe der Gemini API
async function generateVoxelIdea() {
    const promptText = document.getElementById('ideaPromptInput').value.trim();
    const ideaResultDisplay = document.getElementById('ideaResultDisplay');
    const ideaLoadingIndicator = document.getElementById('ideaLoadingIndicator');

    if (!promptText) {
        showToast('Eingabe erforderlich', 'Bitte geben Sie ein Thema oder Konzept ein.', 'warning', 5000);
        return;
    }

    ideaResultDisplay.classList.add('hidden');
    ideaLoadingIndicator.classList.remove('hidden');
    ideaResultDisplay.innerHTML = '';

    try {
        const prompt = `Generiere ein detailliertes und erkennbares Voxel-Modell als JSON-Objekt basierend auf dem folgenden Thema.
        Das Modell sollte den verfügbaren 3D-Gitterraum effektiv nutzen, der von (0,0,0) bis (${GRID-1},${GRID-1},${GRID-1}) reicht.
        Das Modell *muss* ein **einziges, einheitliches und vollständig verbundenes Objekt** bilden. Es sollte **fest, zusammenhängend und wasserdicht** sein, ohne interne Lücken, getrennte Teile oder schwebende Voxel. Jedes Voxel sollte direkt (fläche-an-fläche) an mindestens ein anderes Voxel innerhalb des generierten Sets angrenzen und eine kontinuierliche, kohäsive Masse bilden. Priorisiere das Ausfüllen interner Räume, um Lücken innerhalb der Gesamtform zu vermeiden. Achte beim Bilden von Linien, Oberflächen oder Volumina darauf, dass alle dazwischenliegenden Voxel enthalten sind, um Löcher zu vermeiden. Vermeide das Generieren von spärlichen oder hohlen Strukturen, es sei denn, dies wird ausdrücklich vom Thema verlangt.
        Strebe eine angemessene Anzahl von Voxeln an, typischerweise zwischen 50 und 700, um eine gut definierte, robuste Struktur zu schaffen.
        Alle x, y, z Koordinaten müssen ganze Zahlen innerhalb der Gittergrenzen (0 bis ${GRID-1}) sein.
        Farben müssen gültige Hex-Farbcodes sein (z.B. "#FF0000").
        
        The JSON sollte die folgende Struktur haben:
        {
          "model_name": "Ein prägnanter Name für das Modell",
          "description": "Eine kurze Beschreibung des Modells.",
          "voxels": {
            "x,y,z": "hex_color_string",
            "x2,y2,z2": "hex_color_string"
          }
        }
        `;

        let chatHistory = [];
        chatHistory.push({ role: "user", parts: [{ text: prompt }] });

        const payload = {
            contents: chatHistory,
            generationConfig: {
                responseMimeType: "application/json",
                responseSchema: {
                    type: "OBJECT",
                    properties: {
                        "model_name": { "type": "STRING" },
                        "description": { "type": "STRING" },
                        "voxels": {
                            type: "OBJECT",
                            additionalProperties: { "type": "STRING" },
                            patternProperties: {
                                "^\\d+,\\d+,\\d+$": { "type": "STRING" }
                            }
                        }
                    },
                    required: ["model_name", "description", "voxels"]
                }
            }
        };

        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${AI_API_KEY}`;

        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        const result = await response.json();

        if (result.candidates && result.candidates.length > 0 &&
            result.candidates[0].content && result.candidates[0].content.parts &&
            result.candidates[0].content.parts.length > 0) {
            const jsonResponseText = result.candidates[0].content.parts[0].text;
            try {
                const parsedJson = JSON.parse(jsonResponseText);
                applyAIGeneratedVoxels(parsedJson);
            } catch (parseError) {
                ideaResultDisplay.innerHTML = '<p class="text-error">Fehler: KI-Antwort konnte nicht als Voxel-Modell interpretiert werden. (Ungültiges JSON)</p>';
                ideaResultDisplay.classList.remove('hidden');
            }
        } else {
            ideaResultDisplay.innerHTML = '<p class="text-error">Konnte keine Idee generieren. Bitte versuchen Sie es erneut.</p>';
            ideaResultDisplay.classList.remove('hidden');
        }
    } catch (error) {
        ideaResultDisplay.innerHTML = `<p class="text-error">Fehler beim Generieren der Idee: ${error.message}</p>`;
        ideaResultDisplay.classList.remove('hidden');
    } finally {
        ideaLoadingIndicator.classList.add('hidden');
    }
}

// Wendet die von der KI generierten Voxel-Daten an
function applyAIGeneratedVoxels(aiData) {
    if (!aiData || !aiData.voxels || typeof aiData.voxels !== 'object') {
        showToast('Fehler', 'Ungültige AI-Voxeldaten erhalten.', 'error', 5000);
        return;
    }

    const oldState = [...voxels.entries()].map(([id, data]) => {
        const p = parseKey(id);
        return { gx: p[0], gy: p[1], gz: p[2], color: data.color };
    });

    clearAllInternal(true); // Löscht alle vorhandenen Voxel

    const newVoxels = [];
    for (const keyString in aiData.voxels) {
        const parts = keyString.split(',').map(Number);
        if (parts.length === 3 && !isNaN(parts[0]) && !isNaN(parts[1]) && !isNaN(parts[2])) {
            const [x, y, z] = parts;
            const color = aiData.voxels[keyString];

            // Stellt sicher, dass die Koordinaten innerhalb des Rasters liegen
            const gx = Math.max(0, Math.min(GRID - 1, Math.round(x)));
            const gy = Math.max(0, Math.min(GRID - 1, Math.round(y)));
            const gz = Math.max(0, Math.min(GRID - 1, Math.round(z)));
            
            _addSingleVoxel(gx, gy, gz, color); // Fügt den Voxel hinzu
            newVoxels.push({ gx, gy, gz, color });
        }
    }

    addCommand('batch', oldState, newVoxels); // Fügt den Batch-Befehl zur Historie hinzu

    projectTitle = aiData.model_name || 'KI Generiertes Modell';
    projectDescription = aiData.description || 'Ein von der KI generiertes Modell.';

    showToast('AI-Modell erstellt', `"${aiData.model_name || 'Unbenannt'}" wurde generiert.`, 'success', 5000);
    document.getElementById('ideaGeneratorModal').close(); // Schließt das Modal
}

// Wechselt die Zeichenachse
function cycleDrawingAxis() {
    const axes = ['x', 'y', 'z'];
    const currentIndex = axes.indexOf(currentDrawingAxis);
    currentDrawingAxis = axes[(currentIndex + 1) % axes.length];
    updateGridHelperPosition(); // Aktualisiert die Gitterhelfer-Position
    showToast('Zeichenachse', `Achse: ${currentDrawingAxis.toUpperCase()}`, 'info', 1500);
}

// Bewegt die Zeichenebene nach oben oder unten
function moveDrawingLevel(direction) {
    if (currentMode !== Modes.ADD && currentMode !== Modes.DRAW) {
        showToast('Hinweis', 'Ebenensteuerung nur im Hinzufügen- oder Zeichenmodus verfügbar.', 'warning', 2000);
        return;
    }
    let level = activeDrawingLevel[currentDrawingAxis];

    if (!Number.isFinite(level)) {
        level = 0;
        activeDrawingLevel[currentDrawingAxis] = level;
    }

    level += direction;
    level = Math.max(0, Math.min(GRID - 1, level)); // Klemmen innerhalb des Rasters
    activeDrawingLevel[currentDrawingAxis] = level;
    updateGridHelperPosition(); // Aktualisiert die Gitterhelfer-Position
    showToast('Zeichenebene', `Ebene ${currentDrawingAxis.toUpperCase()}: ${level}`, 'info', 1500);
}

// Öffnet das Modal zur Auswahl einer Vorlage
function openTemplateChooserModal() {
    const templateList = document.getElementById('templateList');
    templateList.innerHTML = ''; // Vorherige Liste leeren
    predefinedTemplates.forEach((template, index) => {
        const templateDiv = document.createElement('div');
        templateDiv.className = 'card bg-base-100 shadow-md cursor-pointer hover:bg-base-300 transition-colors duration-200';
        templateDiv.innerHTML = `
            <div class="card-body p-4">
                <h4 class="card-title text-base text-secondary">${template.name}</h4>
                <p class="text-sm text-base-content/80">${template.description}</p>
            </div>
        `;
        templateDiv.addEventListener('click', () => {
            loadTemplate(template); // Lädt die ausgewählte Vorlage
            document.getElementById('templateChooserModal').close(); // Schließt das Modal
            cvs.focus(); // Setzt den Fokus zurück auf das Canvas
        });
        templateList.appendChild(templateDiv); // Fügt die Vorlage zur Liste hinzu
    });
    document.getElementById('templateChooserModal').showModal(); // Zeigt das Modal an
}


window.onload = async function() {
    closeAllModals(); // Alle Modals beim Start schließen
    try {
        cvs = document.getElementById('voxelCanvas'); containerDiv = document.getElementById('container');
        touchIndicator = document.getElementById('touch-indicator');
        toastContainer = document.getElementById('toast-container');
        scene = new THREE.Scene(); scene.background = new THREE.Color(0x282c34); // Szene und Hintergrundfarbe
        cam = new THREE.PerspectiveCamera(75, containerDiv.clientWidth / containerDiv.clientHeight, 0.1, 1000); // Kamera
        resetCameraPosition(); euler = new THREE.Euler(0, 0, 0, 'YXZ'); // Kamera-Position und Euler-Winkel
        ren = new THREE.WebGLRenderer({ canvas: cvs, antialias: true }); // Renderer
        ren.setSize(containerDiv.clientWidth, containerDiv.clientHeight);
        isMobile = window.matchMedia('(max-width: 768px)').matches; // Mobilgerät-Erkennung
        ren.setPixelRatio(isMobile ? Math.min(1.5, window.devicePixelRatio) : window.devicePixelRatio); // Pixel-Verhältnis
        ren.shadowMap.enabled = true; ren.shadowMap.type = THREE.PCFSoftShadowMap; // Schatten aktivieren
      
        scene.add(new THREE.AmbientLight(0x606060)); // Umgebungslicht
        mainDirectionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // Haupt-Direktionslicht
        mainDirectionalLight.position.set(10, 20, 15); mainDirectionalLight.castShadow = true;
        mainDirectionalLight.shadow.mapSize.width = mainDirectionalLight.shadow.mapSize.height = 2048;
        mainDirectionalLight.shadow.camera.near = 0.5; mainDirectionalLight.shadow.camera.far = 50;
        mainDirectionalLight.shadow.camera.left = -30; mainDirectionalLight.shadow.camera.right = 30;
        mainDirectionalLight.shadow.camera.top = 30; mainDirectionalLight.shadow.camera.bottom = -30;
        mainDirectionalLight.shadow.bias = -0.0005; mainDirectionalLight.shadow.normalBias = 0.02;
        scene.add(mainDirectionalLight);
        const secondDirectionalLight = new THREE.DirectionalLight(0xffffff, 0.3); // Zweites Direktionslicht
        secondDirectionalLight.position.set(-10, 10, -15);
        scene.add(secondDirectionalLight);
        scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.6)); // Halbkugel-Licht
        
        scene.add(previewVoxelMesh); updatePreviewVoxel(0,0,0,false); // Fügt Vorschau-Voxel zur Szene hinzu
        previewLineInstancedMesh = new THREE.InstancedMesh(new THREE.BoxGeometry(VS, VS, VS), new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.3, depthTest: false }));
        previewLineInstancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        previewLineInstancedMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(maxPreviewInstances * 3), 3);
        previewLineInstancedMesh.instanceColor.setUsage(THREE.DynamicDrawUsage); scene.add(previewLineInstancedMesh);
        rebuildHelpers(); // Baut Gitter- und Box-Helfer auf

        // Canvas focus handling
        cvs.tabIndex = 0; // Make canvas focusable
        cvs.focus();      // Give canvas initial focus
        containerDiv.addEventListener('pointerenter', () => {
            // Only focus if not already focused on an input element or a modal is open
            const activeElement = document.activeElement;
            const isModalOpen = ['authModal', 'uploadProjectModal', 'clearConfirmationModal', 'ideaGeneratorModal', 'templateChooserModal'].some(id => document.getElementById(id).open);
            if (!isModalOpen && activeElement && !activeElement.tagName.match(/^(INPUT|TEXTAREA|SELECT|BUTTON)$/)) {
                cvs.focus();
            }
        });


        // Event-Listener
        window.addEventListener('resize', onResize);
        containerDiv.addEventListener('pointerdown', onPointerDown);
        containerDiv.addEventListener('pointermove', onPointerMove);
        containerDiv.addEventListener('pointerup', onPointerUp);
        containerDiv.addEventListener('pointercancel', onPointerUp);
        containerDiv.addEventListener('pointerleave', onPointerLeave);
        containerDiv.addEventListener('wheel', onMouseWheel, { passive: false });
        document.addEventListener('keydown', onKeyDown); document.addEventListener('keyup', onKeyUp);
        document.addEventListener('pointerlockchange', onPointerLockChange, false);
        containerDiv.addEventListener('mousemove', (e) => {
            if (isPointerLocked) {
                mouseMovementX = e.movementX;
                mouseMovementY = e.movementY;
                e.preventDefault();
            }
        });
        containerDiv.addEventListener('contextmenu', (e) => e.preventDefault()); // Kontextmenü bei Rechtsklick verhindern

        // Gittergröße-Slider
        document.getElementById('grid-size-slider').addEventListener('input', (e) => {
            const oldGrid = GRID;
            const newGrid = parseInt(e.target.value);

            // Warnung, wenn Voxel beim Verkleinern des Rasters verloren gehen würden
            if (newGrid < oldGrid) {
                let voxelsWouldBeLost = false;
                for (const [id, data] of voxels.entries()) {
                    const p = parseKey(id);
                    if (p[0] >= newGrid || p[1] >= newGrid || p[2] >= newGrid) {
                        voxelsWouldBeLost = true;
                        break;
                    }
                }

                if (voxelsWouldBeLost) {
                    showToast('Warnung', 'Gittergröße kann nicht reduziert werden, da sonst vorhandene Voxel außerhalb des Rasters verloren gehen würden.', 'warning', 5000);
                    e.target.value = oldGrid;
                    document.getElementById('grid-size-display').textContent = `${oldGrid}×${oldGrid}×${oldGrid}`;
                    return;
                }
            }
            
            // Aktualisiert das Gitter und fügt Befehl zur Historie hinzu
            const oldVoxelState = [...voxels.entries()].map(([id, data]) => { const p = parseKey(id); return { gx: p[0], gy: p[1], gz: p[2], color: data.color }; });
            for (const chunk of chunks.values()) chunk.dispose(); chunks.clear(); voxels.clear();
            oldVoxelState.filter(v => v.gx < newGrid && v.gy < newGrid && v.gz < newGrid).forEach(v => _addSingleVoxel(v.gx, v.gy, v.gz, v.color));
            GRID = newGrid; document.getElementById('grid-size-display').textContent = `${GRID}×${GRID}×${GRID}`; localStorage.setItem('voxelEditorGridSize', GRID);
            addCommand('resizeGrid', oldVoxelState, [...voxels.entries()].map(([id, data]) => { const p = parseKey(id); return { gx: p[0], gy: p[1], gz: p[2], color: data.color }; }), { oldGrid: oldGrid, newGrid: GRID });
            rebuildHelpers(); resetCameraPosition();
        });

        // Farbauswahl
        document.getElementById('color-picker').addEventListener('input', (e) => {
            currentColor = e.target.value; localStorage.setItem('voxelEditorColor', currentColor);
            const mobileColorInput = document.getElementById('mobile-color-input');
            if (mobileColorInput) mobileColorInput.value = currentColor;
            presetBoxes.forEach(box => box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50')); activePresetIndex = -1;
            if (previewVoxelMesh.visible) {
                previewVoxelMaterial.color.set(currentColor);
            }
        });

        // Voreingestellte Farben
        presetBoxes = [document.getElementById('color-preset-1'), document.getElementById('color-preset-2'), document.getElementById('color-preset-3')];
        presetColors.forEach((color, i) => {
            const box = presetBoxes[i]; box.value = color;
            box.addEventListener('click', (e) => setActivePreset(i));
            box.addEventListener('input', (e) => savePresetColor(i, e.target.value));
        });
        if (activePresetIndex !== -1) setActivePreset(activePresetIndex); else document.getElementById('color-picker').value = currentColor;

        document.getElementById('modeToggle').addEventListener('click', cycleMode);
        document.getElementById('current-mode').textContent = `Modus: ${currentMode}`;

        // Clear-Bestätigungsmodal
        document.getElementById('clearBtn').addEventListener('click', () => document.getElementById('clearConfirmationModal').showModal());
        document.getElementById('saveAndClearBtn').addEventListener('click', () => { saveJSON(); clearAll(); document.getElementById('clearConfirmationModal').close(); });
        document.getElementById('clearWithoutSaveBtn').addEventListener('click', () => { clearAll(); document.getElementById('clearConfirmationModal').close(); });
        document.getElementById('cancelClearBtn').addEventListener('click', () => document.getElementById('clearConfirmationModal').close());
        document.getElementById('clearConfirmationModal').addEventListener('cancel', () => document.getElementById('clearConfirmationModal').close());

        document.getElementById('fillLevelBtn').addEventListener('click', fillActiveLevel);
        document.getElementById('saveBtn').addEventListener('click', saveJSON);
        document.getElementById('loadBtn').addEventListener('click', () => document.getElementById('fileInput').click());
        document.getElementById('fileInput').addEventListener('change', loadJSON);
        document.getElementById('exportStlBtn').addEventListener('click', exportSTL);
        document.getElementById('exportObjBtn').addEventListener('click', exportOBJ);
        document.getElementById('exportGlbBtn').addEventListener('click', exportGLB);

        // Fluggeschwindigkeits-Slider
        document.getElementById('fly-speed-slider').addEventListener('input', (e) => {
            moveSpeed = parseFloat(e.target.value); document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2); localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
        });

        document.getElementById('resetCameraBtn').addEventListener('click', resetCameraPosition);
        document.getElementById('generateVoxelIdeaBtn').addEventListener('click', openIdeaGeneratorModal);
        document.getElementById('loadImageTemplateBtn').addEventListener('click', loadImageTemplate);
        document.getElementById('imageFileInput').addEventListener('change', handleImageFileSelect);
        document.getElementById('removeImageTemplateBtn').addEventListener('click', removeImageTemplate);

        // Vorlagen-Funktionen
        document.getElementById('loadTemplateBtn').addEventListener('click', openTemplateChooserModal);
        document.getElementById('removeTemplateBtn').addEventListener('click', removeTemplate);
        // Vorlagen-Modal-Schließung
        document.getElementById('templateChooserCloseBtn').addEventListener('click', () => document.getElementById('templateChooserModal').close());
        document.getElementById('templateChooserModal').addEventListener('click', (e) => { if (e.target === document.getElementById('templateChooserModal')) document.getElementById('templateChooserModal').close(); });

        // Menü-Umschaltung für Mobilgeräte
        document.getElementById('menuToggle').addEventListener('click', () => {
            const controlsPanel = document.getElementById('controls');
            controlsPanel.classList.toggle('hidden');
            if (!controlsPanel.classList.contains('hidden')) controlsPanel.classList.add('flex');
            else controlsPanel.classList.remove('flex');
        });

        // Medienabfrage für responsive Anpassungen
        const mediaQuery = window.matchMedia('(max-width: 768px)');
        function handleMediaQueryChange(e) {
            isMobile = e.matches;
            const controlsPanel = document.getElementById('controls');
            const mobileControls = document.getElementById('mobile-controls');
            const mobileAxisToggle = document.getElementById('mobile-axis-toggle');
            const mobileLevelUp = document.getElementById('mobile-level-up');
            const mobileLevelDown = document.getElementById('mobile-level-down');

            if (e.matches) {
                controlsPanel.classList.add('hidden');
                mobileControls.classList.remove('hidden');
                mobileControls.classList.add('flex');
                toastContainer.classList.remove('toast-end');
                toastContainer.classList.add('toast-top-center');
                
                mobileAxisToggle.classList.remove('hidden');
                mobileLevelUp.classList.remove('hidden');
                mobileLevelDown.classList.remove('hidden');
            }
            else {
                controlsPanel.classList.remove('hidden');
                controlsPanel.classList.add('flex');
                mobileControls.classList.add('hidden');
                mobileControls.classList.remove('flex');
                toastContainer.classList.remove('toast-top-center');
                toastContainer.classList.add('toast-end');

                mobileAxisToggle.classList.add('hidden');
                mobileLevelUp.classList.add('hidden');
                mobileLevelDown.classList.add('hidden');
            }
            onResize();
            rebuildHelpers();
            const mobileModeIcon = document.getElementById('mobile-mode-icon');
            if (mobileModeIcon) {
                mobileModeIcon.className = ModeIcons[currentMode];
            }
        }
        mediaQuery.addListener(handleMediaQueryChange); handleMediaQueryChange(mediaQuery);

        // Mobile Steuerungs-Buttons
        document.getElementById('mobile-undo').addEventListener('click', (e) => { e.stopPropagation(); undo(); });
        document.getElementById('mobile-redo').addEventListener('click', (e) => { e.stopPropagation(); redo(); });
        document.getElementById('mobile-save').addEventListener('click', (e) => { e.stopPropagation(); saveJSON(); });
        document.getElementById('mobile-camera').addEventListener('click', (e) => { e.stopPropagation(); resetCameraPosition(); });
        document.getElementById('mobile-mode-toggle').addEventListener('click', (e) => { e.stopPropagation(); cycleMode(); });
        
        const mobileColorPickerBtn = document.getElementById('mobile-color-picker-btn');
        const mobileColorInput = document.getElementById('mobile-color-input');
        
        mobileColorPickerBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            mobileColorInput.click();
        });

        mobileColorInput.addEventListener('input', (e) => {
            currentColor = e.target.value;
            localStorage.setItem('voxelEditorColor', currentColor);
            document.getElementById('color-picker').value = currentColor;
            presetBoxes.forEach(box => box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'));
            activePresetIndex = -1;
            if (previewVoxelMesh.visible) {
                previewVoxelMaterial.color.set(currentColor);
            }
        });
        mobileColorInput.addEventListener('change', (e) => {
            currentColor = e.target.value;
            localStorage.setItem('voxelEditorColor', currentColor);
            document.getElementById('color-picker').value = currentColor;
            presetBoxes.forEach(box => box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'));
            activePresetIndex = -1;
            if (previewVoxelMesh.visible) {
                previewVoxelMaterial.color.set(currentColor);
            }
        });

        mobileColorInput.value = currentColor;

        document.getElementById('mobile-axis-toggle').addEventListener('click', (e) => { e.stopPropagation(); cycleDrawingAxis(); });
        document.getElementById('mobile-level-up').addEventListener('click', (e) => { e.stopPropagation(); moveDrawingLevel(1); });
        document.getElementById('mobile-level-down').addEventListener('click', (e) => { e.stopPropagation(); moveDrawingLevel(-1); });

        document.getElementById('mobile-generate-idea').addEventListener('click', (e) => { e.stopPropagation(); openIdeaGeneratorModal(); });
        document.getElementById('mobile-template').addEventListener('click', (e) => { e.stopPropagation(); openTemplateChooserModal(); }); // Mobile Template Button
        document.getElementById('mobile-login-logout').addEventListener('click', (e) => { e.stopPropagation(); loginLogout(); });

        // Initialisiert die UI-Elemente mit gespeicherten Werten
        document.getElementById('grid-size-slider').value = GRID; document.getElementById('grid-size-display').textContent = `${GRID}×${GRID}×${GRID}`;
        document.getElementById('color-picker').value = currentColor;
        document.getElementById('fly-speed-slider').value = moveSpeed; document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
        
        document.getElementById('mobile-mode-icon').className = ModeIcons[currentMode];
        document.getElementById('mobile-axis-icon').className = AxisIcons[currentDrawingAxis];

        // Firebase Initialisierung und Authentifizierung
        const app = window.firebase.initializeApp(window.firebaseConfig);
        auth = window.firebase.getAuth(app); db = window.firebase.getFirestore(app);
        const loginLogoutBtn = document.getElementById('loginLogoutBtn');
        const uploadToHubBtn = document.getElementById('uploadToHubBtn');
        const userIdDisplay = document.getElementById('userIdDisplay');
        const goToHubBtn = document.getElementById('goToHubBtn');
        let projectLoadedFromUrl = false;

        predefinedCategories.forEach(cat => { const opt = document.createElement('option'); opt.value = cat; opt.textContent = cat; document.getElementById('uploadCategory').appendChild(opt); });

        window.firebase.setPersistence(auth, window.firebase.browserLocalPersistence)
            .then(async () => {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    try { await window.firebase.signInWithCustomToken(auth, __initial_auth_token); }
                    catch (e) { showToast('Anmeldefehler', `Fehler beim Anmelden mit Token: ${e.message}. Bitte versuchen Sie es erneut.`, 'error', 5000); }
                } else {
                }

                window.firebase.onAuthStateChanged(auth, async (user) => {
                    currentUserId = user ? user.uid : null; currentUser = user;
                    loginLogoutBtn.textContent = user ? 'Abmelden' : 'Anmelden';
                    userIdDisplay.innerHTML = user ? `<img src="${user.photoURL || 'https://placehold.co/24x24/cccccc/000000?text=U'}" alt="User Avatar" class="w-6 h-6 rounded-full align-middle">` : '';
                    uploadToHubBtn.classList.toggle('hidden', !user);
                    document.getElementById('mobile-login-logout').textContent = user ? '🚪' : '🔑';
                    if (user) document.getElementById('authModal').close();

                    if (!projectLoadedFromUrl) {
                        const urlParams = new URLSearchParams(window.location.search);
                        const modelId = urlParams.get('modelId'); const encodedJson = urlParams.get('projectJson');
                        if (modelId) { await loadProjectFromModelId(modelId); projectLoadedFromUrl = true; }
                        else if (encodedJson) {
                            try {
                                const decodedJson = decodeURIComponent(encodedJson);
                                loadProjectData(JSON.parse(decodedJson));
                                showToast('Projekt geladen', 'Projekt erfolgreich aus URL-Parameter geladen.', 'success', 5000);
                                projectLoadedFromUrl = true;
                            } catch (e) { showToast('Fehler', 'Fehler beim Laden des Projekts aus der URL. Ungültige oder beschädigte Projektdaten. Fehler: ' + e.message, 'error', 5000); resetToDefaultProject(); }
                        } else { projectRemixOf = ''; projectSourceJsonUrl = ''; }
                    }
                });
                animate();
            })
            .catch((e) => { showToast('Anmeldefehler', `Fehler bei der Anmeldungspersistenz: ${e.message}.`, 'error', 10000); animate(); });

        document.getElementById('goToHubBtn').addEventListener('click', () => window.open('https://hub.voxelshaper.com', '_blank'));
        loginLogoutBtn.addEventListener('click', loginLogout);
        document.getElementById('authModal').addEventListener('click', (e) => { if (e.target === document.getElementById('authModal')) closeAuthModal(); });
        document.getElementById('authModalCloseBtn').addEventListener('click', closeAuthModal);
        document.getElementById('signInGoogleBtn').addEventListener('click', window.signInWithGoogle);
        document.getElementById('signInGithubBtn').addEventListener('click', window.signInGithub);
        document.getElementById('emailSignInBtn').addEventListener('click', window.signInEmailPassword);
        document.getElementById('emailSignUpBtn').addEventListener('click', window.signUpEmailPassword);
        document.getElementById('showEmailLoginFormBtn').addEventListener('click', () => document.getElementById('emailLoginForm').classList.remove('hidden'));
        document.getElementById('uploadToHubBtn').addEventListener('click', openUploadModal);
        document.getElementById('uploadProjectModal').addEventListener('click', (e) => { if (e.target === document.getElementById('uploadProjectModal')) { document.getElementById('uploadProjectModal').close(); cvs.focus(); } });
        document.getElementById('uploadConfirmBtn').addEventListener('click', uploadProjectToHub);
        document.getElementById('uploadCancelBtn').addEventListener('click', () => { document.getElementById('uploadProjectModal').close(); cvs.focus(); });

        document.getElementById('generateIdeaConfirmBtn').addEventListener('click', generateVoxelIdea);
        document.getElementById('ideaGeneratorCloseBtn').addEventListener('click', () => { document.getElementById('ideaGeneratorModal').close(); cvs.focus(); });
        document.getElementById('ideaGeneratorModal').addEventListener('click', (e) => { if (e.target === document.getElementById('ideaGeneratorModal')) { document.getElementById('ideaGeneratorModal').close(); cvs.focus(); } });

    } catch (e) { showToast('Schwerer Fehler', `Ein unerwarteter Fehler ist aufgetreten: ${e.message}.`, 'error', 10000); }
};

const frustum = new THREE.Frustum(); const tempCameraMatrix = new THREE.Matrix4();
function animate() {
    requestAnimationFrame(animate);
    if (isPointerLocked) {
        if (firstMoveAfterLock) {
            firstMoveAfterLock = false;
            mouseMovementX = mouseMovementY = 0;
            return;
        }
        euler.y -= (mouseMovementX || 0) * rotSpeed;
        euler.x -= (mouseMovementY || 0) * rotSpeed;
        euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
        cam.quaternion.setFromEuler(euler);
        mouseMovementX = mouseMovementY = 0;
        const camDir = new THREE.Vector3(); cam.getWorldDirection(camDir);
        const rightDir = new THREE.Vector3().crossVectors(camDir, cam.up).normalize();
        const upVec = new THREE.Vector3(0, 1, 0); const currMoveSpeed = moveSpeed * 0.5;
        if (keyboard['w']) cam.position.addScaledVector(camDir, currMoveSpeed);
        if (keyboard['s']) cam.position.addScaledVector(camDir, -currMoveSpeed);
        if (keyboard['a']) cam.position.addScaledVector(rightDir, -currMoveSpeed);
        if (keyboard['d']) cam.position.addScaledVector(rightDir, currMoveSpeed);
        if (keyboard['e']) cam.position.addScaledVector(upVec, currMoveSpeed);
        if (keyboard['q']) cam.position.addScaledVector(upVec, -currMoveSpeed);
    }
    cam.updateMatrixWorld(); tempCameraMatrix.multiplyMatrices(cam.projectionMatrix, cam.matrixWorldInverse);
    frustum.setFromProjectionMatrix(tempCameraMatrix);
    for (const chunk of chunks.values()) chunk.instancedMesh.visible = frustum.intersectsBox(chunk.boundingBox);
    ren.render(scene, cam);
}
</script>
</body>
</html>
