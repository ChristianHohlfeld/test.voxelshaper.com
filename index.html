<html lang="de" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta property="og:title" content="VoxelShaper – Create in 3D, Effortlessly">
    <meta property="og:description" content="A powerful, intuitive voxel-based 3D editor – made for makers, artists, and coders.">
    <meta property="og:url" content="https://test.voxelshaper.com/">
    <meta property="og:type" content="website">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover">
    <meta name="format-detection" content="telephone=no, email=no, address=no">
    <title>[TEST] [TEST] VoxelShaper – Simplified Voxel Editor</title>

    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.7.2/dist/full.min.css" rel="stylesheet" type="text/css">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        :root { --toast-z-index: 9999; }
        html, body {
            overflow: hidden;
            height: 100%;
            margin: 0;
            padding: 0;
        }
        #container, #voxelCanvas {
            touch-action: none;
        }
        body {
            display: flex;
            flex-direction: column;
        }
        #container {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
        }
        #voxelCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }
        #voxelCanvas:focus {
            outline: none;
        }
        #controls {
            flex-wrap: nowrap;
        }
        .controls-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-shrink: 1;
            min-width: 0;
        }
        .controls-group > * {
            flex-shrink: 0;
        }
        .controls-group .range {
            flex-shrink: 1;
        }
        input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            padding: 0;
            border: none;
            background-color: transparent;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: 1px solid #555; border-radius: 50%; }
        input[type="color"]::-moz-color-swatch { border: 1px solid #555; border-radius: 50%; }
        .marquee {
            position: absolute;
            border: 1px dashed #ffff00;
            background-color: rgba(255, 255, 0, 0.1);
            pointer-events: none;
            display: none;
        }
        #mobile-ui-container {
            display: none;
        }
        #mobile-ui-container .mobile-bottom-bar > * {
            flex-shrink: 0;
        }
        #mobile-ui-container .mobile-bottom-bar .btn,
        #mobile-ui-container .mobile-bottom-bar input[type="color"],
        #mobile-ui-container .mobile-bottom-bar .dropdown > label {
            width: 3.5rem;
            height: 3.5rem;
            font-size: 1.5rem;
        }
    </style>

    <style>
      .orientation-overlay {
        position: fixed; inset: 0;
        display: none; align-items: center; justify-content: center;
        background: rgba(0,0,0,.6);
        color: #fff; font: 600 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        z-index: 2147483646;
        text-align: center; padding: 24px;
      }
      .orientation-overlay.show { display: flex; }
    </style>
    <style>
      :root { --safe-bottom: env(safe-area-inset-bottom); --safe-top: env(safe-area-inset-top); }
      #mobile-ui-container .mobile-bottom-bar {
        position: fixed; left: 0; right: 0; bottom: 0;
        padding-bottom: calc(var(--safe-bottom) + 8px);
        z-index: 40;
      }
      body.has-mobile-bar {
        padding-bottom: calc(64px + var(--safe-bottom));
      }
    </style>
    <style>
        :where(html, body, #container, #voxelCanvas, #controls, #mobile-ui-container,
                .mobile-bottom-bar, .btn, .dropdown, .menu, .modal, label, span, div) {
          -webkit-user-select: none;
          user-select: none;
          -webkit-touch-callout: none;
          -webkit-tap-highlight-color: transparent;
        }
        input, textarea, select, [contenteditable] {
          -webkit-user-select: text;
          user-select: text;
          -webkit-touch-callout: default;
        }
    </style>
    <style>*, ::before, ::after{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}::after,::before{--tw-content:''}:host,html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4;font-family:ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]:where(:not([hidden=until-found])){display:none}.absolute{position:absolute}.right-2{right:0.5rem}.top-2{top:0.5rem}.z-50{z-index:50}.z-\[1\]{z-index:1}.my-1{margin-top:0.25rem;margin-bottom:0.25rem}.mb-4{margin-bottom:1rem}.ml-2{margin-left:0.5rem}.mr-1{margin-right:0.25rem}.mr-2{margin-right:0.5rem}.mt-4{margin-top:1rem}.flex{display:flex}.hidden{display:none}.h-6{height:1.5rem}.min-h-screen{min-height:100vh}.w-28{width:7rem}.w-52{width:13rem}.w-6{width:1.5rem}.w-full{width:100%}.max-w-xs{max-width:20rem}.flex-grow{flex-grow:1}.cursor-pointer{cursor:pointer}.flex-col{flex-direction:column}.items-center{align-items:center}.justify-start{justify-content:flex-start}.justify-end{justify-content:flex-end}.justify-between{justify-content:space-between}.justify-around{justify-content:space-around}.gap-1{gap:0.25rem}.gap-2{gap:0.5rem}.gap-3{gap:0.75rem}.gap-4{gap:1rem}.overflow-hidden{overflow:hidden}.text-ellipsis{text-overflow:ellipsis}.whitespace-nowrap{white-space:nowrap}.rounded-full{border-radius:9999px}.border-2{border-width:2px}.border-b{border-bottom-width:1px}.border-t{border-top-width:1px}.bg-clip-content{background-clip:content-box}.p-1{padding:0.25rem}.p-2{padding:0.5rem}.py-4{padding-top:1rem;padding-bottom:1rem}.text-left{text-align:left}.text-center{text-align:center}.text-lg{font-size:1.125rem;line-height:1.75rem}.text-sm{font-size:0.875rem;line-height:1.25rem}.font-bold{font-weight:700}.normal-case{text-transform:none}.text-white{--tw-text-opacity:1;color:rgb(255 255 255 / var(--tw-text-opacity, 1))}.shadow{--tw-shadow:0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}@media (min-width: 768px){.md\:flex{display:flex}}</style>
</head>
<body class="bg-base-100 min-h-screen text-base-content flex flex-col" style="">

<!-- Main Controls (Desktop) -->
<div id="controls" class="hidden md:flex flex-wrap items-center justify-between gap-4 p-2 bg-base-200 border-b border-base-content/20 lg:flex-nowrap" style="display: flex;">
    <div class="controls-group">
        <div class="dropdown">
            <label tabindex="0" class="btn btn-sm btn-ghost">File</label>
            <ul tabindex="0" class="dropdown-content z-[1] menu p-2 shadow bg-base-300 rounded-box w-52">
                <li><a id="saveBtn">Save</a></li>
                <li><a id="loadBtn">Load</a></li>
                <li><a id="exportBtn">Export</a></li>
                <div class="divider my-1"></div>
                <li><a id="loadImageBtn">Load Reference Image</a></li>
                <li><a id="removeImageBtn" class="hidden">Remove Reference Image</a></li>
                <div class="divider my-1"></div>
                <li><a id="clearBtn" class="text-error">Clear Scene</a></li>
            </ul>
        </div>
        <div class="dropdown">
            <label tabindex="0" class="btn btn-sm btn-ghost">Edit</label>
            <ul tabindex="0" class="dropdown-content z-[1] menu p-2 shadow bg-base-300 rounded-box w-52">
                <li><a id="undoBtn"><i class="fas fa-undo mr-2"></i>Undo (Ctrl+Z)</a></li>
                <li><a id="redoBtn"><i class="fas fa-redo mr-2"></i>Redo (Ctrl+Y)</a></li>
            </ul>
        </div>
        <div class="dropdown dropdown-bottom">
            <label tabindex="0" class="btn btn-sm btn-ghost">View</label>
            <ul tabindex="0" class="dropdown-content z-[1] menu p-2 shadow bg-base-300 rounded-box w-52">
                    <li><a id="resetCameraBtn">Reset View</a></li>
                    <div class="divider my-1"></div>
                    <li><label class="label cursor-pointer"><span class="label-text">Grid:</span></label></li>
                    <li>
                        <input type="range" id="grid-size-slider" min="5" max="100" value="10" class="range range-xs w-28">
                    </li>
                    <li>
                        <span id="grid-size-display" class="font-bold text-primary text-sm">17³</span>
                    </li>
                    <div class="divider my-1"></div>
                    <li><label class="label cursor-pointer"><span class="label-text">Fly Speed:</span></label></li>
                    <li>
                        <input type="range" id="fly-speed-slider" min="0.01" max="1" value="0.1" step="0.01" class="range range-xs w-28">
                    </li>
                    <li>
                        <span id="fly-speed-display" class="font-bold text-primary text-sm">0.08</span>
                    </li>
                    <div class="divider my-1"></div>
                    <li>
                      <details>
                        <summary>Controls</summary>
                        <ul>
                          <li><label class="label cursor-pointer"><span class="label-text">Invert Look X</span><input type="checkbox" id="invertLookX" class="toggle toggle-primary"></label></li>
                          <li><label class="label cursor-pointer"><span class="label-text">Invert Look Y</span><input type="checkbox" id="invertLookY" class="toggle toggle-primary"></label></li>
                          <li><label class="label cursor-pointer"><span class="label-text">Invert Zoom</span><input type="checkbox" id="invertZoom" class="toggle toggle-primary"></label></li>
                          <li><label class="label cursor-pointer"><span class="label-text">Invert Strafe X</span><input type="checkbox" id="invertStrafeX" class="toggle toggle-primary"></label></li>
                          <li><label class="label cursor-pointer"><span class="label-text">Invert Strafe Y</span><input type="checkbox" id="invertStrafeY" class="toggle toggle-primary"></label></li>
                          <div class="divider my-1"></div>
                          <li><a id="resetDefaultsBtn">Reset to Default</a></li>
                        </ul>
                      </details>
                    </li>
            </ul>
        </div>
        <div class="divider divider-horizontal hidden lg:block"></div>
        <div class="dropdown dropdown-bottom">
            <label tabindex="0" class="btn btn-sm btn-ghost">Tools</label>
            <ul tabindex="0" class="dropdown-content z-[1] menu p-2 shadow bg-base-300 rounded-box w-52">
                <li><a id="cycleAxisBtn">Cycle Axis</a></li>
                <li class="pl-4">
                    <span id="current-axis-display" class="font-bold text-accent text-sm whitespace-nowrap">Axis: Y</span>
                </li>
                <div class="divider my-1"></div>
                <div class="flex items-center gap-2">
                    <button id="levelDownBtn" class="btn btn-sm btn-ghost">-</button>
                    <span id="current-level-display" class="font-bold text-accent text-sm">0</span>
                    <button id="levelUpBtn" class="btn btn-sm btn-ghost">+</button>
                </div>
            </ul>
        </div>
        <button id="modeToggle" class="btn btn-sm btn-neutral">Add</button>
        <label for="color-picker-input" class="btn btn-sm btn-ghost normal-case gap-2">Color
            <input type="color" id="color-picker-input" value="#FFFFFF" class="h-6 w-6 cursor-pointer rounded-full">
        </label>
    </div>

    <div class="flex-grow"></div>

    <div class="controls-group flex-wrap sm:flex-nowrap">
        <div class="divider divider-horizontal hidden lg:block"></div>
        <button id="loginLogoutBtn" class="btn btn-sm btn-info">Logout</button>
        <span id="userIdDisplay" class="font-bold text-info whitespace-nowrap overflow-hidden text-ellipsis max-w-xs flex items-center gap-1"><span>Christian Hohlfeld</span></span>
        <button id="uploadToHubBtn" class="btn btn-sm btn-warning">Upload</button>
        <button id="goToHubBtn" class="btn btn-sm btn-ghost">Hub</button>
    </div>
</div>

<!-- Main Canvas Container -->
<div id="container">
    <canvas id="voxelCanvas" tabindex="0" width="1714" height="1712" style="pointer-events: auto; width: 762px; height: 761px;"></canvas>
    <div id="marquee" class="marquee"></div>
    <input type="file" id="fileInput" accept=".json" class="hidden">
    <input type="file" id="imageFileInput" accept="image/*" class="hidden">
</div>

<!-- Mobile Controls -->
<div id="mobile-ui-container" style="display: none;">
    <div class="mobile-bottom-bar flex items-center justify-around p-2 bg-base-200 border-t border-base-content/20">

        <div class="dropdown dropdown-top">
            <label tabindex="0" class="btn btn-ghost rounded-full" aria-label="File Menu"><i class="fas fa-folder-open"></i></label>
            <ul tabindex="0" class="dropdown-content z-[1] menu p-2 shadow bg-base-300 rounded-box w-52">
                <li><a id="saveBtnMobile">Save</a></li>
                <li><a id="loadBtnMobile">Load</a></li>
                <li><a id="exportBtnMobile">Export</a></li>
                <div class="divider my-1"></div>
                <li><a id="loadImageBtnMobile">Load Reference Image</a></li>
                <li><a id="removeImageBtnMobile" class="hidden">Remove Reference Image</a></li>
                <div class="divider my-1"></div>
                <li><a id="clearBtnMobile" class="text-error">Clear Scene</a></li>
            </ul>
        </div>

        <div class="dropdown dropdown-top">
            <label tabindex="0" class="btn btn-ghost rounded-full" aria-label="Edit Menu"><i class="fas fa-edit"></i></label>
            <ul tabindex="0" class="dropdown-content z-[1] menu p-2 shadow bg-base-300 rounded-box w-52">
                <li><a id="mobile-undo"><i class="fas fa-undo mr-2"></i>Undo</a></li>
                <li><a id="mobile-redo"><i class="fas fa-redo mr-2"></i>Redo</a></li>
            </ul>
        </div>
        
        <div class="dropdown dropdown-top">
            <label tabindex="0" class="btn btn-ghost rounded-full" aria-label="Tools Menu"><i class="fas fa-tools"></i></label>
            <ul tabindex="0" class="dropdown-content z-[1] menu p-2 shadow bg-base-300 rounded-box w-52">
                <li><a id="mobile-cycle-axis">Y</a></li>
                <li><a id="mobile-level-up">Level Up</a></li>
                <li><a id="mobile-level-down">Level Down</a></li>
                <div class="divider my-1"></div>
                <li><a id="mobile-go-to-hub">Go to Hub</a></li>
                <li id="mobile-upload-li"><button id="mobile-upload" class="w-full text-left">Upload to Hub</button></li>
                <div class="divider my-1"></div>
                <li id="mobile-auth-li"><button id="mobile-login-logout" class="w-full text-left">Login</button></li>
            </ul>
        </div>

        <div class="dropdown dropdown-top">
            <label tabindex="0" class="btn btn-ghost rounded-full" aria-label="View Menu"><i class="fas fa-eye"></i></label>
            <ul tabindex="0" class="dropdown-content z-[1] menu p-2 shadow bg-base-300 rounded-box w-52">
              <li><a id="mobile-reset-camera">Reset Camera</a></li>
              <li><a id="mobile-settings" onclick="document.getElementById('mobileControlsModal').showModal();">Settings</a></li>
            </ul>
        </div>

        <input type="color" id="mobile-color-picker" value="#FFFFFF" class="rounded-full p-1 border-2 border-base-content/50 bg-clip-content">
        <button class="btn btn-ghost rounded-full" id="mobile-mode-toggle" aria-label="Toggle Mode">
            <i id="mobile-mode-icon" class="fas fa-plus"></i>
        </button>
    </div>
</div>

<!-- Modals -->
<dialog id="exportOptionsModal" class="modal">
    <div class="modal-box">
        <h3 class="font-bold text-lg">Export Options</h3>
        <div class="form-control mb-4">
            <label class="label"><span class="label-text">Scale Unit:</span></label>
            <div class="flex gap-3">
                <label class="flex items-center"><input type="radio" name="exportScaleUnit" value="mm" class="radio radio-primary" checked=""><span class="ml-2">Millimeters (mm)</span></label>
                <label class="flex items-center"><input type="radio" name="exportScaleUnit" value="cm" class="radio radio-primary"><span class="ml-2">Centimeters (cm)</span></label>
            </div>
        </div>
        <div class="form-control mb-4">
            <label class="label"><span class="label-text">Up-Axis for Export:</span></label>
            <div class="flex gap-3">
                <label class="flex items-center"><input type="radio" name="exportUpAxis" value="Y" class="radio radio-primary"><span class="ml-2">Y-Up (Standard)</span></label>
                <label class="flex items-center"><input type="radio" name="exportUpAxis" value="Z" class="radio radio-primary" checked=""><span class="ml-2">Z-Up (3D Printers)</span></label>
            </div>
        </div>
        <div class="modal-action">
            <button id="confirmExportBtn" class="btn btn-success">Confirm Export</button>
            <form method="dialog"><button class="btn">Cancel</button></form>
        </div>
    </div>
</dialog>
<dialog id="mobileControlsModal" class="modal">
    <div class="modal-box">
        <h3 class="font-bold text-lg">Control Settings</h3>
        <ul class="menu p-2">
            <li><label class="label cursor-pointer"><span class="label-text">Invert Look X</span><input type="checkbox" id="mobileInvertLookX" class="toggle toggle-primary"></label></li>
            <li><label class="label cursor-pointer"><span class="label-text">Invert Look Y</span><input type="checkbox" id="mobileInvertLookY" class="toggle toggle-primary"></label></li>
            <li><label class="label cursor-pointer"><span class="label-text">Invert Zoom</span><input type="checkbox" id="mobileInvertZoom" class="toggle toggle-primary"></label></li>
            <li><label class="label cursor-pointer"><span class="label-text">Invert Strafe X</span><input type="checkbox" id="mobileInvertStrafeX" class="toggle toggle-primary"></label></li>
            <li><label class="label cursor-pointer"><span class="label-text">Invert Strafe Y</span><input type="checkbox" id="mobileInvertStrafeY" class="toggle toggle-primary"></label></li>
        </ul>
        <label for="mobile-fly-speed-slider" class="text-sm whitespace-nowrap mt-4 block">Fly Speed:</label>
        <div class="flex items-center gap-2">
            <input type="range" id="mobile-fly-speed-slider" min="0.01" max="1" value="0.1" step="0.01" class="range range-xs w-full">
            <span id="mobile-fly-speed-display" class="font-bold text-primary text-sm">0.10</span>
        </div>
        <div class="modal-action">
            <button id="mobile-reset-defaults" class="btn btn-warning">Reset to Default</button>
            <form method="dialog"><button class="btn">Close</button></form>
        </div>
    </div>
</dialog>
<dialog id="uploadProjectModal" class="modal">
    <div class="modal-box">
        <h3 class="font-bold text-lg">Upload Project to Hub</h3>
        <form method="dialog" class="flex flex-col gap-4 py-4">
            <input type="text" id="uploadTitle" placeholder="Project Title" class="input input-bordered w-full">
            <textarea id="uploadDescription" placeholder="Description" class="textarea textarea-bordered w-full"></textarea>
            <select id="uploadCategory" class="select select-bordered w-full"><option disabled="" selected="">Select Category</option><option value="Toy">Toy</option><option value="Decoration">Decoration</option><option value="Functional">Functional</option><option value="Art">Art</option><option value="General">General</option><option value="Character">Character</option><option value="Vehicle">Vehicle</option><option value="Nature">Nature</option><option value="Architecture">Architecture</option></select>
            <div class="flex gap-4">
                <label><input type="radio" name="uploadVisibility" value="public" checked="" class="radio radio-primary mr-1"> Public</label>
                <label class="flex items-center"><input type="radio" name="uploadVisibility" value="private" class="radio radio-primary mr-1"> Private</label>
            </div>
            <div class="modal-action">
                <button id="uploadConfirmBtn" class="btn btn-success">Upload</button>
                <button class="btn">Cancel</button>
            </div>
        </form>
    </div>
</dialog>
<dialog id="authModal" class="modal">
    <div class="modal-box text-center">
        <h3 class="font-bold text-lg">Login to VoxelShaper Hub</h3>
        <p class="py-4">Choose a login method or use a magic link.</p>
        <div class="py-4 flex flex-col gap-3">
            <button id="signInGoogleBtn" class="btn btn-error text-white">With Google</button>
            <button id="signInGithubBtn" class="btn bg-neutral text-neutral-content">With GitHub</button>
            <form id="magicLinkForm" class="flex flex-col gap-2 w-full mt-4">
                <input type="email" id="magicLinkEmail" placeholder="Enter your email" class="input input-bordered w-full">
                <label class="label cursor-pointer justify-start gap-2">
                    <input type="checkbox" id="agbCheckbox" class="checkbox">
                    <span class="label-text">Hiermit stimme ich den AGBs und Datenschutzbestimmungen zu.</span>
                </label>
                <label class="label cursor-pointer justify-start gap-2">
                    <input type="checkbox" id="newsletterCheckbox" class="checkbox">
                    <span class="label-text">Ich möchte Neuigkeiten und Angebote per E-Mail erhalten.</span>
                </label>
                <button type="submit" class="btn btn-primary">Send Magic Link</button>
            </form>
        </div>
        <form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form>
    </div>
</dialog>
<dialog id="magicLinkVerifyModal" class="modal">
    <div class="modal-box text-center">
        <h3 class="font-bold text-lg">Check your email!</h3>
        <p class="py-4" id="magicLinkVerifyMessage">We've sent a magic link to your email address. Please check your inbox and click the link to log in. You can close this window now.</p>
        <form method="dialog"><button class="btn">Close</button></form>
    </div>
</dialog>
<dialog id="clearConfirmationModal" class="modal">
    <div class="modal-box">
        <h3 class="font-bold text-lg">Clear Scene</h3>
        <p class="py-4">Are you sure you want to clear the entire project? This action cannot be undone.</p>
        <div class="modal-action">
            <button id="confirmClearBtn" class="btn btn-error">Clear All</button>
            <form method="dialog"><button class="btn">Cancel</button></form>
        </div>
    </div>
</dialog>
<dialog id="loadConfirmationModal" class="modal">
    <div class="modal-box">
        <h3 class="font-bold text-lg">Load New Project</h3>
        <p class="py-4">Your current project has unsaved changes. Do you want to overwrite your work with the new project from the Hub?</p>
        <div class="modal-action">
            <button id="confirmLoadBtn" class="btn btn-warning">Overwrite</button>
            <form method="dialog"><button class="btn">Cancel</button></form>
        </div>
    </div>
</dialog>

<div id="toast-container" class="toast toast-top toast-center z-50"></div>
<div id="rotateOverlay" class="orientation-overlay">Bitte ins Hochformat drehen</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>

<script>
const VoxelApp = {
    // --- Configuration ---
    VS: 1,
    GRID_DEFAULT: 10,
    ROTATE_SPEED: 0.003,
    PAN_SPEED: 0.05,
    PINCH_ZOOM_MULT: 50,
    DRAG_THRESHOLD: 5,
    MAX_HISTORY_SIZE: 50,
    BACKEND_URL: "https://api.voxelshaper.com",
    HUB_URL: (window.location.hostname.startsWith('test.') ? 'https://test.hub.voxelshaper.com' : 'https://test.hub.voxelshaper.com'),
    // --- State ---
    scene: null, cam: null, ren: null, gridHelper: null, boxHelper: null,
    euler: null, voxels: new Map(), keyboard: {},
    cvs: null, containerDiv: null,
    currentColor: '#ffffff',
    GRID: 10,
    flySpeed: 0.1,
    currentMode: 'ADD',
    isMobile: false,
    history: [],
    historyPointer: -1,
    currentStroke: null,
    templateImageMesh: null,
    templateImageData: null,
    templateImagePinnedY: null,
    selectedVoxels: new Set(),
    selectionMeshes: new Map(),
    extrudeGizmoMesh: null,
    currentDrawingAxis: 'y',
    activeDrawingLevel: { x: 0, y: 0, z: 0 },
    activePointers: new Map(),
    isPointerDown: false,
    mouseState: {
        isRotating: false, isPanning: false, isModifying: false, isDragging: false, isExtruding: false,
        lastX: 0, lastY: 0, downX: 0, downY: 0,
        lastActionCoords: null, mouseMovementX: 0, mouseMovementY: 0,
        drawingPlane: new THREE.Plane(),
        extrudeNormal: null,
        dragFixedLayerCoord: null,
        isMarqueeSelecting: false,
        marqueeStart: {x: 0, y: 0},
    },
    touchState: {
        isTapCandidate: false, lastPinchDist: null,
    },
    controls: {
        invertLookX: false, invertLookY: false, invertZoom: false,
        invertStrafeX: false, invertStrafeY: false,
    },
    user: null,
    token: null,
    Modes: {
        ADD: { name: 'Add', icon: 'fas fa-plus' },
        DELETE: { name: 'Delete', icon: 'fas fa-trash' },
        DRAW: { name: 'Draw', icon: 'fas fa-paint-brush' }
    },

    computeMobileMode: function () {
      return window.matchMedia('(pointer: coarse)').matches || navigator.maxTouchPoints > 0;
    },
    applyUIMode: function () {
      const mobile = this.computeMobileMode();
      this.isMobile = mobile;
      const desktopBar = document.getElementById('controls');
      const mobileWrap = document.getElementById('mobile-ui-container');
      if (mobile) {
        if (desktopBar) desktopBar.style.display = 'none';
        if (mobileWrap)  mobileWrap.style.display  = 'block';
      } else {
        if (desktopBar) desktopBar.style.display = 'flex';
        if (mobileWrap)  mobileWrap.style.display  = 'none';
      }
      document.body.classList.toggle('has-mobile-bar', this.isMobile);
    },
    tryLockOrientation: async function () {
      if ('orientation' in screen && screen.orientation && screen.orientation.lock) {
        try { await screen.orientation.lock('portrait'); } catch (e) { /* Not allowed by browser */ }
      }
    },
    updateOrientationOverlay: function () {
      const isPortrait = window.matchMedia('(orientation: portrait)').matches;
      const isTouch = this.computeMobileMode();
      const overlay = document.getElementById('rotateOverlay');
      const show = isTouch && !isPortrait;
      overlay.classList.toggle('show', show);
      this.cvs.style.pointerEvents = show ? 'none' : 'auto';
      document.body.style.overflow = show ? 'hidden' : '';
    },

    init: function() {
        this.setupDOM();
        this.applyUIMode();
        this.tryLockOrientation();
        this.updateOrientationOverlay();
        this.setupThree();
        this.setupEventListeners();
        
        const urlParams = new URLSearchParams(window.location.search);
        if (!urlParams.has('modelId') && !window.location.hash.includes('#oauth_success')) {
            this.loadAutosavedScene();
        }

        const oneTimeLock = () => {
            this.tryLockOrientation();
            window.removeEventListener('pointerdown', oneTimeLock);
            window.removeEventListener('click', oneTimeLock);
        };
        window.addEventListener('pointerdown', oneTimeLock, { once: true });
        window.addEventListener('click', oneTimeLock, { once: true });
        this.authCheckAndInit();
        this.handleResize();
        this.animate();
        setInterval(() => this.autosaveScene(), 60000); // Autosave every 60 seconds
        console.log("VoxelShaper Initialized");
    },
    
    request: async function(endpoint, options = {}) {
        const url = `${this.BACKEND_URL}${endpoint}`;
        const mergedOptions = {
            credentials: 'include',
            ...options,
            headers: { ...(options.headers || {}) }
        };
        const method = (mergedOptions.method || 'GET').toUpperCase();
        if (['POST', 'PUT', 'DELETE', 'PATCH'].includes(method)) {
            try {
                const csrfResponse = await fetch(`${this.BACKEND_URL}/auth/csrf`, { credentials: 'include' });
                if (!csrfResponse.ok) throw new Error(`CSRF token fetch failed with status ${csrfResponse.status}`);
                const { token } = await csrfResponse.json();
                mergedOptions.headers['X-CSRF-Token'] = token;
            } catch (csrfError) {
                console.error("CSRF Token fetch error:", csrfError);
                this.showToast('Security Error', 'Could not verify your session. Please refresh and try again.', 'error');
                throw csrfError;
            }
        }
        const response = await fetch(url, mergedOptions);
        const contentType = response.headers.get('content-type');
        const isJson = contentType && contentType.includes('application/json');
        let data;
        if (response.status !== 204) {
            data = isJson ? await response.json() : await response.text();
        }
        if (!response.ok) {
            const errorMessage = isJson ? (data.error || JSON.stringify(data)) : data;
            throw new Error(errorMessage || `Request to ${endpoint} failed with status ${response.status}`);
        }
        return data;
    },
    // --- NEW: Function to generate a model name using the AI route ---
    generateAiModelName: async function() {
        if (this.voxels.size === 0) return ''; // No voxels, no name

        // 1. Analyze the scene for a prompt
        const colorCounts = {};
        this.voxels.forEach(voxel => {
            colorCounts[voxel.color] = (colorCounts[voxel.color] || 0) + 1;
        });

        const sortedColors = Object.entries(colorCounts).sort(([,a],[,b]) => b-a);
        const topColors = sortedColors.slice(0, 2).map(([color]) => color.replace('#', '')); // Get hex without #

        // 2. Formulate a very short, generic prompt to stay under the 20-character limit
        let prompt = `${this.voxels.size} blocks`;
        if (topColors.length > 0) {
            prompt += ` ${topColors[0]}`; // Add the most prominent color
        }
        prompt = prompt.slice(0, 20); // Enforce API limit

        try {
            this.showToast('AI Naming...', 'Generating a smart title...', 'info', 2000);
            const response = await this.request('/api/ai/short-prompt', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ prompt: prompt })
            });

            if (response && response.response) {
                // Clean up the AI's response, removing any quotes it might have added
                let cleanName = response.response.replace(/^"|"$/g, '').trim();
                return cleanName;
            }
            return ''; // Return empty if AI gives a blank response
        } catch (error) {
            console.error("AI name generation failed:", error);
            // Fail silently without showing an error toast to the user. They can still type a name.
            return '';
        }
    },
    // --- END NEW FUNCTION ---
    handleOAuthRedirect: async function() {
        if (window.location.hash.includes('#oauth_success')) {
            try {
                const user = await this.request('/api/user/me');
                this.user = user;
                this.updateLoginStateUI();
                this.showToast('Login Successful', 'You are now logged in via OAuth!', 'info');
            } catch (e) {
                console.error("OAuth redirect user fetch failed:", e);
                this.showToast('Login Error', 'Failed to retrieve user data after OAuth.', 'error');
            } finally {
                window.history.replaceState({}, document.title, window.location.pathname);
            }
        }
    },
    authCheckAndInit: async function() {
        const unsavedData = sessionStorage.getItem('unsavedVoxelData');
        if (unsavedData) {
            try {
                const data = JSON.parse(unsavedData);
                this.loadFromData(data);
                this.showToast('Progress Restored', 'Your work has been successfully restored.', 'info');
            } catch (e) {
                console.error("Failed to restore work from session storage:", e);
                this.showToast('Error', 'Could not restore your previous work.', 'error');
            } finally {
                sessionStorage.removeItem('unsavedVoxelData');
            }
        }
        await this.handleOAuthRedirect();
        const urlParams  = new URLSearchParams(window.location.search || '');
        const hashParams = new URLSearchParams((window.location.hash || '').slice(1));
        const magicLinkToken = urlParams.get('token') || hashParams.get('token');
        if (!this.user && magicLinkToken) {
            try {
                const response = await this.request('/auth/verify-magic-link', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ token: magicLinkToken })
                });
                this.user = response.user;
                this.updateLoginStateUI();
                this.showToast('Login Successful', 'You are now logged in!', 'info');
            } catch (e) {
                this.showToast('Login Error', e.message, 'error');
            } finally {
                const clean = new URL(window.location.href);
                clean.searchParams.delete('token');
                clean.hash = '';
                window.history.replaceState({}, document.title, clean.toString());
            }
        }
        if (!this.user) {
            try {
                const user = await this.request('/api/user/me');
                this.user = user;
                this.updateLoginStateUI();
            } catch (e) {
                // This is a normal case for non-logged-in users, so no toast.
            }
        }
        const urlModelId = urlParams.get('modelId');
        if (urlModelId) {
            if (this.voxels.size > 0) {
                // Scene is not empty, prompt for confirmation
                document.getElementById('loadConfirmationModal').showModal();
                document.getElementById('confirmLoadBtn').onclick = () => {
                    this.loadProjectFromModelId(urlModelId);
                    document.getElementById('loadConfirmationModal').close();
                };
            } else {
                // Scene is empty, load directly
                this.loadProjectFromModelId(urlModelId);
            }
            const newUrl = new URL(window.location);
            newUrl.searchParams.delete('modelId');
            window.history.replaceState({}, document.title, newUrl.pathname);
        }
    },
    
    setupDOM: function() {
        this.cvs = document.getElementById('voxelCanvas');
        this.containerDiv = document.getElementById('container');
        this.marqueeElement = document.getElementById('marquee');
        const categories = ["Toy", "Decoration", "Functional", "Art", "General", "Character", "Vehicle", "Nature", "Architecture"];
        const categorySelect = document.getElementById('uploadCategory');
        categories.forEach(cat => {
            const opt = document.createElement('option');
            opt.value = cat;
            opt.textContent = cat;
            categorySelect.appendChild(opt);
        });
        this.GRID = parseInt(localStorage.getItem('voxelEditorGridSize') || this.GRID_DEFAULT);
        this.currentColor = localStorage.getItem('voxelEditorColor') || '#ffffff';
        this.flySpeed = parseFloat(localStorage.getItem('voxelEditorFlySpeed') || 0.1);
        this.controls.invertLookX = localStorage.getItem('invertLookX') === 'true';
        this.controls.invertLookY = localStorage.getItem('invertLookY') === 'true';
        this.controls.invertZoom = localStorage.getItem('invertZoom') === 'true';
        this.controls.invertStrafeX = localStorage.getItem('invertStrafeX') === 'true';
        this.controls.invertStrafeY = localStorage.getItem('invertStrafeY') === 'true';
        this.currentDrawingAxis = localStorage.getItem('currentDrawingAxis') || 'y';
        this.activeDrawingLevel = JSON.parse(localStorage.getItem('activeDrawingLevel')) || { x: 0, y: 0, z: 0 };
        const agbChecked = localStorage.getItem('agbCheckbox');
        const newsletterChecked = localStorage.getItem('newsletterCheckbox');
        if (agbChecked !== null) {
            document.getElementById('agbCheckbox').checked = agbChecked === 'true';
        }
        document.getElementById('newsletterCheckbox').checked = newsletterChecked ? (newsletterChecked === 'true') && !this.computeMobileMode() : false;
        this.updateAllControlInputs();
    },

    setupThree: function() {
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x282c34);
        this.cam = new THREE.PerspectiveCamera(75, this.containerDiv.clientWidth / this.containerDiv.clientHeight, 0.1, 1000);
        this.euler = new THREE.Euler(0, 0, 0, 'YXZ');
        this.resetCamera();
        this.ren = new THREE.WebGLRenderer({ canvas: this.cvs, antialias: true, logarithmicDepthBuffer: true });
        this.ren.shadowMap.enabled = true;
        this.ren.shadowMap.type = THREE.PCFSoftShadowMap;
        this.scene.add(new THREE.AmbientLight(0x606060));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(10, 20, 15);
        dirLight.castShadow = true;
        this.scene.add(dirLight);
        this.scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.6));
        this.previewVoxel = new THREE.Mesh(
            new THREE.BoxGeometry(this.VS, this.VS, this.VS),
            new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5, depthTest: false })
        );
        this.previewVoxel.visible = false;
        this.scene.add(this.previewVoxel);
        const extrudeGizmoGeometry = new THREE.PlaneGeometry(this.VS, this.VS);
        const extrudeGizmoMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
        this.extrudeGizmoMesh = new THREE.Mesh(extrudeGizmoGeometry, extrudeGizmoMaterial);
        this.extrudeGizmoMesh.visible = false;
        this.scene.add(this.extrudeGizmoMesh);
        this.rebuildHelpers();
    },
    
    setupEventListeners: function() {
        window.addEventListener('resize', () => this.handleResize());
        window.addEventListener('resize', () => this.updateOrientationOverlay());
        window.addEventListener('orientationchange', () => this.updateOrientationOverlay());
        this.containerDiv.addEventListener('pointerdown', (e) => this.onPointerDown(e));
        this.containerDiv.addEventListener('pointermove', (e) => this.onPointerMove(e));
        this.containerDiv.addEventListener('pointerup', (e) => this.onPointerUp(e));
        this.containerDiv.addEventListener('pointerleave', (e) => this.onPointerUp(e));
        this.containerDiv.addEventListener('pointercancel', (e) => this.onPointerUp(e));
        this.containerDiv.addEventListener('wheel', (e) => this.onMouseWheel(e), { passive: false });
        window.addEventListener('keydown', (e) => this.onKeyDown(e));
        window.addEventListener('keyup', (e) => this.onKeyUp(e));
        this.cvs.addEventListener('contextmenu', (e) => e.preventDefault());
        document.addEventListener('pointerlockchange', this.onPointerLockChange.bind(this), false);
        const gridSizeSlider = document.getElementById('grid-size-slider');
        if (gridSizeSlider) gridSizeSlider.addEventListener('input', (e) => this.setGridSize(parseInt(e.target.value)));
        const flySpeedSlider = document.getElementById('fly-speed-slider');
        if (flySpeedSlider) flySpeedSlider.addEventListener('input', (e) => this.setFlySpeed(parseFloat(e.target.value)));
        document.getElementById('color-picker-input').addEventListener('input', (e) => this.setColor(e.target.value));
        document.getElementById('modeToggle').addEventListener('click', () => this.cycleMode());
        document.getElementById('clearBtn').addEventListener('click', () => document.getElementById('clearConfirmationModal').showModal());
        document.getElementById('saveBtn').addEventListener('click', () => this.saveJSON());
        document.getElementById('loadBtn').addEventListener('click', () => document.getElementById('fileInput').click());
        document.getElementById('exportBtn').addEventListener('click', () => document.getElementById('exportOptionsModal').showModal());
        document.getElementById('fileInput').addEventListener('change', (e) => this.loadJSON(e));
        document.getElementById('loadImageBtn').addEventListener('click', () => this.loadImageTemplate());
        document.getElementById('removeImageBtn').addEventListener('click', () => this.removeImageTemplate());
        document.getElementById('imageFileInput').addEventListener('change', (e) => this.handleImageFileSelect(e));
        document.getElementById('cycleAxisBtn').addEventListener('click', () => this.cycleDrawingAxis());
        document.getElementById('levelUpBtn').addEventListener('click', () => this.moveDrawingLevel(1));
        document.getElementById('levelDownBtn').addEventListener('click', () => this.moveDrawingLevel(-1));
        document.getElementById('invertLookX').addEventListener('change', (e) => this.setControl('invertLookX', e.target.checked));
        document.getElementById('invertLookY').addEventListener('change', (e) => this.setControl('invertLookY', e.target.checked));
        document.getElementById('invertZoom').addEventListener('change', (e) => this.setControl('invertZoom', e.target.checked));
        document.getElementById('invertStrafeX').addEventListener('change', (e) => this.setControl('invertStrafeX', e.target.checked));
        document.getElementById('invertStrafeY').addEventListener('change', (e) => this.setControl('invertStrafeY', e.target.checked));
        document.getElementById('resetDefaultsBtn').addEventListener('click', () => this.resetToDefaults());
        document.getElementById('resetCameraBtn').addEventListener('click', () => this.resetCamera());
        document.getElementById('undoBtn').addEventListener('click', () => this.undo());
        document.getElementById('redoBtn').addEventListener('click', () => this.redo());
        document.getElementById('mobile-mode-toggle').addEventListener('click', () => this.cycleMode());
        document.getElementById('mobile-color-picker').addEventListener('input', (e) => this.setColor(e.target.value));
        const mobileUploadBtn = document.getElementById('mobile-upload');
        if (mobileUploadBtn) mobileUploadBtn.addEventListener('click', () => document.getElementById('uploadProjectModal').showModal());
        document.getElementById('mobile-undo').addEventListener('click', () => this.undo());
        document.getElementById('mobile-redo').addEventListener('click', () => this.redo());
        document.getElementById('mobile-go-to-hub').addEventListener('click', () => window.open(this.HUB_URL, '_blank', 'noopener,noreferrer'));
        document.getElementById('mobile-reset-camera').addEventListener('click', () => this.resetCamera());
        document.getElementById('mobileInvertLookX').addEventListener('change', (e) => this.setControl('invertLookX', e.target.checked));
        document.getElementById('mobileInvertLookY').addEventListener('change', (e) => this.setControl('invertLookY', e.target.checked));
        document.getElementById('mobileInvertZoom').addEventListener('change', (e) => this.setControl('invertZoom', e.target.checked));
        document.getElementById('mobileInvertStrafeX').addEventListener('change', (e) => this.setControl('invertStrafeX', e.target.checked));
        document.getElementById('mobileInvertStrafeY').addEventListener('change', (e) => this.setControl('invertStrafeY', e.target.checked));
        document.getElementById('mobile-reset-defaults').addEventListener('click', () => this.resetToDefaults());
        const mobileFlySpeedSlider = document.getElementById('mobile-fly-speed-slider');
        if (mobileFlySpeedSlider) mobileFlySpeedSlider.addEventListener('input', (e) => this.setFlySpeed(parseFloat(e.target.value)));

        document.getElementById('mobile-cycle-axis').addEventListener('click', () => this.cycleDrawingAxis());
        document.getElementById('mobile-level-up').addEventListener('click', () => this.moveDrawingLevel(1));
        document.getElementById('mobile-level-down').addEventListener('click', () => this.moveDrawingLevel(-1));
        const mobileLoginLogoutBtn = document.getElementById('mobile-login-logout');
        if (mobileLoginLogoutBtn) mobileLoginLogoutBtn.addEventListener('click', this.loginLogout.bind(this));

        document.getElementById('saveBtnMobile').addEventListener('click', () => this.saveJSON());
        document.getElementById('loadBtnMobile').addEventListener('click', () => document.getElementById('fileInput').click());
        document.getElementById('exportBtnMobile').addEventListener('click', () => document.getElementById('exportOptionsModal').showModal());
        document.getElementById('loadImageBtnMobile').addEventListener('click', () => this.loadImageTemplate());
        document.getElementById('removeImageBtnMobile').addEventListener('click', () => this.removeImageTemplate());
        document.getElementById('clearBtnMobile').addEventListener('click', () => document.getElementById('clearConfirmationModal').showModal());
        
        document.getElementById('loginLogoutBtn').addEventListener('click', this.loginLogout.bind(this));
        document.getElementById('goToHubBtn').addEventListener('click', () => {
            const w = window.open(this.HUB_URL, '_blank', 'noopener,noreferrer');
            if (w) w.opener = null;
        });
        const handleUploadClick = async () => {
            document.getElementById('uploadTitle').value = '';
            document.getElementById('uploadProjectModal').showModal();
            const aiName = await this.generateAiModelName();
            if (aiName) {
                document.getElementById('uploadTitle').value = aiName;
            }
        };
        document.getElementById('uploadToHubBtn').addEventListener('click', handleUploadClick.bind(this));
        const mobileUploadBtn2 = document.getElementById('mobile-upload');
        if (mobileUploadBtn2) mobileUploadBtn2.addEventListener('click', handleUploadClick.bind(this));
        document.getElementById('uploadConfirmBtn').addEventListener('click', (e) => {
            e.preventDefault();
            this.uploadProjectToHub();
            document.getElementById('uploadProjectModal').close();
        });
        document.getElementById('signInGoogleBtn').addEventListener('click', () => this.signInWithProvider('google'));
        document.getElementById('signInGithubBtn').addEventListener('click', () => this.signInWithProvider('github'));
        document.getElementById('magicLinkForm').addEventListener('submit', (e) => {
            e.preventDefault();
            this.sendMagicLink();
        });
        document.getElementById('agbCheckbox').addEventListener('change', (e) => localStorage.setItem('agbCheckbox', e.target.checked));
        document.getElementById('newsletterCheckbox').addEventListener('change', (e) => localStorage.setItem('newsletterCheckbox', e.target.checked));
        document.getElementById('confirmClearBtn').addEventListener('click', () => {
            this.clearAllConfirmed();
            document.getElementById('clearConfirmationModal').close();
        });
        document.getElementById('confirmExportBtn').addEventListener('click', () => {
            const scaleUnit = document.querySelector('input[name="exportScaleUnit"]:checked').value;
            const upAxis = document.querySelector('input[name="exportUpAxis"]:checked').value;
            this.exportSTL(scaleUnit, upAxis);
            document.getElementById('exportOptionsModal').close();
        });
        
        let lastTouchEnd = 0;
        this.containerDiv.addEventListener('touchend', (e) => {
          const now = Date.now();
          if (now - lastTouchEnd <= 300) {
            e.preventDefault();
          }
          lastTouchEnd = now;
        }, { passive: false });
        this.containerDiv.addEventListener('dblclick', (e) => e.preventDefault(), { passive: false });
        document.addEventListener('selectstart', (e) => {
          if (!e.target.closest('input, textarea, select, [contenteditable]')) e.preventDefault();
        }, { passive: false });
        window.addEventListener('gesturestart', (e) => e.preventDefault(), { passive: false });

        document.addEventListener('click', (e) => {
            const isDropdown = e.target.closest('.dropdown');
            const dropdowns = document.querySelectorAll('.dropdown');
            if (isDropdown) {
                const wasOpen = isDropdown.classList.contains('dropdown-open');
                dropdowns.forEach(d => {
                    d.classList.remove('dropdown-open');
                    const label = d.querySelector('label');
                    if (label) {
                        label.blur();
                    }
                });
                if (!wasOpen) {
                    isDropdown.classList.add('dropdown-open');
                }
            } else {
                dropdowns.forEach(d => {
                    d.classList.remove('dropdown-open');
                    const label = d.querySelector('label');
                    if (label) {
                        label.blur();
                    }
                });
            }
        });

    },

    uploadProjectToHub: async function() {
        if (!this.user) {
            this.showToast('Error', 'You must be logged in to upload.', 'error');
            return;
        }
        if (this.voxels.size === 0) {
            this.showToast('Error', 'Cannot upload an empty project.', 'error');
            return;
        }
        const title = document.getElementById('uploadTitle').value;
        if (!title) {
            this.showToast('Error', 'Title is required.', 'error');
            return;
        }
        this.showToast('Uploading...', 'Please wait...', 'info');
        const projectData = {
            gridSize: this.GRID,
            voxels: Object.fromEntries(
                Array.from(this.voxels.entries()).map(([k, v]) => {
                    const [x, y, z] = this.parseKey(k);
                    return [`${x},${y},${z}`, v.color];
                })
            )
        };
        const hubDocument = {
            name: title,
            description: document.getElementById('uploadDescription').value,
            category: document.getElementById('uploadCategory').value,
            visibility: document.querySelector('input[name="uploadVisibility"]:checked').value,
            project_json: projectData
        };
        try {
            const response = await this.request('/api/models', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(hubDocument)
            });
            this.showToast('Upload Successful!', `Project saved. Model ID: ${response.public_id}`, 'info');
        } catch (error) {
            this.showToast('Upload Failed', error.message, 'error');
        }
    },

    loadProjectFromModelId: async function(modelId) {
        this.showToast('Loading Project...', `Fetching model ${modelId}`, 'info');
        try {
            const data = await this.request(`/api/models/${modelId}`);
            
            const projectData = data.project_json;
            if (!projectData || !projectData.voxels || typeof projectData.voxels !== 'object') {
                throw new Error("Invalid or empty project data received from API.");
            }

            this.voxels.forEach(v => {
                this.scene.remove(v.mesh);
                v.mesh.geometry.dispose();
                v.mesh.material.dispose();
            });
            this.voxels.clear();

            let maxX = 0, maxY = 0, maxZ = 0;
            for (const key in projectData.voxels) {
                if (Object.prototype.hasOwnProperty.call(projectData.voxels, key)) {
                    const coords = key.split(',').map(Number);
                    if (coords.length === 3) {
                        const [x, y, z] = coords;
                        if (x > maxX) maxX = x;
                        if (y > maxY) maxY = y;
                        if (z > maxZ) maxZ = z;
                        const k = this.key(x, y, z);
                        this.voxels.set(k, { color: projectData.voxels[key] });
                    }
                }
            }

            const requiredGridSize = Math.max(maxX, maxY, maxZ) + 1;
            const finalGridSize = Math.max(requiredGridSize, projectData.gridSize || this.GRID_DEFAULT);
            this.setGridSize(finalGridSize);
            
            this.rebuildSceneFromVoxels();
            this.resetCamera();
            this.history = []; this.historyPointer = -1;
            this.autosaveScene();
            this.showToast('Project Loaded', `Loaded "${data.name}"`, 'info');

        } catch (error) {
            console.error("Failed to load project from Hub:", error);
            this.showToast('Load Error', error.message, 'error');
        }
    },

    onPointerDown: function(e) {
        e.preventDefault();
        
        if (this.isMobile && e.button === 0 && this.currentMode === 'DELETE') {
            this.mouseState.isModifying = true;
            this.mouseState.downX = e.clientX;
            this.mouseState.downY = e.clientY;
            const coords = this.calculateRayTarget(e.clientX, e.clientY);
            if (coords) {
                this.modifyVoxel(coords.x, coords.y, coords.z);
                this.mouseState.lastActionCoords = coords;
            }
            return;
        }

        if (this.isMobile) {
            this.isPointerDown = true;
            this.activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
            if (this.activePointers.size === 1) {
                this.touchState.isTapCandidate = true;
                this.mouseState.downX = e.clientX;
                this.mouseState.downY = e.clientY;
            } else {
                this.touchState.isTapCandidate = false;
            }
        } else {
            this.mouseState.downX = e.clientX;
            this.mouseState.downY = e.clientY;
            if (e.button === 0) {
                if (this.currentMode !== 'SELECT') {
                    this.mouseState.isModifying = true;
                    const coords = this.calculateRayTarget(e.clientX, e.clientY);
                    if (coords) {
                        if (this.currentMode === 'ADD') {
                            this.mouseState.dragFixedLayerCoord = coords[this.currentDrawingAxis];
                        }
                        this.modifyVoxel(coords.x, coords.y, coords.z);
                        this.mouseState.lastActionCoords = coords;
                    }
                }
            } else if (e.button === 1) {
                this.mouseState.isPanning = true;
            } else if (e.button === 2) {
                this.cvs.focus();
                this.cvs.requestPointerLock();
            }
            this.mouseState.lastX = e.clientX;
            this.mouseState.lastY = e.clientY;
        }
    },
    
    onPointerMove: function(e) {
        e.preventDefault();
        if (document.pointerLockElement === this.cvs) {
            const rotX = this.controls.invertLookX ? e.movementX : -e.movementX;
            const rotY = this.controls.invertLookY ? e.movementY : -e.movementY;
            this.euler.y += rotX * this.ROTATE_SPEED;
            this.euler.x += rotY * this.ROTATE_SPEED;
            this.euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.euler.x));
            this.cam.quaternion.setFromEuler(this.euler);
            return;
        }

        const deltaX = e.clientX - this.mouseState.lastX;
        const deltaY = e.clientY - this.mouseState.lastY;

        if (this.isMobile) {
            if (!this.isPointerDown) return;
            const dist = Math.hypot(e.clientX - this.mouseState.downX, e.clientY - this.mouseState.downY);
            if (dist > this.DRAG_THRESHOLD) this.touchState.isTapCandidate = false;

            if (this.mouseState.isModifying) { 
                let coords = this.calculateRayTarget(e.clientX, e.clientY);
                if (coords && this.mouseState.lastActionCoords) {
                    this.drawVoxelLine(this.mouseState.lastActionCoords, coords);
                    this.mouseState.lastActionCoords = coords;
                }
            } else {
                const currentPointer = this.activePointers.get(e.pointerId);
                if (!currentPointer) return;
                if (this.activePointers.size === 1 && !this.touchState.isTapCandidate) {
                    this.euler.y -= (this.controls.invertLookX ? -deltaX : deltaX) * this.ROTATE_SPEED;
                    this.euler.x -= (this.controls.invertLookY ? -deltaY : deltaY) * this.ROTATE_SPEED;
                } else if (this.activePointers.size === 2) {
                    const pointers = Array.from(this.activePointers.values());
                    const newDist = Math.hypot(pointers[0].x - pointers[1].x, pointers[0].y - pointers[1].y);
                    if (!this.touchState.lastPinchDist) this.touchState.lastPinchDist = newDist;
                    let zoomDelta = (this.touchState.lastPinchDist - newDist) * this.PINCH_ZOOM_MULT * 0.001;
                    if (this.controls.invertZoom) zoomDelta *= -1;
                    this.cam.position.addScaledVector(this.cam.getWorldDirection(new THREE.Vector3()), zoomDelta);
                    this.touchState.lastPinchDist = newDist;
                }
            }
            this.activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
        } else {
            if (this.mouseState.isPanning) {
                const pan = new THREE.Vector3(-deltaX * this.PAN_SPEED, deltaY * this.PAN_SPEED, 0);
                pan.applyQuaternion(this.cam.quaternion);
                this.cam.position.add(pan);
            }
            if (this.mouseState.isModifying) {
                const dist = Math.hypot(e.clientX - this.mouseState.downX, e.clientY - this.mouseState.downY);
                if (dist > this.DRAG_THRESHOLD) {
                    this.mouseState.isDragging = true;
                    let coords = this.calculateRayTarget(e.clientX, e.clientY);
                    if (coords) {
                        if (this.currentMode === 'ADD') {
                            coords[this.currentDrawingAxis] = this.mouseState.dragFixedLayerCoord;
                        }
                        if (this.mouseState.lastActionCoords && (coords.x !== this.mouseState.lastActionCoords.x || coords.y !== this.mouseState.lastActionCoords.y || coords.z !== this.mouseState.lastActionCoords.z)) {
                            this.drawVoxelLine(this.mouseState.lastActionCoords, coords);
                            this.mouseState.lastActionCoords = coords;
                        }
                    }
                }
            }
            this.mouseState.lastX = e.clientX;
            this.mouseState.lastY = e.clientY;
        }
        if (!this.mouseState.isModifying && !this.mouseState.isPanning && !this.isPointerDown && document.pointerLockElement !== this.cvs) {
              const coords = this.calculateRayTarget(e.clientX, e.clientY);
              this.updatePreviewVoxel(coords);
        } else {
            this.previewVoxel.visible = false;
        }
        this.euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.euler.x));
        this.cam.quaternion.setFromEuler(this.euler);
    },
    
    onPointerUp: function(e) {
        e.preventDefault();
        if (this.mouseState.isModifying && this.currentStroke && this.currentStroke.size > 0) {
            const actualChanges = new Map();
            for (const [key, value] of this.currentStroke.entries()) {
                const beforeColor = value.before ? value.before.color : null;
                const afterColor = value.after ? value.after.color : null;
                if (beforeColor !== afterColor) {
                    actualChanges.set(key, value);
                }
            }
            if (actualChanges.size > 0) {
                this.addHistoryStep(actualChanges);
            }
        }
        this.currentStroke = null;
        if (this.isMobile) {
            if (this.isPointerDown && this.touchState.isTapCandidate && this.currentMode !== 'DELETE') { 
                const coords = this.calculateRayTarget(this.mouseState.downX, this.mouseState.downY);
                if (coords) this.modifyVoxel(coords.x, coords.y, coords.z);
            }
            this.activePointers.delete(e.pointerId);
            if (this.activePointers.size === 0) {
                this.isPointerDown = false;
                this.touchState.isTapCandidate = false;
                this.touchState.lastPinchDist = null;
            }
        } else {
            if (e.button === 2 && document.pointerLockElement === this.cvs) {
                document.exitPointerLock();
            }
        }
        this.mouseState.isModifying = false;
        this.mouseState.isPanning = false;
        this.mouseState.isRotating = false;
        this.mouseState.isDragging = false;
        this.mouseState.lastActionCoords = null;
        this.mouseState.dragFixedLayerCoord = null;
    },

    onPointerLockChange: function() {
        if (document.pointerLockElement === this.cvs) {
            this.mouseState.isRotating = true;
            this.previewVoxel.visible = false;
        } else {
            this.mouseState.isRotating = false;
        }
    },

    onMouseWheel: function(e) {
        e.preventDefault();
        if (e.altKey) {
            const direction = -Math.sign(e.deltaY);
            this.moveDrawingLevel(direction);
            return;
        }
        if (document.pointerLockElement === this.cvs) {
            const speedChange = e.deltaY > 0 ? -0.01 : 0.01;
            const newSpeed = this.flySpeed + speedChange;
            this.setFlySpeed(newSpeed);
        } else {
            let zoomAmount = e.deltaY * 0.001 * this.PINCH_ZOOM_MULT;
            if (this.controls.invertZoom) zoomAmount *= -1;
            this.cam.position.addScaledVector(this.cam.getWorldDirection(new THREE.Vector3()), zoomAmount);
        }
    },
    
    onKeyDown: function(e) {
        if (e.code === 'Space') {
            e.preventDefault();
            if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA' && e.target.tagName !== 'SELECT') {
                this.cycleMode();
            }
            return;
        }
         if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
            e.preventDefault();
            if (e.shiftKey) this.redo(); else this.undo();
            return;
        }
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;
        this.keyboard[e.key.toLowerCase()] = true;
    },
    
    onKeyUp: function(e) { this.keyboard[e.key.toLowerCase()] = false; },
    
    handleResize: function() {
        this.ren.setSize(this.containerDiv.clientWidth, this.containerDiv.clientHeight);
        this.cam.aspect = this.containerDiv.clientWidth / this.containerDiv.clientHeight;
        this.cam.updateProjectionMatrix();
        this.ren.setPixelRatio(this.isMobile ? 1.5 : window.devicePixelRatio);
        this.applyUIMode();
    },

    key: (x, y, z) => (x | (y << 10) | (z << 20)) >>> 0,
    parseKey: (k) => [k & 1023, (k >> 10) & 1023, (k >> 20) & 1023],

    setGridSize: function(newSize) {
        let minSize = 5;
        if (this.voxels.size > 0) {
            let maxX = 0, maxY = 0, maxZ = 0;
            this.voxels.forEach((v,k) => {
                const [x,y,z] = this.parseKey(k);
                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
                if (z > maxZ) maxZ = z;
            });
            minSize = Math.max(maxX, maxY, maxZ) + 1;
        }
        const slider = document.getElementById('grid-size-slider');
        if (slider) slider.value = newSize;
        const gridSizeDisplay = document.getElementById('grid-size-display');
        if (gridSizeDisplay) gridSizeDisplay.textContent = `${newSize}³`;
        this.GRID = newSize;
        localStorage.setItem('voxelEditorGridSize', this.GRID);
        this.updateAllControlInputs();
        this.rebuildHelpers();
        this.resetCamera();
        this.updateTemplateImagePosition();
    },
    
    setColor: function(newColor) {
        this.currentColor = newColor;
        localStorage.setItem('voxelEditorColor', this.currentColor);
        this.updateAllControlInputs();
        this.previewVoxel.material.color.set(this.currentColor);
    },

    setFlySpeed: function(newSpeed) {
        const minSpeed = 0.01;
        const maxSpeed = 1.0;
        this.flySpeed = Math.max(minSpeed, Math.min(maxSpeed, newSpeed));
        const flySpeedDisplay = document.getElementById('fly-speed-display');
        if (flySpeedDisplay) flySpeedDisplay.textContent = this.flySpeed.toFixed(2);
        const flySpeedSlider = document.getElementById('fly-speed-slider');
        if (flySpeedSlider) flySpeedSlider.value = this.flySpeed;
        const mobileFlySpeedSlider = document.getElementById('mobile-fly-speed-slider');
        if (mobileFlySpeedSlider) mobileFlySpeedSlider.value = this.flySpeed;
        const mobileFlySpeedDisplay = document.getElementById('mobile-fly-speed-display');
        if (mobileFlySpeedDisplay) mobileFlySpeedDisplay.textContent = this.flySpeed.toFixed(2);
        localStorage.setItem('voxelEditorFlySpeed', this.flySpeed);
    },
    
    setControl: function(controlName, value) {
        if (this.controls.hasOwnProperty(controlName)) {
            this.controls[controlName] = value;
            localStorage.setItem(controlName, value);
            this.updateAllControlInputs();
            this.showToast('Setting Changed', `${controlName.replace('invert', 'Invert ')} is now ${value ? 'On' : 'Off'}`, 'info', 1000);
        }
    },

    cycleMode: function() {
        const modeKeys = Object.keys(this.Modes);
        const currentIndex = modeKeys.indexOf(this.currentMode);
        this.currentMode = modeKeys[(currentIndex + 1) % modeKeys.length];
        this.updateModeUI();
    },

    modifyVoxel: function(x, y, z) {
        x = Math.max(0, Math.min(this.GRID - 1, x));
        y = Math.max(0, Math.min(this.GRID - 1, y));
        z = Math.max(0, Math.min(this.GRID - 1, z));
        const k = this.key(x, y, z);
        if (this.currentStroke && !this.currentStroke.has(k)) {
            const originalVoxel = this.voxels.get(k);
            this.currentStroke.set(k, {
                before: originalVoxel ? { color: originalVoxel.color } : null
            });
        }
        const existingVoxel = this.voxels.get(k);
        let modified = false;
        switch (this.currentMode) {
            case 'ADD':
                if (!existingVoxel) {
                    const voxelMesh = new THREE.Mesh(new THREE.BoxGeometry(this.VS, this.VS, this.VS), new THREE.MeshLambertMaterial({ color: this.currentColor }));
                    voxelMesh.position.set(x * this.VS + 0.5, y * this.VS + 0.5, z * this.VS + 0.5);
                    voxelMesh.castShadow = true;
                    voxelMesh.receiveShadow = true;
                    this.scene.add(voxelMesh);
                    this.voxels.set(k, { color: this.currentColor, mesh: voxelMesh });
                    modified = true;
                }
                break;
            case 'DELETE':
                if (existingVoxel) {
                    this.scene.remove(existingVoxel.mesh);
                    existingVoxel.mesh.geometry.dispose();
                    existingVoxel.mesh.material.dispose();
                    this.voxels.delete(k);
                    modified = true;
                }
                break;
            case 'DRAW':
                if (existingVoxel && existingVoxel.color !== this.currentColor) {
                    existingVoxel.mesh.material.color.set(this.currentColor);
                    this.voxels.get(k).color = this.currentColor;
                    modified = true;
                }
                break;
        }
        if (this.currentStroke && modified) {
            const finalVoxel = this.voxels.get(k);
            const historyEntry = this.currentStroke.get(k);
            historyEntry.after = finalVoxel ? { color: finalVoxel.color } : null;
        }
    },
    
    drawVoxelLine: function(start, end) {
        let x0 = start.x, y0 = start.y, z0 = start.z;
        let x1 = end.x, y1 = end.y, z1 = end.z;
        const dx = Math.abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
        const dy = Math.abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
        const dz = Math.abs(z1 - z0), sz = z0 < z1 ? 1 : -1;
        let dm = Math.max(dx, dy, dz), i = dm;
        x1 = y1 = z1 = dm / 2;
        while(i-- >= 0) {
            this.modifyVoxel(x0, y0, z0);
            x1 -= dx; if (x1 < 0) { x1 += dm; x0 += sx; }
            y1 -= dy; if (y1 < 0) { y1 += dm; y0 += sy; }
            z1 -= dz; if (z1 < 0) { z1 += dm; z0 += sz; }
        }
    },

    calculateRayTarget: function(clientX, clientY) {
        const rect = this.cvs.getBoundingClientRect();
        const mouse = new THREE.Vector2(((clientX - rect.left) / rect.width) * 2 - 1, -((clientY - rect.top) / rect.height) * 2 + 1);
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, this.cam);
        const meshes = Array.from(this.voxels.values()).map(v => v.mesh);
        const intersects = raycaster.intersectObjects(meshes);
        if (intersects.length > 0) {
            const hit = intersects[0];
            const pos = hit.point.clone();
            if (this.currentMode === 'ADD') {
                pos.add(hit.face.normal.multiplyScalar(0.5));
            } else {
                pos.sub(hit.face.normal.multiplyScalar(0.5));
            }
            return { x: Math.floor(pos.x / this.VS), y: Math.floor(pos.y / this.VS), z: Math.floor(pos.z / this.VS) };
        } else if (this.currentMode === 'ADD') {
            let planeNormal = new THREE.Vector3();
            let planeConstant = 0;
            if (this.currentDrawingAxis === 'y') {
                planeNormal.set(0, 1, 0);
                planeConstant = -(this.activeDrawingLevel.y * this.VS);
            } else if (this.currentDrawingAxis === 'x') {
                planeNormal.set(1, 0, 0);
                planeConstant = -(this.activeDrawingLevel.x * this.VS);
            } else { // 'z'
                planeNormal.set(0, 0, 1);
                planeConstant = -(this.activeDrawingLevel.z * this.VS);
            }
            const drawingPlane = new THREE.Plane(planeNormal, planeConstant);
            const intersectionPoint = new THREE.Vector3();
            if (raycaster.ray.intersectPlane(drawingPlane, intersectionPoint)) {
                let x = Math.floor(intersectionPoint.x / this.VS);
                let y = Math.floor(intersectionPoint.y / this.VS);
                let z = Math.floor(intersectionPoint.z / this.VS);
                if (this.currentDrawingAxis === 'y') y = this.activeDrawingLevel.y;
                else if (this.currentDrawingAxis === 'x') x = this.activeDrawingLevel.x;
                else if (this.currentDrawingAxis === 'z') z = this.activeDrawingLevel.z;
                return { x, y, z };
            }
        }
        return null;
    },
    
    updatePreviewVoxel: function(coords) {
        if (this.currentMode === 'SELECT') {
            this.previewVoxel.visible = false;
            return;
        }
        if (coords && coords.x >= 0 && coords.x < this.GRID && coords.y >= 0 && coords.y < this.GRID && coords.z >= 0 && coords.z < this.GRID) {
            this.previewVoxel.position.set(coords.x * this.VS + 0.5, coords.y * this.VS + 0.5, coords.z * this.VS + 0.5);
            this.previewVoxel.material.opacity = this.currentMode === 'DELETE' ? 0.2 : 0.5;
            this.previewVoxel.visible = true;
        } else {
            this.previewVoxel.visible = false;
        }
    },

    clearAllConfirmed: function() {
        this.removeImageTemplate();
        const oldVoxels = new Map(this.voxels);
        if (oldVoxels.size > 0) {
            const changes = new Map();
            oldVoxels.forEach((voxel, key) => {
                changes.set(key, { before: { color: voxel.color }, after: null });
            });
            this.addHistoryStep(changes);
        }
        this.voxels.forEach(v => {
            this.scene.remove(v.mesh);
            v.mesh.geometry.dispose();
            v.mesh.material.dispose();
        });
        this.voxels.clear();
        localStorage.removeItem('voxelshaper_autosave');
        this.showToast('Project Cleared', '', 'info');
    },

    rebuildHelpers: function() {
        if (this.gridHelper) this.scene.remove(this.gridHelper);
        if (this.boxHelper) this.scene.remove(this.boxHelper);
        const size = this.GRID * this.VS;
        this.gridHelper = new THREE.GridHelper(size, this.GRID);
        if (this.currentDrawingAxis === 'y') {
            this.gridHelper.position.set(size / 2, this.activeDrawingLevel.y * this.VS, size / 2);
            this.gridHelper.rotation.set(0, 0, 0);
        } else if (this.currentDrawingAxis === 'x') {
            this.gridHelper.position.set(this.activeDrawingLevel.x * this.VS, size / 2, size / 2);
            this.gridHelper.rotation.set(0, 0, Math.PI / 2);
        } else { // 'z'
            this.gridHelper.position.set(size / 2, size / 2, this.activeDrawingLevel.z * this.VS);
            this.gridHelper.rotation.set(Math.PI / 2, 0, 0);
        }
        this.scene.add(this.gridHelper);
        const boxGeom = new THREE.BoxGeometry(size, size, size);
        const edges = new THREE.EdgesGeometry(boxGeom);
        this.boxHelper = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x4a5568 }));
        this.boxHelper.position.set(size / 2, size / 2, size / 2);
        this.scene.add(this.boxHelper);
    },

    resetCamera: function() {
        this.currentDrawingAxis = 'y';
        this.activeDrawingLevel = { x: 0, y: 0, z: 0 };
        this.updateAxisAndLevelUI();
        this.rebuildHelpers();

        const size = this.GRID * this.VS;
        this.cam.position.set(size, size * 1.2, size * 1.5);
        this.cam.lookAt(size / 2, size / 2, size / 2);
        if (this.euler) this.euler.setFromQuaternion(this.cam.quaternion, 'YXZ');
    },
    
    updateModeUI: function() {
        const modeInfo = this.Modes[this.currentMode];
        const modeToggleBtn = document.getElementById('modeToggle');
        if (modeToggleBtn) modeToggleBtn.textContent = modeInfo.name;
        if(this.isMobile) document.getElementById('mobile-mode-icon').className = modeInfo.icon;
    },

    updateLoginStateUI: function() {
        const isLoggedIn = !!this.user;
        document.getElementById('loginLogoutBtn').textContent = isLoggedIn ? 'Logout' : 'Login';
        document.getElementById('uploadToHubBtn').classList.toggle('hidden', !isLoggedIn);
        
        const uploadLi = document.getElementById('mobile-upload-li');
        if (uploadLi) uploadLi.classList.toggle('hidden', !isLoggedIn);

        const authLi = document.getElementById('mobile-auth-li');
        if (authLi) {
            const loginLogoutBtn = authLi.querySelector('button');
            if (loginLogoutBtn) {
                loginLogoutBtn.textContent = isLoggedIn ? 'Logout' : 'Login';
            }
        }

        const userIdDisplay = document.getElementById('userIdDisplay');
        userIdDisplay.replaceChildren();
        if (isLoggedIn && this.user) {
            if (this.user.photoURL) {
                const img = document.createElement('img');
                img.src = this.user.photoURL;
                img.alt = "User";
                img.className = "w-6 h-6 rounded-full";
                img.referrerPolicy = 'no-referrer';
                img.decoding = 'async';
                img.loading = 'lazy';
                userIdDisplay.appendChild(img);
            }
            const span = document.createElement('span');
            span.textContent = this.user.name || this.user.email;
            userIdDisplay.appendChild(span);
        }
    },
    
    showToast: function(title, message, type = 'info', duration = 1500) {
      const container = document.getElementById('toast-container');
      const alertClass = { success: 'alert-success', info: 'alert-info',
                            warning: 'alert-warning', error: 'alert-error' }[type] || 'alert-info';

      const toast = document.createElement('div');
      toast.className = `alert ${alertClass} shadow-lg`;

      const wrap = document.createElement('div');
      const strong = document.createElement('strong');
      strong.textContent = title;
      const br = document.createElement('br');
      const span = document.createElement('span');
      span.textContent = message;

      wrap.appendChild(strong);
      wrap.appendChild(br);
      wrap.appendChild(span);
      toast.appendChild(wrap);

      container.appendChild(toast);
      setTimeout(() => toast.remove(), duration);
    },

    loginLogout: async function() {
        if (this.user) {
            try {
                await this.request('/auth/logout', { method: 'POST' });
                this.user = null;
                this.token = null;
                this.updateLoginStateUI();
                this.showToast('Logged Out', '', 'info');
            } catch (e) {
                this.showToast('Logout Error', e.message, 'error');
            }
        } else {
            document.getElementById('authModal').showModal();
        }
    },
    
    signInWithProvider: function(providerName) {
        try {
            if (this.voxels.size > 0) {
                const data = {
                    gridSize: this.GRID,
                    currentDrawingAxis: this.currentDrawingAxis,
                    activeDrawingLevel: this.activeDrawingLevel,
                    voxels: Array.from(this.voxels.entries()).map(([k, v]) => {
                        const [x, y, z] = this.parseKey(k);
                        return { x, y, z, color: v.color };
                    }),
                    templateImageData: this.templateImageData,
                    templateImagePinnedY: this.templateImagePinnedY,
                };
                sessionStorage.setItem('unsavedVoxelData', JSON.stringify(data));
                this.showToast('Progress Saved', 'Your work will be restored after login.', 'info', 2500);
            }
        } catch (e) {
            console.error("Could not save work to session storage:", e);
            this.showToast('Warning', 'Could not save your current work before login.', 'warning');
        }
        const authUrl = new URL(`${this.BACKEND_URL}/auth/${providerName}`);
        authUrl.searchParams.append('state', window.location.href);
        if (providerName === 'google') {
            authUrl.searchParams.append('prompt', 'select_account');
        }
        window.location.href = authUrl.toString();
    },

    sendMagicLink: async function() {
        const email = document.getElementById('magicLinkEmail').value;
        const acceptsAgb = document.getElementById('agbCheckbox').checked;
        const receivesMarketingEmails = document.getElementById('newsletterCheckbox').checked;
        if (!email) {
            this.showToast('Error', 'Please enter your email.', 'error');
            return;
        }
        if (!acceptsAgb) {
            this.showToast('Error', 'Bitte AGBs akzeptieren.', 'error');
            return;
        }
        try {
            await this.request('/auth/magic-link', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    email,
                    receivesMarketingEmails,
                    acceptsAgb,
                    redirect: window.location.origin + window.location.pathname
                })
            });
            document.getElementById('authModal').close();
            document.getElementById('magicLinkVerifyModal').showModal();
        } catch (e) {
            this.showToast('Error', e.message, 'error');
        }
    },

    saveJSON: function() {
        const data = {
            gridSize: this.GRID,
            currentDrawingAxis: this.currentDrawingAxis,
            activeDrawingLevel: this.activeDrawingLevel,
            voxels: Array.from(this.voxels.entries()).map(([k, v]) => {
                const [x, y, z] = this.parseKey(k);
                return { x, y, z, color: v.color };
            }),
            templateImageData: this.templateImageData,
            templateImagePinnedY: this.templateImagePinnedY,
        };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = 'voxel-project.json'; a.click();
        URL.revokeObjectURL(url);
        this.showToast('Project Saved', 'File downloaded as voxel-project.json', 'info');
    },

    loadFromData: function(data) {
        try {
            this.voxels.forEach(v => {
                this.scene.remove(v.mesh);
                v.mesh.geometry.dispose();
                v.mesh.material.dispose();
            });
            this.voxels.clear();
            this.GRID = data.gridSize || this.GRID_DEFAULT;
            this.currentDrawingAxis = data.currentDrawingAxis || 'y';
            this.activeDrawingLevel = data.activeDrawingLevel || { x: 0, y: 0, z: 0 };
            if (Array.isArray(data.voxels)) {
                data.voxels.forEach(v => {
                    const k = this.key(v.x, v.y, v.z);
                    this.voxels.set(k, { color: v.color });
                });
            }
            this.templateImagePinnedY = (data.templateImagePinnedY ?? null);
            if (data.templateImageData) {
                this.loadImageFromData(data.templateImageData);
            } else {
                this.removeImageTemplate();
            }
            this.rebuildSceneFromVoxels();
            this.rebuildHelpers();
            this.updateAllControlInputs();
            this.resetCamera();
            this.history = []; this.historyPointer = -1;
            return true;
        } catch (err) {
            this.showToast('Load Error', `Invalid project data. ${err.message}`, 'error');
            return false;
        }
    },

    loadJSON: function(event) {
        const file = event.target.files[0]; if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                if (this.loadFromData(data)) {
                    this.showToast('Project Loaded', 'Successfully loaded from file.', 'info');
                }
            } catch (err) {
                this.showToast('Load Error', `Could not read the file. ${err.message}`, 'error');
            }
        };
        reader.readAsText(file);
        event.target.value = '';
    },
    
    exportSTL: function(scaleUnit = 'mm', upAxis = 'Z') {
        if (this.voxels.size === 0) { this.showToast('Export Error', 'Scene is empty.', 'warning'); return; }
        this.showToast('Exporting...', 'Generating STL file...', 'info');
        const exporter = new THREE.STLExporter();
        const geometries = [];
        const scale = scaleUnit === 'cm' ? 10 : 1;
        this.voxels.forEach((v,k) => {
            const [x,y,z] = this.parseKey(k);
            const geom = new THREE.BoxGeometry(this.VS * scale, this.VS * scale, this.VS * scale);
            geom.translate(x * this.VS * scale + (0.5 * scale), y * this.VS * scale + (0.5 * scale), z * this.VS * scale + (0.5 * scale));
            geometries.push(geom);
        });
        const mergedGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries(geometries, false);
        if (upAxis === 'Z') {
            mergedGeometry.rotateX(-Math.PI / 2);
        }
        const mesh = new THREE.Mesh(mergedGeometry);
        const stlString = exporter.parse(mesh, { binary: true });
        const blob = new Blob([stlString], { type: 'application/octet-stream' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = 'voxel-model.stl'; a.click();
        URL.revokeObjectURL(url);
        mergedGeometry.dispose(); geometries.forEach(g => g.dispose());
        this.showToast('Export Complete', 'Downloaded voxel-model.stl', 'info');
    },

    animate: function() {
        requestAnimationFrame(() => this.animate());
        if (document.pointerLockElement === this.cvs) {
            const rotX = this.controls.invertLookX ? this.mouseState.mouseMovementX : -this.mouseState.mouseMovementX;
            const rotY = this.controls.invertLookY ? this.mouseState.mouseMovementY : -this.mouseState.mouseMovementY;
            this.euler.y += rotX * this.ROTATE_SPEED;
            this.euler.x += rotY * this.ROTATE_SPEED;
            this.euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.euler.x));
            this.cam.quaternion.setFromEuler(this.euler);
            this.mouseState.mouseMovementX = 0;
            this.mouseState.mouseMovementY = 0;
            const forward = new THREE.Vector3();
            this.cam.getWorldDirection(forward);
            const right = new THREE.Vector3().crossVectors(forward, this.cam.up).normalize();
            const strafeXSpeed = this.controls.invertStrafeX ? -this.flySpeed : this.flySpeed;
            const strafeYSpeed = this.controls.invertStrafeY ? -this.flySpeed : this.flySpeed;
            if (this.keyboard['w']) this.cam.position.addScaledVector(forward, this.flySpeed);
            if (this.keyboard['s']) this.cam.position.addScaledVector(forward, -this.flySpeed);
            if (this.keyboard['a']) this.cam.position.addScaledVector(right, -strafeXSpeed);
            if (this.keyboard['d']) this.cam.position.addScaledVector(right, strafeXSpeed);
            if (this.keyboard['e']) this.cam.position.y += strafeYSpeed;
            if (this.keyboard['q']) this.cam.position.y -= strafeYSpeed;
        }
        this.ren.render(this.scene, this.cam);
    },

    rebuildSceneFromVoxels: function() {
        this.scene.children.filter(c => c.isMesh && c !== this.previewVoxel && c !== this.templateImageMesh && c !== this.extrudeGizmoMesh).forEach(c => {
            this.scene.remove(c);
            if(c.geometry) c.geometry.dispose();
            if(c.material) c.material.dispose();
        });
        this.voxels.forEach((voxelData, key) => {
            const [x, y, z] = this.parseKey(key);
            const voxelMesh = new THREE.Mesh(new THREE.BoxGeometry(this.VS, this.VS, this.VS), new THREE.MeshLambertMaterial({ color: voxelData.color }));
            voxelMesh.position.set(x * this.VS + 0.5, y * this.VS + 0.5, z * this.VS + 0.5);
            voxelMesh.castShadow = true;
            voxelMesh.receiveShadow = true;
            this.scene.add(voxelMesh);
            voxelData.mesh = voxelMesh;
        });
    },

    addHistoryStep: function(changes) {
        // Only add if there are actual changes
        if (changes.size > 0) {
            if (this.historyPointer < this.history.length - 1) {
                this.history.splice(this.historyPointer + 1);
            }
            this.history.push(changes);
            if (this.history.length > this.MAX_HISTORY_SIZE) {
                this.history.shift();
            }
            this.historyPointer = this.history.length - 1;
            this.autosaveScene();
        }
    },

    undo: function() {
        if (this.historyPointer < 0) return;
        const changes = this.history[this.historyPointer];
        changes.forEach((change, key) => {
            const [x, y, z] = this.parseKey(key);
            if (change.before === null) {
                const existingVoxel = this.voxels.get(key);
                if (existingVoxel) {
                    this.scene.remove(existingVoxel.mesh);
                    existingVoxel.mesh.geometry.dispose();
                    existingVoxel.mesh.material.dispose();
                    this.voxels.delete(key);
                }
            } else {
                const existingVoxel = this.voxels.get(key);
                if(existingVoxel) {
                    existingVoxel.mesh.material.color.set(change.before.color);
                    existingVoxel.color = change.before.color;
                } else {
                     const voxelMesh = new THREE.Mesh(new THREE.BoxGeometry(this.VS, this.VS, this.VS), new THREE.MeshLambertMaterial({ color: change.before.color }));
                    voxelMesh.position.set(x * this.VS + 0.5, y * this.VS + 0.5, z * this.VS + 0.5);
                    voxelMesh.castShadow = true;
                    voxelMesh.receiveShadow = true;
                    this.scene.add(voxelMesh);
                    this.voxels.set(key, { color: change.before.color, mesh: voxelMesh });
                }
            }
        });
        this.historyPointer--;
        this.autosaveScene();
    },

    redo: function() {
        if (this.historyPointer >= this.history.length - 1) return;
        this.historyPointer++;
        const changes = this.history[this.historyPointer];
        changes.forEach((change, key) => {
              const [x, y, z] = this.parseKey(key);
            if (change.after === null) {
                const existingVoxel = this.voxels.get(key);
                if (existingVoxel) {
                    this.scene.remove(existingVoxel.mesh);
                    existingVoxel.mesh.geometry.dispose();
                    existingVoxel.mesh.material.dispose();
                    this.voxels.delete(key);
                }
            } else {
                const existingVoxel = this.voxels.get(key);
                if (existingVoxel) {
                    existingVoxel.mesh.material.color.set(change.after.color);
                    existingVoxel.color = change.after.color;
                  } else {
                    const voxelMesh = new THREE.Mesh(new THREE.BoxGeometry(this.VS, this.VS, this.VS), new THREE.MeshLambertMaterial({ color: change.after.color }));
                    voxelMesh.position.set(x * this.VS + 0.5, y * this.VS + 0.5, z * this.VS + 0.5);
                    voxelMesh.castShadow = true;
                    voxelMesh.receiveShadow = true;
                    this.scene.add(voxelMesh);
                    this.voxels.set(key, { color: change.after.color, mesh: voxelMesh });
                  }
            }
        });
        this.autosaveScene();
    },
    
    cycleDrawingAxis: function() {
        const axes = ['y', 'z', 'x'];
        const currentIndex = axes.indexOf(this.currentDrawingAxis);
        this.currentDrawingAxis = axes[(currentIndex + 1) % axes.length];
        this.updateAxisAndLevelUI();
        this.rebuildHelpers();
        localStorage.setItem('currentDrawingAxis', this.currentDrawingAxis);
    },

    moveDrawingLevel: function(direction) {
        let level = this.activeDrawingLevel[this.currentDrawingAxis];
        level += direction;
        this.activeDrawingLevel[this.currentDrawingAxis] = Math.max(0, Math.min(this.GRID - 1, level));
        this.updateAxisAndLevelUI();
        this.rebuildHelpers();
        localStorage.setItem('activeDrawingLevel', JSON.stringify(this.activeDrawingLevel));
    },

    updateAxisAndLevelUI: function() {
        const axisText = `Axis: ${this.currentDrawingAxis.toUpperCase()}`;
        document.getElementById('current-axis-display').textContent = axisText;
        const level = this.activeDrawingLevel[this.currentDrawingAxis];
        document.getElementById('current-level-display').textContent = level;
        const mobileCycleAxis = document.getElementById('mobile-cycle-axis');
        if (mobileCycleAxis) mobileCycleAxis.textContent = this.currentDrawingAxis.toUpperCase();
    },

    resetToDefaults: function() {
        this.controls.invertLookX = false;
        this.controls.invertLookY = false;
        this.controls.invertZoom = false;
        this.controls.invertStrafeX = false;
        this.controls.invertStrafeY = false;
        this.GRID = this.GRID_DEFAULT;
        this.currentColor = '#ffffff';
        this.flySpeed = 0.1;
        this.currentDrawingAxis = 'y';
        this.activeDrawingLevel = { x: 0, y: 0, z: 0 };
        Object.keys(this.controls).forEach(key => localStorage.setItem(key, this.controls[key]));
        localStorage.setItem('voxelEditorGridSize', this.GRID);
        localStorage.setItem('voxelEditorColor', this.currentColor);
        localStorage.setItem('voxelEditorFlySpeed', this.flySpeed);
        localStorage.setItem('currentDrawingAxis', this.currentDrawingAxis);
        localStorage.setItem('activeDrawingLevel', JSON.stringify(this.activeDrawingLevel));
        this.updateAllControlInputs();
        this.clearAllConfirmed();
        this.rebuildHelpers();
        this.resetCamera();
        this.showToast('Settings Reset', 'All settings have been reset to their default values.', 'info');
    },

    updateAllControlInputs: function() {
        const gridSizeSlider = document.getElementById('grid-size-slider');
        if (gridSizeSlider) gridSizeSlider.value = this.GRID;
        const gridSizeDisplay = document.getElementById('grid-size-display');
        if (gridSizeDisplay) gridSizeDisplay.textContent = `${this.GRID}³`;
        const colorPickerInput = document.getElementById('color-picker-input');
        if (colorPickerInput) colorPickerInput.value = this.currentColor;
        const mobileColorPicker = document.getElementById('mobile-color-picker');
        if (mobileColorPicker) mobileColorPicker.value = this.currentColor;
        this.setFlySpeed(this.flySpeed);
        
        const invertLookX = document.getElementById('invertLookX');
        if (invertLookX) invertLookX.checked = this.controls.invertLookX;
        const invertLookY = document.getElementById('invertLookY');
        if (invertLookY) invertLookY.checked = this.controls.invertLookY;
        const invertZoom = document.getElementById('invertZoom');
        if (invertZoom) invertZoom.checked = this.controls.invertZoom;
        const invertStrafeX = document.getElementById('invertStrafeX');
        if (invertStrafeX) invertStrafeX.checked = this.controls.invertStrafeX;
        const invertStrafeY = document.getElementById('invertStrafeY');
        if (invertStrafeY) invertStrafeY.checked = this.controls.invertStrafeY;

        if(this.isMobile) {
            const mobileInvertLookX = document.getElementById('mobileInvertLookX');
            if (mobileInvertLookX) mobileInvertLookX.checked = this.controls.invertLookX;
            const mobileInvertLookY = document.getElementById('mobileInvertLookY');
            if (mobileInvertLookY) mobileInvertLookY.checked = this.controls.invertLookY;
            const mobileInvertZoom = document.getElementById('mobileInvertZoom');
            if (mobileInvertZoom) mobileInvertZoom.checked = this.controls.invertZoom;
            const mobileInvertStrafeX = document.getElementById('mobileInvertStrafeX');
            if (mobileInvertStrafeX) mobileInvertStrafeX.checked = this.controls.invertStrafeX;
            const mobileInvertStrafeY = document.getElementById('mobileInvertStrafeY');
            if (mobileInvertStrafeY) mobileInvertStrafeY.checked = this.controls.invertStrafeY;

            const mobileFlySpeedSlider = document.getElementById('mobile-fly-speed-slider');
            if (mobileFlySpeedSlider) mobileFlySpeedSlider.value = this.flySpeed;
            const mobileFlySpeedDisplay = document.getElementById('mobile-fly-speed-display');
            if (mobileFlySpeedDisplay) mobileFlySpeedDisplay.textContent = this.flySpeed.toFixed(2);
        }
        this.updateAxisAndLevelUI();
        this.updateModeUI();
    },
    
    disposeTemplateImageMesh: function () {
      if (this.templateImageMesh) {
        this.scene.remove(this.templateImageMesh);
        this.templateImageMesh.geometry.dispose();
        if (this.templateImageMesh.material.map) this.templateImageMesh.material.map.dispose();
        this.templateImageMesh.material.dispose();
        this.templateImageMesh = null;
      }
    },
    loadImageTemplate: function() {
        document.getElementById('imageFileInput').click();
    },
    handleImageFileSelect: function(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            this.templateImageData = e.target.result;
            this.loadImageFromData(this.templateImageData);
        };
        reader.readAsDataURL(file);
        event.target.value = '';
    },
    loadImageFromData: function(imageData) {
        this.disposeTemplateImageMesh();
        const loader = new THREE.TextureLoader();
        loader.load(imageData, (texture) => {
            const img = texture.image;
            const aspect = img.width / img.height;
            const size = this.GRID * this.VS;
            let planeWidth, planeHeight;
            if (aspect >= 1) {
                planeWidth = size;
                planeHeight = size / aspect;
            } else {
                planeHeight = size;
                planeWidth = size * aspect;
            }
            const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                side: THREE.DoubleSide,
                depthTest: true,
                depthWrite: false
            });
            this.templateImageMesh = new THREE.Mesh(geometry, material);
            if (this.templateImagePinnedY == null) {
              this.templateImagePinnedY = (this.activeDrawingLevel?.y ?? 0);
            }
            this.templateImageMesh.renderOrder = -1;
            this.updateTemplateImagePosition();
            this.scene.add(this.templateImageMesh);
            document.getElementById('removeImageBtn').classList.remove('hidden');
            document.getElementById('removeImageBtnMobile').classList.remove('hidden');
            document.getElementById('loadImageBtn').classList.add('hidden');
            document.getElementById('loadImageBtnMobile').classList.add('hidden');
        });
    },
    removeImageTemplate: function() {
        if (this.templateImageMesh) {
            this.scene.remove(this.templateImageMesh);
            this.templateImageMesh.geometry.dispose();
            if (this.templateImageMesh.material.map) this.templateImageMesh.material.map.dispose();
            this.templateImageMesh.material.dispose();
            this.templateImageMesh = null;
        }
        this.templateImageData = null;
        this.templateImagePinnedY = null;
        document.getElementById('removeImageBtn').classList.add('hidden');
        document.getElementById('removeImageBtnMobile').classList.add('hidden');
        document.getElementById('loadImageBtn').classList.remove('hidden');
        document.getElementById('loadImageBtnMobile').classList.remove('hidden');
    },
    updateTemplateImagePosition: function() {
        if (!this.templateImageMesh) return;
        const sizeAll = this.GRID * this.VS;
        const offsetY = -0.01;
        const y = (this.templateImagePinnedY ?? 0) * this.VS + offsetY;
        this.templateImageMesh.position.set(sizeAll / 2, y, sizeAll / 2);
        this.templateImageMesh.rotation.set(-Math.PI / 2, 0, 0);
    },
    
    autosaveScene: function() {
        if (this.voxels.size === 0 && !this.templateImageData) {
            localStorage.removeItem('voxelshaper_autosave');
            return;
        }
        try {
            const data = {
                gridSize: this.GRID,
                currentDrawingAxis: this.currentDrawingAxis,
                activeDrawingLevel: this.activeDrawingLevel,
                voxels: Array.from(this.voxels.entries()).map(([k, v]) => {
                    const [x, y, z] = this.parseKey(k);
                    return { x, y, z, color: v.color };
                }),
                templateImageData: this.templateImageData,
                templateImagePinnedY: this.templateImagePinnedY,
            };
            localStorage.setItem('voxelshaper_autosave', JSON.stringify(data));
        } catch (e) {
            console.error("Autosave failed:", e);
        }
    },

    loadAutosavedScene: function() {
        const savedData = localStorage.getItem('voxelshaper_autosave');
        if (savedData) {
            try {
                const data = JSON.parse(savedData);
                if (this.loadFromData(data)) {
                    this.showToast('Scene Restored', 'Your last session was loaded.', 'info');
                }
            } catch (e) {
                console.error("Failed to load autosaved scene:", e);
                localStorage.removeItem('voxelshaper_autosave');
            }
        }
    }
};

document.addEventListener('DOMContentLoaded', () => VoxelApp.init());
</script>




</body></html>
