<html lang="en" data-theme="dark"><head>
    <meta charset="UTF-8">
    <title>VoxelShaper - Brick CAD with Polyslice Slicer</title>
    <meta name="description" content="Create, design, and export 3D models for printing with VoxelShaper, the easy-to-use online voxel editor. Supports STL export and G-Code generation via the integrated Polyslice.js slicer.">
    <meta name="keywords" content="voxel editor, voxel cad, 3d design tool, easy 3d modeling, online voxel art, 3d printing software, stl export, block modeling, hobbyist cad, lego style 3d editor, polyslice, gcode">
    <link rel="canonical" href="https://voxelshaper.com/">
    <meta name="theme-color" content="#0f1117">

    <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover">
    <meta name="format-detection" content="telephone=no, email=no, address=no">

    <meta property="og:type" content="website">
    <meta property="og:url" content="https://voxelshaper.com/">
    <meta property="og:title" content="VoxelShaper – Brick CAD with Polyslice">
    <meta property="og:description" content="Simple brick-based CAD for makers. Exports as STL and features Polyslice integration.">
    <meta property="og:image" content="https://voxelshaper.com/og.png">
    <meta property="og:site_name" content="VoxelShaper">
    <meta property="og:locale" content="en_US">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="VoxelShaper – Brick CAD with Polyslice">
    <meta property="og:description" content="Simple brick-based CAD for makers. Exports as STL and features Polyslice integration.">
    <meta name="twitter:image" content="https://voxelshaper.com/og.png">

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@graph": [
        {
          "@type": "Organization",
          "@id": "https://voxelshaper.com/#org",
          "name": "VoxelShaper",
          "url": "https://voxelshaper.com/",
          "logo": "https://voxelshaper.com/logo-512.png"
        },
        {
          "@type": "WebApplication",
          "@id": "https://voxelshaper.com/#app",
          "name": "VoxelShaper",
          "url": "https://voxelshaper.com/",
          "applicationCategory": "DesignApplication",
          "operatingSystem": "Web",
          "isAccessibleForFree": true,
          "copyrightHolder": { "@id": "https://voxelshaper.com/#org" }
        }
      ]
    }
    </script>

    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.7.2/dist/full.min.css" rel="stylesheet" type="text/css">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        /* ... (General styles retained and adapted) ... */
        :root { --toast-z-index: 9999; }
        html, body {
            overflow: hidden;
            height: 100%;
            margin: 0;
            padding: 0;
            touch-action: none;
            font-family: 'Inter', sans-serif;
        }
        #container, #voxelCanvas { 
            touch-action: none;
        }
        body {
            display: flex;
            flex-direction: column;
        }
        #container {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
        }
        #voxelCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }
        #voxelCanvas:focus { 
            outline: none; 
        }
        /* Desktop controls alignment fix */
        #controls {
            flex-wrap: nowrap;
        }
        .controls-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-shrink: 1;
            min-width: 0;
        }
        .controls-group > * {
            flex-shrink: 0;
        }
        .controls-group .range {
            flex-shrink: 1;
        }
        input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            padding: 0;
            border: none;
            background-color: transparent;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: 1px solid #555; border-radius: 50%; }
        input[type="color"]::-moz-color-swatch { border: 1px solid #555; border-radius: 50%; }
        
        #color-history-palette .color-swatch {
            width: 1.5rem;
            height: 1.5rem;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #555;
        }
        /* The preview mode controls are now dynamically managed */
        #in-app-rounded-controls {
            display: none; 
        }
        
        #current-display-mode {
            cursor: pointer;
            border: 1px solid currentColor;
            padding: 0.25rem 0.5rem;
            border-radius: 0.5rem;
            transition: all 0.1s;
        }
        #current-display-mode:hover {
            opacity: 0.8;
            box-shadow: 0 0 5px currentColor;
        }

        .marquee {
            position: absolute;
            border: 1px dashed #ffff00;
            background-color: rgba(255, 255, 0, 0.1);
            pointer-events: none;
            display: none;
        }
        #mobile-ui-container { 
            display: none; 
        }
        #mobile-ui-container .mobile-bottom-bar > * {
            flex-shrink: 0;
        }
        #mobile-ui-container .mobile-bottom-bar .btn,
        #mobile-ui-container .mobile-bottom-bar input[type="color"],
        #mobile-ui-container .mobile-bottom-bar .dropdown > label {
            width: 3.5rem;
            height: 3.5rem;
            font-size: 1.5rem;
        }
        :root { --safe-bottom: env(safe-area-inset-bottom); --safe-top: env(safe-area-inset-top); }
        #mobile-ui-container .mobile-bottom-bar {
            position: fixed; left: 0; right: 0; bottom: 0;
            padding-bottom: calc(var(--safe-bottom) + 8px);
            z-index: 40;
        }
        body.has-mobile-bar {
            padding-bottom: 0 !important; /* Let the bar float */
        }
        :where(html, body, #container, #voxelCanvas, #controls, #mobile-ui-container,
                 .mobile-bottom-bar, .btn, .dropdown, .menu, .modal, label, span, div) {
            -webkit-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        input, textarea, select, [contenteditable] {
            -webkit-user-select: text;
            user-select: text;
            -webkit-touch-callout: default;
            touch-action: pan-y; /* Allow scrolling inside modals on mobile */
        }

        /* Visuelles Haptic-Overlay */
        #haptic-layer {
          position: absolute;
          inset: 0;
          pointer-events: none;
          z-index: 40;
        }
        .haptic-ripple {
          position: absolute;
          width: 20px;
          height: 20px;
          border-radius: 9999px;
          border: 2px solid rgba(255,255,255,.65);
          transform: translate(-50%, -50%) scale(0.7);
          opacity: 0;
          animation: hRipple .35s ease-out forwards;
        }
        @keyframes hRipple {
          0% { opacity: .85; transform: translate(-50%, -50%) scale(0.7); }
          100% { opacity: 0; transform: translate(-50%, -50%) scale(2.2); }
        }
    </style>
</head>
<body class="bg-base-100 min-h-screen text-base-content flex flex-col rounded-lg">

<div id="controls" class="hidden md:flex items-center justify-between gap-4 p-2 bg-base-200 border-b border-base-content/20" style="display: flex;">
    <div class="controls-group">
        <div class="dropdown">
            <label tabindex="0" class="btn btn-sm btn-ghost">File</label>
            <ul tabindex="0" class="dropdown-content z-[1] menu p-2 shadow bg-base-300 rounded-box w-52">
                <li><a id="saveBtn">Save Local (.json)</a></li>
                <li><a id="loadBtn">Load Local (.json)</a></li>
                <li><a id="exportBtn">Export Options</a></li>
                <div class="divider my-1"></div>
                <li><a id="loadImageBtn">Load Reference Image</a></li>
                <li><a id="removeImageBtn" class="hidden">Remove Reference Image</a></li>
                <div class="divider my-1"></div>
                <li><a id="clearBtn" class="text-error">Clear Scene</a></li>
            </ul>
        </div>
        <div class="dropdown">
            <label tabindex="0" class="btn btn-sm btn-ghost">Edit</label>
            <ul tabindex="0" class="dropdown-content z-[1] menu p-2 shadow bg-base-300 rounded-box w-52">
                <li><a id="undoBtn"><i class="fas fa-undo mr-2"></i>Undo (Ctrl+Z)</a></li>
                <li><a id="redoBtn"><i class="fas fa-redo mr-2"></i>Redo (Ctrl+Y)</a></li>
            </ul>
        </div>
        <div class="dropdown">
            <label tabindex="0" class="btn btn-sm btn-ghost">View</label>
            <ul tabindex="0" class="dropdown-content z-[1] menu p-2 shadow bg-base-300 rounded-box w-60">
                <li><a id="resetCameraBtn">Reset View</a></li>
                <li>
                    <a id="cycleDisplayModeBtn" class="flex justify-between items-center">
                        <span>Preview Mode (F)</span>
                        <span id="current-display-mode" class="text-primary text-xs font-bold badge badge-outline">Brick-Studs</span>
                    </a>
                </li>
                <div class="divider my-1"></div>
                <li>
                    <details>
                        <summary>Drawing Plane</summary>
                        <ul>
                            <li>
                                <a id="cycleAxisBtn" class="flex justify-between">
                                    <span>Cycle Axis</span>
                                    <span id="current-axis-display" class="badge badge-accent">Y</span>
                                </a>
                            </li>
                            <li>
                                <div class="flex items-center justify-between w-full px-4 py-2">
                                    <span>Level</span>
                                    <div class="flex items-center gap-1">
                                        <button id="levelDownBtn" class="btn btn-xs btn-ghost">-</button>
                                        <span id="current-level-display" class="w-6 text-center font-bold text-accent">0</span>
                                        <button id="levelUpBtn" class="btn btn-xs btn-ghost">+</button>
                                    </div>
                                </div>
                            </li>
                        </ul>
                    </details>
                </li>
                <li>
                    <details>
                        <summary>Reference Image Plane</summary>
                        <ul>
                            <li>
                                <a id="cycleImageAxisBtn" class="flex justify-between">
                                    <span>Cycle Image Axis</span>
                                    <span id="current-image-axis-display" class="badge badge-accent">Z</span>
                                </a>
                            </li>
                        </ul>
                    </details>
                </li>
                <li>
                    <details>
                        <summary>Controls</summary>
                        <ul>
                            <li><label class="label cursor-pointer"><span class="label-text">Invert Look X</span><input type="checkbox" id="invertLookX" class="toggle toggle-primary"></label></li>
                            <li><label class="label cursor-pointer"><span class="label-text">Invert Look Y</span><input type="checkbox" id="invertLookY" class="toggle toggle-primary"></label></li>
                            <li><label class="label cursor-pointer"><span class="label-text">Invert Zoom</span><input type="checkbox" id="invertZoom" class="toggle toggle-primary"></label></li>
                            <li><label class="label cursor-pointer"><span class="label-text">Invert Strafe X</span><input type="checkbox" id="invertStrafeX" class="toggle toggle-primary"></label></li>
                            <li><label class="label cursor-pointer"><span class="label-text">Invert Strafe Y</span><input type="checkbox" id="invertStrafeY" class="toggle toggle-primary"></label></li>
                            <div class="divider my-1"></div>
                            <li><a id="resetDefaultsBtn">Reset to Default</a></li>
                        </ul>
                    </details>
                </li>
            </ul>
        </div>
        <div class="divider divider-horizontal"></div>
        <label for="grid-size-slider" class="text-sm whitespace-nowrap">Grid:</label>
        <input type="range" id="grid-size-slider" min="5" max="100" value="10" class="range range-xs w-28">
        <span id="grid-size-display" class="font-bold text-primary text-sm">10³</span>
        <label for="color-picker-input" class="btn btn-sm btn-ghost normal-case gap-2">Color
            <input type="color" id="color-picker-input" value="#FFFFFF" class="h-6 w-6 cursor-pointer rounded-full">
        </label>
        <div id="color-history-palette" class="controls-group gap-1"><div class="color-swatch" title="#FFFFFF" style="background-color: rgb(255, 255, 255);"></div></div>
        <button id="modeToggle" class="btn btn-sm btn-neutral">Mode</button>
        <span id="current-mode" class="font-bold text-success text-center text-sm whitespace-nowrap">Mode: Select</span>
        <button id="selectionLockToggle" class="btn btn-sm btn-ghost text-lg"><i class="fas fa-unlock"></i></button>
        <div id="brush-controls" class="controls-group">
            <div class="divider divider-horizontal"></div>
            <label for="brush-size-slider" class="text-sm whitespace-nowrap">Brush:</label>
            <input type="range" id="brush-size-slider" min="1" max="10" value="1" class="range range-xs w-16" disabled="">
            <span id="brush-size-display" class="font-bold text-sm text-base-content/50">1x1</span>
        </div>
        
        <!-- ROUNDED PREVIEW CONTROLS (Removed/Hidden as it conflicts with Brick geometry) -->
        <div id="in-app-rounded-controls" class="controls-group border border-base-300 rounded-lg p-1" style="display: none;">
            <label for="roundedPreviewToggle" class="label cursor-pointer gap-2">
                <span class="label-text text-sm">Rounded Preview:</span>
                <input type="checkbox" id="roundedPreviewToggle" class="toggle toggle-accent toggle-sm">
            </label>
            <div id="preview-slider-group" class="controls-group gap-1 ml-2" style="opacity: 0.5;">
                 <input type="range" id="previewRoundnessSlider" min="0.01" max="1.0" value="0.25" step="0.01" class="range range-xs w-16" disabled="">
                 <span id="preview-factor-display" class="font-bold text-sm text-accent w-16 text-right">0.25</span>
            </div>
        </div>
    </div>

    <div class="flex-grow"></div>

    <div class="controls-group justify-end">
        <label for="fly-speed-slider" class="text-sm whitespace-nowrap">Fly Speed:</label>
        <input type="range" id="fly-speed-slider" min="0.01" max="1" value="0.1" step="0.01" class="range range-xs w-28">
        <span id="fly-speed-display" class="font-bold text-primary text-sm">0.19</span>
        <div class="divider divider-horizontal"></div>
        
        <button id="goToHubBtn" class="btn btn-sm btn-ghost" aria-label="Go to VoxelShaper Hub"><i class="fas fa-home"></i></button>

        <button id="shareBtn" class="btn btn-sm btn-warning" aria-label="Share or Upload Project">
            <i class="fas fa-share-alt"></i>
        </button>

        <button id="loginLogoutBtn" class="btn btn-sm btn-info">Logout</button>
        <span id="userIdDisplay" class="font-bold text-info whitespace-nowrap overflow-hidden text-ellipsis max-w-xs flex items-center gap-1"><span>Chris Field</span></span>
        
    </div>
</div>
<div id="container">
    <canvas id="voxelCanvas" tabindex="0" width="1177" height="858" style="width: 1037px; height: 756px;"></canvas>
    <div id="marquee" class="marquee"></div>
    <div id="haptic-layer"></div>
    <input type="file" id="fileInput" accept=".json" class="hidden">
    <input type="file" id="imageFileInput" accept="image/*" class="hidden">
</div>

<!-- MOBILE UI CONTAINER -->
<div id="mobile-ui-container" style="display: none;">
  <!-- Undo/Redo overlay -->
  <div id="mobile-undo-redo-overlay" class="absolute bottom-24 right-4 z-50 flex flex-row gap-2" style="bottom: calc(5.5rem + var(--safe-bottom));">
    <button id="mobile-overlay-undo" class="btn btn-circle btn-ghost bg-base-200/80 backdrop-blur-sm shadow-lg">
      <i class="fas fa-undo"></i>
    </button>
    <button id="mobile-overlay-redo" class="btn btn-circle btn-ghost bg-base-200/80 backdrop-blur-sm shadow-lg">
      <i class="fas fa-redo"></i>
    </button>
  </div>

  <!-- Bottom bar -->
  <div class="mobile-bottom-bar flex items-center justify-around p-2 bg-base-200 border-t border-base-content/20">
    <!-- FILE (left) -->
    <div class="dropdown dropdown-top">
      <label tabindex="0" class="btn btn-ghost rounded-full" aria-label="File Menu">
        <i class="fas fa-folder-open"></i>
      </label>
      <ul tabindex="0" class="dropdown-content z-[60] menu p-2 shadow bg-base-300 rounded-box w-52 left-0 right-auto">
        <li><a id="saveBtnMobile">Save Local (.json)</a></li>
        <li><a id="loadBtnMobile">Load Local (.json)</a></li>
        <li><a id="exportBtnMobile">Export Options</a></li>
        <li><a id="mobile-share">Share Project</a></li>
        <div class="divider my-1"></div>
        <li><a id="loadImageBtnMobile">Load Reference Image</a></li>
        <li><a id="removeImageBtnMobile" class="hidden">Remove Reference Image</a></li>
        <div class="divider my-1"></div>
        <li id="mobile-upload-li" class="">
          <a><button id="mobile-upload" class="w-full text-left">Upload to Hub</button></a>
        </li>
        <li id="mobile-login-li" class="hidden">
          <a><button id="mobile-login-logout" class="w-full text-left">Logout</button></a>
        </li>
        <li id="mobile-logout-li" class="">
          <a><button id="mobile-logout" class="w-full text-left text-error">Logout</button></a>
        </li>
      </ul>
    </div>

    <!-- EDIT (middle) -->
    <div class="dropdown dropdown-top">
      <label tabindex="0" class="btn btn-ghost rounded-full" aria-label="Edit Menu">
        <i class="fas fa-edit"></i>
      </label>
      <ul tabindex="0" class="dropdown-content z-[60] menu p-2 shadow bg-base-300 rounded-box w-52">
        <li><a id="mobile-undo"><i class="fas fa-undo mr-2"></i>Undo</a></li>
        <li><a id="mobile-redo"><i class="fas fa-redo mr-2"></i>Redo</a></li>
        <div class="divider my-1"></div>
        <li><a id="clearBtnMobile" class="text-error">Clear Scene</a></li>
      </ul>
    </div>

    <!-- TOOLS (right) -->
    <div class="dropdown dropdown-top dropdown-end">
      <label tabindex="0" class="btn btn-ghost rounded-full" aria-label="Tools Menu">
        <i class="fas fa-tools"></i>
      </label>
      <ul tabindex="0" class="dropdown-content z-[60] menu p-2 shadow bg-base-300 rounded-box w-45">
        <li>
            <a id="mobile-cycle-display-mode" class="flex justify-between">
                <span>Preview Mode</span>
                <span id="mobile-display-mode-display" class="badge badge-accent">Brick-Studs</span>
            </a>
        </li>
        <div class="divider my-1"></div>
        <li>
          <a id="mobile-cycle-axis" class="flex justify-between">
            <span>Draw Axis</span>
            <span id="mobile-axis-display" class="badge badge-accent">Y</span>
          </a>
        </li>
        <li><a id="mobile-level-up">Level Up</a></li>
        <li><a id="mobile-level-down">Level Down</a></li>
        <div class="divider my-1"></div>
        <li>
          <a id="mobile-cycle-image-axis" class="flex justify-between">
            <span>Image Axis</span>
            <span id="mobile-image-axis-display" class="badge badge-accent">Z</span>
          </a>
        </li>
        <div class="divider my-1"></div>
        <li>
          <a id="mobile-selection-lock-toggle" class="flex justify-between">
            <span>Select Lock</span>
            <span id="mobile-lock-status-icon"><i class="fas fa-unlock"></i></span>
          </a>
        </li>
        <li><a id="mobile-properties">Grid &amp; Brush Size</a></li>
        <li><a id="mobile-reset-camera">Reset Camera</a></li>
        <li><a id="mobile-settings">Control Settings</a></li>
      </ul>
    </div>

    <input type="color" id="mobile-color-picker" value="#FFFFFF" class="rounded-full p-1 border-2 border-base-content/50 bg-clip-content">

    <button class="btn btn-ghost rounded-full" id="mobile-mode-toggle" aria-label="Toggle Mode">
      <i id="mobile-mode-icon" class="fas fa-mouse-pointer"></i>
    </button>
  </div>
</div>

<dialog id="exportOptionsModal" class="modal">
    <div class="modal-box">
        <h3 class="font-bold text-lg">Export Options</h3>
        
        <!-- Shape Type Selection - NOW THREE OPTIONS -->
        <div class="form-control mb-4">
            <label class="label"><span class="label-text font-semibold">Shape Type:</span></label>
            <div class="flex gap-3 flex-wrap">
                <label class="flex items-center"><input type="radio" name="exportShapeType" value="BRICK_STUDS" class="radio radio-primary" checked=""><span class="ml-2">Brick-Studs</span></label>
                <label class="flex items-center"><input type="radio" name="exportShapeType" value="ROUNDED" id="roundedExportRadio" class="radio radio-primary"><span class="ml-2">Rounded (Filleted)</span></label>
                <label class="flex items-center"><input type="radio" name="exportShapeType" value="SHARP_CUBE" id="sharpCubeExportRadio" class="radio radio-primary"><span class="ml-2">Sharp Cube (Regular)</span></label>
            </div>
        </div>

        <!-- Roundness Slider (ONLY applies to "Rounded" export type) -->
        <div class="form-control mb-4" id="roundnessSliderGroup" style="display: none;">
            <label class="label">
                <span class="label-text">Fillet Factor: </span>
                <span id="fillet-factor-display" class="font-bold text-primary">0.25</span>
            </label>
            <input type="range" id="filletRoundnessSlider" min="0.01" max="1.0" value="0.25" step="0.01" class="range range-xs range-primary">
            <p class="text-xs text-gray-400 mt-1">Factor $1.00$ = Max Roundness (half voxel unit). Only applies to 'Rounded' export.</p>
        </div>
        
        <div class="form-control mb-4">
            <label class="label"><span class="label-text">Scale Unit (for STL &amp; G-Code):</span></label>
            <div class="flex gap-3">
                <label class="flex items-center"><input type="radio" name="exportScaleUnit" value="mm" class="radio radio-primary" checked=""><span class="ml-2">Millimeters (mm)</span></label>
                <label class="flex items-center"><input type="radio" name="exportScaleUnit" value="cm" class="radio radio-primary"><span class="ml-2">Centimeters (cm)</span></label>
            </div>
        </div>
        
        <div class="form-control mb-4">
            <label class="label"><span class="label-text">Up-Axis (for STL):</span></label>
            <div class="flex gap-3">
                <label class="flex items-center"><input type="radio" name="exportUpAxis" value="Y" class="radio radio-primary"><span class="ml-2">Y-Up (Standard)</span></label>
                <label class="flex items-center"><input type="radio" name="exportUpAxis" value="Z" class="radio radio-primary" checked=""><span class="ml-2">Z-Up (3D Printers)</span></label>
            </div>
        </div>

        <div class="modal-action">
            <button id="exportBambuStudioBtn" class="btn btn-accent">Bambu 3MF</button>
            <button id="exportGCodePolysliceBtn" class="btn btn-success">G-Code</button>
            <button id="exportSTLFinalBtn" class="btn btn-primary">STL</button>
            <form method="dialog"><button class="btn btn-ghost">Cancel</button></form>
        </div>
    </div>
</dialog>

<!-- MODAL CONTENT REMAINS THE SAME -->
<dialog id="mobileControlsModal" class="modal">
    <div class="modal-box">
        <h3 class="font-bold text-lg">Control Settings</h3>
        <ul class="menu p-2">
            <li><label class="label cursor-pointer"><span class="label-text">Invert Look X</span><input type="checkbox" id="mobileInvertLookX" class="toggle toggle-primary"></label></li>
            <li><label class="label cursor-pointer"><span class="label-text">Invert Look Y</span><input type="checkbox" id="mobileInvertLookY" class="toggle toggle-primary"></label></li>
            <li><label class="label cursor-pointer"><span class="label-text">Invert Zoom</span><input type="checkbox" id="mobileInvertZoom" class="toggle toggle-primary"></label></li>
            <li><label class="label cursor-pointer"><span class="label-text">Invert Strafe X</span><input type="checkbox" id="mobileInvertStrafeX" class="toggle toggle-primary"></label></li>
            <li><label class="label cursor-pointer"><span class="label-text">Invert Strafe Y</span><input type="checkbox" id="mobileInvertStrafeY" class="toggle toggle-primary"></label></li>
        </ul>
        <div class="modal-action">
            <form method="dialog"><button class="btn">Close</button></form>
        </div>
    </div>
</dialog>
<dialog id="mobilePropertiesModal" class="modal">
    <div class="modal-box">
        <h3 class="font-bold text-lg">Grid &amp; Brush Size</h3>
        <div class="py-4 space-y-4">
            <div>
                <label for="mobile-grid-size-slider" class="label"><span class="label-text">Grid Size: <span id="mobile-grid-size-display">10³</span></span></label>
                <input type="range" id="mobile-grid-size-slider" min="5" max="100" value="10" class="range range-primary">
            </div>
            <div>
                <label for="mobile-brush-size-slider" class="label"><span class="label-text">Brush Size: <span id="mobile-brush-size-display">1x1</span></span></label>
                <input type="range" id="mobile-brush-size-slider" min="1" max="10" value="1" class="range range-accent" disabled="">
            </div>
        </div>
        <div class="modal-action">
            <form method="dialog"><button class="btn">Close</button></form>
        </div>
    </div>
</dialog>
<dialog id="uploadProjectModal" class="modal">
    <div class="modal-box">
        <h3 class="font-bold text-lg">Upload Project to Hub</h3>
        <form method="dialog" class="flex flex-col gap-4 py-4">
            <input type="text" id="uploadTitle" placeholder="Project Title" class="input input-bordered w-full">
            <textarea id="uploadDescription" placeholder="Description" class="textarea textarea-bordered w-full"></textarea>
            <select id="uploadCategory" class="select select-bordered w-full"><option disabled="" selected="">Select Category</option></select>
            <div class="flex gap-4">
                <label><input type="radio" name="uploadVisibility" value="public" class="radio radio-primary mr-1" checked=""> Public</label>
                <label><input type="radio" name="uploadVisibility" value="private" class="radio radio-primary mr-1"> Private</label>
            </div>
            <div class="modal-action">
                <button id="uploadConfirmBtn" class="btn btn-success">Upload</button>
                <button class="btn">Cancel</button>
            </div>
        </form>
    </div>
</dialog>
<dialog id="authModal" class="modal">
    <div class="modal-box text-center">
        <h3 class="font-bold text-lg">Login to VoxelShaper Hub</h3>
        <p class="py-4">Choose a login method or use a magic link.</p>
        <div class="py-4 flex flex-col gap-3">
            <button id="signInGoogleBtn" class="btn btn-error text-white">With Google</button>
            <button id="signInGithubBtn" class="btn bg-neutral text-neutral-content">With GitHub</button>
            <form id="magicLinkForm" class="flex flex-col gap-2 w-full mt-4">
                <input type="email" id="magicLinkEmail" placeholder="Enter your email" class="input input-bordered w-full">
                <label class="label cursor-pointer justify-start gap-2">
                    <input type="checkbox" id="agbCheckbox" class="checkbox">
                    <span class="label-text">I agree to the Terms of Service and Privacy Policy.</span>
                </label>
                <label class="label cursor-pointer justify-start gap-2">
                    <input type="checkbox" id="newsletterCheckbox" class="checkbox">
                    <span class="label-text">I would like to receive news and offers by email.</span>
                </label>
                <button type="submit" class="btn btn-primary">Send Magic Link</button>
            </form>
        </div>
        <form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form>
    </div>
</dialog>
<dialog id="magicLinkVerifyModal" class="modal">
    <div class="modal-box text-center">
        <h3 class="font-bold text-lg">Check your email!</h3>
        <p class="py-4" id="magicLinkVerifyMessage">We've sent a magic link to your email address. Please check your inbox and click the link to log in. You can close this window now.</p>
        <form method="dialog"><button class="btn">Close</button></form>
    </div>
</dialog>
<dialog id="clearConfirmationModal" class="modal">
    <div class="modal-box">
        <h3 class="font-bold text-lg">Clear Scene</h3>
        <p class="py-4">Are you sure you want to clear the entire project? This action cannot be undone.</p>
        <div class="modal-action">
            <button id="confirmClearBtn" class="btn btn-error">Clear All</button>
            <form method="dialog"><button class="btn">Cancel</button></form>
        </div>
    </div>
</dialog>
<dialog id="shareModal" class="modal">
    <div class="modal-box">
        <h3 class="font-bold text-lg">Share &amp; Publish Project</h3>
        <p class="py-4">Choose how you would like to share your work.</p>
        <div class="flex flex-col gap-3">
            <button id="copyShareLinkBtn" class="btn btn-primary"><i class="fas fa-link mr-2"></i>Copy Share Link</button>
            <button id="uploadToHubFromShareBtn" class="btn btn-success"><i class="fas fa-cloud-upload-alt mr-2"></i>Upload to VoxelShaper Hub</button>
        </div>
        <div class="modal-action">
            <form method="dialog"><button class="btn btn-ghost">Cancel</button></form>
        </div>
    </div>
</dialog>
<dialog id="onboardingModal" class="modal">
    <div class="modal-box">
        <h3 class="font-bold text-lg">Welcome to VoxelShaper!</h3>
        <p class="py-4">Here are some quick tips to get you started:</p>
        <ul class="list-disc list-inside space-y-2">
            <li><b>Look Around:</b> Drag with one finger.</li>
            <li><b>Zoom &amp; Pan:</b> Pinch or drag with two fingers.</li>
            <li><b>Paint / Select / Delete:</b> Double-tap and hold, then drag.</li>
            <li><b>Undo:</b> Tap with three fingers.</li>
        </ul>
        <div class="modal-action mt-6">
            <button id="loadSampleProjectBtn" class="btn btn-primary">Load Sample Project</button>
            <button id="startBlankBtn" class="btn">Start with Blank Canvas</button>
        </div>
    </div>
</dialog>


<div id="toast-container" class="toast toast-top toast-center z-50"></div>

<!-- Core Libraries -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
<!-- Polyslice Integration -->
<script src="https://unpkg.com/@jgphilpott/polyslice/dist/index.browser.min.js"></script>


<script>

const VOXEL_SEGMENTS = 10;
const VOXEL_SIZE_EXPORT = 1.0;
let ACTUAL_BRICK_HEIGHT; // NEW: Holds the calculated height of the brick geometry

/**
 * Creates a geometry for a 1x1 brick with a stud on top and a recess (anti-stud) below.
 * The body height is exactly 'unitSize', and the geometry's base is at Y=0.
 *
 * @param {number} unitSize - The desired side length of the brick body (e.g., VS).
 * @returns {THREE.BufferGeometry} A merged BufferGeometry representing the brick.
 */
function createBrickGeometry(unitSize) {
    const geometries = [];
    // Tolerance for 3D printing
    const printTolerance_mm = 0.10; 
    
    // Standard LEGO dimensions (normalized to scale a 1x1 brick body to unitSize x unitSize x unitSize)
    const brick_brick_width_mm = 8.0; 
    const brick_brick_body_height_mm = 9.6; 
    const brick_stud_height_mm = 3.6;
    const brick_stud_diameter_mm = 5.4;
    const brick_outer_wall_thickness_mm = 1.5;

    // Scaling factors based on making the body width equal to unitSize
    const scale = unitSize / brick_brick_width_mm; 

    // Scaled dimensions (assuming proportional scaling based on width)
    const scaled_brick_width = brick_brick_width_mm * scale; // unitSize
    const scaled_brick_body_height = brick_brick_body_height_mm * scale; 
    const scaled_stud_height = brick_stud_height_mm * scale; 
    const scaled_stud_diameter = brick_stud_diameter_mm * scale; 
    const scaled_outer_wall_thickness = brick_outer_wall_thickness_mm * scale; 
    const scaled_print_tolerance = printTolerance_mm * scale; 

    const halfScaledWidth = scaled_brick_width / 2;
    const innerSpan = scaled_brick_width - 2 * scaled_outer_wall_thickness;

    // 1. Outer Walls (main body) - These must form a 1x1 hollow cube of height scaled_brick_body_height
    const outerWallHeight = scaled_brick_body_height;
    const outerWallYPos = outerWallHeight / 2;

    // Front and back walls
    geometries.push(new THREE.BoxGeometry(innerSpan, outerWallHeight, scaled_outer_wall_thickness).translate(0, outerWallYPos, halfScaledWidth - scaled_outer_wall_thickness / 2));
    geometries.push(new THREE.BoxGeometry(innerSpan, outerWallHeight, scaled_outer_wall_thickness).translate(0, outerWallYPos, -halfScaledWidth + scaled_outer_wall_thickness / 2));

    // Left and right walls (cover full width to include corners)
    geometries.push(new THREE.BoxGeometry(scaled_outer_wall_thickness, outerWallHeight, scaled_brick_width).translate(-halfScaledWidth + scaled_outer_wall_thickness / 2, outerWallYPos, 0));
    geometries.push(new THREE.BoxGeometry(scaled_outer_wall_thickness, outerWallHeight, scaled_brick_width).translate(halfScaledWidth - scaled_outer_wall_thickness / 2, outerWallYPos, 0));

    // 1.5. Top Plate (Ceiling)
    // We make the top plate slightly thicker than a single wall thickness for stability
    const topPlateHeight = scaled_outer_wall_thickness * 1.5; 
    const topPlateYPos = scaled_brick_body_height - (topPlateHeight / 2);
    const topPlateGeo = new THREE.BoxGeometry(innerSpan, topPlateHeight, innerSpan);
    topPlateGeo.translate(0, topPlateYPos, 0);
    geometries.push(topPlateGeo);

    // 2. Circular Stud (Top)
    // Position the stud so its base (y=0 in its local cylinder coordinates) sits at a position 
    // where it slightly overlaps with the brick body (e.g., studBottomYPos).
    const studBottomYPos = scaled_brick_body_height - (scaled_stud_height * 0.25); // Embed stud 25% into the body
    const stud_fit_diameter = scaled_stud_diameter - (2 * scaled_print_tolerance);
    const stud_radius = stud_fit_diameter / 2;

    const circularStudGeo = new THREE.CylinderGeometry(stud_radius, stud_radius, scaled_stud_height, 24); 
    circularStudGeo.translate(0, studBottomYPos + scaled_stud_height / 2, 0); // Position the center of the cylinder at studBottomYPos + half its height
    geometries.push(circularStudGeo);

    // 3. Square Anti-Stud Recess (Bottom)
    const scaledAntiStudHeight = scaled_brick_body_height;
    let holeInnerSide = scaled_stud_diameter + 2 * scaled_print_tolerance;

    let cornerPillarSide = (innerSpan - holeInnerSide) / 2;
    const minPillarThickness = 0.02 * scale; 
    if (cornerPillarSide < minPillarThickness) {
        cornerPillarSide = minPillarThickness;
        holeInnerSide = innerSpan - 2 * minPillarThickness;
    }

    const halfHoleInnerSide = holeInnerSide / 2;
    const halfCornerPillarSide = cornerPillarSide / 2;

    const xPosPillar = halfHoleInnerSide + halfCornerPillarSide;
    const zPosPillar = halfHoleInnerSide + halfCornerPillarSide;

    // Four corner pillars for the anti-stud recess
    // These pillars have their base at Y=0 (the bottom of the brick)
    geometries.push(new THREE.BoxGeometry(cornerPillarSide, scaledAntiStudHeight, cornerPillarSide).translate(xPosPillar, scaledAntiStudHeight / 2, zPosPillar));
    geometries.push(new THREE.BoxGeometry(cornerPillarSide, scaledAntiStudHeight, cornerPillarSide).translate(-xPosPillar, scaledAntiStudHeight / 2, zPosPillar));
    geometries.push(new THREE.BoxGeometry(cornerPillarSide, scaledAntiStudHeight, cornerPillarSide).translate(xPosPillar, scaledAntiStudHeight / 2, -zPosPillar));
    geometries.push(new THREE.BoxGeometry(cornerPillarSide, scaledAntiStudHeight, cornerPillarSide).translate(-xPosPillar, scaledAntiStudHeight / 2, -zPosPillar));

    const mergedGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries(geometries);
    mergedGeometry.computeVertexNormals();

    // Ensure the very bottom of the brick (minY) is at Y=0
    mergedGeometry.computeBoundingBox();
    const minY = mergedGeometry.boundingBox.min.y;
    mergedGeometry.translate(0, -minY, 0);

    return mergedGeometry;
}


/**
 * Creates a rounded cube geometry (filleted voxel) for export or preview.
 * This function handles neighbor checks for seamless geometry merges.
 */
function createRoundedVoxelGeometry(position, roundnessFactor, voxelUnitSize, neighbors = {}) {
  const s = voxelUnitSize;
  const H = s * 0.5;

  // Clamp fillet so it never eats the cube
  const R_MAX = 0.45 * H;
  const R = Math.max(0.001, Math.min(R_MAX, roundnessFactor * R_MAX));

  // If a neighbor exists on a side, radius for that side = 0 (keeps shared face flat)
  const px = neighbors.px ? 0 : R, nx = neighbors.nx ? 0 : R;
  const py = neighbors.py ? 0 : R, ny = neighbors.ny ? 0 : R;
  const pz = neighbors.pz ? 0 : R, nz = neighbors.nz ? 0 : R;

  // Inner core bounds (asymmetric if some sides are blocked)
  const minX = -H + nx, maxX = H - px;
  const minY = -H + ny, maxY = H - py;
  const minZ = -H + nz, maxZ = H - pz;

  const geom = new THREE.BoxGeometry(s, s, s, VOXEL_SEGMENTS, VOXEL_SEGMENTS, VOXEL_SEGMENTS);
  const posAttr = geom.getAttribute('position');
  const v = new THREE.Vector3();

  for (let i = 0; i < posAttr.count; i++) {
    v.fromBufferAttribute(posAttr, i);

    // Clamp to inner core
    const cx = Math.max(minX, Math.min(maxX, v.x));
    const cy = Math.max(minY, Math.min(maxY, v.y));
    const cz = Math.max(minZ, Math.min(maxZ, v.z));

    // Push outward to fillet radius along exposed directions
    const dx = v.x - cx, dy = v.y - cy, dz = v.z - cz;
    const len = Math.hypot(dx, dy, dz);
    if (len > 1e-8) {
      const k = R / len;
      v.set(cx + dx * k, cy + dy * k, cz + dz * k);
    } else {
      v.set(cx, cy, cz);
    }

    // Translate into world space for grid position
    // Note: The origin is at the center of the voxel (x.5, y.5, z.5)
    v.x += position.x * s + H;
    v.y += position.y * s + H;
    v.z += position.z * s + H;

    posAttr.setXYZ(i, v.x, v.y, v.z);
  }

  geom.attributes.position.needsUpdate = true;
  geom.computeVertexNormals();
  return geom;
}


// --- START: 3MF EXPORTER INTEGRATION ---
const VoxelApp3MFExporter = {
    exportBambuStudio3MF: async function(voxels, voxelSize, showToast, parseKey, scaleUnit, exportMode, roundnessFactor = 0) {
        if (!voxels || voxels.size === 0) {
            showToast('Export Error', 'Scene is empty.', 'warning');
            return;
        }
        if (!window.JSZip || !window.saveAs) {
            showToast('Export Error', 'Required libraries (JSZip, FileSaver) not found.', 'error');
            return;
        }
        showToast('Exporting...', 'Building Multi-Color 3MF Project File...', 'info');

        try {
            const useBrickGeometry = exportMode === 'BRICK_STUDS';
            const isRounded = exportMode === 'ROUNDED';
            roundnessFactor = isRounded ? parseFloat(document.getElementById('filletRoundnessSlider').value) : 0;

            const voxelArray = Array.from(voxels.entries()).map(([key, data]) => {
                const [x, y, z] = parseKey(key);
                if (y < 0) return null;
                return {x, y, z, color: this.normalizeColor(data.color)};
            }).filter(v => v !== null);
            
            if (voxelArray.length === 0) {
                showToast('Export Error', 'No voxels to export.', 'warning');
                return;
            }
            
            const palette = Array.from(new Set(voxelArray.map(v => v.color))).slice(0, 16); // Limit to 16 colors for AMS/Palette
            const voxelMM = (scaleUnit === 'cm' ? 10 : 1) * voxelSize;

            const mainMesh = this.buildPaintMesh(voxelArray, voxelMM, palette, isRounded, roundnessFactor, useBrickGeometry);
            const dummies = palette.map((_, i) => this.tinyTriangle(-0.2 - i * 0.05));
            
            const { xml: modelXML, ids } = this.build3DModelXML({ mainMesh, dummies });
            const projectJSON = this.buildProjectSettingsJSON(palette);
            const modelXMLset = this.buildModelSettingsXML(ids);
            
            const contentTypes = this.buildContentTypesXML();
            const rootRels = this.buildRootRelsXML();
            const modelRels = this.buildModelRelsXML();

            const zip = new JSZip();
            zip.file("[Content_Types].xml", contentTypes);
            zip.folder("_rels").file(".rels", rootRels);
            zip.folder("3D").file("3dmodel.model", modelXML);
            zip.folder("3D").folder("_rels").file("3dmodel.model.rels", modelRels);

            const metadata = zip.folder("Metadata");
            const bigThumb = this.dataURLtoUint8Array(this.makeThumb('plate_1', 600, 600));
            const smallThumb = this.dataURLtoUint8Array(this.makeThumb('plate_1_small', 300, 300));
            metadata.file("plate_1.png", bigThumb, {binary:true});
            metadata.file("plate_1_small.png", smallThumb, {binary:true});
            metadata.file("project_settings.config", projectJSON);
            metadata.file("model_settings.config", modelXMLset);

            const blob = await zip.generateAsync({type:"blob", compression:"DEFLATE", compressionOptions:{level:6}});
            
            const filenameMap = {
                'BRICK_STUDS': 'VoxelShaper_brick_studs.3mf',
                'ROUNDED': `VoxelShaper_rounded_${roundnessFactor.toFixed(2)}.3mf`,
                'SHARP_CUBE': 'VoxelShaper_sharp_cube.3mf'
            };
            const filename = filenameMap[exportMode] || 'VoxelShaper_model.3mf';

            saveAs(blob, filename);
            
            showToast('Export Complete', `${filename} saved!`, 'success');
        } catch(err) {
            console.error("3MF Export Error:", err);
            showToast('Export Error', err.message, 'error');
        }
    },
    
    esc: (s) => String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/"/g,'&quot;'),
    pad2: (n) => String(n).padStart(2,'0'),
    ymd: (d=new Date()) => `${d.getFullYear()}-${VoxelApp3MFExporter.pad2(d.getMonth()+1)}-${VoxelApp3MFExporter.pad2(d.getDate())}`,
    fmt: (n) => Number.isInteger(n)? String(n) : Number(n).toFixed(7).replace(/\.?0+$/,''),

    normalizeColor: function(c) {
        if(!c) return '#FFFFFFFF';
        let s = String(c).trim();
        if(/^0x/i.test(s)) s = '#' + s.slice(2);
        if(!s.startsWith('#')) s = '#' + s;
        if(/^#([0-9a-f]{3})$/i.test(s)){ s = '#'+s[1]+s[1]+s[2]+s[2]+s[3]+s[3]; }
        if(/^#([0-9a-f]{6})$/i.test(s)) s = s + 'FF';
        if(!/^#([0-9a-f]{8})$/i.test(s)) return '#FFFFFFFF';
        return s.toUpperCase();
    },
    tokenForColorNumber: function(n) {
        if (n <= 1) return "0";
        if (n === 2) return "8";
        return ((n-3).toString(16).toUpperCase() + "C");
    },
    
    tokenFromPaletteIndex: function(i) { return this.tokenForColorNumber(i + 1); },

    // MODIFIED: Takes useBrickGeometry and isRounded flags for geometry selection
    buildPaintMesh: function (voxels, voxelMM, palette, isRounded = false, roundnessFactor = 0, useBrickGeometry = true) {
        const V = [];            // final unique vertices as [xStr,yStr,zStr]
        const T = [];            // final triangles as [i0,i1,i2, paintToken]
        const colorToIdx = new Map(palette.map((c, i) => [String(c).toUpperCase(), i]));
        const s_mm = +voxelMM || 1;

        // occupancy for neighbor checks (used for rounded/sharp cubes)
        const occKey = (x,y,z) => `${x},${y},${z}`;
        const occ = new Set(voxels.map(v => occKey(v.x, v.y, v.z)));
        const has = (x,y,z) => occ.has(occKey(x,y,z));

        // global vertex map (after 3MF transform + scale) so triangles share indices
        const vertMap = new Map(); // key -> index
        const q = n => Math.round(n * 1e6) / 1e6; // snap to tolerate fp noise
        const getIdx = (x, y, z) => {
            const k = `${q(x)},${q(y)},${q(z)}`;
            if (!vertMap.has(k)) {
                V.push([this.fmt(x), this.fmt(y), this.fmt(z)]);
                vertMap.set(k, V.length - 1);
            }
            return vertMap.get(k);
        };

        const pushTriIdx = (i0,i1,i2, token) => {
            // skip degenerate/near-collinear
            const x0 = parseFloat(V[i0][0]), y0 = parseFloat(V[i0][1]), z0 = parseFloat(V[i0][2]);
            const x1 = parseFloat(V[i1][0]), y1 = parseFloat(V[i1][1]), z1 = parseFloat(V[i1][2]);
            const x2 = parseFloat(V[i2][0]), y2 = parseFloat(V[i2][1]), z2 = parseFloat(V[i2][2]);
            const ux = x1-x0, uy = y1-y0, uz = z1-z0;
            const vx = x2-x0, vy = y2-y0, vz = z2-z0;
            const cx = uy*vz - uz*vy, cy = uz*vx - ux*vz, cz = ux*vy - uy*vx;
            const area2 = cx*cx + cy*cy + cz*cz;
            if (area2 < 1e-18) return;
            T.push([i0, i1, i2, token]);
        };

        const tokenFromColor = (hex) => this.tokenFromPaletteIndex(colorToIdx.get(hex) ?? 0);
        const BGU = (THREE && THREE.BufferGeometryUtils) || (typeof BufferGeometryUtils !== 'undefined' ? BufferGeometryUtils : null);
        if (!BGU) throw new Error('BufferGeometryUtils not found. Load it after three.min.js');

        const p0 = new THREE.Vector3();
        const p1 = new THREE.Vector3();
        const p2 = new THREE.Vector3();
        const dummy = new THREE.Object3D();

        for (const v of voxels) {
            if (v.y < 0) continue;
            const token = tokenFromColor((v.color || '#FFFFFF').toUpperCase());
            
            let gRaw;
            let centerX, base_Y, centerZ;

            if (useBrickGeometry) {
                // BRICK GEOMETRY EXPORT
                gRaw = createBrickGeometry(1.0); 
                centerX = v.x + 0.5;
                base_Y = v.y;
                centerZ = v.z + 0.5;
                
                dummy.position.set(centerX, base_Y, centerZ);
                dummy.updateMatrix();
                gRaw.applyMatrix4(dummy.matrix);

            } else if (isRounded) {
                // ROUNDED CUBE EXPORT
                const neighbors = {
                    px: has(v.x+1, v.y, v.z), nx: has(v.x-1, v.y, v.z),
                    py: has(v.x, v.y+1, v.z), ny: has(v.x, v.y-1, v.z),
                    pz: has(v.x, v.y, v.z+1), nz: has(v.x, v.y, v.z-1),
                };
                gRaw = createRoundedVoxelGeometry(
                    new THREE.Vector3(v.x, v.y, v.z),
                    roundnessFactor,
                    1.0,
                    neighbors
                );
            } else {
                 // SHARP CUBE EXPORT
                 centerX = v.x + 0.5;
                 base_Y = v.y + 0.5; 
                 centerZ = v.z + 0.5;
                 
                 gRaw = new THREE.BoxGeometry(1.0, 1.0, 1.0);
                 gRaw.translate(centerX, base_Y, centerZ);
            }

            // Merge vertices for all custom geometries (brick and rounded)
            const geom = BGU.mergeVertices(gRaw, 1e-6);
            gRaw.dispose();

            const pos = geom.getAttribute('position');
            const idx = geom.index ? geom.index.array : [...Array(pos.count).keys()];

            for (let i = 0; i < idx.length; i += 3) {
                p0.fromBufferAttribute(pos, idx[i+0]);
                p1.fromBufferAttribute(pos, idx[i+1]);
                p2.fromBufferAttribute(pos, idx[i+2]);

                // 3MF transform + scale: (x, -z, y) * s_mm (Y is up in 3MF/Bambu)
                const i0 = getIdx(p0.x * s_mm, -p0.z * s_mm, p0.y * s_mm);
                const i1 = getIdx(p1.x * s_mm, -p1.z * s_mm, p1.y * s_mm);
                const i2 = getIdx(p2.x * s_mm, -p2.z * s_mm, p2.y * s_mm);
                
                // Add triangle only if indices are unique and area is not degenerate (checked in pushTriIdx)
                pushTriIdx(i0, i1, i2, token);
            }

            geom.dispose();
        }

        return { V, T, palette };
    },
    
    tinyTriangle: function(z = 0) {
        return {
            // X, -Z, Y axis swap
            V: [[0,0,z],[0.1,0,z],[0,0.1,z]].map(([x,y,z]) => [this.fmt(x), this.fmt(-z), this.fmt(y)]),
            T: [[0,1,2]],
        };
    },

    build3DModelXML: function({mainMesh, dummies, title='VoxelShaper Model', buildXYZ=[125,125,0]}) {
        const today = this.ymd();
        const [bx,by,bz] = buildXYZ.map(n=>+n||0);

        let nextId = 1;
        const mainId = nextId++;
        const dummyIds = dummies.map(()=>nextId++);
        const wrapperId = nextId++;

        let xml = `<?xml version="1.0" encoding="UTF-8"?>\n`;
        xml += `<model unit="millimeter" xml:lang="en-US" xmlns="http://schemas.microsoft.com/3dmanufacturing/core/2015/02" xmlns:BambuStudio="http://schemas.bambulab.com/package/2021">\n`;
        xml += ` <metadata name="Application">BambuStudio-02.02.02.56</metadata>\n <metadata name="BambuStudio:3mfVersion">1</metadata>\n`;
        xml += ` <metadata name="CreationDate">${today}</metadata>\n <metadata name="Thumbnail_Middle">/Metadata/plate_1.png</metadata>\n`;
        xml += ` <metadata name="Thumbnail_Small">/Metadata/plate_1_small.png</metadata>\n <metadata name="Title">${this.esc(title)}</metadata>\n`;

        const tokenMap = {};
        mainMesh.palette.forEach((hex, i) => { tokenMap[this.tokenFromPaletteIndex(i)] = hex; });
        xml += ` <metadata name="BambuStudio:PaintTokenARGB">${this.esc(JSON.stringify(tokenMap))}</metadata>\n`;
        xml += ` <resources>\n`;
        
        xml += `  <object id="${mainId}" type="model" name="PaintedMesh">\n  <mesh>\n    <vertices>\n`;
        for (const [x,y,z] of mainMesh.V) { xml += `      <vertex x="${x}" y="${y}" z="${z}"/>\n`; }
        xml += `    </vertices>\n  <triangles>\n`;
        for (const [v1,v2,v3,pc] of mainMesh.T) { xml += `      <triangle v1="${v1}" v2="${v2}" v3="${v3}" paint_color="${pc}"/>\n`; }
        xml += `    </triangles>\n  </mesh>\n </object>\n`;

        dummies.forEach((d, i) => {
            const id = dummyIds[i];
            xml += `  <object id="${id}" type="model" name="ColorSlot_${i+1}">\n  <mesh>\n    <vertices>\n`;
            d.V.forEach(([x,y,z]) => { xml += `      <vertex x="${x}" y="${y}" z="${z}"/>\n`; });
            xml += `    </vertices>\n    <triangles>\n`;
            d.T.forEach(([a,b,c]) => { xml += `      <triangle v1="${a}" v2="${b}" v3="${c}"/>\n`; });
            xml += `    </triangles>\n  </mesh>\n </object>\n`;
        });

        xml += `  <object id="${wrapperId}" type="model">\n  <components>\n`;
        xml += `      <component objectid="${mainId}" transform="1 0 0 0 1 0 0 0 1 0 0 0"/>\n`;
        xml += `  </components>\n </object>\n </resources>\n <build>\n`;
        
        let minX = Infinity, minY = Infinity, minZ = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        mainMesh.V.forEach(([x,y,z]) => {
            minX = Math.min(minX, x); maxX = Math.max(maxX, x);
            minY = Math.min(minY, y); maxY = Math.max(maxY, y);
            minZ = Math.min(minZ, z);
        });
        // Calculate center offset (assuming Bambu's plate is 256x256, center 128)
        const PLATE_CENTER = 128;
        const final_bx = PLATE_CENTER - (minX + (maxX-minX)/2);
        const final_by = PLATE_CENTER - (minY + (maxY-minY)/2);
        const final_bz = 0 - minZ; // Place on the bed (Z=0)
        
        xml += `    <item objectid="${wrapperId}" transform="1 0 0 0 1 0 0 0 1 ${this.fmt(final_bx)} ${this.fmt(final_by)} ${this.fmt(final_bz)}" printable="1"/>\n`;
        dummies.forEach((_, i) => {
            xml += `    <item objectid="${dummyIds[i]}" transform="1 0 0 0 1 0 0 0 1 ${this.fmt(final_bx)} ${this.fmt(final_by)} ${this.fmt(final_bz)}" printable="0"/>\n`;
        });
        xml += `</build>\n</model>\n`;
        
        return {xml, ids:{mainId, wrapperId, dummyIds}};
    },

    // ... (rest of 3MF functions remain the same) ...
    
    buildProjectSettingsJSON: function(palette){
        const cols = palette.map(c=>c.slice(0,7));
        const n = Math.min(cols.length, 16);
        const arr = v => Array.from({length:n}, ()=>v);
        const PRINTER_PRESET_NAME = "VoxelShaper Custom Printer";
        const niceNames = cols.map(c => `VoxelShaper PLA ${c}`);
        const j = {
            "version": "02.02.02.56",
            "printer_settings_id": PRINTER_PRESET_NAME,
            "plate_name": ["1"],
            "plates": [0],
            "bed_type": "Textured PEI Plate",
            "curr_bed_type": "Textured PEI Plate",
            "plate_model_index": [[0]],
            "filament_settings_id":  niceNames,
            "filament_name":         niceNames,
            "filament_display_name": niceNames,
            "filament_colour": cols,
            "filament_color":  cols,
            "filament_vendor": arr("Generic"),
            "filament_type":   arr("PLA"),
            "filament_diameter": arr("1.75"),
            "filament_ids": cols.map((_,i)=>`GEN-PLA-${i+1}`),
            "filament_is_support": arr("0"),
            "filament_printable":  arr("3"),
            "filament_map_mode": "Manual",
            "filament_map": Array.from({length:n}, (_,i)=> String(i+1)),
            "nozzle_diameter": ["0.4"],
            "selected_plate_index": 0,
            "project_location_type": "local"
        };
        return JSON.stringify(j);
    },

    buildModelSettingsXML: function(ids) {
        let x = `<?xml version="1.0" encoding="UTF-8"?>\n<config version="02.02.02.56">\n <global>\n  <object_include exclude-non-stl="0"/>\n  <object_split split="1"/>\n </global>\n <objects>\n`;
        x += `  <object id="${ids.mainId}">\n  <metadata key="extruder" value="1"/>\n </object>\n`;
        ids.dummyIds.forEach((oid, i) => {
            x += `  <object id="${oid}">\n  <metadata key="extruder" value="${i+2}"/>\n </object>\n`;
        });
        x += `</objects>\n</config>\n`;
        return x;
    },

    buildContentTypesXML: () => `<?xml version="1.0" encoding="UTF-8"?><Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types"><Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/><Default Extension="png" ContentType="image/png"/><Default Extension="json" ContentType="application/json"/><Default Extension="config" ContentType="text/xml"/><Default Extension="xml" ContentType="application/xml"/><Default Extension="model" ContentType="application/vnd.ms-package.3dmanufacturing-3dmodel+xml"/></Types>`,
    buildRootRelsXML: () => `<?xml version="1.0" encoding="UTF-8"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rel0" Type="http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel" Target="/3D/3dmodel.model"/></Relationships>`,
    buildModelRelsXML: () => `<?xml version="1.0" encoding="UTF-8"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rThumb1" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/thumbnail" Target="/Metadata/plate_1.png"/><Relationship Id="rThumb2" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/thumbnail" Target="/Metadata/plate_1_small.png"/></Relationships>`,    
    dataURLtoUint8Array: function(dataURL) {
        const base64 = dataURL.split(',')[1];
        const binary = atob(base64);
        const len = binary.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i);
        return bytes;
    },

    makeThumb: function(label="plate_1", w=600, h=600) {
        const c = document.createElement('canvas');
        c.width = w; c.height = h;
        const ctx = c.getContext('2d');
        const g = ctx.createLinearGradient(0,0,w,h);
        g.addColorStop(0,'#191a1f'); g.addColorStop(0.5,'#3b3f46'); g.addColorStop(1,'#0e0f12');
        ctx.fillStyle = g; ctx.fillRect(0,0,w,h);
        ctx.fillStyle = '#ffffff';
        ctx.globalAlpha = 0.9;
        ctx.font = `${Math.floor(w*0.08)}px system-ui,Arial,sans-serif`;
        ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText(label, w/2, h/2);
        return c.toDataURL('image/png');
    }
};
// --- END: 3MF EXPORTER INTEGRATION ---


// --- START: POLYSLICE G-CODE INTEGRATION ---
const PolysliceWrapper = {
    slicer: null,

    defaultOptions: {
        nozzleTemperature: 210, layerHeight: 0.2, nozzleDiameter: 0.4,
        travelSpeed: 4500, printSpeed: 1800, retractSpeed: 3600, retractLength: 0.8, 
        numPerimeters: 2, fillDensity: 0.2, skirtLoops: 2,
        bedSizeX: 235, bedSizeY: 235, maxZ: 250,
    },

    init: function() {
        if (typeof Polyslice === 'undefined') {
            VoxelApp.showToast('Slicer Error', 'Polyslice library not found. Cannot enable G-Code export.', 'error', 3000);
            return false;
        }
        this.slicer = new Polyslice(this.defaultOptions);
        return true;
    },

    generateGCode: async function(mergedMesh, scaleFactor, layerHeight) {
        if (!this.slicer && !this.init()) return null;
        if (!mergedMesh) return null;

        VoxelApp.showToast('Slicing...', `Starting slice at layer height ${layerHeight}mm.`, 'info');

        const scaleMatrix = new THREE.Matrix4().makeScale(scaleFactor, scaleFactor, scaleFactor);
        const scaledMesh = mergedMesh.clone();
        scaledMesh.geometry.applyMatrix4(scaleMatrix);

        const gcode = await this.slicer.slice(scaledMesh, { layerHeight: layerHeight });

        scaledMesh.geometry.dispose();

        return gcode;
    }
};
// --- END: POLYSLICE G-CODE INTEGRATION ---


const VoxelApp = {
    // --- Configuration ---
    VS: 1,
    GRID_DEFAULT: 10,
    ROTATE_SPEED: 0.003,
    MOBILE_ROTATE_SPEED_MULT: 1.5,
    PAN_SPEED: 0.05,
    PINCH_ZOOM_MULT: 50,
    DRAG_THRESHOLD: 5,
    MAX_HISTORY_SIZE: 50,
    LONG_PRESS_DURATION: 250,
    BACKEND_URL: "https://api.voxelshaper.com",
    HUB_URL: "https://hub.voxelshaper.com",
    // --- State ---
    scene: null, cam: null, ren: null, gridHelper: null, boxHelper: null,
    // MODIFIED: Use sharedBrickGeometry instead of sharedBoxGeometry
    sharedBrickGeometry: null,
    // NEW: Shared geometry for Sharp Cube (used for drawing and raycasting fallback)
    sharedSharpGeometry: null, 
    materialCache: new Map(),
    euler: null, voxels: new Map(), 
    groundPlaneMesh: null,
    cvs: null, containerDiv: null,
    currentColor: '#ffffff',
    GRID: 10,
    flySpeed: 0.1, 
    currentMode: 'SELECT',
    brushSize: 1,
    isMobile: false,
    history: [],
    historyPointer: -1,
    colorHistory: [],
    selectionChange: { before: null },
    currentStroke: null,
    templateImageMesh: null,
    templateImageData: null,
    templateImagePinnedY: null,
    templateImageAxis: 'z',
    selectedFaces: new Set(),
    selectionFaceMeshes: new Map(),
    isSelectionLocked: false,
    selectionNormalIndex: null, 
    AUTO_RESET_ORIENTATION_ON_MISMATCH: false,
    ghostVoxels: new Map(),
    previewBrush: null,
    previewVoxel: null,
    currentDrawingAxis: 'y',
    activeDrawingLevel: { x: 0, y: 0, z: 0 },
    activePointers: new Map(),
    isPointerDown: false,
    currentModelId: null,
    hapticLayer: null,
    
    // NEW: Display Mode Control
    currentDisplayMode: 'BRICK_STUDS', // Options: 'SHARP_CUBE', 'BRICK_STUDS', 'ROUNDED_BRICK' (for previewing rounded faces on a brick model)

    // REMOVED/IGNORED: Rounded preview state
    isRoundedPreviewEnabled: false, 
    previewRoundnessFactor: 0.25, 
    originalVoxelsGroup: null, 
    roundedVoxelsGroup: null, 
    mouseState: {
        isRotating: false, isPanning: false, isModifying: false, isDragging: false, isExtruding: false,
        lastX: 0, lastY: 0, downX: 0, downY: 0,
        lastActionCoords: null,
        lastActionNormal: null,
        mouseMovementX: 0, mouseMovementY: 0,
        drawingPlane: new THREE.Plane(),
        dragStartPoint: new THREE.Vector3(),
        extrudeNormal: null,
        selectionAxisLock: null,
        selectionDragStartTarget: null,
    },
    touchState: {
        longPressTimeout: null,
        isInteracting: false,
        isLookAround: false,
        isThreeFingerUndoCandidate: false,
        lastPinchDist: null,
        lastPinchCenter: null,
    },
    controls: {
        invertLookX: false, invertLookY: false, invertZoom: true,
        invertStrafeX: false, invertStrafeY: false,
    },
    user: null,
    token: null,
    Modes: {
        SELECT: { name: 'Select', icon: 'fas fa-mouse-pointer' },
        PAINT: { name: 'Paint', icon: 'fas fa-paint-brush' },
        DELETE: { name: 'Delete', icon: 'fas fa-trash' },
    },
    keyboard: {},
    
    sampleProjectData: {
        gridSize: 10,
        voxels: [
            { x: 3, y: 0, z: 3, color: '#8B4513' }, { x: 4, y: 0, z: 3, color: '#8B4513' }, { x: 5, y: 0, z: 3, color: '#8B4513' },
            { x: 3, y: 0, z: 4, color: '#8B4513' }, { x: 4, y: 0, z: 4, color: '#8B4513' }, { x: 5, y: 0, z: 4, color: '#8B4513' },
            { x: 3, y: 0, z: 5, color: '#8B4513' }, { x: 4, y: 0, z: 5, color: '#8B4513' }, { x: 5, y: 0, z: 5, color: '#8B4513' },
            { x: 3, y: 1, z: 3, color: '#D2B48C' }, { x: 5, y: 1, z: 3, color: '#D2B48C' }, { x: 3, y: 1, z: 4, color: '#D2B48C' },
            { x: 5, y: 1, z: 4, color: '#D2B48C' }, { x: 3, y: 1, z: 5, color: '#D2B48C' }, { x: 4, y: 1, z: 5, color: '#D2B48C' },
            { x: 5, y: 1, z: 5, color: '#D2B48C' }, { x: 3, y: 2, z: 3, color: '#D2B48C' }, { x: 5, y: 2, z: 3, color: '#D2B48C' },
            { x: 3, y: 2, z: 4, color: '#D2B48C' }, { x: 5, y: 2, z: 4, color: '#D2B48C' }, { x: 3, y: 2, z: 5, color: '#D2B48C' },
            { x: 4, y: 2, z: 5, color: '#D2B48C' }, { x: 5, y: 2, z: 5, color: '#D2B48C' }, { x: 2, y: 3, z: 2, color: '#A52A2A' },
            { x: 3, y: 3, z: 2, color: '#A52A2A' }, { x: 4, y: 3, z: 2, color: '#A52A2A' }, { x: 5, y: 3, z: 2, color: '#A52A2A' },
            { x: 6, y: 3, z: 2, color: '#A52A2A' }, { x: 2, y: 3, z: 3, color: '#A52A2A' }, { x: 6, y: 3, z: 3, color: '#A52A2A' },
            { x: 2, y: 3, z: 4, color: '#A52A2A' }, { x: 6, y: 3, z: 4, color: '#A52A2A' }, { x: 2, y: 3, z: 5, color: '#A52A2A' },
            { x: 6, y: 3, z: 5, color: '#A52A2A' }, { x: 2, y: 3, z: 6, color: '#A52A2A' }, { x: 3, y: 3, z: 6, color: '#A52A2A' },
            { x: 4, y: 3, z: 6, color: '#A52A2A' }, { x: 5, y: 3, z: 6, color: '#A52A2A' }, { x: 6, y: 3, z: 6, color: '#A52A2A' },
            { x: 3, y: 4, z: 3, color: '#A52A2A' }, { x: 4, y: 4, z: 3, color: '#A52A2A' }, { x: 5, y: 4, z: 3, color: '#A52A2A' },
            { x: 3, y: 4, z: 4, color: '#A52A2A' }, { x: 4, y: 4, z: 4, color: '#A52A2A' }, { x: 5, y: 4, z: 4, color: '#A52A2A' },
            { x: 3, y: 4, z: 5, color: '#A52A2A' }, { x: 4, y: 4, z: 5, color: '#A52A2A' }, { x: 5, y: 4, z: 5, color: '#A52A2A' },
        ]
    },
    
    key: (x, y, z) => (x | ((y + 1) << 10) | (z << 20)) >>> 0,
    parseKey: (k) => [k & 1023, ((k >> 10) & 1023) - 1, (k >> 20) & 1023],

    getMaterial: function(color) {
        // Use a Standard material for better PBR lighting on bricks
        if (!this.materialCache.has(color)) {
            const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.7, metalness: 0.1 });
            this.materialCache.set(color, mat);
        }
        return this.materialCache.get(color);
    },


isEmptyAt: function (x, y) {
  const hit = this.getFaceTarget(x, y);
  // treat “no hit” or the bed plane as empty
  return !hit || (hit.object && hit.object.userData && hit.object.userData.isFoundation);
},

    computeMobileMode: function () {
        return window.matchMedia('(pointer: coarse)').matches || navigator.maxTouchPoints > 0;
    },
    applyUIMode: function () {
        const mobile = this.computeMobileMode();
        this.isMobile = mobile;
        const desktopBar = document.getElementById('controls');
        const mobileWrap = document.getElementById('mobile-ui-container');
        if (mobile) {
            if (desktopBar) desktopBar.style.display = 'none';
            if (mobileWrap) mobileWrap.style.display = 'block';
        } else {
            if (desktopBar) desktopBar.style.display = 'flex';
            if (mobileWrap) mobileWrap.style.display = 'none';
        }
        document.body.classList.toggle('has-mobile-bar', this.isMobile);
    },

    init: function() {
        this.setupDOM();
        if (typeof this.keyboard === 'undefined' || this.keyboard === null) {
            this.keyboard = {};
        }
        this.applyUIMode();
        this.setupThree();
        this.rebuildFoundation();
        this.setupEventListeners();
        this.initVisualHapticLayer();
        
        // Initialize Polyslice
        PolysliceWrapper.init();

        const urlParams = new URLSearchParams(window.location.search);
        
        // Onboarding logic
        const onboardingComplete = localStorage.getItem('voxelshaper_onboarding_complete') === 'true';
        if (!onboardingComplete && !urlParams.has('modelId')) {
            this.startOnboarding();
        } else if (!urlParams.has('modelId') && !window.location.hash.includes('#oauth_success')) {
            this.loadAutosavedScene(); 
        }

        this.updateModeUI();
        this.updateDisplayModeUI(); // NEW: Update display mode label
        this.renderColorHistory();
        this.updateImageAxisUI();
        this.authCheckAndInit();
        this.handleResize();
        this.animate();
        console.log("VoxelShaper Initialized (Polyslice Ready)");
    },
    
    request: async function(endpoint, options = {}) {
        const url = `${this.BACKEND_URL}${endpoint}`;
        const mergedOptions = {
            credentials: 'include',
            ...options,
            headers: { ...(options.headers || {}) }
        };
        const method = (mergedOptions.method || 'GET').toUpperCase();
        if (['POST', 'PUT', 'DELETE', 'PATCH'].includes(method)) {
            try {
                const csrfResponse = await fetch(`${this.BACKEND_URL}/auth/csrf`, { credentials: 'include' });
                if (!csrfResponse.ok) throw new Error(`CSRF token fetch failed with status ${csrfResponse.status}`);
                const { token } = await csrfResponse.json();
                mergedOptions.headers['X-CSRF-Token'] = token;
            } catch (csrfError) {
                console.error("CSRF Token fetch error:", csrfError);
                this.showToast('Security Error', 'Could not verify your session. Please refresh and try again.', 'error');
                throw csrfError;
            }
        }
        const response = await fetch(url, mergedOptions);
        const contentType = response.headers.get('content-type');
        const isJson = contentType && contentType.includes('application/json');
        let data;
        if (response.status !== 204) {
            data = isJson ? await response.json() : await response.text();
        }
        if (!response.ok) {
            const errorMessage = isJson ? (data.error || JSON.stringify(data)) : data;
            throw new Error(errorMessage || `Request to ${endpoint} failed with status ${response.status}`);
        }
        return data;
    },

    handleOAuthRedirect: async function() {
        if (window.location.hash.includes('#oauth_success')) {
            try {
                const user = await this.request('/api/user/me');
                this.user = user;
                this.updateLoginStateUI();
                this.showToast('Login Successful', 'You are now logged in via OAuth!', 'info');
            } catch (e) {
                console.error("OAuth redirect user fetch failed:", e);
                this.showToast('Login Error', 'Failed to retrieve user data after OAuth.', 'error');
            } finally {
                // Restore original URL from state if it exists
                const originalUrl = new URLSearchParams(window.location.hash.substring(1)).get('state') || window.location.pathname;
                window.history.replaceState({}, document.title, originalUrl);
            }
        }
    },
    authCheckAndInit: async function() {
        const unsavedData = sessionStorage.getItem('unsavedVoxelData');
        if (unsavedData) {
            try {
                const data = JSON.parse(unsavedData);
                this.loadFromData(data);
                this.showToast('Progress Restored', 'Your work has been successfully restored.', 'info');
            } catch (e) {
                console.error("Failed to restore work from session storage:", e);
                this.showToast('Error', 'Could not restore your previous work.', 'error');
            } finally {
                sessionStorage.removeItem('unsavedVoxelData');
            }
        }
        await this.handleOAuthRedirect();
        const urlParams = new URLSearchParams(window.location.search || '');
        const hashParams = new URLSearchParams((window.location.hash || '').slice(1));
        const magicLinkToken = urlParams.get('token') || hashParams.get('token');
        if (!this.user && magicLinkToken) {
            try {
                const response = await this.request('/auth/magic-link', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ token: magicLinkToken })
                });
                this.user = response.user;
                this.updateLoginStateUI();
                this.showToast('Login Successful', 'You are now logged in!', 'info');
            } catch (e) {
                this.showToast('Login Error', e.message, 'error');
            } finally {
                const clean = new URL(window.location.href);
                clean.searchParams.delete('token');
                clean.hash = '';
                window.history.replaceState({}, document.title, clean.toString());
            }
        }
        if (!this.user) {
            try {
                const user = await this.request('/api/user/me');
                this.user = user;
                this.updateLoginStateUI();
            } catch (e) {
                // This is a normal case for non-logged-in users.
            }
        }
        const urlModelId = urlParams.get('modelId');
        if (urlModelId) {
            await this.loadProjectFromModelId(urlModelId);
        }
    },
    
    setupDOM: function() {
        this.cvs = document.getElementById('voxelCanvas');
        this.containerDiv = document.getElementById('container');
        this.marqueeElement = document.getElementById('marquee');
        this.hapticLayer = document.getElementById('haptic-layer');

        const categories = ["Toy", "Decoration", "Functional", "Art", "General", "Character", "Vehicle", "Nature", "Architecture"];
        const categorySelect = document.getElementById('uploadCategory');
        categories.forEach(cat => {
            const opt = document.createElement('option');
            opt.value = cat;
            opt.textContent = cat;
            categorySelect.appendChild(opt);
        });
        this.GRID = parseInt(localStorage.getItem('voxelEditorGridSize') || this.GRID_DEFAULT);
        this.currentColor = localStorage.getItem('voxelEditorColor') || '#ffffff';
        this.flySpeed = parseFloat(localStorage.getItem('voxelEditorFlySpeed') || 0.1);
        this.brushSize = parseInt(localStorage.getItem('voxelEditorBrushSize') || 1);
        this.colorHistory = JSON.parse(localStorage.getItem('voxelColorHistory')) || [];
        this.isSelectionLocked = localStorage.getItem('isSelectionLocked') === 'true';
        
        // IGNORE/FORCE DISABLE Rounded Preview settings
        this.isRoundedPreviewEnabled = false;
        this.previewRoundnessFactor = 0.25;
        // NEW: Load/set display mode
        this.currentDisplayMode = localStorage.getItem('currentDisplayMode') || 'BRICK_STUDS';
        
        this.controls.invertLookX = localStorage.getItem('invertLookX') === 'true';
        this.controls.invertLookY = localStorage.getItem('invertLookY') === 'true';
        this.controls.invertZoom = localStorage.getItem('invertZoom') !== 'false';
        this.controls.invertStrafeX = localStorage.getItem('invertStrafeX') === 'true';
        this.controls.invertStrafeY = localStorage.getItem('invertStrafeY') === 'true';
        this.currentDrawingAxis = localStorage.getItem('currentDrawingAxis') || 'y';
        this.activeDrawingLevel = JSON.parse(localStorage.getItem('activeDrawingLevel')) || { x: 0, y: 0, z: 0 };
        this.templateImageAxis = localStorage.getItem('templateImageAxis') || 'z';
        const agbChecked = localStorage.getItem('agbCheckbox');
        const newsletterChecked = localStorage.getItem('newsletterCheckbox');
        if (agbChecked !== null) {
            document.getElementById('agbCheckbox').checked = agbChecked === 'true';
        }
        document.getElementById('newsletterCheckbox').checked = newsletterChecked ? (newsletterChecked === 'true') && !this.computeMobileMode() : false;
        this.updateAllControlInputs();
    },

    setupThree: function() {
        // MODIFIED: Replace sharedBoxGeometry with sharedBrickGeometry and calculate ACTUAL_BRICK_HEIGHT
        this.sharedBrickGeometry = createBrickGeometry(this.VS);
        this.sharedBrickGeometry.computeBoundingBox();
        ACTUAL_BRICK_HEIGHT = this.sharedBrickGeometry.boundingBox.max.y;
        
        // NEW: Shared geometry for Sharp Cube
        this.sharedSharpGeometry = new THREE.BoxGeometry(this.VS, this.VS, this.VS);
        
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x282c34);
        
        this.originalVoxelsGroup = new THREE.Group();
        this.scene.add(this.originalVoxelsGroup);
        
        this.cam = new THREE.PerspectiveCamera(75, this.containerDiv.clientWidth / this.containerDiv.clientHeight, 0.1, 1000);
        this.euler = new THREE.Euler(0, 0, 0, 'YXZ');
        this.resetCamera();
        this.ren = new THREE.WebGLRenderer({ canvas: this.cvs, antialias: true });
        this.ren.shadowMap.enabled = true;
        this.ren.shadowMap.type = THREE.PCFSoftShadowMap;
        this.scene.add(new THREE.AmbientLight(0x606060));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.position.set(10, 20, 15);
        dirLight.castShadow = true;
        this.scene.add(dirLight);
        this.scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.2));
        
        this.previewVoxel = new THREE.Mesh(
            this.sharedBrickGeometry, 
            new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5, depthTest: false })
        );
        this.previewVoxel.visible = false;
        this.scene.add(this.previewVoxel);
        
        this.previewBrush = new THREE.Group();
        this.scene.add(this.previewBrush);

        const groundSize = this.GRID * this.VS * 2;
        const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize);
        const groundMaterial = new THREE.MeshBasicMaterial({ color: 0x2a2e37, transparent: true, opacity: 0.01, side: THREE.DoubleSide, visible: false }); 
        this.groundPlaneMesh = new THREE.Mesh(groundGeometry, groundMaterial);
        
        this.groundPlaneMesh.rotation.x = -Math.PI / 2;
        this.groundPlaneMesh.position.set(this.GRID * this.VS / 2, 0, this.GRID * this.VS / 2);
        this.groundPlaneMesh.userData.isFoundation = true;
        this.scene.add(this.groundPlaneMesh);

        this.rebuildHelpers();
    },
    
    setupEventListeners: function() {
        window.addEventListener('resize', () => this.handleResize());
        window.addEventListener('orientationchange', () => this.handleResize());
        this.containerDiv.addEventListener('pointerdown', (e) => this.onPointerDown(e));
        this.containerDiv.addEventListener('pointermove', (e) => this.onPointerMove(e));
        window.addEventListener('pointerup', (e) => this.onPointerUp(e));
        this.containerDiv.addEventListener('pointerleave', (e) => this.onPointerUp(e));
        this.containerDiv.addEventListener('pointercancel', (e) => this.onPointerUp(e));
        this.containerDiv.addEventListener('wheel', (e) => this.onMouseWheel(e), { passive: false });
        window.addEventListener('keydown', (e) => this.onKeyDown(e));
        window.addEventListener('keyup', (e) => this.onKeyUp(e));
        this.cvs.addEventListener('contextmenu', (e) => e.preventDefault());
        document.addEventListener('pointerlockchange', this.onPointerLockChange.bind(this), false);
        // Desktop controls
        document.getElementById('grid-size-slider').addEventListener('input', (e) => this.setGridSize(parseInt(e.target.value)));
        document.getElementById('brush-size-slider').addEventListener('input', (e) => this.setBrushSize(parseInt(e.target.value)));
        document.getElementById('fly-speed-slider').addEventListener('input', (e) => this.setFlySpeed(parseFloat(e.target.value)));
        document.getElementById('color-picker-input').addEventListener('input', (e) => this.setColor(e.target.value));
        document.getElementById('modeToggle').addEventListener('click', () => this.cycleMode());
        document.getElementById('selectionLockToggle').addEventListener('click', () => this.toggleSelectionLock());
        document.getElementById('clearBtn').addEventListener('click', () => document.getElementById('clearConfirmationModal').showModal());
        document.getElementById('saveBtn').addEventListener('click', () => this.saveJSON());
        document.getElementById('loadBtn').addEventListener('click', () => document.getElementById('fileInput').click());
        document.getElementById('exportBtn').addEventListener('click', () => document.getElementById('exportOptionsModal').showModal());
        document.getElementById('fileInput').addEventListener('change', (e) => this.loadJSON(e));
        document.getElementById('loadImageBtn').addEventListener('click', () => this.loadImageTemplate());
        document.getElementById('removeImageBtn').addEventListener('click', () => this.removeImageTemplate());
        document.getElementById('imageFileInput').addEventListener('change', (e) => this.handleImageFileSelect(e));
        document.getElementById('cycleAxisBtn').addEventListener('click', () => this.cycleDrawingAxis());
        document.getElementById('levelUpBtn').addEventListener('click', () => this.moveDrawingLevel(1));
        document.getElementById('levelDownBtn').addEventListener('click', () => this.moveDrawingLevel(-1));
        document.getElementById('invertLookX').addEventListener('change', (e) => this.setControl('invertLookX', e.target.checked));
        document.getElementById('invertLookY').addEventListener('change', (e) => this.setControl('invertLookY', e.target.checked));
        document.getElementById('invertZoom').addEventListener('change', (e) => this.setControl('invertZoom', e.target.checked));
        document.getElementById('invertStrafeX').addEventListener('change', (e) => this.setControl('invertStrafeX', e.target.checked));
        document.getElementById('invertStrafeY').addEventListener('change', (e) => this.setControl('invertStrafeY', e.target.checked));
        document.getElementById('resetDefaultsBtn').addEventListener('click', () => this.resetToDefaults());
        document.getElementById('resetCameraBtn').addEventListener('click', () => this.resetCamera());
        document.getElementById('undoBtn').addEventListener('click', () => this.undo());
        document.getElementById('redoBtn').addEventListener('click', () => this.redo());
        
        // NEW: Listener for display mode toggle button and mobile menu item
        document.getElementById('cycleDisplayModeBtn').addEventListener('click', () => this.cycleDisplayMode());
        document.getElementById('mobile-cycle-display-mode').addEventListener('click', () => this.cycleDisplayMode());

// Click/tap empty space anywhere → deselect (SELECT mode only)
this.containerDiv.addEventListener('pointerdown', (e) => {
  if (this.currentMode !== 'SELECT') return;
  if (document.querySelector('dialog[open]')) return;
  if (['INPUT','TEXTAREA','SELECT'].includes(e.target.tagName)) return;
  if (this.isEmptyAt(e.clientX, e.clientY)) this.clearSelection();
}, true);

// ESC or T → deselect (desktop)
window.addEventListener('keydown', (e) => {
  if (document.querySelector('dialog[open]')) return;
  if (['INPUT','TEXTAREA','SELECT'].includes(e.target.tagName)) return;
  if (e.key === 'Escape' || e.key.toLowerCase() === 't') this.clearSelection();
});

        // Export Modal Controls (Updated for Polyslice and 3MF)
        document.getElementById('exportBambuStudioBtn').addEventListener('click', () => {
            const scaleUnit = document.querySelector('input[name="exportScaleUnit"]:checked').value;
            const exportMode = document.querySelector('input[name="exportShapeType"]:checked').value;
            VoxelApp3MFExporter.exportBambuStudio3MF(this.voxels, this.VS, this.showToast.bind(this), this.parseKey.bind(this), scaleUnit, exportMode);
            document.getElementById('exportOptionsModal').close();
        });
        document.getElementById('exportGCodePolysliceBtn').addEventListener('click', () => {
            const scaleUnit = document.querySelector('input[name="exportScaleUnit"]:checked').value;
            const exportMode = document.querySelector('input[name="exportShapeType"]:checked').value;
            this.exportGCodePolyslice(scaleUnit, exportMode);
            document.getElementById('exportOptionsModal').close();
        });

        document.getElementById('exportSTLFinalBtn').addEventListener('click', () => {
            const scaleUnit = document.querySelector('input[name="exportScaleUnit"]:checked').value;
            const upAxis = document.querySelector('input[name="exportUpAxis"]:checked').value;
            const exportMode = document.querySelector('input[name="exportShapeType"]:checked').value;
            
            this.exportSTL(scaleUnit, upAxis, exportMode);
            document.getElementById('exportOptionsModal').close();
        });
        
        // Update listeners for new export options
        document.querySelectorAll('input[name="exportShapeType"]').forEach(radio => {
            radio.addEventListener('change', this.updateExportRoundnessUI.bind(this));
        });
        document.getElementById('filletRoundnessSlider').addEventListener('input', this.updateExportRoundnessUI.bind(this));


        // Mobile controls
        document.getElementById('mobile-overlay-undo').addEventListener('click', () => this.undo());
        document.getElementById('mobile-overlay-redo').addEventListener('click', () => this.redo());
        document.getElementById('mobile-mode-toggle').addEventListener('click', () => this.cycleMode());
        document.getElementById('mobile-selection-lock-toggle').addEventListener('click', () => this.toggleSelectionLock());
        document.getElementById('mobile-color-picker').addEventListener('input', (e) => this.setColor(e.target.value));
        document.getElementById('mobile-upload').addEventListener('click', () => document.getElementById('uploadProjectModal').showModal());
        document.getElementById('mobile-undo').addEventListener('click', () => this.undo());
        document.getElementById('mobile-redo').addEventListener('click', () => this.redo());
        document.getElementById('mobile-reset-camera').addEventListener('click', () => this.resetCamera());
        document.getElementById('mobile-settings').addEventListener('click', () => document.getElementById('mobileControlsModal').showModal());
        document.getElementById('mobile-properties').addEventListener('click', () => document.getElementById('mobilePropertiesModal').showModal());
        document.getElementById('mobile-cycle-axis').addEventListener('click', () => this.cycleDrawingAxis());
        document.getElementById('mobile-level-up').addEventListener('click', () => this.moveDrawingLevel(1));
        document.getElementById('mobile-level-down').addEventListener('click', () => this.moveDrawingLevel(-1));
        document.getElementById('mobileInvertLookX').addEventListener('change', (e) => this.setControl('invertLookX', e.target.checked));
        document.getElementById('mobileInvertLookY').addEventListener('change', (e) => this.setControl('invertLookY', e.target.checked));
        document.getElementById('mobileInvertZoom').addEventListener('change', (e) => this.setControl('invertZoom', e.target.checked));
        document.getElementById('mobileInvertStrafeX').addEventListener('change', (e) => this.setControl('invertStrafeX', e.target.checked));
        document.getElementById('mobileInvertStrafeY').addEventListener('change', (e) => this.setControl('invertStrafeY', e.target.checked));
        document.getElementById('mobile-grid-size-slider').addEventListener('input', (e) => this.setGridSize(parseInt(e.target.value)));
        document.getElementById('mobile-brush-size-slider').addEventListener('input', (e) => this.setBrushSize(parseInt(e.target.value)));

        const mobileLogoutBtn = document.getElementById('mobile-logout');
        if (mobileLogoutBtn) mobileLogoutBtn.addEventListener('click', this.loginLogout.bind(this));
        document.getElementById('saveBtnMobile').addEventListener('click', () => this.saveJSON());
        document.getElementById('loadBtnMobile').addEventListener('click', () => document.getElementById('fileInput').click());
        document.getElementById('exportBtnMobile').addEventListener('click', () => document.getElementById('exportOptionsModal').showModal());
        document.getElementById('mobile-share').addEventListener('click', () => document.getElementById('shareModal').showModal());

        document.getElementById('goToHubBtn').addEventListener('click', () => window.open(this.HUB_URL, '_blank', 'noopener,noreferrer'));

        document.getElementById('loadImageBtnMobile').addEventListener('click', () => this.loadImageTemplate());
        document.getElementById('removeImageBtnMobile').addEventListener('click', () => this.removeImageTemplate());
        document.getElementById('clearBtnMobile').addEventListener('click', () => document.getElementById('clearConfirmationModal').showModal());

        document.getElementById('cycleImageAxisBtn').addEventListener('click', () => this.cycleImageAxis());
        document.getElementById('mobile-cycle-image-axis').addEventListener('click', () => this.cycleImageAxis());
        
        document.getElementById('loginLogoutBtn').addEventListener('click', this.loginLogout.bind(this));
        document.getElementById('mobile-login-logout').addEventListener('click', this.loginLogout.bind(this));
        
        document.getElementById('shareBtn').addEventListener('click', () => document.getElementById('shareModal').showModal());
        document.getElementById('copyShareLinkBtn').addEventListener('click', () => this.copyShareLink());
        document.getElementById('uploadToHubFromShareBtn').addEventListener('click', () => {
            document.getElementById('shareModal').close();
            document.getElementById('uploadProjectModal').showModal();
        });

        document.getElementById('uploadConfirmBtn').addEventListener('click', (e) => {
            e.preventDefault();
            this.uploadProjectToHub();
            document.getElementById('uploadProjectModal').close();
        });
        document.getElementById('signInGoogleBtn').addEventListener('click', () => this.signInWithProvider('google'));
        document.getElementById('signInGithubBtn').addEventListener('click', () => this.signInWithProvider('github'));
        document.getElementById('magicLinkForm').addEventListener('submit', (e) => {
            e.preventDefault();
            this.sendMagicLink();
        });
        document.getElementById('agbCheckbox').addEventListener('change', (e) => localStorage.setItem('agbCheckbox', e.target.checked));
        document.getElementById('newsletterCheckbox').addEventListener('change', (e) => localStorage.setItem('newsletterCheckbox', e.target.checked));
        document.getElementById('confirmClearBtn').addEventListener('click', () => {
            this.clearAllConfirmed();
            document.getElementById('clearConfirmationModal').close();
        });
        
        // Initial UI updates
        this.updateExportRoundnessUI();
        // Onboarding listeners
        document.getElementById('loadSampleProjectBtn').addEventListener('click', () => this.loadSampleProject());
        document.getElementById('startBlankBtn').addEventListener('click', () => this.markOnboardingComplete());
    },
    
    updateExportRoundnessUI: function() {
        const exportMode = document.querySelector('input[name="exportShapeType"]:checked').value;
        const isRounded = exportMode === 'ROUNDED';
        const sliderGroup = document.getElementById('roundnessSliderGroup');
        const slider = document.getElementById('filletRoundnessSlider');
        const display = document.getElementById('fillet-factor-display');

        if (sliderGroup) {
            sliderGroup.style.display = isRounded ? 'block' : 'none';
        }
        if (display && slider) {
            display.textContent = parseFloat(slider.value).toFixed(2);
        }
    },
    
    handleTapInteraction: function(event) {
      if (this.currentMode === 'SELECT') {
        const target = this.getFaceTarget(event.clientX, event.clientY);
        // Tap should ONLY affect selection — no extrusion on tap.
        if (target) {
          this.handleFaceSelection(event);
        }
        return;
      }

      // Non-select modes keep their single-tap modify behavior:
      const targetInfo = this.getRayTargetInfo(this.mouseState.downX, this.mouseState.downY);
      if (targetInfo) this.modifyVoxel(targetInfo.x, targetInfo.y, targetInfo.z, targetInfo.normal);
    },

    onPointerDown: function (e) {
        if (e.target !== this.cvs) return;
        e.preventDefault();

        // Close any open dropdowns on canvas touch
        if (document.activeElement && document.activeElement.blur) {
            document.activeElement.blur();
        }

        this.currentStroke = new Map();
        this.isPointerDown = true;
        this.activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
        
        if (this.isMobile && this.activePointers.size >= 2 && this.touchState.longPressTimeout) {
          clearTimeout(this.touchState.longPressTimeout);
          this.touchState.longPressTimeout = null;
        }

        this.mouseState.downX = e.clientX;
        this.mouseState.downY = e.clientY;
        this.mouseState.lastX = e.clientX;
        this.mouseState.lastY = e.clientY;
        
        if (this.isMobile) {
            if (this.activePointers.size === 1) {
                this.touchState.longPressTimeout = setTimeout(() => {
                    this.hapticOrVisualAt(this.mouseState.downX, this.mouseState.downY);
                    this.touchState.isInteracting = true;
                    this.touchState.isLookAround = false;
                    
                    if (this.currentMode === 'SELECT') {
                        this.selectionChange.before = new Set(this.selectedFaces);
                        const target = this.getFaceTarget(this.mouseState.downX, this.mouseState.downY);
                        this.mouseState.selectionDragStartTarget = target;

                        if (target && this.selectedFaces.has(target.faceKey)) {
                            const startNormalIdx = parseInt(target.faceKey.split(':')[1], 10);
                            const sameOrientation = [...this.selectedFaces].every(k => parseInt(k.split(':')[1], 10) === startNormalIdx);
                            if (sameOrientation) {
                                this.mouseState.isExtruding = true;
                                this.mouseState.extrudeNormal = target.normal.clone();
                                const viewN = this.cam.getWorldDirection(new THREE.Vector3()).negate();
                                this.mouseState.drawingPlane.setFromNormalAndCoplanarPoint(viewN, target.intersectionPoint);
                                this.mouseState.dragStartPoint.copy(target.intersectionPoint);
                            }
                        }
                    } else {
                        this.mouseState.isModifying = true;
                    }
                }, this.LONG_PRESS_DURATION);
            } else if (this.activePointers.size === 3) {
                this.touchState.isThreeFingerUndoCandidate = true;
            } else {
                this.touchState.isThreeFingerUndoCandidate = false;
            }
            return;
        }

        // --- Desktop Logic ---
        this.mouseState.isModifying = (e.button === 0);
        this.mouseState.isPanning = (e.button === 1);
        
        if (this.mouseState.isModifying && this.currentMode === 'SELECT') {
            this.selectionChange.before = new Set(this.selectedFaces);
            const target = this.getFaceTarget(e.clientX, e.clientY);
            this.mouseState.selectionDragStartTarget = target;
            if (target && this.selectedFaces.has(target.faceKey)) {
                const startNormalIdx = parseInt(target.faceKey.split(':')[1], 10);
                const sameOrientation = [...this.selectedFaces].every(k => parseInt(k.split(':')[1], 10) === startNormalIdx);
                if (sameOrientation) {
                    this.mouseState.isExtruding = true;
                    this.mouseState.extrudeNormal = target.normal.clone();
                    const viewN = this.cam.getWorldDirection(new THREE.Vector3()).negate();
                    this.mouseState.drawingPlane.setFromNormalAndCoplanarPoint(viewN, target.intersectionPoint);
                    this.mouseState.dragStartPoint.copy(target.intersectionPoint);
                }
            }
        } else if (e.button === 2) {
            this.cvs.focus();
            this.cvs.requestPointerLock();
        }
    },
    
    onPointerMove: function(e) {
        if (document.pointerLockElement === this.cvs) {
            this.mouseState.mouseMovementX += e.movementX;
            this.mouseState.mouseMovementY += e.movementY;
            return;
        }

        if (!this.isPointerDown) {
            const targetInfo = this.getRayTargetInfo(e.clientX, e.clientY);
            this.updateToolPreview(targetInfo);
            return;
        }

        if (this.isMobile && this.activePointers.size !== 3) {
          this.touchState.isThreeFingerUndoCandidate = false;
        }
        
        const dist = Math.hypot(e.clientX - this.mouseState.downX, e.clientY - this.mouseState.downY);
        
        // --- Mobile Logic ---
        if (this.isMobile) {
             if (!this.mouseState.isDragging && dist > this.DRAG_THRESHOLD) { // First frame of drag
                 this.mouseState.isDragging = true;
                 this.touchState.isThreeFingerUndoCandidate = false;

                 if (this.touchState.longPressTimeout) {
                     clearTimeout(this.touchState.longPressTimeout);
                     this.touchState.longPressTimeout = null;
                 }
                 if (this.activePointers.size === 1 && !this.touchState.isInteracting) {
                     this.touchState.isLookAround = true;
                 }
             }

             if (this.touchState.isInteracting) {
                 const targetInfo = this.getRayTargetInfo(e.clientX, e.clientY);
                 this.updateToolPreview(targetInfo);
                 if (this.mouseState.isExtruding) {
                     const raycaster = new THREE.Raycaster();
                     const mouse = new THREE.Vector2(((e.clientX - this.cvs.getBoundingClientRect().left) / this.cvs.clientWidth) * 2 - 1, -((e.clientY - this.cvs.getBoundingClientRect().top) / this.cvs.clientHeight) * 2 + 1);
                     raycaster.setFromCamera(mouse, this.cam);
                     const intersection = new THREE.Vector3();
                     if (raycaster.ray.intersectPlane(this.mouseState.drawingPlane, intersection)) {
                         const dragVector = intersection.clone().sub(this.mouseState.dragStartPoint);
                         const extrusionDistance = dragVector.dot(this.mouseState.extrudeNormal);
                         const voxelDistance = Math.round(extrusionDistance / this.VS);
                         this.updateExtrudePreview(voxelDistance);
                     }
                 } else if (this.currentMode === 'SELECT') {
                     this.handleDragSelection(e);
                 } else {
                     if (targetInfo) {
                         const coords = {x: targetInfo.x, y: targetInfo.y, z: targetInfo.z};
                         if (!this.mouseState.lastActionCoords || coords.x !== this.mouseState.lastActionCoords.x || coords.y !== this.mouseState.lastActionCoords.y || coords.z !== this.mouseState.lastActionCoords.z) {
                             this.drawVoxelLine(this.mouseState.lastActionCoords || coords, coords, this.mouseState.lastActionNormal || targetInfo.normal);
                             this.mouseState.lastActionCoords = coords;
                             this.mouseState.lastActionNormal = targetInfo.normal;
                         }
                     }
                 }
             } else if (this.activePointers.size === 2) {
                 const pointers = Array.from(this.activePointers.values());
                 const newDist = Math.hypot(pointers[0].x - pointers[1].x, pointers[0].y - pointers[1].y);
                 const center = { x: (pointers[0].x + pointers[1].x) / 2, y: (pointers[0].y + pointers[1].y) / 2 };
                 if (!this.touchState.lastPinchDist) this.touchState.lastPinchDist = newDist;
                 let zoomDelta = (this.touchState.lastPinchDist - newDist) * this.PINCH_ZOOM_MULT * 0.001;
                 if (this.controls.invertZoom) zoomDelta *= -1;
                 this.cam.position.addScaledVector(this.cam.getWorldDirection(new THREE.Vector3()), zoomDelta);
                 this.touchState.lastPinchDist = newDist;

                 if (this.touchState.lastPinchCenter) {
                     const deltaX = center.x - this.touchState.lastPinchCenter.x;
                     const deltaY = center.y - this.touchState.lastPinchCenter.y;
                     const strafeX = this.controls.invertStrafeX ? deltaX : -deltaX;
                     const strafeY = this.controls.invertStrafeY ? -deltaY : deltaY;
                     const pan = new THREE.Vector3(strafeX * this.PAN_SPEED, strafeY * this.PAN_SPEED, 0);
                     pan.applyQuaternion(this.cam.quaternion);
                     this.cam.position.add(pan);
                 }
                 this.touchState.lastPinchCenter = center;
             } else if (this.touchState.isLookAround) { // Single-finger drag for look
                 const deltaX = e.clientX - this.mouseState.lastX;
                 const deltaY = e.clientY - this.mouseState.lastY;
                 this.euler.y -= (this.controls.invertLookX ? -deltaX : deltaX) * this.ROTATE_SPEED * this.MOBILE_ROTATE_SPEED_MULT;
                 this.euler.x -= (this.controls.invertLookY ? -deltaY : deltaY) * this.ROTATE_SPEED * this.MOBILE_ROTATE_SPEED_MULT;
             }
             
             this.activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

        } else { // --- Desktop Logic ---
             if (!this.mouseState.isDragging && dist > this.DRAG_THRESHOLD) {
                 this.mouseState.isDragging = true;
             }
             const targetInfo = this.getRayTargetInfo(e.clientX, e.clientY);
             this.updateToolPreview(targetInfo);
             if (this.mouseState.isExtruding) {
                 const raycaster = new THREE.Raycaster();
                 const mouse = new THREE.Vector2(((e.clientX - this.cvs.getBoundingClientRect().left) / this.cvs.clientWidth) * 2 - 1, -((e.clientY - this.cvs.getBoundingClientRect().top) / this.cvs.clientHeight) * 2 + 1);
                 raycaster.setFromCamera(mouse, this.cam);
                 const intersection = new THREE.Vector3();
                 if (raycaster.ray.intersectPlane(this.mouseState.drawingPlane, intersection)) {
                     const dragVector = intersection.clone().sub(this.mouseState.dragStartPoint);
                     const extrusionDistance = dragVector.dot(this.mouseState.extrudeNormal);
                     const voxelDistance = Math.round(extrusionDistance / this.VS);
                     this.updateExtrudePreview(voxelDistance);
                 }
             } else if (this.mouseState.isDragging && this.mouseState.isModifying) {
                 if (this.currentMode === 'SELECT') {
                     this.handleDragSelection(e);
                 } else {
                     if (targetInfo) {
                         const coords = {x: targetInfo.x, y: targetInfo.y, z: targetInfo.z};
                         if (!this.mouseState.lastActionCoords || coords.x !== this.mouseState.lastActionCoords.x || coords.y !== this.mouseState.lastActionCoords.y || coords.z !== this.mouseState.lastActionCoords.z) {
                             this.drawVoxelLine(this.mouseState.lastActionCoords || coords, coords, this.mouseState.lastActionNormal || targetInfo.normal);
                             this.mouseState.lastActionCoords = coords;
                             this.mouseState.lastActionNormal = targetInfo.normal;
                         }
                     }
                 }
             } else if (this.mouseState.isPanning) {
                 const deltaX = e.clientX - this.mouseState.lastX;
                 const deltaY = e.clientY - this.mouseState.lastY;
                 const pan = new THREE.Vector3(-deltaX * this.PAN_SPEED, deltaY * this.PAN_SPEED, 0);
                 pan.applyQuaternion(this.cam.quaternion);
                 this.cam.position.add(pan);
             }
        }
        
        this.mouseState.lastX = e.clientX;
        this.mouseState.lastY = e.clientY;
        this.euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.euler.x));
        this.cam.quaternion.setFromEuler(this.euler);
    },
    
    onPointerUp: function(e) {
        if (!this.isPointerDown) return;
        
        const beforeCount = this.activePointers.size;

        if(this.touchState.longPressTimeout) {
            clearTimeout(this.touchState.longPressTimeout);
            this.touchState.longPressTimeout = null;
        }

        if (this.isMobile) {
            if (this.touchState.isThreeFingerUndoCandidate) {
                this.undo();
                this.showToast('Action', 'Undo', 'info', 1000);
            } else if (this.touchState.isInteracting && !this.mouseState.isDragging) { // Is a long press tap
                this.handleTapInteraction(e);
            }
        } else if (!this.mouseState.isDragging && this.mouseState.isModifying) { // Desktop tap
            this.handleTapInteraction(e);
        }

        if (this.mouseState.isExtruding) {
            const distance = this.ghostVoxels.size > 0 ? (this.ghostVoxels.get(this.ghostVoxels.keys().next().value).distance || 0) : 0;
            this.updateExtrudePreview(0);
            if (distance !== 0) this.extrudeSelectedFaces(distance);
            this.onModelChanged(); 
        } else if (this.currentMode === 'SELECT' && this.selectionChange.before) {
            const beforeSet = this.selectionChange.before;
            const afterSet = this.selectedFaces;
            if (this.mouseState.isDragging || beforeSet.size !== afterSet.size || ![...beforeSet].every(value => afterSet.has(value))) {
                this.addHistoryStep({ type: 'SELECT', before: beforeSet, after: new Set(afterSet) });
            }
        }

        if (this.mouseState.isModifying && this.currentStroke && this.currentStroke.size > 0) {
            const actualChanges = new Map();
            for (const [key, value] of this.currentStroke.entries()) {
                const beforeColor = value.before ? value.before.color : null;
                const afterColor = value.after ? value.after.color : null;
                if (beforeColor !== afterColor) {
                    actualChanges.set(key, value);
                }
            }
            if (actualChanges.size > 0) {
                 this.addHistoryStep({ type: 'MODIFY', changes: actualChanges });
                 this.onModelChanged(); 
            }
        }

        if (document.pointerLockElement === this.cvs) document.exitPointerLock();
        
        this.activePointers.delete(e.pointerId);
        const nowCount = this.activePointers.size;

        if (this.isMobile && beforeCount >= 3 && nowCount < 3) {
            this.touchState.isThreeFingerUndoCandidate = false;
        }

        if (this.isMobile && beforeCount >= 2 && nowCount === 1) {
            const remainingPointer = this.activePointers.values().next().value;
            this.mouseState.downX = remainingPointer.x;
            this.mouseState.downY = remainingPointer.y;
            this.mouseState.lastX = remainingPointer.x;
            this.mouseState.lastY = remainingPointer.y;
            this.mouseState.isDragging = false; 
            this.touchState.isInteracting = false; 
        }
        
        if (this.activePointers.size === 0) this.isPointerDown = false;

        // --- Universal Cleanup ---
        this.currentStroke = null;
        this.touchState.longPressTimeout = null;
        this.touchState.isInteracting = false;
        this.touchState.isLookAround = false;
        this.touchState.isThreeFingerUndoCandidate = false;
        this.touchState.lastPinchDist = null;
        this.touchState.lastPinchCenter = null;
        
        Object.keys(this.mouseState).forEach(key => { if(typeof this.mouseState[key] === 'boolean') this.mouseState[key] = false });
        this.mouseState.lastActionCoords = null;
        this.mouseState.lastActionNormal = null;
        this.mouseState.selectionAxisLock = null;
        this.mouseState.selectionDragStartTarget = null;
        this.marqueeElement.style.display = 'none';
    },

    toggleSelectionLock: function() {
        this.isSelectionLocked = !this.isSelectionLocked;
        localStorage.setItem('isSelectionLocked', this.isSelectionLocked);
        this.updateSelectionLockUI();
        const state = this.isSelectionLocked ? 'Locked (Line)' : 'Unlocked (Free)';
        this.showToast('Selection Mode', `Select is now ${state}`, 'info');
    },

    updateSelectionLockUI: function() {
        const isLocked = this.isSelectionLocked;
        const desktopIcon = document.querySelector('#selectionLockToggle i');
        const mobileIcon = document.querySelector('#mobile-lock-status-icon i');
        const iconClass = isLocked ? 'fas fa-lock' : 'fas fa-unlock';
        if (desktopIcon) desktopIcon.className = iconClass;
        if (mobileIcon) mobileIcon.className = iconClass;
    },

    updateUrlWithModelId: function() {
        const newUrl = new URL(window.location.href);
        if (this.currentModelId) {
            newUrl.searchParams.set('modelId', this.currentModelId);
        } else {
            newUrl.searchParams.delete('modelId');
        }
        window.history.replaceState({ path: newUrl.href }, '', newUrl.href);
    },

    copyShareLink: function() {
        if (!this.currentModelId) {
            this.showToast('Cannot Share', 'Please upload your project to the Hub first to get a shareable link.', 'warning');
            document.getElementById('shareModal').close();
            document.getElementById('uploadProjectModal').showModal();
            return;
        }
        const link = `${window.location.origin}${window.location.pathname}?modelId=${this.currentModelId}`;
        navigator.clipboard.writeText(link).then(() => {
            this.showToast('Link Copied', 'The shareable link has been copied to your clipboard.', 'info');
        }).catch(err => {
            console.error('Failed to copy share link: ', err);
            this.showToast('Copy Failed', 'Could not copy the link.', 'error');
        });
        document.getElementById('shareModal').close();
    },

    uploadProjectToHub: async function() {
        if (!this.user) {
            this.showToast('Error', 'You must be logged in to upload.', 'error');
            return;
        }
        if (this.voxels.size === 0) {
            this.showToast('Error', 'Cannot upload an empty project.', 'error');
            return;
        }
        const title = document.getElementById('uploadTitle').value;
        if (!title) {
            this.showToast('Error', 'Title is required.', 'error');
            return;
        }
        this.showToast('Uploading...', 'Please wait...', 'info');
        const projectData = {
            gridSize: this.GRID,
            voxels: Object.fromEntries(
                Array.from(this.voxels.entries()).map(([k, v]) => {
                    const [x, y, z] = this.parseKey(k);
                    if (y < 0) return null;
                    return [`${x},${y},${z}`, v.color];
                }).filter(v => v !== null)
            )
        };
        const hubDocument = {
            name: title,
            description: document.getElementById('uploadDescription').value,
            category: document.getElementById('uploadCategory').value,
            visibility: document.querySelector('input[name="uploadVisibility"]:checked').value,
            project_json: projectData
        };
        try {
            const response = await this.request('/api/models', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(hubDocument)
            });
            this.currentModelId = response.public_id;
            this.updateUrlWithModelId();
            this.showToast('Upload Successful!', `Project saved. Share link updated.`, 'success');
        } catch (error) {
            this.showToast('Upload Failed', error.message, 'error');
        }
    },

    loadProjectFromModelId: async function(modelId) {
        this.showToast('Loading Project...', `Fetching model ${modelId}`, 'info');
        try {
            const data = await this.request(`/api/models/${modelId}`);
            
            this.clearAllConfirmed(); 

            const projectData = data.project_json;
            if (!projectData || !projectData.voxels || typeof projectData.voxels !== 'object') {
                throw new Error("Invalid or empty project data received from API.");
            }
            
            let maxX = 0, maxY = 0, maxZ = 0;
            for (const key in projectData.voxels) {
                if (Object.prototype.hasOwnProperty.call(projectData.voxels, key)) {
                    const coords = key.split(',').map(Number);
                    if (coords.length === 3) {
                        const [x, y, z] = coords;
                        if (x > maxX) maxX = x;
                        if (y > maxY) maxY = y;
                        if (z > maxZ) maxZ = z;
                        const k = this.key(x, y, z);
                        this.voxels.set(k, { color: projectData.voxels[key] });
                    }
                }
            }

            const requiredGridSize = Math.max(maxX, maxY, maxZ) + 1;
            const finalGridSize = Math.max(requiredGridSize, projectData.gridSize || this.GRID_DEFAULT);
            this.setGridSize(finalGridSize);
            
            this.rebuildSceneFromVoxels();
            this.resetCamera();
            this.currentModelId = modelId; // Keep track of the loaded ID
            this.updateUrlWithModelId(); // Ensure URL is correct
            this.showToast('Project Loaded', `Loaded "${data.name}"`, 'info');

        } catch (error) {
            console.error("Failed to load project from Hub:", error);
            this.showToast('Load Error', error.message, 'error');
            // Clear the bad modelId from URL
            const cleanUrl = new URL(window.location.href);
            cleanUrl.searchParams.delete('modelId');
            window.history.replaceState({}, document.title, cleanUrl.href);
        }
    },

    onPointerLockChange: function() {
        if (document.pointerLockElement === this.cvs) {
            this.mouseState.isRotating = true;
            this.previewVoxel.visible = false;
            this.previewBrush.visible = false;
        } else {
            this.mouseState.isRotating = false;
        }
    },

    onMouseWheel: function(e) {
        e.preventDefault();
        if (e.altKey) {
            const direction = -Math.sign(e.deltaY);
            this.moveDrawingLevel(direction);
            return;
        }
        if (document.pointerLockElement === this.cvs) {
            const speedChange = e.deltaY > 0 ? -0.01 : 0.01;
            const newSpeed = this.flySpeed + speedChange;
            this.setFlySpeed(newSpeed);
        } else {
            let zoomAmount = e.deltaY * 0.001 * this.PINCH_ZOOM_MULT;
            if (this.controls.invertZoom) zoomAmount *= -1;
            this.cam.position.addScaledVector(this.cam.getWorldDirection(new THREE.Vector3()), zoomAmount);
        }
    },
    
    onKeyDown: function(e) {
        if (e.code === 'Space') {
            if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA' && e.target.tagName !== 'SELECT' && !document.querySelector('dialog[open]')) {
                e.preventDefault();
                this.cycleMode();
            }
            return;
        }
        
        // NEW: Cycle display mode (F key)
        if (e.key.toLowerCase() === 'f' && !e.ctrlKey && !e.metaKey && e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA' && e.target.tagName !== 'SELECT' && !document.querySelector('dialog[open]')) {
             e.preventDefault();
             this.cycleDisplayMode();
             return;
        }

          if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
              e.preventDefault();
              this.undo();
              return;
            }        
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'y') {
            e.preventDefault();
            this.redo();
            return;
        }      
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's') {
            e.preventDefault();
            this.saveJSON();
        }
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;
        this.keyboard[e.key.toLowerCase()] = true;
    },
    
    onKeyUp: function(e) { this.keyboard[e.key.toLowerCase()] = false; },
    
    handleResize: function() {
        this.ren.setSize(this.containerDiv.clientWidth, this.containerDiv.clientHeight);
        this.cam.aspect = this.containerDiv.clientWidth / this.containerDiv.clientHeight;
        this.cam.updateProjectionMatrix();
        this.ren.setPixelRatio(this.isMobile ? 1.5 : window.devicePixelRatio);
        this.applyUIMode();
    },

    setGridSize: function(newSize) {
        let minSize = 5;
        if (this.voxels.size > 0) {
            let maxX = 0, maxY = 0, maxZ = 0;
            this.voxels.forEach((v,k) => {
                const [x,y,z] = this.parseKey(k);
                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
                if (z > maxZ) maxZ = z;
            });
            minSize = Math.max(maxX, maxY, maxZ) + 1;
        }
        const slider = document.getElementById('grid-size-slider');
        slider.min = minSize;
        if (newSize < minSize) {
            this.showToast('Error', `Grid cannot be smaller than the current model (${minSize}³).`, 'error');
            slider.value = minSize;
            return;
        }
        this.GRID = newSize;
        localStorage.setItem('voxelEditorGridSize', this.GRID);
        this.updateAllControlInputs();
        this.rebuildHelpers(); 
        this.rebuildFoundation();
        this.resetCamera();
        this.updateTemplateImagePosition();
    },
    
    setColor: function(newColor) {
        this.currentColor = newColor;
        localStorage.setItem('voxelEditorColor', this.currentColor);
        this.updateAllControlInputs();
        // Update the preview voxel with the new geometry determined by the current mode
        this.updatePreviewVoxelGeometry(this.previewVoxel);
        this.previewVoxel.material.color.set(this.currentColor);
    },

    setFlySpeed: function(newSpeed) {
        const minSpeed = 0.01;
        const maxSpeed = 1.0;
        this.flySpeed = Math.max(minSpeed, Math.min(maxSpeed, newSpeed));
        document.getElementById('fly-speed-display').textContent = this.flySpeed.toFixed(2);
        document.getElementById('fly-speed-slider').value = this.flySpeed;
        localStorage.setItem('voxelEditorFlySpeed', this.flySpeed);
    },
    
    setControl: function(controlName, value) {
        if (this.controls.hasOwnProperty(controlName)) {
            this.controls[controlName] = value;
            localStorage.setItem(controlName, value);
            this.updateAllControlInputs();
            this.showToast('Setting Changed', `${controlName.replace('invert', 'Invert ')} is now ${value ? 'On' : 'Off'}`, 'info', 1000);
        }
    },

    cycleMode: function() {
        const oldMode = this.currentMode;
        if (oldMode === 'SELECT') {
             if (this.selectedFaces.size > 0) {
                 const before = new Set(this.selectedFaces);
                 this.selectedFaces.clear();
                 this.updateSelectionVisuals();
                 this.addHistoryStep({ type: 'SELECT', before, after: new Set(this.selectedFaces) });
             }
        }
        const modeKeys = Object.keys(this.Modes);
        const currentIndex = modeKeys.indexOf(this.currentMode);
        this.currentMode = modeKeys[(currentIndex + 1) % modeKeys.length];
        this.updateModeUI();
    },

    modifyVoxel: function(x, y, z, normal, modeOverride) {
        if (this.currentMode === 'SELECT' && !modeOverride) return;

        const size = this.brushSize;
        if (y < 0) return; 

        if (size <= 1 || !normal || (this.currentMode !== 'PAINT' && this.currentMode !== 'DELETE')) {
            this._modifySingleVoxel(x, y, z, modeOverride);
            return;
        }
        
        const halfSize = Math.floor(size / 2);

        let iter1, iter2;
        if (Math.abs(normal.x) > 0.5) { 
            iter1 = 'y'; iter2 = 'z';
        } else if (Math.abs(normal.y) > 0.5) {
            iter1 = 'x'; iter2 = 'z';
        } else {
            iter1 = 'x'; iter2 = 'y';
        }

        for (let i = 0; i < size; i++) {
            for (let j = 0; j < size; j++) {
                const coords = { x: x, y: y, z: z };
                coords[iter1] += i - halfSize;
                coords[iter2] += j - halfSize;
                
                this._modifySingleVoxel(coords.x, coords.y, coords.z, modeOverride);
            }
        }
    },

    _modifySingleVoxel: function(x, y, z, modeOverride = null) {
        if (y < 0) return;
        x = Math.max(0, Math.min(this.GRID - 1, x));
        y = Math.max(0, Math.min(this.GRID - 1, y));
        z = Math.max(0, Math.min(this.GRID - 1, z));
        const k = this.key(x, y, z);

        if (this.currentStroke && !this.currentStroke.has(k)) {
            const originalVoxel = this.voxels.get(k);
            this.currentStroke.set(k, { 
                before: originalVoxel ? { color: originalVoxel.color } : null 
            });
        }

        const existingVoxel = this.voxels.get(k);
        let modified = false;
        const mode = modeOverride || this.currentMode;
        
        // Positioning variables for brick geometry
        const centerX = x * this.VS + 0.5;
        const base_Y_brick = y * this.VS; // Brick base aligns to grid Y=0
        const base_Y_cube = y * this.VS + 0.5; // Cube centers at grid Y=0.5
        const centerZ = z * this.VS + 0.5;

        // Determine geometry for ADD operation
        const isBrick = (this.currentDisplayMode === 'BRICK_STUDS' || this.currentDisplayMode === 'BRICK_ROUNDED');
        const geometryToUse = isBrick ? this.sharedBrickGeometry : this.sharedSharpGeometry;
        const yPos = isBrick ? base_Y_brick : base_Y_cube;

        switch (mode) {
            case 'PAINT':
                if (existingVoxel && existingVoxel.color !== this.currentColor) {
                    existingVoxel.mesh.material = this.getMaterial(this.currentColor);
                    this.voxels.get(k).color = this.currentColor;
                    modified = true;
                    this.addColorToHistory(this.currentColor);
                }
                break;
            case 'DELETE':
                if (existingVoxel) {
                    this.originalVoxelsGroup.remove(existingVoxel.mesh);
                    if (existingVoxel.mesh.geometry) existingVoxel.mesh.geometry.dispose();
                    if (existingVoxel.mesh.material) existingVoxel.mesh.material.dispose();
                    this.voxels.delete(k);
                    modified = true;
                }
                break;
            case 'ADD':
                if (!existingVoxel) {
                    // Mesh needs a clone of the geometry if it's the shared Sharp Cube, 
                    // or the shared Brick geometry (which is pre-cloned in init)
                    const geom = isBrick ? this.sharedBrickGeometry : this.sharedSharpGeometry; 
                    const mesh = new THREE.Mesh(geom, this.getMaterial(this.currentColor)); 
                    mesh.position.set(centerX, yPos, centerZ); 
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    this.originalVoxelsGroup.add(mesh);
                    this.voxels.set(k, { color: this.currentColor, mesh: mesh });
                    modified = true;
                    this.addColorToHistory(this.currentColor);
                }
                break;
        }

        if (this.currentStroke && modified) {
            const finalVoxel = this.voxels.get(k);
            const historyEntry = this.currentStroke.get(k);
            historyEntry.after = finalVoxel ? { color: finalVoxel.color } : null;
            
        }
    },

    getNormalIndex: function(normal) {
        if (Math.abs(normal.x) > 0.5) return normal.x > 0 ? 0 : 1;
        if (Math.abs(normal.y) > 0.5) return normal.y > 0 ? 2 : 3;
        if (Math.abs(normal.z) > 0.5) return normal.z > 0 ? 4 : 5;
        return -1;
    },

    getNormalFromIndex: function(index) {
        const normals = [
            new THREE.Vector3(1, 0, 0), new THREE.Vector3(-1, 0, 0),
            new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, -1, 0),
            new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1),
        ];
        return normals[index];
    },

    findVoxelDataByMesh: function(mesh) {
        if (mesh.userData.isFoundation) {
            return { mesh: this.groundPlaneMesh, isFoundation: true };
        }
        for (const voxelData of this.voxels.values()) {
            if (voxelData.mesh === mesh) return voxelData;
        }
        return null;
    },
extrudeSelectedFaces: function (distance) {
    if (this.selectedFaces.size === 0 || distance === 0) return;

    const changes = new Map();
    const newFacesToSelect = new Set();

    const isNegativeExtrude = distance < 0;
    const distanceAbs = Math.abs(distance);

    for (const faceKey of this.selectedFaces) {
        const [voxelKeyStr, normalIndexStr] = faceKey.split(':');
        const voxelKey = parseInt(voxelKeyStr);
        const normalIndex = parseInt(normalIndexStr);
        const normal = this.getNormalFromIndex(normalIndex);

        const extrudeColor = this.currentColor;
        const [x, y, z] = this.parseKey(voxelKey);

        if (!isNegativeExtrude) { // ADD
            if (!extrudeColor) continue;
            for (let i = 1; i <= distanceAbs; i++) {
                const newX = x + normal.x * i;
                const newY = y + normal.y * i;
                const newZ = z + normal.z * i;
                if (newX < 0 || newX >= this.GRID || newY < 0 || newY >= this.GRID || newZ < 0 || newZ >= this.GRID) break;

                const newKey = this.key(newX, newY, newZ);
                if (this.voxels.has(newKey)) continue;

                if (!changes.has(newKey)) changes.set(newKey, { before: null });

                // Use shared brick geometry; y is brick base
                const mesh = new THREE.Mesh(this.sharedBrickGeometry, this.getMaterial(extrudeColor));
                mesh.position.set(newX * this.VS + 0.5, newY * this.VS, newZ * this.VS + 0.5);
                mesh.castShadow = true; mesh.receiveShadow = true;

                this.originalVoxelsGroup.add(mesh);
                this.voxels.set(newKey, { color: extrudeColor, mesh });
                changes.get(newKey).after = { color: extrudeColor };
                this.addColorToHistory(extrudeColor);

                if (i === distanceAbs) newFacesToSelect.add(`${newKey}:${normalIndex}`);
            }
        } else { // DELETE (cut inwards)
            const cutDirection = normal.clone().multiplyScalar(-1);
            for (let i = 0; i < distanceAbs; i++) {
                const delX = x + cutDirection.x * i;
                const delY = y + cutDirection.y * i;
                const delZ = z + cutDirection.z * i;
                const delKey = this.key(delX, delY, delZ);

                const voxelToDelete = this.voxels.get(delKey);
                if (voxelToDelete && delY >= 0) {
                    if (!changes.has(delKey)) {
                        changes.set(delKey, { before: { color: voxelToDelete.color }, after: null });
                    }
                    this.originalVoxelsGroup.remove(voxelToDelete.mesh);
                    if (voxelToDelete.mesh.geometry) voxelToDelete.mesh.geometry.dispose();
                    if (voxelToDelete.mesh.material) voxelToDelete.mesh.material.dispose();
                    this.voxels.delete(delKey);
                }
            }

            const adjX = x + normal.x * distance;
            const adjY = y + normal.y * distance;
            const adjZ = z + normal.z * distance;
            const adjacentKey = this.key(adjX, adjY, adjZ);
            if (this.voxels.has(adjacentKey) || adjY === -1) {
                newFacesToSelect.add(`${adjacentKey}:${normalIndex}`);
            }
        }
    }

    if (changes.size > 0) {
        this.addHistoryStep({ type: 'MODIFY', changes });
        const before = new Set(this.selectedFaces);
        this.selectedFaces = newFacesToSelect;
        this.updateSelectionVisuals();
        this.addHistoryStep({ type: 'SELECT', before, after: new Set(this.selectedFaces) });
        this.onModelChanged();
    }
},

    
    updateExtrudePreview: function(distance) {
        this.ghostVoxels.forEach(ghost => {
            this.scene.remove(ghost.mesh);
            ghost.mesh.geometry.dispose();
            ghost.mesh.material.dispose();
        });
        this.ghostVoxels.clear();
        if (this.selectedFaces.size === 0) return;
        
        const firstFaceKey = this.selectedFaces.keys().next().value;
        const [, normalIndexStr] = firstFaceKey.split(':');
        const normal = this.getNormalFromIndex(parseInt(normalIndexStr));
        
        const extrudeColor = this.currentColor;
        const ghostMat = new THREE.MeshLambertMaterial({ color: extrudeColor, transparent: true, opacity: 0.5 });
        const deleteMat = new THREE.MeshLambertMaterial({ color: 0xff0000, transparent: true, opacity: 0.4 });
        this.selectedFaces.forEach(faceKey => {
            const [voxelKeyStr] = faceKey.split(':');
            const voxelKey = parseInt(voxelKeyStr);
            const [x, y, z] = this.parseKey(voxelKey);
            if (distance > 0) { // Preview ADDING
                for (let i = 1; i <= distance; i++) {
                    const newX = x + normal.x * i, newY = y + normal.y * i, newZ = z + normal.z * i;
                    const newKey = this.key(newX, newY, newZ);
                    if (!this.voxels.has(newKey) && !this.ghostVoxels.has(newKey) && newY >= 0) {
                        const ghostMesh = new THREE.Mesh(this.sharedBrickGeometry, ghostMat.clone()); // MODIFIED: Use sharedBrickGeometry
                        
                        const centerX = newX * this.VS + 0.5;
                        const base_Y = newY * this.VS; // MODIFIED: Y position change
                        const centerZ = newZ * this.VS + 0.5;

                        ghostMesh.position.set(centerX, base_Y, centerZ);
                        this.scene.add(ghostMesh);
                        this.ghostVoxels.set(newKey, { mesh: ghostMesh, distance: distance });
                    }
                }
            } else { // Preview DELETING (cutting)
                const distanceAbs = Math.abs(distance);
                const cutDirection = normal.clone().multiplyScalar(-1);
                
                for (let i = 0; i < distanceAbs; i++) {
                    const delX = x + cutDirection.x * i, delY = y + cutDirection.y * i, delZ = z + cutDirection.z * i; 
                    const delKey = this.key(delX, delY, delZ);
                    
                    if (this.voxels.has(delKey) && !this.ghostVoxels.has(delKey) && delY >= 0) {
                        const existingMesh = this.voxels.get(delKey).mesh;
                        const ghostMesh = new THREE.Mesh(this.sharedBrickGeometry, deleteMat.clone()); // MODIFIED: Use sharedBrickGeometry
                        ghostMesh.position.copy(existingMesh.position);
                        this.scene.add(ghostMesh);
                        this.ghostVoxels.set(delKey, { mesh: ghostMesh, distance: distance });
                    }
                }
            }
        });
        ghostMat.dispose(); deleteMat.dispose(); 
    },


    clearSelection: function() {
        if (this.selectedFaces.size > 0) {
            const before = new Set(this.selectedFaces);
            this.selectedFaces.clear();
            this.selectionNormalIndex = null;
            this.updateSelectionVisuals();
            this.addHistoryStep({ type: 'SELECT', before, after: new Set() });
        }
    },


    drawVoxelLine: function(start, end, normal) {
        if(this.currentMode === 'SELECT') return;

        let x0 = start.x, y0 = start.y, z0 = start.z;
        let x1 = end.x, y1 = end.y, z1 = end.z;
        const dx = Math.abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
        const dy = Math.abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
        const dz = Math.abs(z1 - z0), sz = z0 < z1 ? 1 : -1;
        let dm = Math.max(dx, dy, dz), i = dm;
        x1 = y1 = z1 = dm / 2;
        while(i-- >= 0) {
            this.modifyVoxel(x0, y0, z0, normal);
            x1 -= dx; if (x1 < 0) { x1 += dm; x0 += sx; }
            y1 -= dy; if (y1 < 0) { y1 += dm; y0 += sy; }
            z1 -= dz; if (z1 < 0) { z1 += dm; z0 += sz; }
        }
    },
    
   
    handleDragSelection: function (e) {
        // line selection when locked
        if (this.isSelectionLocked) {
            return this.handleLineSelectionDrag(e);
        }

        // if drag started on empty space -> marquee
        if (this.mouseState.selectionDragStartTarget === null && !this.isMobile) {
            this.selectVoxelsInMarquee();
            return true;
        }

        const currentNormalIndex =
            this.selectedFaces.size > 0 ? parseInt([...this.selectedFaces][0].split(':')[1], 10) : -1;

        const target = this.getFaceTarget(e.clientX, e.clientY);
        if (!target) return false;

        const targetNormalIndex = parseInt(target.faceKey.split(':')[1], 10);
        if (currentNormalIndex === -1 || targetNormalIndex === currentNormalIndex) {
            if (this.selectionNormalIndex == null) this.selectionNormalIndex = targetNormalIndex;
            if (!this.selectedFaces.has(target.faceKey)) {
                this.selectedFaces.add(target.faceKey);
                this.updateSelectionVisuals();
            }
            return true;
        }
        return false;
    },
    

     handleLineSelectionDrag: function (e) {
        const start = this.mouseState.selectionDragStartTarget;
        if (!start || !start.faceKey) return false;

        const [startKeyStr, startNormalIdxStr] = start.faceKey.split(':');
        const startNormalIdx = parseInt(startNormalIdxStr, 10);
        this.selectionNormalIndex = startNormalIdx;
        const [sx, sy, sz] = this.parseKey(parseInt(startKeyStr, 10));

        let cx, cy, cz;
        const cur = this.getFaceTarget(e.clientX, e.clientY);

        if (cur) {
            // We hit a face, get the voxel coords from the key
            const [x, y, z] = this.parseKey(parseInt(cur.faceKey.split(':')[0], 10));
            cx = x; cy = y; cz = z;
        } else {
            // Fallback: We are outside the grid, so raycast to an infinite plane
            const startNormal = this.getNormalFromIndex(startNormalIdx);
            
            // The plane passes through the center of the starting voxel's face
            const faceCenterPosition = new THREE.Vector3(
                (sx + 0.5) * this.VS,
                (sy + 0.5) * this.VS,
                (sz + 0.5) * this.VS
            ).addScaledVector(startNormal, 0.5 * this.VS);

            const selectionPlane = new THREE.Plane().setFromNormalAndCoplanarPoint(startNormal, faceCenterPosition);

            const rect = this.cvs.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((e.clientX - rect.left) / rect.width) * 2 - 1,
                -((e.clientY - rect.top) / rect.height) * 2 + 1
            );
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, this.cam);

            const intersectionPoint = new THREE.Vector3();
            if (raycaster.ray.intersectPlane(selectionPlane, intersectionPoint)) {
                // Convert the 3D intersection point to grid coordinates.
                // Subtract a tiny amount along the normal so points on a boundary floor correctly.
                const adjustedPoint = intersectionPoint.clone().addScaledVector(startNormal, -0.001);
                cx = Math.floor(adjustedPoint.x / this.VS);
                cy = Math.floor(adjustedPoint.y / this.VS);
                cz = Math.floor(adjustedPoint.z / this.VS);
            } else {
                return false; // Ray is parallel to the plane, can't determine a point.
            }
        }

        let allowedAxes;
        if (startNormalIdx === 0 || startNormalIdx === 1) {      // ±X face -> move in Y/Z
            allowedAxes = ['y', 'z'];
        } else if (startNormalIdx === 2 || startNormalIdx === 3) { // ±Y face -> move in X/Z
            allowedAxes = ['x', 'z'];
        } else {                                                     // ±Z face -> move in X/Y
            allowedAxes = ['x', 'y'];
        }

        const deltas = { x: Math.abs(cx - sx), y: Math.abs(cy - sy), z: Math.abs(cz - sz) };
        let axis = null;
        
        // Keyboard override still takes precedence
        const forced = e.shiftKey ? 'z' : (e.ctrlKey ? 'x' : null);
        if (forced && allowedAxes.includes(forced)) {
            axis = forced;
        } else {
            // Always determine the dominant axis from the allowed set.
            let maxDelta = -1;
            allowedAxes.forEach(allowedAxis => {
                if (deltas[allowedAxis] > maxDelta) {
                    maxDelta = deltas[allowedAxis];
                    axis = allowedAxis;
                }
            });
        }

        this.mouseState.selectionAxisLock = axis;
        if (!axis) return false;

        // End coordinates with chosen axis
        let ex = sx, ey = sy, ez = sz;
        if (axis === 'x') ex = cx;
        if (axis === 'y') ey = cy;
        if (axis === 'z') ez = cz;

        // Build new selection. Start with the "before" state, but only keep faces
        // that share the same orientation as the line we are drawing.
        const base = new Set();
        if(this.selectionChange.before) {
            this.selectionChange.before.forEach(faceKey => {
                if(parseInt(faceKey.split(':')[1], 10) === startNormalIdx) {
                    base.add(faceKey);
                }
            });
        }
        
        // Always add the start face.
        base.add(start.faceKey);

        const step = (a, b) => (a <= b ? 1 : -1);
        const inBounds = (x, y, z) =>
            x >= 0 && x < this.GRID &&
            y >= -1 && y < this.GRID && // allow foundation (y === -1)
            z >= 0 && z < this.GRID;
        
        // Draw the line from start to end along the dominant axis
        if (axis === 'x') {
            const inc = step(sx, ex);
            for (let x = sx; x !== ex + inc; x += inc) {
                if (sy < 0 && startNormalIdx !== 2) continue;
                if (inBounds(x, sy, sz)) base.add(`${this.key(x, sy, sz)}:${startNormalIdx}`);
            }
        } else if (axis === 'y') {
            const inc = step(sy, ey);
            for (let y = sy; y !== ey + inc; y += inc) {
                if (y < 0 && startNormalIdx !== 2) continue;
                if (inBounds(sx, y, sz)) base.add(`${this.key(sx, y, sz)}:${startNormalIdx}`);
            }
        } else { // 'z'
            const inc = step(sz, ez);
            for (let z = sz; z !== ez + inc; z += inc) {
                if (sy < 0 && startNormalIdx !== 2) continue;
                if (inBounds(sx, sy, z)) base.add(`${this.key(sx, sy, z)}:${startNormalIdx}`);
            }
        }

        this.selectedFaces = base;
        this.updateSelectionVisuals();
        this.marqueeElement.style.display = 'none';
        return true;
    },
    selectVoxelsInMarquee: function() {
        if (!this.selectionChange.before) return;
        const rect = this.containerDiv.getBoundingClientRect();
        const startX = parseFloat(this.marqueeElement.style.left) + rect.left;
        const startY = parseFloat(this.marqueeElement.style.top) + rect.top;
        const endX = startX + parseFloat(this.marqueeElement.style.width);
        const endY = startY + parseFloat(this.marqueeElement.style.height);
        let enforcedIdx = this.selectionNormalIndex;
        if (enforcedIdx == null) {
            const forward = new THREE.Vector3(); this.cam.getWorldDirection(forward);
            let best = -Infinity, bestIdx = 0;
            for (let i = 0; i < 6; i++) {
                const n = this.getNormalFromIndex(i); const dot = n.dot(forward.clone().negate());
                if (dot > best) { best = dot; bestIdx = i; }
            }
            enforcedIdx = bestIdx; this.selectionNormalIndex = enforcedIdx;
        }
        this.selectedFaces = new Set();
        if (this.selectionChange.before) {
            this.selectionChange.before.forEach(face => {
                if (parseInt(face.split(':')[1], 10) === enforcedIdx) this.selectedFaces.add(face);
            });
        }
        const allVoxelKeys = [...this.voxels.keys()];
        for (let x = 0; x < this.GRID; x++) for (let z = 0; z < this.GRID; z++) allVoxelKeys.push(this.key(x, -1, z));
        allVoxelKeys.forEach(voxelKey => {
            const [x, y, z] = this.parseKey(voxelKey);
            if (y === -1 && enforcedIdx !== 2) return;
            // MODIFIED: Use the center position of the *BRICK* for projection (X+0.5, Y, Z+0.5)
            const pos3D = new THREE.Vector3(x * this.VS + 0.5, y * this.VS + ACTUAL_BRICK_HEIGHT / 2, z * this.VS + 0.5);
            pos3D.project(this.cam);
            const screenX = (pos3D.x * 0.5 + 0.5) * rect.width + rect.left;
            const screenY = (-pos3D.y * 0.5 + 0.5) * rect.height + rect.top;
            if (screenX >= startX && screenX <= endX && screenY >= startY && screenY <= endY) {
                const i = enforcedIdx;
                const normal = this.getNormalFromIndex(i);
                const nx = x + normal.x, ny = y + normal.y, nz = z + normal.z;
                const neighborKey = this.key(nx, ny, nz);
                if (!this.voxels.has(neighborKey) && ny >= -1) this.selectedFaces.add(`${voxelKey}:${i}`);
            }
        });
        this.updateSelectionVisuals();
    },
handleFaceSelection: function (event) {
  // Ignore if we're actively dragging a marquee on desktop
  if (this.mouseState && this.mouseState.isDragging && !this.isMobile) return;

  const before = new Set(this.selectedFaces);
  const target = this.getFaceTarget(event.clientX, event.clientY);
  const isAdd = !!(event.ctrlKey || event.shiftKey);

  // If nothing was hit: optionally clear selection (unless we're in additive mode)
  if (!target) {
    if (!isAdd && before.size > 0) {
      this.selectedFaces.clear();
      this.selectionNormalIndex = null;
      this.updateSelectionVisuals();
      this.addHistoryStep({ type: 'SELECT', before, after: new Set(this.selectedFaces) });
    }
    return;
  }

  const faceKey = target.faceKey;          // "<voxelKey>:<normalIndex>"
  const targetNormalIndex = parseInt(faceKey.split(':')[1], 10);

  // Helper to finalize + history if changed
  const finalize = () => {
    this.updateSelectionVisuals();
    const after = new Set(this.selectedFaces);
    if (
      before.size !== after.size ||
      [...before].some(v => !after.has(v)) ||
      [...after].some(v => !before.has(v))
    ) {
      this.addHistoryStep({ type: 'SELECT', before, after });
    }
  };

  // If not in additive mode, single-select semantics
  if (!isAdd) {
    // Toggle off if clicking the same single face
    if (this.selectedFaces.size === 1 && this.selectedFaces.has(faceKey)) {
      this.selectedFaces.clear();
      this.selectionNormalIndex = null;
      finalize();
      return;
    }
    this.selectedFaces = new Set([faceKey]);
    this.selectionNormalIndex = targetNormalIndex;
    finalize();
    return;
  }

  // Additive (Ctrl/Shift) mode
  if (this.selectedFaces.size === 0) {
    // First item defines orientation
    this.selectedFaces.add(faceKey);
    this.selectionNormalIndex = targetNormalIndex;
    finalize();
    return;
  }

  // If we don't have an orientation yet (edge-case), adopt the target's
  if (this.selectionNormalIndex == null) {
    this.selectionNormalIndex = targetNormalIndex;
  }

  // If orientation matches, toggle target in selection
  if (this.selectionNormalIndex === targetNormalIndex) {
    if (this.selectedFaces.has(faceKey)) {
      this.selectedFaces.delete(faceKey);
      if (this.selectedFaces.size === 0) this.selectionNormalIndex = null;
    } else {
      this.selectedFaces.add(faceKey);
    }
    finalize();
    return;
  }

  // Orientation mismatch
  if (this.AUTO_RESET_ORIENTATION_ON_MISMATCH) {
    // Drop faces with other orientations, then add this one
    this.selectedFaces = new Set(
      [...this.selectedFaces].filter(k => parseInt(k.split(':')[1], 10) === targetNormalIndex)
    );
    this.selectedFaces.add(faceKey);
    this.selectionNormalIndex = targetNormalIndex;
    finalize();
  } else {
    this.showToast(
      'Selection limited',
      'All faces in a group must share the same orientation. (Tip: press Esc to clear.)',
      'info',
      1400
    );
  }
},

    getNormalIndex: function(normal) {
        if (Math.abs(normal.x) > 0.5) return normal.x > 0 ? 0 : 1;
        if (Math.abs(normal.y) > 0.5) return normal.y > 0 ? 2 : 3;
        if (Math.abs(normal.z) > 0.5) return normal.z > 0 ? 4 : 5;
        return -1;
    },



    getNormalFromIndex: function(index) {
        const normals = [
            new THREE.Vector3(1, 0, 0), new THREE.Vector3(-1, 0, 0),
            new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, -1, 0),
            new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1),
        ];
        return normals[index];
    },

    findVoxelDataByMesh: function(mesh) {
        if (mesh.userData.isFoundation) {
            return { mesh: this.groundPlaneMesh, isFoundation: true };
        }
        for (const voxelData of this.voxels.values()) {
            if (voxelData.mesh === mesh) return voxelData;
        }
        return null;
    },
getFaceAt: function (clientX, clientY) {
  const rect = this.cvs.getBoundingClientRect();
  const mouse = new THREE.Vector2(
    ((clientX - rect.left) / rect.width) * 2 - 1,
    -((clientY - rect.top) / rect.height) * 2 + 1
  );

  const raycaster = new THREE.Raycaster();
  raycaster.setFromCamera(mouse, this.cam);

  // Intersect original brick (or cube) meshes + foundation/ground plane
  const allMeshes = [
    ...this.originalVoxelsGroup.children,
    this.groundPlaneMesh
  ].filter(m => m && m.visible !== false);

  if (allMeshes.length === 0) return null;

  const intersects = raycaster.intersectObjects(allMeshes, false);
  return (intersects && intersects.length) ? intersects[0] : null;
},

    updateSelectionVisuals: function () {
        this.selectionFaceMeshes.forEach((mesh, key) => {
            if (!this.selectedFaces.has(key)) {
                this.scene.remove(mesh);
                mesh.geometry.dispose();
                mesh.material.dispose();
                this.selectionFaceMeshes.delete(key);
            }
        });
        this.selectedFaces.forEach(faceKey => {
            if (this.selectionFaceMeshes.has(faceKey)) return;
            const [voxelKeyStr, normalIndexStr] = faceKey.split(':');
            const voxelKey = parseInt(voxelKeyStr, 10);
            const normal = this.getNormalFromIndex(parseInt(normalIndexStr, 10));
            const voxelData = this.voxels.get(voxelKey);
            const isFoundation = !voxelData;
            
            const [x, y, z] = this.parseKey(voxelKey);
            
            let basePos;
            if (voxelData && voxelData.mesh) {
                // If voxel exists, use its position.
                basePos = voxelData.mesh.position;
            } else if (isFoundation && y === -1) {
                // If it's foundation, calculate center of the 1x1 base cell.
                basePos = new THREE.Vector3(x * this.VS + 0.5, y * this.VS, z * this.VS + 0.5);
            } else { return; }
            
            // Selection planes are based on the standard 1x1x1 grid size (VS)
            const plane = new THREE.Mesh(
              new THREE.PlaneGeometry(this.VS, this.VS),
              new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.6, side: THREE.DoubleSide })
            );
            
            // For X/Z faces, position is relative to the brick's center/base.
            // For Y faces, position is aligned to the top/bottom plane of the 1x1x1 space.
            let centerX, centerY, centerZ;
            
            if (y === -1 && normalIndexStr === '2') { // Foundation face (+Y up)
                centerX = basePos.x; 
                centerY = 0.001; 
                centerZ = basePos.z;
            } else { // Voxel face
                centerX = basePos.x + normal.x * 0.501 * this.VS;
                centerY = basePos.y + (ACTUAL_BRICK_HEIGHT / 2) + normal.y * 0.501 * ACTUAL_BRICK_HEIGHT;
                centerZ = basePos.z + normal.z * 0.501 * this.VS;
            }

            plane.position.set(centerX, centerY, centerZ);
            plane.lookAt(plane.position.clone().add(normal));
            this.scene.add(plane);
            this.selectionFaceMeshes.set(faceKey, plane);
        });
    },
getRayTargetInfo: function (clientX, clientY) {
  const hit = this.getFaceAt(clientX, clientY);
  if (!hit) return null;

  // Determine outward face normal (snapped)
  let normal = new THREE.Vector3();
  let point = hit.point.clone();

  if (hit.object === this.groundPlaneMesh || (hit.object.userData && hit.object.userData.isFoundation)) {
    normal.set(0, 1, 0);
  } else {
    normal.copy(hit.face.normal).transformDirection(hit.object.matrixWorld);
    const ax = Math.abs(normal.x), ay = Math.abs(normal.y), az = Math.abs(normal.z);
    if (ax >= ay && ax >= az) normal.set(Math.sign(normal.x), 0, 0);
    else if (ay >= ax && ay >= az) normal.set(0, Math.sign(normal.y), 0);
    else normal.set(0, 0, Math.sign(normal.z));
  }

  // Offset along normal so that flooring lands in the intended cell
  const isDelete = (this.currentMode === 'DELETE');
  const half = 0.5 * this.VS;
  const epsilon = 0.001;

  const offset = isDelete ? -(half - epsilon) : (half + epsilon);
  point.addScaledVector(normal, offset);

  // Convert to voxel coordinates
  const x = Math.floor(point.x / this.VS);
  const y = Math.floor(point.y / this.VS);
  const z = Math.floor(point.z / this.VS);

  // Bounds check
  if (x < 0 || x >= this.GRID || y < -1 || y >= this.GRID || z < 0 || z >= this.GRID) {
    return null;
  }

  return { x, y, z, normal, intersectionPoint: hit.point.clone() };
},

    updateToolPreview: function(targetInfo) {
        this.previewVoxel.visible = false;
        this.previewBrush.visible = false;
        if (this.currentMode === 'SELECT' || !targetInfo) return;
        
        const {x, y, z, normal} = targetInfo;
        const coords = {x, y, z};
        const targetKey = this.key(x, y, z);
        const voxelExists = this.voxels.has(targetKey);
        
        if ((this.currentMode === 'PAINT' || this.currentMode === 'DELETE') && !voxelExists) return;

        // Ensure preview voxel uses the correct geometry
        this.updatePreviewVoxelGeometry(this.previewVoxel);

        if (this.brushSize <= 1) {
            this.updateSingleVoxelPreview(coords);
        } else {
            this.updateBrushPreview(coords, normal);
        }
    },
    
    // NEW: Function to swap preview voxel's geometry based on currentDisplayMode
    updatePreviewVoxelGeometry: function(mesh) {
        const isBrick = (this.currentDisplayMode === 'BRICK_STUDS' || this.currentDisplayMode === 'BRICK_ROUNDED');
        const newGeometry = isBrick ? this.sharedBrickGeometry : this.sharedSharpGeometry;

        if (mesh.geometry !== newGeometry) {
             // Since we rely on a shared geometry, just update the reference
             mesh.geometry = newGeometry;
             // Update the position logic to match the new geometry center
             if (mesh.userData.lastPosition) {
                 const [x, y, z] = mesh.userData.lastPosition;
                 const centerX = x * this.VS + 0.5;
                 const yPos = isBrick ? y * this.VS : y * this.VS + 0.5;
                 const centerZ = z * this.VS + 0.5;
                 mesh.position.set(centerX, yPos, centerZ);
             }
        }
    },

    updateBrushPreview: function(coords, normal) {
        while(this.previewBrush.children.length > 0){ 
            const child = this.previewBrush.children[0];
            this.previewBrush.remove(child);
            child.material.dispose();
        }
        const size = this.brushSize;
        const halfSize = Math.floor(size / 2);
        let iter1, iter2;
        if (Math.abs(normal.x) > 0.5) { iter1 = 'y'; iter2 = 'z'; } 
        else if (Math.abs(normal.y) > 0.5) { iter1 = 'x'; iter2 = 'z'; } 
        else { iter1 = 'x'; iter2 = 'y'; }
        
        const isDelete = this.currentMode === 'DELETE';
        const previewColor = isDelete ? 0xff0000 : this.currentColor;
        const opacity = isDelete ? 0.4 : 0.5;
        const previewMat = new THREE.MeshBasicMaterial({ color: previewColor, transparent: true, opacity: opacity, depthTest: false });
        
        // Determine geometry for brush preview
        const isBrick = (this.currentDisplayMode === 'BRICK_STUDS' || this.currentDisplayMode === 'BRICK_ROUNDED');
        const geometryToUse = isBrick ? this.sharedBrickGeometry : this.sharedSharpGeometry;
        const yOffset = isBrick ? 0 : 0.5;

        for (let i = 0; i < size; i++) {
            for (let j = 0; j < size; j++) {
                const brushCoords = { ...coords };
                brushCoords[iter1] += i - halfSize;
                brushCoords[iter2] += j - halfSize;
                
                if (brushCoords.x >= 0 && brushCoords.x < this.GRID && brushCoords.y >= 0 && brushCoords.y < this.GRID && brushCoords.z >= 0 && brushCoords.z < this.GRID) {
                    if ((this.currentMode === 'PAINT' || this.currentMode === 'DELETE') && !this.voxels.has(this.key(brushCoords.x, brushCoords.y, brushCoords.z))) continue;
                    
                    const previewMesh = new THREE.Mesh(geometryToUse, previewMat); 
                    
                    const centerX = brushCoords.x * this.VS + 0.5;
                    const yPos = brushCoords.y * this.VS + yOffset; 
                    const centerZ = brushCoords.z * this.VS + 0.5;

                    previewMesh.position.set(centerX, yPos, centerZ);
                    this.previewBrush.add(previewMesh);
                }
            }
        }
        this.previewBrush.visible = true;
        previewMat.dispose();
    },
    
    updateSingleVoxelPreview: function(coords) {
        if (coords.x >= 0 && coords.x < this.GRID && coords.y >= 0 && coords.y < this.GRID && coords.z >= 0 && coords.z < this.GRID) {
            
            const isBrick = (this.currentDisplayMode === 'BRICK_STUDS' || this.currentDisplayMode === 'BRICK_ROUNDED');
            const yOffset = isBrick ? 0 : 0.5;

            const centerX = coords.x * this.VS + 0.5;
            const yPos = coords.y * this.VS + yOffset; 
            const centerZ = coords.z * this.VS + 0.5;
            
            this.previewVoxel.position.set(centerX, yPos, centerZ);
            this.previewVoxel.userData.lastPosition = [coords.x, coords.y, coords.z]; // Store position for geometry swap

            const isDelete = this.currentMode === 'DELETE';
            this.previewVoxel.material.opacity = isDelete ? 0.4 : 0.5;
            const previewColor = isDelete ? 0xff0000 : this.currentColor;
            this.previewVoxel.material.color.set(previewColor);
            this.previewVoxel.visible = true;
        } else {
            this.previewVoxel.visible = false;
        }
    },

    clearAllConfirmed: function() {
        this.clearSelection();
        this.removeImageTemplate();
        const oldVoxels = new Map(this.voxels);
        if (oldVoxels.size > 0) {
            const changes = new Map();
            oldVoxels.forEach((voxel, key) => {
                changes.set(key, { before: { color: voxel.color }, after: null });
            });
            this.addHistoryStep({type: 'MODIFY', changes: changes});
        }
        // Dispose of children in the voxel group
        this.originalVoxelsGroup.children.forEach(v => {
            if (v.geometry) v.geometry.dispose();
            if (v.material) v.material.dispose();
        });
        this.originalVoxelsGroup.remove(...this.originalVoxelsGroup.children);
        
        this.voxels.clear();
        this.currentModelId = null; // Clear model ID on clear
        this.updateUrlWithModelId();
        localStorage.removeItem('voxelshaper_autosave');
        this.showToast('Project Cleared', '', 'info');
        this.onModelChanged('clear');
    },

 rebuildFoundation: function() {
        const size = this.GRID * this.VS * 2;
        this.groundPlaneMesh.geometry.dispose();
        this.groundPlaneMesh.geometry = new THREE.PlaneGeometry(size, size);
        this.groundPlaneMesh.position.set(this.GRID * this.VS / 2, 0, this.GRID * this.VS / 2);
        this.groundPlaneMesh.rotation.x = -Math.PI / 2;
    },

    rebuildHelpers: function() {
        if (this.gridHelper) this.scene.remove(this.gridHelper);
        if (this.boxHelper) this.scene.remove(this.boxHelper);
        const size = this.GRID * this.VS;
        this.gridHelper = new THREE.GridHelper(size, this.GRID);
        if (this.currentDrawingAxis === 'y') {
            // MODIFIED: Grid should align with the base of the objects
            // Use 0.001 offset to avoid z-fighting with the ground plane
            this.gridHelper.position.set(size / 2, this.activeDrawingLevel.y * this.VS + 0.001, size / 2);
            this.gridHelper.rotation.set(0, 0, 0);
        } else if (this.currentDrawingAxis === 'x') {
            this.gridHelper.position.set(this.activeDrawingLevel.x * this.VS, size / 2, size / 2);
            this.gridHelper.rotation.set(0, 0, Math.PI / 2);
        } else { // 'z'
            this.gridHelper.position.set(size / 2, size / 2, this.activeDrawingLevel.z * this.VS);
            this.gridHelper.rotation.set(Math.PI / 2, 0, 0);
        }
        this.scene.add(this.gridHelper);
        const boxGeom = new THREE.BoxGeometry(size, size, size);
        const edges = new THREE.EdgesGeometry(boxGeom);
        this.boxHelper = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x4a5568 })); 
        // MODIFIED: Box position needs to account for the grid size
        this.boxHelper.position.set(size / 2, size / 2, size / 2);
        this.scene.add(this.boxHelper);
        boxGeom.dispose();
        edges.dispose();
    },

    resetCamera: function() {
        this.currentDrawingAxis = 'y';
        this.activeDrawingLevel = { x: 0, y: 0, z: 0 };
        this.updateAxisAndLevelUI();
        this.rebuildHelpers();
        const size = this.GRID * this.VS;
        // MODIFIED: Center the camera a bit higher to accommodate the taller brick geometry
        this.cam.position.set(size, size * 1.5, size * 1.5); 
        this.cam.lookAt(size / 2, size / 2, size / 2);
        if (this.euler) this.euler.setFromQuaternion(this.cam.quaternion, 'YXZ');
    },
    
    updateModeUI: function() {
        const modeInfo = this.Modes[this.currentMode];
        document.getElementById('current-mode').textContent = `Mode: ${modeInfo.name}`;
        if(this.isMobile) document.getElementById('mobile-mode-icon').className = modeInfo.icon;
        
        const isSelectMode = this.currentMode === 'SELECT';
        document.getElementById('selectionLockToggle').classList.toggle('hidden', !isSelectMode);
        document.getElementById('mobile-selection-lock-toggle').closest('li').style.display = isSelectMode ? '' : 'none';
        
        const isBrushMode = this.currentMode === 'PAINT' || this.currentMode === 'DELETE';
        const brushSlider = document.getElementById('brush-size-slider');
        const brushDisplay = document.getElementById('brush-size-display');
        const mobileBrushSlider = document.getElementById('mobile-brush-size-slider');
        if (brushSlider) brushSlider.disabled = !isBrushMode;
        if (mobileBrushSlider) mobileBrushSlider.disabled = !isBrushMode;
        
        if (brushSlider && brushDisplay) {
            brushDisplay.classList.toggle('text-base-content/50', !isBrushMode);
            brushDisplay.classList.toggle('text-primary', isBrushMode);
        }
        this.updateSelectionLockUI();
    },

    // NEW: Display Mode UI update function
    updateDisplayModeUI: function() {
        const currentModeName = {
            'SHARP_CUBE': 'Sharp Cube',
            'BRICK_STUDS': 'Brick-Studs',
            'BRICK_ROUNDED': 'Brick-Rounded'
        }[this.currentDisplayMode];

        const desktopDisplay = document.getElementById('current-display-mode');
        if (desktopDisplay) desktopDisplay.textContent = currentModeName;
        const mobileDisplay = document.getElementById('mobile-display-mode-display');
        if (mobileDisplay) mobileDisplay.textContent = currentModeName;
    },

    // NEW: Cycle Display Mode
    cycleDisplayMode: function() {
        const modes = ['BRICK_STUDS', 'BRICK_ROUNDED', 'SHARP_CUBE'];
        const currentIndex = modes.indexOf(this.currentDisplayMode);
        this.currentDisplayMode = modes[(currentIndex + 1) % modes.length];
        
        localStorage.setItem('currentDisplayMode', this.currentDisplayMode);
        this.updateDisplayModeUI(); 
        
        // Full model rebuild to apply new geometry
        this.rebuildSceneFromVoxels();
        this.onModelChanged('display_mode_change');
    },

    updateLoginStateUI: function() {
        const isLoggedIn = !!this.user;
        document.getElementById('loginLogoutBtn').textContent = isLoggedIn ? 'Logout' : 'Login';
        const uploadLi = document.getElementById('mobile-upload-li');
        if (uploadLi) uploadLi.classList.toggle('hidden', !isLoggedIn);
        document.getElementById('mobile-login-logout').textContent = isLoggedIn ? 'Logout' : 'Login';
        const loginLi = document.getElementById('mobile-login-li');
        const logoutLi = document.getElementById('mobile-logout-li');
        if (loginLi) loginLi.classList.toggle('hidden', isLoggedIn);
        if (logoutLi) logoutLi.classList.toggle('hidden', !isLoggedIn);
        const userIdDisplay = document.getElementById('userIdDisplay');
        userIdDisplay.replaceChildren();
        if (isLoggedIn && this.user) {
            if (this.user.photoURL) {
                const img = document.createElement('img');
                img.src = this.user.photoURL;
                img.alt = "User";
                img.className = "w-6 h-6 rounded-full";
                img.referrerPolicy = 'no-referrer';
                img.decoding = 'async';
                img.loading = 'lazy';
                userIdDisplay.appendChild(img);
            }
            const span = document.createElement('span');
            span.textContent = this.user.name || this.user.email;
            userIdDisplay.appendChild(span);
        }
    },
    
    showToast: function(title, message, type = 'info', duration = 1500) {
        const container = document.getElementById('toast-container');
        const alertClass = { success: 'alert-success', info: 'alert-info', warning: 'alert-warning', error: 'alert-error' }[type] || 'alert-info';
        const toast = document.createElement('div');
        toast.className = `alert ${alertClass} shadow-lg`;
        const wrap = document.createElement('div');
        const strong = document.createElement('strong');
        strong.textContent = title;
        wrap.appendChild(strong);
        if(message) {
            const br = document.createElement('br');
            const span = document.createElement('span');
            span.textContent = message;
            wrap.appendChild(br);
            wrap.appendChild(span);
        }
        toast.appendChild(wrap);
        container.appendChild(toast);
        setTimeout(() => toast.remove(), duration);
    },

    loginLogout: async function() {
        if (this.user) {
            try {
                await this.request('/auth/logout', { method: 'POST' });
                this.user = null;
                this.token = null;
                this.updateLoginStateUI();
                this.showToast('Logged Out', '', 'info');
            } catch (e) {
                this.showToast('Logout Error', e.message, 'error');
            }
        } else {
            document.getElementById('authModal').showModal();
        }
    },
    
    signInWithProvider: function(providerName) {
        try {
            if (this.voxels.size > 0) {
                const data = { 
                    gridSize: this.GRID, 
                    currentDrawingAxis: this.currentDrawingAxis,
                    activeDrawingLevel: this.activeDrawingLevel,
                    voxels: Array.from(this.voxels.entries()).map(([k, v]) => {
                        const [x, y, z] = this.parseKey(k);
                        return { x, y, z, color: v.color };
                    }),
                    templateImageData: this.templateImageData,
                    templateImagePinnedY: this.templateImagePinnedY,
                    templateImageAxis: this.templateImageAxis,
                };
                sessionStorage.setItem('unsavedVoxelData', JSON.stringify(data));
                this.showToast('Progress Saved', 'Your work will be restored after login.', 'info', 2500);
            }
        } catch (e) {
            console.error("Could not save work to session storage:", e);
            this.showToast('Warning', 'Could not save your current work before login.', 'warning');
        }
        const authUrl = new URL(`${this.BACKEND_URL}/auth/${providerName}`);
        authUrl.searchParams.append('state', window.location.href);
        if (providerName === 'google') {
            authUrl.searchParams.append('prompt', 'select_account');
        }
        window.location.href = authUrl.toString();
    },

    sendMagicLink: async function() {
        const email = document.getElementById('magicLinkEmail').value;
        const acceptsAgb = document.getElementById('agbCheckbox').checked;
        const receivesMarketingEmails = document.getElementById('newsletterCheckbox').checked;
        if (!email) {
            this.showToast('Error', 'Please enter your email.', 'error');
            return;
        }
        if (!acceptsAgb) {
            this.showToast('Error', 'Please accept the Terms of Service.', 'error');
            return;
        }
        try {
            await this.request('/auth/magic-link', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    email, 
                    receivesMarketingEmails, 
                    acceptsAgb,
                    redirect: window.location.origin + window.location.pathname
                })
            });
            document.getElementById('authModal').close();
            document.getElementById('magicLinkVerifyModal').showModal();
        } catch (e) {
            this.showToast('Error', e.message, 'error');
        }
    },

    setBrushSize: function(newSize) {
        this.brushSize = newSize;
        localStorage.setItem('voxelEditorBrushSize', this.brushSize);
        this.updateAllControlInputs();
    },

    saveJSON: function() {
        const data = { 
            gridSize: this.GRID, 
            currentDrawingAxis: this.currentDrawingAxis,
            activeDrawingLevel: this.activeDrawingLevel,
            voxels: Array.from(this.voxels.entries()).map(([k, v]) => {
                const [x, y, z] = this.parseKey(k);
                return { x, y, z, color: v.color };
            }),
            templateImageData: this.templateImageData,
            templateImagePinnedY: this.templateImagePinnedY,
            templateImageAxis: this.templateImageAxis,
            isRoundedPreviewEnabled: this.isRoundedPreviewEnabled, 
            previewRoundnessFactor: this.previewRoundnessFactor, 
            currentDisplayMode: this.currentDisplayMode, // NEW: Save current display mode
        };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = 'voxel-project.json'; a.click();
        URL.revokeObjectURL(url);
        this.showToast('Project Saved', 'File downloaded as voxel-project.json', 'info');
    },

    loadFromData: function(data) {
        try {
            this.clearSelection();
            
            // Dispose of existing meshes before clearing the map
            this.originalVoxelsGroup.children.forEach(v => {
                if (v.geometry) v.geometry.dispose();
                if (v.material) v.material.dispose();
            });
            this.originalVoxelsGroup.remove(...this.originalVoxelsGroup.children);
            this.voxels.clear();
            
            this.GRID = data.gridSize || this.GRID_DEFAULT;
            this.currentDrawingAxis = data.currentDrawingAxis || 'y';
            this.activeDrawingLevel = data.activeDrawingLevel || { x: 0, y: 0, z: 0 };
            this.templateImageAxis = data.templateImageAxis || 'z';
            
            // IGNORE/FORCE DISABLE Rounded Preview settings on load
            this.isRoundedPreviewEnabled = false;
            this.previewRoundnessFactor = 0.25;
            // NEW: Load current display mode
            this.currentDisplayMode = data.currentDisplayMode || 'BRICK_STUDS';


            this.colorHistory = [];
            if (Array.isArray(data.voxels)) {
                data.voxels.forEach(v => {
                    const k = this.key(v.x, v.y, v.z);
                    this.voxels.set(k, { color: v.color });
                    this.addColorToHistory(v.color);
                });
            }
            this.renderColorHistory();

            this.templateImagePinnedY = (data.templateImagePinnedY ?? null);
            if (data.templateImageData) {
                this.loadImageFromData(data.templateImageData);
            } else {
                this.removeImageTemplate();
            }
            this.rebuildSceneFromVoxels();
            this.rebuildHelpers(); 
            this.updateAllControlInputs();
            this.updateImageAxisUI();
            this.updateDisplayModeUI(); // NEW: Update display mode label
            this.resetCamera();
            this.history = []; this.historyPointer = -1;
            return true;
        } catch (err) {
            this.showToast('Load Error', `Invalid project data. ${err.message}`, 'error');
            return false;
        }
    },

    loadJSON: function(event) {
        const file = event.target.files[0]; if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                if (this.loadFromData(data)) {
                    this.showToast('Project Loaded', 'Successfully loaded from file.', 'info');
                }
            } catch (err) {
                this.showToast('Load Error', `Could not read the file. ${err.message}`, 'error');
            }
        };
        reader.readAsText(file);
        event.target.value = '';
    },
    
    // --- EXPORT FUNCTIONS ---
    
    /**
     * Builds the complete merged mesh for the model based on rounding options.
     * @param {string} exportMode - The selected export mode ('SHARP_CUBE', 'BRICK_STUDS', 'ROUNDED').
     * @returns {THREE.Mesh|null} The merged mesh or null if empty.
     */
    buildMergedMesh: function(exportMode) {
        if (this.voxels.size === 0) return null;
        this.showToast('Building Mesh', `Combining ${this.voxels.size} voxels...`, 'info');
        
        const useBrickGeometry = exportMode === 'BRICK_STUDS';
        const isRounded = exportMode === 'ROUNDED'; 
        
        const geoms = [];
        const s = this.VS;
        const H = s * 0.5;
        const ROUNDNESS = isRounded ? parseFloat(document.getElementById('filletRoundnessSlider').value) : 0;
        const has = (x,y,z) => this.voxels.has(this.key(x,y,z));

        this.voxels.forEach((v, packedKey) => {
            const [x, y, z] = this.parseKey(packedKey);
            if (y < 0) return;

            let g;
            if (useBrickGeometry) {
                // BRICK GEOMETRY
                g = createBrickGeometry(s); 
                // Translate so the BRICK's base (Y=0) is at the correct grid level (y * s)
                g.translate(x * s + H, y * s, z * s + H);
            } else if (isRounded) {
                // ROUNDED CUBE GEOMETRY
                const neighbors = {
                    px: has(x+1,y,z), nx: has(x-1,y,z),
                    py: has(x,y+1,z), ny: has(x,y-1,z),
                    pz: has(x,y,z+1), nz: has(x,y,z-1),
                };
                g = createRoundedVoxelGeometry(new THREE.Vector3(x,y,z), ROUNDNESS, s, neighbors);
            } else {
                // SHARP CUBE GEOMETRY
                g = new THREE.BoxGeometry(s, s, s);
                g.translate(x * s + H, y * s + H, z * s + H);
            }
            geoms.push(g);
        });

        if (geoms.length === 0) return null;

        const BGU = (THREE && THREE.BufferGeometryUtils) || (typeof BufferGeometryUtils !== 'undefined' ? BufferGeometryUtils : null);
        if (!BGU) {
            this.showToast('Error', 'BufferGeometryUtils not found for export.', 'error');
            geoms.forEach(g => g.dispose());
            return null;
        }

        const merged = BGU.mergeBufferGeometries(geoms, false);
        geoms.forEach(g => g.dispose());
        
        const mesh = new THREE.Mesh(merged);
        mesh.updateMatrixWorld(true);
        return mesh;
    },

    exportSTL: function(scaleUnit = 'mm', upAxis = 'Z', exportMode) {
        if (this.voxels.size === 0) {
            this.showToast('Export Error', 'Scene is empty.', 'warning');
            return;
        }
        this.showToast('Exporting...', 'Generating STL file...', 'info');

        const mergedMesh = this.buildMergedMesh(exportMode);
        if (!mergedMesh) return;
        
        const exporter = new THREE.STLExporter();
        const scale = (scaleUnit === 'cm') ? 10 : 1;
        
        // Scale + axis correction
        const m = new THREE.Matrix4().makeScale(scale, scale, scale);
        if (upAxis === 'Z') m.multiply(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
        
        mergedMesh.geometry.applyMatrix4(m);
        mergedMesh.updateMatrixWorld(true);

        const stlData = exporter.parse(mergedMesh, { binary: true });
        
        mergedMesh.geometry.dispose();
        
        const filenameMap = {
            'BRICK_STUDS': 'voxel-model-brick-studs.stl',
            'ROUNDED': `voxel-model-rounded_${parseFloat(document.getElementById('filletRoundnessSlider').value).toFixed(2)}.stl`,
            'SHARP_CUBE': 'voxel-model-sharp-cube.stl'
        };
        const filename = filenameMap[exportMode] || 'voxel-model.stl';

        const blob = new Blob([stlData], { type: 'application/octet-stream' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url; a.download = filename; a.click();
        URL.revokeObjectURL(url);

        this.showToast('Export Complete', `Downloaded ${filename}`, 'success');
    },

    exportGCodePolyslice: async function(scaleUnit = 'mm', exportMode) {
        if (this.voxels.size === 0) {
            this.showToast('Export Error', 'Scene is empty.', 'warning');
            return;
        }
        if (!PolysliceWrapper.slicer) {
             this.showToast('Slicer Error', 'Polyslice failed to initialize. Cannot generate G-Code.', 'error');
             return;
        }
        
        const mergedMesh = this.buildMergedMesh(exportMode);
        if (!mergedMesh) return;

        const scaleFactor = (scaleUnit === 'cm') ? 10 : 1;
        
        try {
            const gcode = await PolysliceWrapper.generateGCode(
                mergedMesh, 
                scaleFactor, 
                PolysliceWrapper.defaultOptions.layerHeight 
            );

            if (gcode) {
                const blob = new Blob([gcode], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                
                const filenameMap = {
                    'BRICK_STUDS': 'voxel-print-brick-studs.gcode',
                    'ROUNDED': 'voxel-print-rounded.gcode',
                    'SHARP_CUBE': 'voxel-print-sharp-cube.gcode'
                };
                const filename = filenameMap[exportMode] || 'voxel-print.gcode';

                const a = document.createElement('a');
                a.href = url; a.download = filename; a.click();
                URL.revokeObjectURL(url);

                this.showToast('Slicing Complete', `G-Code for ${filename} downloaded!`, 'success', 3000);
            } else {
                this.showToast('Slicing Failed', 'Polyslice returned no G-Code. Check your model.', 'error', 3000);
            }
        } catch (e) {
            console.error('Polyslice G-Code Generation Error:', e);
            this.showToast('Slicing Error', `Failed to generate G-Code: ${e.message}`, 'error', 5000);
        } finally {
            if (mergedMesh) {
                mergedMesh.geometry.dispose();
            }
        }
    },


    animate: function() {
        requestAnimationFrame(() => this.animate());
        
        if (document.pointerLockElement === this.cvs) {
            const rotX = this.controls.invertLookX ? this.mouseState.mouseMovementX : -this.mouseState.mouseMovementX;
            const rotY = this.controls.invertLookY ? this.mouseState.mouseMovementY : -this.mouseState.mouseMovementY;
            this.euler.y += rotX * this.ROTATE_SPEED;
            this.euler.x += rotY * this.ROTATE_SPEED;
            this.euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.euler.x));
            this.cam.quaternion.setFromEuler(this.euler);
            this.mouseState.mouseMovementX = 0;
            this.mouseState.mouseMovementY = 0;
            const forward = new THREE.Vector3();
            this.cam.getWorldDirection(forward);
            const right = new THREE.Vector3().crossVectors(forward, this.cam.up).normalize();
            const strafeXSpeed = this.controls.invertStrafeX ? -this.flySpeed : this.flySpeed;
            const strafeYSpeed = this.controls.invertStrafeY ? -this.flySpeed : this.flySpeed;
            if (this.keyboard['w']) this.cam.position.addScaledVector(forward, this.flySpeed);
            if (this.keyboard['s']) this.cam.position.addScaledVector(forward, -this.flySpeed);
            if (this.keyboard['a']) this.cam.position.addScaledVector(right, -strafeXSpeed);
            if (this.keyboard['d']) this.cam.position.addScaledVector(right, strafeXSpeed);
            if (this.keyboard['e']) this.cam.position.y += strafeYSpeed;
            if (this.keyboard['q']) this.cam.position.y -= strafeYSpeed;
        }
        this.ren.render(this.scene, this.cam);
    },
    
    // State
    roundedPreviewDirty: false,
    _roundedRebuildRAF: null,

    onModelChanged(reason = '') {
      this.autosaveScene();
    },

    rebuildSceneFromVoxels: function () {
        // Dispose of the original group children
        this.originalVoxelsGroup.children.forEach(v => {
            if (v.geometry) v.geometry.dispose();
            if (v.material) v.material.dispose();
        });
        this.originalVoxelsGroup.remove(...this.originalVoxelsGroup.children);

        // Determine geometry and Y-position logic based on the new display mode
        const isBrick = (this.currentDisplayMode === 'BRICK_STUDS' || this.currentDisplayMode === 'BRICK_ROUNDED');
        const geometryToUse = isBrick ? this.sharedBrickGeometry : this.sharedSharpGeometry;
        const yOffset = isBrick ? 0 : 0.5; // Brick base at Y=0, Cube center at Y=0.5

        this.voxels.forEach((voxelData, key) => {
            const [x, y, z] = this.parseKey(key);
            
            if (y < 0) return; 

            const mesh = new THREE.Mesh(
                geometryToUse, 
                this.getMaterial(voxelData.color)
            );
            
            const centerX = x * this.VS + 0.5;
            const yPos = y * this.VS + yOffset; 
            const centerZ = z * this.VS + 0.5;

            mesh.position.set(centerX, yPos, centerZ); 
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.userData.isVoxel = true;
            mesh.userData.isFoundation = false;
            this.originalVoxelsGroup.add(mesh);
            voxelData.mesh = mesh;
        });
        
        // Ensure the preview voxel geometry is also updated
        this.updatePreviewVoxelGeometry(this.previewVoxel);
    },

    addHistoryStep: function(action) {
        if (this.historyPointer < this.history.length - 1) {
            this.history.splice(this.historyPointer + 1);
        }
        this.history.push(action);
        if (this.history.length > this.MAX_HISTORY_SIZE) {
            this.history.shift();
        }
        this.historyPointer = this.history.length - 1;
        this.autosaveScene();
    },

    undo: function() {
        if (this.historyPointer < 0) return;
        const action = this.history[this.historyPointer];
        
        // Determine current geometry settings
        const isBrick = (this.currentDisplayMode === 'BRICK_STUDS' || this.currentDisplayMode === 'BRICK_ROUNDED');
        const geometryToUse = isBrick ? this.sharedBrickGeometry : this.sharedSharpGeometry;
        const yOffset = isBrick ? 0 : 0.5;

        switch(action.type) {
            case 'MODIFY':
                action.changes.forEach((change, key) => {
                    const [x, y, z] = this.parseKey(key);
                    if (y < 0) return;
                    
                    const centerX = x * this.VS + 0.5;
                    const yPos = y * this.VS + yOffset; 
                    const centerZ = z * this.VS + 0.5;
                    
                    if (change.before === null) {
                        const existingVoxel = this.voxels.get(key);
                        if (existingVoxel) {
                            this.originalVoxelsGroup.remove(existingVoxel.mesh);
                            if (existingVoxel.mesh.geometry) existingVoxel.mesh.geometry.dispose();
                            if (existingVoxel.mesh.material) existingVoxel.mesh.material.dispose();
                            this.voxels.delete(key);
                        }
                    } else {
                        const existingVoxel = this.voxels.get(key);
                        if(existingVoxel) {
                            existingVoxel.mesh.material = this.getMaterial(change.before.color);
                            existingVoxel.color = change.before.color;
                            // Ensure geometry is correct after undo in case mode changed mid-session
                            existingVoxel.mesh.geometry = geometryToUse;
                            existingVoxel.mesh.position.set(centerX, yPos, centerZ);
                        } else {
                            const voxelMesh = new THREE.Mesh(geometryToUse, this.getMaterial(change.before.color));
                            voxelMesh.position.set(centerX, yPos, centerZ);
                            voxelMesh.castShadow = true;
                            voxelMesh.receiveShadow = true;
                            this.originalVoxelsGroup.add(voxelMesh);
                            this.voxels.set(key, { color: change.before.color, mesh: voxelMesh });
                        }
                    }
                });
                break;
                
            case 'SELECT':
                this.selectedFaces = new Set(action.before);
                this.updateSelectionVisuals();
                break;
        }
        this.historyPointer--;
        this.autosaveScene();
        this.onModelChanged('undo');
    },

    redo: function() {
        if (this.historyPointer >= this.history.length - 1) return;
        this.historyPointer++;
        const action = this.history[this.historyPointer];
        
        // Determine current geometry settings
        const isBrick = (this.currentDisplayMode === 'BRICK_STUDS' || this.currentDisplayMode === 'BRICK_ROUNDED');
        const geometryToUse = isBrick ? this.sharedBrickGeometry : this.sharedSharpGeometry;
        const yOffset = isBrick ? 0 : 0.5;

        switch(action.type) {
            case 'MODIFY':
                action.changes.forEach((change, key) => {
                     const [x, y, z] = this.parseKey(key);
                    if (y < 0) return;
                    
                    const centerX = x * this.VS + 0.5;
                    const yPos = y * this.VS + yOffset;
                    const centerZ = z * this.VS + 0.5;

                    if (change.after === null) {
                        const existingVoxel = this.voxels.get(key);
                        if (existingVoxel) {
                            this.originalVoxelsGroup.remove(existingVoxel.mesh);
                            if (existingVoxel.mesh.geometry) existingVoxel.mesh.geometry.dispose();
                            if (existingVoxel.mesh.material) existingVoxel.mesh.material.dispose();
                            this.voxels.delete(key);
                        }
                    } else {
                        const existingVoxel = this.voxels.get(key);
                        if (existingVoxel) {
                            existingVoxel.mesh.material = this.getMaterial(change.after.color);
                            existingVoxel.color = change.after.color;
                            // Ensure geometry is correct after redo in case mode changed mid-session
                            existingVoxel.mesh.geometry = geometryToUse;
                            existingVoxel.mesh.position.set(centerX, yPos, centerZ);
                        } else {
                            const voxelMesh = new THREE.Mesh(geometryToUse, this.getMaterial(change.after.color));
                            voxelMesh.position.set(centerX, yPos, centerZ);
                            voxelMesh.castShadow = true;
                            voxelMesh.receiveShadow = true;
                            this.originalVoxelsGroup.add(voxelMesh);
                            this.voxels.set(key, { color: change.after.color, mesh: voxelMesh });
                        }
                    }
                });
                break;
                
            case 'SELECT':
                this.selectedFaces = new Set(action.after);
                this.updateSelectionVisuals();
                break;
        }
        this.autosaveScene();
        this.onModelChanged('redo');
    },
    
    cycleDrawingAxis: function() {
        const axes = ['y', 'z', 'x'];
        const currentIndex = axes.indexOf(this.currentDrawingAxis);
        this.currentDrawingAxis = axes[(currentIndex + 1) % axes.length];
        this.updateAxisAndLevelUI();
        this.rebuildHelpers();
        localStorage.setItem('currentDrawingAxis', this.currentDrawingAxis);
    },

    moveDrawingLevel: function(direction) {
        let level = this.activeDrawingLevel[this.currentDrawingAxis];
        level += direction;
        this.activeDrawingLevel[this.currentDrawingAxis] = Math.max(0, Math.min(this.GRID - 1, level));
        this.updateAxisAndLevelUI();
        this.rebuildHelpers();
        localStorage.setItem('activeDrawingLevel', JSON.stringify(this.activeDrawingLevel));
    },

    updateAxisAndLevelUI: function() {
        const level = this.activeDrawingLevel[this.currentDrawingAxis];
        const axisUpper = this.currentDrawingAxis.toUpperCase();
        document.getElementById('current-level-display').textContent = level;
        document.getElementById('current-axis-display').textContent = axisUpper;
        document.getElementById('mobile-axis-display').textContent = axisUpper;
    },

    cycleImageAxis: function() { 
        const axes = ['z', 'x', 'y'];
        const currentIndex = axes.indexOf(this.templateImageAxis);
        this.templateImageAxis = axes[(currentIndex + 1) % axes.length];
        localStorage.setItem('templateImageAxis', this.templateImageAxis);
        this.updateTemplateImagePosition();
        this.updateImageAxisUI();
        this.showToast('Image Axis Changed', `Reference plane set to ${this.templateImageAxis.toUpperCase()}-axis.`, 'info', 1500);
    },

    updateImageAxisUI: function() { 
        const axisUpper = this.templateImageAxis.toUpperCase();
        const display = document.getElementById('current-image-axis-display');
        if (display) display.textContent = axisUpper;
        const mobileDisplay = document.getElementById('mobile-image-axis-display');
        if(mobileDisplay) mobileDisplay.textContent = axisUpper;
    },

    resetToDefaults: function() {
        this.controls.invertLookX = false;
        this.controls.invertLookY = false;
        this.controls.invertZoom = true;
        this.controls.invertStrafeX = false;
        this.controls.invertStrafeY = false;
        this.GRID = this.GRID_DEFAULT;
        this.currentColor = '#ffffff';
        this.flySpeed = 0.1;
        this.currentDrawingAxis = 'y';
        this.activeDrawingLevel = { x: 0, y: 0, z: 0 };
        this.templateImageAxis = 'z';
        this.currentDisplayMode = 'BRICK_STUDS'; // Reset to default display mode
        
        // IGNORE/FORCE DISABLE Rounded Preview settings on reset
        localStorage.setItem('isRoundedPreviewEnabled', 'false');
        localStorage.setItem('previewRoundnessFactor', '0.25');

        Object.keys(this.controls).forEach(key => localStorage.setItem(key, this.controls[key]));
        localStorage.setItem('voxelEditorGridSize', this.GRID);
        localStorage.setItem('voxelEditorColor', this.currentColor);
        localStorage.setItem('voxelEditorFlySpeed', this.flySpeed);
        localStorage.setItem('currentDrawingAxis', this.currentDrawingAxis);
        localStorage.setItem('activeDrawingLevel', JSON.stringify(this.activeDrawingLevel));
        localStorage.setItem('templateImageAxis', this.templateImageAxis);
        localStorage.setItem('currentDisplayMode', this.currentDisplayMode);

        this.isRoundedPreviewEnabled = false;
        this.previewRoundnessFactor = 0.25;

        this.updateAllControlInputs();
        this.clearAllConfirmed();
        this.rebuildHelpers();
        this.resetCamera();
        this.showToast('Settings Reset', 'All settings have been reset to their default values.', 'info');
    },

    updateAllControlInputs: function() {
        document.getElementById('grid-size-slider').value = this.GRID;
        document.getElementById('grid-size-display').textContent = `${this.GRID}³`;
        document.getElementById('color-picker-input').value = this.currentColor;
        document.getElementById('brush-size-slider').value = this.brushSize;
        document.getElementById('brush-size-display').textContent = `${this.brushSize}x${this.brushSize}`;
        
        if (this.isMobile) {
            document.getElementById('mobile-color-picker').value = this.currentColor;
            document.getElementById('mobile-grid-size-slider').value = this.GRID;
            document.getElementById('mobile-grid-size-display').textContent = `${this.GRID}³`;
            document.getElementById('mobile-brush-size-slider').value = this.brushSize;
            document.getElementById('mobile-brush-size-display').textContent = `${this.brushSize}x${this.brushSize}`;
        }
        this.setFlySpeed(this.flySpeed);
        document.getElementById('invertLookX').checked = this.controls.invertLookX;
        document.getElementById('invertLookY').checked = this.controls.invertLookY;
        document.getElementById('invertZoom').checked = this.controls.invertZoom;
        document.getElementById('invertStrafeX').checked = this.controls.invertStrafeX;
        document.getElementById('invertStrafeY').checked = this.controls.invertStrafeY;
        if(this.isMobile) {
            document.getElementById('mobileInvertLookX').checked = this.controls.invertLookX;
            document.getElementById('mobileInvertLookY').checked = this.controls.invertLookY;
            document.getElementById('mobileInvertZoom').checked = this.controls.invertZoom;
            document.getElementById('mobileInvertStrafeX').checked = this.controls.invertStrafeX;
            document.getElementById('mobileInvertStrafeY').checked = this.controls.invertStrafeY;
        }
        this.updateAxisAndLevelUI();
        this.updateImageAxisUI();
        this.updateModeUI();
        this.updateDisplayModeUI(); // NEW: Update display mode label
    },
getFaceTarget: function (clientX, clientY) {
  const hit = this.getFaceAt(clientX, clientY);
  if (!hit) return null;

  let voxelKey = null;
  let nrm = new THREE.Vector3();

  // Foundation (ground) hit → treat as y = -1, normal = +Y
  if (hit.object === this.groundPlaneMesh || (hit.object.userData && hit.object.userData.isFoundation)) {
    nrm.set(0, 1, 0);
    const p = hit.point;
    const x = Math.floor(p.x / this.VS);
    const z = Math.floor(p.z / this.VS);
    if (x < 0 || x >= this.GRID || z < 0 || z >= this.GRID) return null;
    voxelKey = this.key(x, -1, z);
  } else {
    // Voxel mesh hit
    const voxelData = this.findVoxelDataByMesh(hit.object);
    if (!voxelData) return null;

    // Derive base voxel coordinates from brick placement convention:
    // mesh.position = (x*VS + 0.5, y*VS, z*VS + 0.5) for bricks
    const base = hit.object.position;
    const x = Math.round(base.x / this.VS - 0.5);
    const y = Math.round(base.y / this.VS);
    const z = Math.round(base.z / this.VS - 0.5);
    voxelKey = this.key(x, y, z);

    // Face normal in world space → snap to major axis
    nrm.copy(hit.face.normal).transformDirection(hit.object.matrixWorld);
    const ax = Math.abs(nrm.x), ay = Math.abs(nrm.y), az = Math.abs(nrm.z);
    if (ax >= ay && ax >= az) nrm.set(Math.sign(nrm.x), 0, 0);
    else if (ay >= ax && ay >= az) nrm.set(0, Math.sign(nrm.y), 0);
    else nrm.set(0, 0, Math.sign(nrm.z));
  }

  const normalIndex = this.getNormalIndex(nrm);
  return {
    faceKey: `${voxelKey}:${normalIndex}`,
    normal: nrm.clone(),
    intersectionPoint: hit.point.clone()
  };
},

    addColorToHistory: function(color) {
        if (!color) return;
        const upperColor = color.toUpperCase();
        const index = this.colorHistory.indexOf(upperColor);
        if (index > -1) {
            this.colorHistory.splice(index, 1);
        }
        this.colorHistory.unshift(upperColor);
        if (this.colorHistory.length > 8) {
            this.colorHistory.pop();
        }
        localStorage.setItem('voxelColorHistory', JSON.stringify(this.colorHistory));
        this.renderColorHistory();
    },

    renderColorHistory: function() {
        const palette = document.getElementById('color-history-palette');
        palette.innerHTML = '';
        this.colorHistory.forEach(color => {
            const swatch = document.createElement('div');
            swatch.className = 'color-swatch';
            swatch.style.backgroundColor = color;
            swatch.title = color;
            swatch.addEventListener('click', this.setColor.bind(this, color));
            palette.appendChild(swatch);
        });
    },
    

    disposeTemplateImageMesh: function () {
      if (this.templateImageMesh) {
        this.scene.remove(this.templateImageMesh);
        this.templateImageMesh.geometry.dispose();
        if (this.templateImageMesh.material.map) this.templateImageMesh.material.map.dispose();
        this.templateImageMesh.material.dispose();
        this.templateImageMesh = null;
      }
    },
    loadImageTemplate: function() {
        document.getElementById('imageFileInput').click();
    },
    handleImageFileSelect: function(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            this.templateImageData = e.target.result;
            this.loadImageFromData(this.templateImageData);
        };
        reader.readAsDataURL(file);
        event.target.value = '';
    },
    loadImageFromData: function(imageData) {
        this.disposeTemplateImageMesh();
        const loader = new THREE.TextureLoader();
        loader.load(imageData, (texture) => {
            const img = texture.image;
            const aspect = img.width / img.height;
            const size = this.GRID * this.VS;
            let planeWidth, planeHeight;
            if (aspect >= 1) {
                planeWidth = size;
                planeHeight = size / aspect;
            } else {
                planeHeight = size;
                planeWidth = size * aspect;
            }
            const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
            const material = new THREE.MeshBasicMaterial({ 
                map: texture, 
                transparent: true, 
                side: THREE.DoubleSide, 
                depthTest: true,
                depthWrite: false
            });
            this.templateImageMesh = new THREE.Mesh(geometry, material);
            this.updateTemplateImagePosition();
            this.scene.add(this.templateImageMesh);
            document.getElementById('removeImageBtn').classList.remove('hidden');
            document.getElementById('removeImageBtnMobile').classList.remove('hidden');
            document.getElementById('loadImageBtn').classList.add('hidden');
            document.getElementById('loadImageBtnMobile').classList.add('hidden');
        });
    },
    removeImageTemplate: function() {
        if (this.templateImageMesh) {
            this.scene.remove(this.templateImageMesh);
            this.templateImageMesh.geometry.dispose();
            if (this.templateImageMesh.material.map) this.templateImageMesh.material.map.dispose();
            this.templateImageMesh.material.dispose();
            this.templateImageMesh = null;
        }
        this.templateImageData = null;
        this.templateImagePinnedY = null;
        document.getElementById('removeImageBtn').classList.add('hidden');
        document.getElementById('removeImageBtnMobile').classList.add('hidden');
        document.getElementById('loadImageBtn').classList.remove('hidden');
        document.getElementById('loadImageBtnMobile').classList.remove('hidden');
    },
    updateTemplateImagePosition: function() { 
        if (!this.templateImageMesh) return;
        const sizeAll = this.GRID * this.VS;
        const center = sizeAll / 2;
        const offset = -0.01;
        this.templateImageMesh.rotation.set(0, 0, 0);
        switch (this.templateImageAxis) {
            case 'x':
                this.templateImageMesh.rotation.y = Math.PI / 2;
                this.templateImageMesh.position.set(offset, center, center);
                break;
            case 'y':
                this.templateImageMesh.rotation.x = Math.PI / 2;
                this.templateImageMesh.position.set(center, offset, center);
                break;
            case 'z':
            default:
                this.templateImageMesh.position.set(center, center, offset);
                break;
        }
    },
 
    autosaveScene: function() {
        if (this.voxels.size === 0 && !this.templateImageData) {
            localStorage.removeItem('voxelshaper_autosave');
            return;
        }
        try {
            const data = { 
                gridSize: this.GRID, 
                currentDrawingAxis: this.currentDrawingAxis,
                activeDrawingLevel: this.activeDrawingLevel,
                voxels: Array.from(this.voxels.entries()).map(([k, v]) => {
                    const [x, y, z] = this.parseKey(k);
                    return { x, y, z, color: v.color };
                }),
                templateImageData: this.templateImageData,
                templateImagePinnedY: this.templateImagePinnedY,
                templateImageAxis: this.templateImageAxis,
                currentDisplayMode: this.currentDisplayMode,
            };
            localStorage.setItem('voxelshaper_autosave', JSON.stringify(data));
        } catch (e) {
            console.error("Autosave failed:", e);
        }
    },

    loadAutosavedScene: function() {
        const savedData = localStorage.getItem('voxelshaper_autosave');
        if (savedData) {
            try {
                const data = JSON.parse(savedData);
                if (this.loadFromData(data)) {
                    this.showToast('Scene Restored', 'Your last session was loaded.', 'info');
                }
            } catch (e) {
                console.error("Failed to load autosaved scene:", e);
                localStorage.removeItem('voxelshaper_autosave');
            }
        }
    },


    // --- NEW: Onboarding Methods ---
    startOnboarding: function() {
        document.getElementById('onboardingModal').showModal();
    },

    markOnboardingComplete: function() {
        localStorage.setItem('voxelshaper_onboarding_complete', 'true');
        document.getElementById('onboardingModal').close();
    },

    loadSampleProject: function() {
        this.loadFromData(this.sampleProjectData);
        this.markOnboardingComplete();
        this.showToast('Sample Loaded', 'Explore the sample house project!', 'info');
    },

    initVisualHapticLayer: function () {
      if (!this.containerDiv) return;
      this.hapticLayer = document.getElementById('haptic-layer');
      if (!this.hapticLayer) {
        this.hapticLayer = document.createElement('div');
        this.hapticLayer.id = 'haptic-layer';
        this.containerDiv.appendChild(this.hapticLayer);
      }
    },
    
    fallbackHaptic: function (clientX, clientY, color) {
      // 1) small visual feedback
      try {
        this.containerDiv.animate(
          [{ transform: 'scale(1)' }, { transform: 'scale(0.985)' }, { transform: 'scale(1)' }],
          { duration: 120, easing: 'ease-out' }
        );
      } catch {}

      // 2) Ripple at the touch position
      if (!this.hapticLayer) this.initVisualHapticLayer();
      if (!this.hapticLayer) return;

      const rect = this.containerDiv.getBoundingClientRect();
      const x = clientX - rect.left;
      const y = clientY - rect.top;

      const ripple = document.createElement('div');
      ripple.className = 'haptic-ripple';

      // Color selection: Delete = red, otherwise current drawing color
      const stroke = color || (this.currentMode === 'DELETE' ? 'rgba(255,0,0,.65)' : this.currentColor || '#ffffff');
      ripple.style.borderColor = stroke;

      ripple.style.left = `${x}px`;
      ripple.style.top  = `${y}px`;

      this.hapticLayer.appendChild(ripple);
      ripple.addEventListener('animationend', () => ripple.remove());
    },
  
    
    hapticOrVisualAt: function (clientX, clientY) {
      const isIOS = /iP(ad|hone|od)/.test(navigator.userAgent) ||
                    (navigator.userAgent.includes('Mac') && 'ontouchend' in document);

      let didVibrate = false;
      if (!isIOS && document.visibilityState === 'visible' && 'vibrate' in navigator) {
        if (!navigator.userActivation || navigator.userActivation.isActive) {
          didVibrate = !!navigator.vibrate(40);
        }
      }
      if (!didVibrate) this.fallbackHaptic(clientX, clientY);
      return didVibrate;
    },
};

document.addEventListener('DOMContentLoaded', () => VoxelApp.init());
</script>


</body></html>
